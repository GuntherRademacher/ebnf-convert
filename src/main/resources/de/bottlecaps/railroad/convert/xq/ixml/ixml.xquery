xquery version "3.1" encoding "UTF-8";

(: This file was generated on Wed Dec 21, 2022 23:11 (UTC+01) by REx v5.56 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -glalr 1 -tree -a none -xquery -name de/bottlecaps/railroad/convert/xq/ixml/ixml.xquery ..\..\..\..\..\..\..\..\main\java\de\bottlecaps\railroad\convert\ixml\ixml.ebnf :)

(:~
 : The parser that was generated for the de/bottlecaps/railroad/convert/xq/ixml/ixml.xquery grammar.
 :)
module namespace p="de/bottlecaps/railroad/convert/xq/ixml/ixml.xquery";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 7;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 8;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 2, 3, 4, 2, 2, 2,
  5, 6, 7, 8, 9, 10, 11, 12, 2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 2, 16, 2, 17, 18, 19, 19, 19, 19, 19,
  19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 2, 22, 23, 24, 2, 25, 25, 25,
  25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 28, 29, 30, 2
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  432, 580, 1309, 1309, 1309, 463, 1245, 448, 1309, 493, 537, 512, 642, 1270, 688, 1201, 1339, 1351, 553, 596, 612, 628,
  658, 674, 714, 749, 765, 796, 568, 823, 839, 855, 871, 902, 1309, 1309, 698, 918, 945, 961, 1308, 1309, 1309, 1309,
  496, 982, 998, 1014, 527, 1030, 1488, 1460, 1054, 1070, 1092, 1108, 1563, 1076, 1309, 886, 1309, 1309, 1380, 1124,
  1140, 477, 1156, 1172, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173,
  1173, 1173, 1173, 1173, 1189, 733, 1217, 1233, 807, 1173, 1173, 1173, 1261, 1286, 1302, 1325, 1173, 1173, 1173, 1173,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1038, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 966, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1367, 1309, 1309, 1396,
  1412, 728, 1428, 1451, 780, 1476, 1504, 929, 1520, 1536, 1435, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
  1309, 1309, 1552, 1585, 1579, 1585, 1585, 1593, 1601, 1625, 1631, 1639, 1646, 1646, 1651, 1659, 1666, 1666, 1671,
  2161, 1702, 1812, 1812, 1992, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1995, 1812, 1812, 1812, 1812,
  1812, 1812, 1812, 1812, 2080, 1812, 1818, 2159, 1815, 2173, 2159, 2159, 1812, 1815, 2159, 2159, 2159, 2159, 2159,
  2159, 2095, 2098, 2050, 2095, 2102, 2159, 1679, 1810, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812,
  1812, 1812, 1812, 1812, 2185, 1812, 1812, 1812, 2159, 2094, 2095, 2095, 2095, 2095, 1717, 1689, 2159, 1812, 1812,
  1812, 1817, 1817, 2159, 2052, 2095, 2101, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 2159,
  1811, 1812, 1812, 1812, 1813, 2230, 1811, 1812, 1812, 1812, 2061, 1812, 1812, 1812, 1812, 1812, 1812, 1731, 2094,
  2258, 1715, 1812, 1771, 2095, 1811, 1811, 1812, 1812, 1812, 1812, 1812, 1897, 2100, 2129, 2096, 2095, 2101, 2159,
  2159, 2159, 2159, 2158, 2229, 1608, 2229, 1812, 1812, 1813, 1812, 1812, 1812, 1813, 1812, 1976, 2185, 1809, 1812,
  1812, 1993, 1789, 1804, 2114, 1826, 2159, 2205, 1771, 2095, 1818, 2159, 2217, 1835, 1809, 1812, 1812, 1993, 1882,
  2318, 2309, 1937, 2246, 1889, 2035, 2095, 1844, 2159, 2217, 1995, 1992, 1812, 1812, 1993, 1885, 1804, 1681, 2258,
  2231, 2159, 1771, 2095, 2159, 2159, 2095, 2100, 1812, 1812, 1812, 1812, 1812, 2294, 2095, 2095, 2095, 1941, 2128,
  1812, 1976, 2185, 1809, 1812, 1812, 1993, 1885, 1855, 2114, 2234, 2233, 2205, 1771, 2095, 2230, 2159, 1829, 1873,
  1832, 1878, 1737, 1873, 1812, 1818, 2102, 2234, 2231, 2159, 2035, 2095, 2159, 2159, 2127, 1812, 1812, 1812, 2095,
  2095, 2095, 1616, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1832, 1813, 1832, 1812, 1812, 1812, 1812,
  1920, 1989, 1993, 1812, 1812, 1993, 1990, 2143, 2018, 2113, 2036, 1818, 1771, 2095, 2159, 2159, 2160, 1812, 1810,
  1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1815, 1781, 2078, 2159, 1920, 1989, 1993,
  1812, 1812, 1993, 1990, 1855, 2233, 2037, 2159, 2161, 1771, 2095, 1739, 2159, 1920, 1989, 1993, 1812, 1812, 1812,
  1812, 1905, 2114, 1826, 2159, 2159, 1771, 2095, 2159, 1810, 1812, 1812, 1812, 1812, 1812, 1816, 2159, 2235, 2159,
  2095, 2101, 2095, 2095, 1747, 2228, 1920, 1812, 1813, 1810, 1812, 1812, 1992, 1997, 1813, 2245, 1952, 2159, 2159,
  2159, 2159, 2159, 2160, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1794, 1796, 1921, 1811, 1701,
  1697, 1897, 1913, 1996, 2097, 2095, 1617, 2159, 2159, 2159, 2159, 2231, 2159, 2159, 2101, 2095, 2101, 1930, 2246,
  1812, 1811, 1812, 1812, 1812, 1815, 2094, 2096, 1718, 1750, 2095, 2094, 2095, 2095, 2095, 2098, 2233, 2159, 2159,
  2159, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1949, 2093, 1865, 2095, 2101, 1814, 1962, 1735, 1919,
  1900, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 2095, 2095, 2095, 2095, 2096, 2159, 2159, 2020, 1847, 1826,
  2095, 1972, 1812, 1812, 1812, 1812, 1995, 2162, 1812, 1812, 1812, 1812, 1812, 1991, 1812, 1832, 1812, 1812, 1812,
  1812, 1832, 1813, 1832, 1812, 1813, 1812, 1812, 1812, 1812, 1812, 1762, 1861, 2159, 2125, 2254, 2095, 2101, 1812,
  1812, 1813, 2229, 1812, 1812, 1832, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1949, 2159, 2159, 2159, 2159,
  1812, 1812, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1815, 2159, 2159, 2159, 2159,
  2159, 2159, 1986, 1812, 1812, 1817, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1817, 2159, 2159, 1812,
  1989, 2005, 2159, 1812, 1812, 2005, 2159, 1812, 1812, 2015, 2159, 1812, 1989, 2308, 2159, 1812, 1812, 1812, 1812,
  1812, 1812, 1964, 2097, 2233, 2094, 2115, 2029, 2095, 2101, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 2282, 1812,
  1812, 1812, 1812, 1812, 1812, 1812, 1812, 1814, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812,
  2129, 2102, 1812, 1812, 1812, 1812, 1812, 1812, 2045, 2096, 1935, 2098, 2021, 2297, 2095, 2101, 2095, 2101, 2160,
  2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2111, 2095, 2093, 2123, 2138, 2159, 2060, 1812,
  1812, 1812, 1812, 1812, 2070, 1954, 2261, 1816, 2095, 2101, 2159, 2021, 2099, 2159, 2062, 1812, 1812, 1812, 1613,
  1693, 2095, 1747, 1812, 1812, 1812, 1812, 2130, 2088, 2101, 2159, 1812, 1812, 1812, 1812, 1812, 1812, 1989, 1996,
  2264, 1815, 2186, 1816, 1812, 1815, 2264, 1815, 2151, 2156, 2159, 2159, 2159, 2103, 2159, 2232, 2102, 2159, 2159,
  2103, 2159, 2159, 2230, 2160, 2170, 1810, 1997, 2184, 2173, 1888, 1812, 2194, 1920, 1836, 2159, 2159, 2159, 2159,
  2159, 2159, 1737, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159,
  1812, 1812, 1812, 1812, 1812, 1813, 1812, 1812, 1812, 1812, 1812, 1813, 1812, 1812, 1812, 1812, 1749, 2095, 2283,
  2159, 2095, 1747, 1812, 1812, 1812, 2294, 2076, 2229, 1812, 1812, 1812, 1812, 1995, 2162, 1812, 1812, 1812, 1812,
  1812, 1812, 1812, 2160, 2159, 2232, 1812, 1812, 1813, 2159, 1813, 1813, 1813, 1813, 1813, 1813, 1813, 1813, 2095,
  2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 1989, 2196, 2204, 2159, 2159, 2159,
  2159, 1775, 2184, 1737, 1811, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1710, 2297, 1726, 2074,
  2095, 1903, 1812, 1812, 1813, 2217, 1811, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1991, 1920,
  1812, 1812, 1812, 1812, 1814, 1811, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812,
  1812, 1812, 1812, 1812, 1813, 2159, 2159, 1812, 1812, 1812, 1817, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812,
  1749, 1760, 1758, 2296, 2159, 2159, 1812, 1812, 1812, 2006, 2159, 2159, 2159, 2159, 1993, 1815, 2159, 2159, 2159,
  2159, 2159, 2159, 2020, 2095, 2095, 2096, 1812, 1815, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812,
  1812, 1812, 1812, 1814, 1814, 1812, 1812, 1812, 1812, 1814, 1814, 1812, 2176, 1812, 1812, 1812, 1814, 1812, 1815,
  1812, 1812, 2095, 2078, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 2129, 2020, 1763, 1812, 1812, 1812, 2232, 1812,
  1812, 1812, 1812, 1812, 1812, 1812, 1812, 1814, 2159, 2101, 2159, 1812, 2195, 1816, 2159, 1812, 1817, 2159, 2159,
  2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 2317, 2258, 2095, 2101, 2277, 2125, 1812, 1812,
  2213, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1812, 1816, 2159, 2159, 1811, 2159, 2095, 2101, 2159, 2159,
  2159, 2159, 2095, 1747, 1812, 1812, 1749, 2097, 1812, 1812, 2129, 2095, 2101, 2159, 1812, 1812, 1812, 1815, 2007,
  2102, 2245, 1939, 2035, 2095, 1812, 1812, 1812, 1814, 1815, 2159, 2061, 1812, 1812, 1812, 1812, 1812, 1846, 2243,
  2159, 2160, 2095, 2101, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1812, 2272, 2291, 2282, 2159, 2159,
  1978, 1812, 2306, 2220, 2159, 1994, 1994, 1994, 2159, 1813, 1813, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159,
  2159, 2159, 1812, 1812, 1812, 1812, 1816, 2159, 1812, 1812, 1813, 1922, 1812, 1812, 1812, 1812, 1812, 1816, 2020,
  2298, 2159, 2095, 1779, 2095, 1747, 1812, 1812, 1812, 1814, 0, 33, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 33, 2, 3, 4, 2,
  2, 2, 5, 6, 7, 8, 9, 10, 11, 12, 2, 2, 2, 2, 2, 31, 2, 32, 32, 32, 32, 2, 2, 31, 31, 31, 31, 13, 13, 13, 13, 13, 13,
  13, 13, 14, 15, 2, 16, 2, 17, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 2, 22, 23, 24, 2, 25,
  25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 28, 29, 30, 2, 31, 31, 2, 32, 32, 32, 32, 32, 2, 32, 2, 32,
  32, 2, 32, 32, 2, 32, 2, 2, 31, 31, 2, 31, 31, 31, 2, 31, 2, 31, 31, 31, 31, 31, 31, 2, 31, 32, 32, 32, 32, 32, 32,
  32, 2, 32, 32, 32, 32, 32, 32, 32, 31, 31, 32, 2, 32, 31, 2, 2, 2, 31, 31, 2, 2, 2, 2, 2, 32, 32, 31, 31, 31, 31, 31,
  31, 32, 32, 32, 32, 32, 32, 32, 31, 32, 32, 32, 32, 32, 32, 2, 31, 31, 31, 32, 32, 2, 2, 32, 32, 32, 32, 2, 2, 2, 31,
  31, 31, 31, 32, 31, 2, 31, 2, 2, 2, 31, 31, 2, 31, 2, 2, 31, 2, 2, 31, 31, 2, 2, 32, 31, 2, 2, 31, 31, 31, 31, 31, 31,
  31, 31, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 31, 2, 31, 31, 31, 31, 2, 2, 2, 2, 31, 2, 32, 32, 31, 31, 31, 32, 2, 2,
  32, 32, 2, 31, 31, 2, 2, 32, 31, 2, 32, 32, 2, 2, 32, 32, 2, 2, 32, 32, 31, 31, 31, 31, 2, 2, 2, 31, 31, 2, 31, 2, 31,
  31, 2, 31, 31, 2, 31, 31, 31, 31, 2, 31, 2, 31, 32, 31, 31, 32, 32, 32, 32, 31, 31, 31, 2, 2, 31, 2, 2, 32, 32, 2, 32,
  32, 31, 2, 2, 2, 2, 2, 2, 31, 31, 31, 31, 31, 2, 2, 2, 2, 2, 32, 2, 32, 2, 2, 32, 32, 32, 2, 2, 2, 2, 31, 31, 31, 31,
  31, 2, 2, 32, 32, 32, 2, 32, 2, 2, 2, 32, 32, 31, 31, 31, 31, 32, 32, 2, 32, 32, 32, 2, 2, 2, 32, 2, 2, 2, 31, 31, 31,
  2, 2, 33, 31, 31, 31, 31, 31, 31, 31, 2, 31, 31, 31, 31, 31, 31, 2, 31, 2, 2, 31, 31, 32, 32, 32, 2, 2, 2, 2, 32, 31,
  31, 32, 32, 2, 2, 2, 2, 2, 32, 32, 32, 32, 32, 2, 2, 2, 2, 31, 32, 2, 2, 2, 2, 2, 2, 32, 32, 2, 2, 31, 31, 31, 31, 31,
  2, 32, 2, 2, 2, 32, 32, 32, 33, 2, 32, 32, 32, 32, 2, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 2, 32, 32, 32, 32, 31,
  31, 2, 2, 2, 2, 31, 31, 32, 32, 2, 2, 2, 32, 2, 32, 32, 32, 32, 32, 32, 32, 32, 2, 2, 2, 2, 2, 2, 2, 33, 32, 32, 32,
  2, 32, 32, 32, 32, 2, 2, 2, 31, 32, 31, 31, 31, 31, 32, 31, 31, 31, 31, 31, 31, 31, 32, 2, 31, 31, 2, 2, 32, 31, 31,
  2, 2, 2, 31, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 2, 2, 2, 2, 2, 2, 2, 2, 31, 2, 2, 2, 2, 31, 2, 2, 2, 2, 31, 2,
  31, 2, 31, 2, 31, 2, 31, 31, 31, 31, 31, 2, 2, 31, 31, 31, 31, 2, 2, 31, 31, 31, 31, 2, 2, 33, 2, 2, 2, 2, 31, 31, 2,
  31, 31, 31, 31, 2, 2, 32, 32, 2, 2, 31, 31, 31, 2, 32, 2, 2, 2, 2, 31, 2, 2, 2, 2, 2, 2, 2, 32, 2, 2, 2, 32, 32, 2, 2,
  32, 2, 2, 2, 2, 2, 2, 31, 31, 31, 31, 32, 2, 2, 2, 2, 32, 2, 2, 31, 31, 31, 2, 31, 31, 32, 31, 32, 32, 32, 31, 31, 32,
  31, 31, 31, 32, 31, 2, 2, 2, 2, 2, 2, 32, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 2, 2, 32, 32, 31, 31, 31, 2, 32, 32,
  2, 2, 2, 2, 32, 31, 31, 31, 2, 2, 32, 2, 2, 2
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64110, 64112, 64218, 64256, 64263, 64275, 64280, 64285, 64286, 64287, 64297, 64298, 64311, 64312, 64317,
  64318, 64319, 64320, 64322, 64323, 64325, 64326, 64434, 64467, 64830, 64848, 64912, 64914, 64968, 65008, 65020, 65024,
  65040, 65056, 65063, 65136, 65141, 65142, 65277, 65296, 65306, 65313, 65339, 65345, 65371, 65382, 65471, 65474, 65480,
  65482, 65488, 65490, 65496, 65498, 65501, 65536, 65548, 65549, 65575, 65576, 65595, 65596, 65598, 65599, 65614, 65616,
  65630, 65664, 65787, 66045, 66046, 66176, 66205, 66208, 66257, 66304, 66335, 66352, 66369, 66370, 66378, 66432, 66462,
  66464, 66500, 66504, 66512, 66560, 66718, 66720, 66730, 67584, 67590, 67592, 67593, 67594, 67638, 67639, 67641, 67644,
  67645, 67647, 67670, 67840, 67862, 67872, 67898, 67968, 68024, 68030, 68032, 68096, 68097, 68100, 68101, 68103, 68108,
  68112, 68116, 68117, 68120, 68121, 68148, 68152, 68155, 68159, 68160, 68192, 68221, 68352, 68406, 68416, 68438, 68448,
  68467, 68608, 68681, 69633, 69634, 69635, 69688, 69703, 69734, 69744, 69760, 69762, 69763, 69808, 69811, 69815, 69817,
  69819, 69840, 69865, 69872, 69882, 69888, 69891, 69927, 69932, 69933, 69941, 69942, 69952, 70016, 70018, 70019, 70067,
  70070, 70079, 70081, 70085, 70096, 70106, 71296, 71339, 71340, 71341, 71342, 71344, 71350, 71351, 71352, 71360, 71370,
  73728, 74607, 77824, 78895, 92160, 92729, 93952, 94021, 94032, 94033, 94095, 94099, 94112, 110592, 110594, 119143,
  119146, 119163, 119171, 119173, 119180, 119210, 119214, 119362, 119365, 119808, 119893, 119894, 119965, 119966,
  119968, 119970, 119971, 119973, 119975, 119977, 119981, 119982, 119994, 119995, 119996, 119997, 120004, 120005,
  120070, 120071, 120075, 120077, 120085, 120086, 120093, 120094, 120122, 120123, 120127, 120128, 120133, 120134,
  120135, 120138, 120145, 120146, 120486, 120488, 120513, 120514, 120539, 120540, 120571, 120572, 120597, 120598,
  120629, 120630, 120655, 120656, 120687, 120688, 120713, 120714, 120745, 120746, 120771, 120772, 120780, 120782,
  120832, 126464, 126468, 126469, 126496, 126497, 126499, 126500, 126501, 126503, 126504, 126505, 126515, 126516,
  126520, 126521, 126522, 126523, 126524, 126530, 126531, 126535, 126536, 126537, 126538, 126539, 126540, 126541,
  126544, 126545, 126547, 126548, 126549, 126551, 126552, 126553, 126554, 126555, 126556, 126557, 126558, 126559,
  126560, 126561, 126563, 126564, 126565, 126567, 126571, 126572, 126579, 126580, 126584, 126585, 126589, 126590,
  126591, 126592, 126602, 126603, 126620, 126625, 126628, 126629, 126634, 126635, 126652, 131072, 173783, 173824,
  177973, 177984, 178206, 194560, 195102, 917760, 918000, 63743, 64109, 64111, 64217, 64255, 64262, 64274, 64279, 64284,
  64285, 64286, 64296, 64297, 64310, 64311, 64316, 64317, 64318, 64319, 64321, 64322, 64324, 64325, 64433, 64466, 64829,
  64847, 64911, 64913, 64967, 65007, 65019, 65023, 65039, 65055, 65062, 65135, 65140, 65141, 65276, 65295, 65305, 65312,
  65338, 65344, 65370, 65381, 65470, 65473, 65479, 65481, 65487, 65489, 65495, 65497, 65500, 65533, 65547, 65548, 65574,
  65575, 65594, 65595, 65597, 65598, 65613, 65615, 65629, 65663, 65786, 66044, 66045, 66175, 66204, 66207, 66256, 66303,
  66334, 66351, 66368, 66369, 66377, 66431, 66461, 66463, 66499, 66503, 66511, 66559, 66717, 66719, 66729, 67583, 67589,
  67591, 67592, 67593, 67637, 67638, 67640, 67643, 67644, 67646, 67669, 67839, 67861, 67871, 67897, 67967, 68023, 68029,
  68031, 68095, 68096, 68099, 68100, 68102, 68107, 68111, 68115, 68116, 68119, 68120, 68147, 68151, 68154, 68158, 68159,
  68191, 68220, 68351, 68405, 68415, 68437, 68447, 68466, 68607, 68680, 69632, 69633, 69634, 69687, 69702, 69733, 69743,
  69759, 69761, 69762, 69807, 69810, 69814, 69816, 69818, 69839, 69864, 69871, 69881, 69887, 69890, 69926, 69931, 69932,
  69940, 69941, 69951, 70015, 70017, 70018, 70066, 70069, 70078, 70080, 70084, 70095, 70105, 71295, 71338, 71339, 71340,
  71341, 71343, 71349, 71350, 71351, 71359, 71369, 73727, 74606, 77823, 78894, 92159, 92728, 93951, 94020, 94031, 94032,
  94094, 94098, 94111, 110591, 110593, 119142, 119145, 119162, 119170, 119172, 119179, 119209, 119213, 119361, 119364,
  119807, 119892, 119893, 119964, 119965, 119967, 119969, 119970, 119972, 119974, 119976, 119980, 119981, 119993,
  119994, 119995, 119996, 120003, 120004, 120069, 120070, 120074, 120076, 120084, 120085, 120092, 120093, 120121,
  120122, 120126, 120127, 120132, 120133, 120134, 120137, 120144, 120145, 120485, 120487, 120512, 120513, 120538,
  120539, 120570, 120571, 120596, 120597, 120628, 120629, 120654, 120655, 120686, 120687, 120712, 120713, 120744,
  120745, 120770, 120771, 120779, 120781, 120831, 126463, 126467, 126468, 126495, 126496, 126498, 126499, 126500,
  126502, 126503, 126504, 126514, 126515, 126519, 126520, 126521, 126522, 126523, 126529, 126530, 126534, 126535,
  126536, 126537, 126538, 126539, 126540, 126543, 126544, 126546, 126547, 126548, 126550, 126551, 126552, 126553,
  126554, 126555, 126556, 126557, 126558, 126559, 126560, 126562, 126563, 126564, 126566, 126570, 126571, 126578,
  126579, 126583, 126584, 126588, 126589, 126590, 126591, 126601, 126602, 126619, 126624, 126627, 126628, 126633,
  126634, 126651, 131071, 173782, 173823, 177972, 177983, 178205, 194559, 195101, 917759, 917999, 1114111, 2, 31, 2, 31,
  2, 31, 2, 31, 2, 31, 32, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 32, 2, 32, 2,
  31, 2, 31, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
  32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
  31, 2, 31, 2, 31, 2, 31, 2, 31, 32, 2, 32, 2, 32, 31, 2, 31, 2, 31, 2, 32, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31,
  2, 32, 2, 31, 32, 2, 32, 2, 32, 2, 31, 2, 32, 2, 32, 2, 31, 2, 32, 2, 32, 31, 32, 2, 32, 2, 32, 2, 32, 2, 31, 2, 32,
  2, 31, 2, 32, 2, 31, 32, 2, 32, 2, 32, 2, 32, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 32, 31, 2, 31, 2, 32, 2,
  32, 2, 32, 2, 32, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
  31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
  32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
  31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
  31, 2, 31, 2, 31, 2, 31, 2, 32, 2
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  861, 33, 34, 35, 36, 867, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 883
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 544, 551, 561, 558,
  626, 558, 560, 545, 560, 560, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546,
  546, 546, 572, 546, 581, 589, 546, 576, 590, 574, 591, 577, 596, 595, 597, 546, 546, 546, 771, 546, 770, 601, 546,
  609, 602, 607, 603, 610, 615, 614, 616, 546, 546, 546, 620, 640, 630, 638, 546, 645, 639, 650, 652, 646, 655, 654,
  656, 772, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 546, 547, 661, 660, 662, 546, 546, 546, 771, 787, 770,
  565, 786, 785, 546, 785, 787, 668, 669, 667, 666, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 783, 782,
  546, 784, 780, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 807, 806, 546, 808, 804, 546, 546, 546, 771,
  546, 770, 565, 546, 809, 546, 809, 676, 675, 546, 677, 673, 546, 546, 546, 771, 711, 770, 565, 710, 546, 712, 683,
  713, 710, 681, 681, 682, 546, 546, 546, 771, 849, 770, 565, 850, 849, 546, 849, 851, 687, 825, 689, 691, 546, 546,
  546, 695, 546, 770, 565, 546, 546, 546, 546, 546, 546, 546, 709, 546, 546, 546, 546, 771, 546, 717, 565, 847, 546,
  546, 546, 546, 546, 546, 848, 846, 546, 546, 546, 771, 546, 770, 721, 722, 728, 722, 872, 730, 729, 723, 734, 724,
  546, 546, 546, 771, 546, 738, 565, 870, 546, 546, 546, 546, 546, 546, 871, 869, 546, 546, 546, 771, 546, 770, 565,
  546, 546, 546, 546, 887, 886, 546, 888, 884, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 742, 774, 773, 750,
  749, 751, 546, 546, 546, 695, 546, 770, 565, 763, 546, 762, 762, 756, 755, 760, 760, 761, 546, 546, 546, 771, 546,
  770, 565, 763, 546, 762, 762, 756, 755, 760, 760, 761, 546, 546, 546, 771, 546, 767, 778, 546, 584, 546, 584, 546,
  585, 792, 791, 793, 546, 546, 546, 771, 546, 770, 797, 566, 568, 798, 568, 566, 567, 546, 546, 567, 546, 546, 546,
  771, 546, 770, 565, 546, 546, 802, 819, 816, 641, 813, 817, 818, 546, 546, 546, 771, 546, 770, 565, 823, 546, 823,
  823, 633, 634, 829, 829, 830, 546, 546, 546, 695, 546, 770, 565, 624, 546, 834, 624, 622, 835, 839, 839, 840, 546,
  546, 546, 771, 546, 770, 565, 624, 546, 834, 624, 622, 835, 839, 839, 840, 546, 546, 546, 771, 546, 770, 704, 844,
  704, 701, 698, 701, 703, 705, 703, 703, 546, 546, 546, 771, 546, 770, 855, 890, 857, 890, 889, 859, 858, 891, 863,
  892, 546, 546, 546, 771, 546, 770, 867, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 771, 546, 770,
  565, 546, 553, 546, 553, 546, 554, 877, 876, 878, 546, 546, 546, 771, 546, 770, 565, 882, 546, 882, 882, 744, 745,
  896, 896, 897, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 546, 546, 546, 709, 546, 546, 546, 546, 771,
  546, 770, 544, 551, 561, 558, 626, 558, 560, 545, 560, 560, 546, 546, 546, 128, 1024, 0, 0, 0, 0, 448, 0, 1024, 0, 0,
  768, 0, 768, 1024, 0, 1024, 1024, 1024, 0, 0, 128, 0, 0, 0, 576, 0, 0, 52, 256, 0, 1216, 1216, 0, 1216, 0, 1216, 0,
  1268, 256, 0, 0, 1984, 0, 1984, 128, 0, 1216, 0, 0, 1216, 0, 1216, 1216, 1216, 1216, 192, 128, 0, 384, 0, 0, 384, 0,
  384, 384, 0, 384, 0, 384, 0, 384, 384, 384, 384, 0, 192, 53, 0, 0, 960, 0, 0, 0, 1024, 1024, 0, 192, 1333, 0, 0, 2048,
  0, 2048, 128, 0, 1280, 0, 0, 0, 640, 1280, 0, 1280, 0, 1280, 0, 1280, 1280, 0, 0, 1280, 1280, 1280, 1280, 0, 0, 448,
  448, 448, 448, 0, 1344, 1344, 1344, 0, 1344, 0, 1344, 0, 1536, 1536, 0, 1536, 0, 0, 1536, 1600, 1600, 1600, 1600, 0,
  0, 1664, 0, 1664, 0, 1664, 1664, 1664, 0, 192, 256, 323, 0, 0, 2112, 2112, 0, 2112, 2112, 2112, 0, 0, 0, 1152, 0, 0,
  0, 1600, 0, 1600, 1600, 0, 192, 256, 1728, 128, 0, 0, 1792, 1792, 1792, 0, 0, 1792, 0, 1792, 0, 0, 1792, 1792, 1792,
  1792, 0, 192, 256, 1856, 512, 0, 0, 0, 1088, 0, 1088, 0, 512, 512, 512, 512, 0, 0, 896, 0, 896, 896, 896, 896, 896,
  896, 0, 0, 0, 1984, 192, 256, 0, 192, 256, 0, 0, 0, 512, 0, 128, 1984, 0, 0, 1408, 0, 1408, 0, 0, 0, 1344, 0, 0, 0,
  1984, 1984, 1984, 1984, 0, 128, 0, 0, 576, 576, 0, 640, 0, 0, 1472, 0, 1472, 0, 0, 0, 1536, 640, 640, 640, 640, 0,
  640, 640, 640, 0, 0, 2048, 0, 0, 0, 1664, 1664, 2048, 2048, 2048, 2048, 0, 960, 0, 960, 0, 960, 960, 960, 960, 960, 0,
  0, 2112, 0, 0, 1728, 0, 0, 0, 1664, 0, 0, 128, 0, 0, 2176, 0, 2176, 0, 0, 2176, 2176, 2176, 2176, 704, 0, 0, 0, 1856,
  0, 0, 0, 1792, 0, 768, 768, 768, 768, 0, 1088, 0, 0, 0, 1920, 0, 1920, 0, 0, 0, 2176, 2176, 2176, 0, 1088, 1088, 1088,
  1088, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  4, 8, 16, 262144, 524288, 1048576, 16777216, 33554432, 1073741824, 262148, 524296, 335544320, 1026, 1073774592,
  786464, 134217984, -2147393536, 335577088, 168820736, 150995200, 819232, 134250752, 1074530336, 177209344,
  -2147360768, 17572384, 134267136, 151027968, -2130615680, 17572640, 1074563104, 177242112, 17605152, 720371712,
  -2130582912, 17605408, 720404480, -1072830432, 720404736, -1056085280, -1056052512, -920818976, -888313120,
  -887264544, -1074536448, -920786208, -888280352, -878875936, -887231776, -878843168, -136224, 4, 8, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0, 2, 0, 1, 2, 2, 1, 3, 0, 2, 1, 0, 3, 3, 0, 0, 1, 3, 1, 2, 1, 1, 3, 1, 3, 0, 1, 2, 2, 2, 3,
  3, 3, 2, 3, 3, 3, 0, 0
);

(:~
 : The match-code to case-id map. Maps decision point and lookahead to next action code.
 :)
declare variable $p:CASEID as xs:integer+ :=
(
  442, 228, 232, 407, 239, 233, 519, 243, 247, 252, 233, 232, 255, 228, 232, 264, 312, 232, 248, 235, 232, 286, 259,
  263, 418, 239, 233, 298, 268, 233, 425, 272, 247, 449, 281, 285, 264, 312, 232, 248, 432, 247, 336, 293, 232, 425,
  290, 247, 297, 233, 233, 302, 233, 233, 248, 234, 232, 495, 310, 232, 298, 268, 233, 425, 307, 247, 425, 317, 232,
  425, 321, 247, 425, 321, 247, 248, 439, 247, 456, 325, 233, 449, 329, 285, 354, 432, 247, 233, 303, 233, 466, 333,
  233, 449, 340, 285, 449, 344, 233, 449, 348, 352, 449, 358, 362, 354, 432, 247, 354, 432, 247, 459, 275, 232, 354,
  313, 247, 368, 233, 233, 374, 233, 233, 248, 432, 247, 248, 432, 247, 529, 380, 233, 485, 310, 232, 459, 275, 232,
  354, 364, 247, 541, 333, 233, 473, 386, 233, 354, 364, 247, 354, 364, 247, 354, 313, 247, 233, 277, 233, 233, 370,
  233, 233, 482, 392, 233, 492, 398, 233, 502, 404, 509, 411, 415, 516, 233, 233, 233, 422, 233, 297, 429, 233, 233,
  436, 233, 302, 446, 233, 233, 526, 233, 382, 531, 453, 233, 475, 233, 388, 376, 463, 538, 233, 233, 297, 470, 233,
  302, 479, 233, 400, 394, 489, 499, 233, 233, 506, 233, 233, 513, 233, 233, 233, 523, 233, 233, 535, 233, 550, 546,
  550, 547, 545, 546, 546, 546, 546, 548, 550, 599, 546, 556, 622, 562, 564, 564, 564, 569, 546, 546, 546, 551, 812,
  546, 814, 546, 547, 549, 565, 587, 579, 593, 595, 581, 546, 546, 546, 572, 599, 546, 546, 622, 562, 546, 561, 571,
  546, 546, 546, 583, 692, 606, 546, 618, 644, 620, 546, 546, 546, 576, 562, 550, 570, 571, 546, 546, 548, 733, 546,
  546, 546, 597, 772, 546, 546, 546, 634, 562, 550, 561, 571, 546, 550, 546, 546, 547, 546, 562, 546, 550, 571, 562,
  570, 561, 571, 628, 546, 546, 634, 606, 621, 638, 644, 699, 546, 649, 546, 549, 547, 551, 606, 621, 618, 644, 606,
  546, 660, 644, 606, 669, 666, 644, 668, 546, 546, 546, 550, 551, 606, 676, 673, 644, 675, 546, 546, 546, 570, 546,
  739, 546, 546, 546, 697, 546, 783, 546, 546, 546, 704, 546, 628, 546, 546, 546, 771, 546, 745, 546, 546, 546, 788,
  688, 712, 546, 546, 546, 802, 546, 720, 546, 546, 546, 805, 546, 731, 546, 546, 546, 557, 555, 597, 757, 546, 546,
  662, 752, 546, 546, 546, 557, 555, 604, 682, 546, 546, 546, 563, 796, 572, 656, 546, 546, 546, 564, 796, 549, 753,
  546, 546, 546, 570, 796, 546, 547, 549, 572, 693, 546, 546, 546, 610, 614, 597, 776, 546, 546, 546, 632, 650, 546,
  549, 546, 551, 787, 546, 546, 546, 642, 648, 654, 589, 546, 546, 546, 686, 546, 546, 782, 546, 600, 546, 546, 546,
  703, 708, 546, 549, 549, 798, 804, 546, 546, 546, 721, 718, 546, 549, 626, 798, 778, 546, 546, 546, 725, 729, 737,
  789, 546, 546, 546, 743, 661, 749, 546, 809, 546, 546, 761, 546, 546, 563, 561, 565, 714, 546, 546, 546, 766, 546,
  546, 632, 546, 546, 762, 546, 767, 546, 546, 546, 793, 546, 546, 642, 680, 654, 24946, 0, 0, 0, 0, 8406, 0, 0, 0,
  16626, 0, 32776, 0, 0, 0, 32776, 8406, 8406, 0, 8406, 8406, 8406, 8406, 16626, 24946, 8406, 0, 0, 8406, 8406, 16626,
  0, 147464, 147464, 140630, 140630, 140630, 140630, 0, 0, 82610, 0, 147464, 155656, 0, 0, 32782, 0, 155656, 14, 140630,
  140630, 0, 147464, 147464, 0, 0, 0, 49166, 198, 147464, 147464, 0, 131090, 139282, 0, 476754, 122898, 32776, 0,
  466962, 0, 149282, 466962, 49156, 0, 49156, 0, 0, 0, 147464, 8406, 8406, 0, 0, 131090, 139282, 0, 476754, 0, 0,
  157538, 0, 466962, 0, 0, 49156, 0, 550498, 0, 0, 157538, 147464, 338002, 163848, 0, 0, 0, 149282, 0, 540690, 0, 0,
  181654, 0, 466962, 0, 0, 0, 163860, 32788, 466962, 73780, 0, 73780, 0, 0, 73780, 466962, 81972, 0, 81972, 0, 0, 81972,
  0, 163848, 0, 0, 286738, 0, 0, 598034, 0, 0, 286744, 286740, 82594, 0, 0, 0, 189926, 0, 25322, 0, 0, 319506, 327698,
  41798, 0, 0, 0, 286740, 0, 41798, 0, 172882, 0, 172898, 0, 0, 401426, 0, 0, 50166, 0, 50166, 0, 0, 181250, 57364,
  188434, 196626, 57364, 0, 57364, 0, 57364, 0, 0, 492978, 0, 0, 204818, 0, 0, 558530, 0, 0, 163860, 0, 0, 581650,
  589842, 0, 32788, 32788, 16398, 0, 0, 0, 294930, 32788, 0, 163860, 163860, 231026, 0, 0, 0, 362466, 344082, 0, 0, 0,
  409618, 338002, 0, 0, 0, 509442, 0, 362482, 0, 0, 606226, 0, 368658, 0, 0, 0, 566802, 286740, 286740, 0, 0, 0, 614418,
  378498, 0, 0, 0, 8406, 0, 8406, 0, 16626, 270388, 0, 0, 198326, 0, 0, 0, 417810, 0, 0, 0, 25010, 0, 0, 16938, 0
);

(:~
 : The parser tokenset table. Maps state to lookahead tokenset code.
 :)
declare variable $p:TOKENSET as xs:integer+ :=
(
  35, 28, 52, 12, 37, 24, 17, 46, 32, 16, 48, 44, 24, 38, 30, 47, 0, 1, 13, 36, 16, 50, 42, 51, 51, 31, 22, 43, 40, 8,
  29, 45, 41, 49, 49, 40, 40, 20, 21, 0, 1, 38, 38, 14, 33, 20, 27, 25, 14, 27, 27, 21, 11, 7, 18, 23, 34, 39, 2, 3, 9,
  4, 10, 5, 15, 6, 26, 2, 9, 10, 19, 0, 1, 2, 3, 4
);

(:~
 : The conflict action list table. Contains list of conflicting actions.
 :)
declare variable $p:APPENDIX as xs:integer+ :=
(
  70315, 77828, 16394, 81930, 90827, 200713, 94963, 204809
);

(:~
 : The parser lookback table. Maps lookback code and itemset id to next lookback code.
 :)
declare variable $p:LOOKBACK as xs:integer+ :=
(
  138, 138, 138, 136, 136, 136, 139, 144, 154, 154, 154, 149, 157, 160, 165, 165, 165, 165, 170, 170, 170, 170, 138,
  138, 138, 138, 175, 175, 175, 175, 182, 182, 182, 182, 189, 196, 138, 199, 202, 205, 205, 205, 208, 211, 214, 219,
  222, 225, 138, 138, 138, 138, 228, 233, 238, 243, 248, 248, 248, 248, 138, 138, 138, 251, 256, 261, 264, 264, 264,
  138, 267, 270, 273, 276, 138, 138, 138, 279, 284, 289, 294, 299, 138, 138, 138, 302, 307, 307, 307, 312, 317, 317,
  317, 317, 322, 327, 327, 327, 327, 138, 332, 337, 337, 342, 347, 352, 357, 362, 138, 367, 370, 373, 138, 376, 379,
  382, 385, 388, 138, 391, 391, 391, 394, 394, 394, 394, 404, 409, 414, 419, 419, 419, 419, 397, 422, 425, 2, 2, 0, 9,
  8, 4, 3, 0, 9, 9, 4, 4, 0, 9, 10, 4, 5, 0, 7, 6, 0, 7, 11, 0, 19, 18, 15, 14, 0, 19, 20, 15, 16, 0, 19, 21, 15, 17, 0,
  31, 30, 27, 26, 23, 22, 0, 31, 32, 27, 28, 23, 24, 0, 31, 33, 27, 29, 23, 25, 0, 34, 34, 0, 36, 36, 0, 37, 37, 0, 38,
  38, 0, 40, 39, 0, 40, 41, 0, 43, 43, 42, 42, 0, 44, 44, 0, 45, 45, 0, 46, 46, 0, 57, 56, 49, 48, 0, 57, 58, 49, 50, 0,
  57, 59, 49, 51, 0, 54, 54, 53, 53, 0, 55, 55, 0, 67, 66, 61, 60, 0, 67, 68, 61, 62, 0, 64, 64, 0, 65, 65, 0, 69, 69,
  0, 70, 70, 0, 71, 71, 0, 72, 72, 0, 76, 74, 75, 74, 0, 76, 75, 75, 75, 0, 76, 76, 75, 75, 0, 79, 77, 78, 77, 0, 80,
  80, 0, 87, 86, 83, 82, 0, 87, 88, 83, 84, 0, 92, 90, 91, 90, 0, 92, 93, 91, 93, 0, 97, 95, 96, 95, 0, 97, 98, 96, 98,
  0, 76, 99, 75, 99, 0, 79, 100, 78, 100, 0, 102, 101, 101, 101, 0, 102, 102, 101, 101, 0, 104, 103, 103, 103, 0, 104,
  104, 103, 103, 0, 106, 105, 105, 105, 0, 76, 108, 0, 79, 109, 0, 110, 110, 0, 76, 112, 0, 79, 113, 0, 114, 114, 0,
  115, 115, 0, 116, 116, 0, 118, 118, 0, 120, 119, 0, 130, 132, 123, 125, 120, 121, 0, 130, 129, 123, 122, 0, 130, 131,
  123, 124, 0, 127, 127, 126, 126, 0, 128, 128, 0, 133, 133, 0, 134, 134, 0
);

(:~
 : The parser goto table. Maps state and nonterminal to next action code.
 :)
declare variable $p:GOTO as xs:integer+ :=
(
  130, 131, 234, 153, 131, 136, 131, 272, 131, 131, 141, 131, 254, 131, 131, 146, 131, 131, 194, 131, 151, 155, 131,
  153, 131, 160, 131, 132, 228, 232, 165, 131, 266, 131, 131, 170, 131, 176, 131, 131, 131, 180, 131, 147, 131, 186,
  131, 188, 131, 131, 131, 192, 200, 131, 131, 198, 131, 206, 131, 131, 204, 131, 260, 131, 131, 131, 210, 137, 228,
  232, 214, 131, 131, 131, 220, 142, 278, 284, 228, 232, 226, 230, 156, 238, 232, 242, 230, 172, 131, 131, 174, 131,
  222, 131, 131, 246, 131, 131, 161, 131, 131, 252, 182, 131, 131, 258, 131, 131, 166, 131, 264, 131, 248, 131, 131,
  270, 131, 131, 276, 282, 131, 131, 288, 131, 131, 290, 131, 216, 131, 131, 294, 305, 305, 305, 305, 310, 351, 305,
  305, 305, 364, 434, 305, 305, 305, 369, 431, 305, 305, 305, 374, 360, 304, 305, 305, 297, 305, 305, 305, 392, 446,
  305, 305, 305, 394, 321, 305, 305, 305, 455, 330, 305, 305, 305, 324, 305, 305, 305, 333, 305, 305, 394, 305, 305,
  336, 305, 339, 305, 305, 305, 342, 305, 449, 305, 305, 305, 380, 305, 404, 305, 305, 305, 401, 305, 416, 305, 305,
  305, 407, 305, 305, 455, 305, 359, 327, 305, 305, 305, 410, 305, 305, 368, 305, 305, 422, 305, 305, 388, 314, 300,
  318, 349, 355, 359, 305, 305, 306, 304, 398, 461, 318, 349, 305, 392, 398, 465, 419, 305, 305, 305, 428, 305, 305,
  374, 305, 305, 440, 305, 437, 305, 305, 305, 443, 305, 425, 305, 305, 305, 452, 305, 469, 305, 305, 305, 457, 305,
  305, 369, 373, 378, 373, 472, 373, 479, 345, 305, 305, 384, 476, 305, 413, 305, 305, 305, 6, 4113, 8345, 0, 24881,
  29337, 0, 32772, 32772, 57348, 20769, 0, 0, 0, 0, 16417, 49705, 217449, 221577, 225769, 229385, 28676, 28676, 28676,
  61444, 53817, 29337, 0, 82481, 8345, 0, 86044, 8345, 0, 99149, 8345, 0, 107129, 8345, 0, 110601, 8345, 0, 115765,
  8345, 0, 119705, 8345, 0, 123841, 8345, 0, 126980, 118788, 155657, 57953, 66181, 0, 0, 8345, 0, 61444, 57348, 102404,
  102404, 107381, 0, 0, 0, 16457, 49705, 258057, 221577, 225769, 111525, 0, 0, 0, 118788, 61444, 0, 0, 0, 249865,
  152153, 66181, 0, 0, 77828, 29369, 49705, 0, 221641, 225769, 49705, 0, 0, 225817, 49705, 0, 0, 0, 241673, 0, 49156, 0,
  0, 0, 127417, 8345, 0, 131593, 8345, 0, 135177, 8345, 0, 135188, 8345, 0, 135196, 8345, 0, 139273, 8345, 0, 139276,
  8345, 0, 176753, 8345, 0, 193537, 8345, 0, 196617, 8345, 0, 213313, 8345, 0, 32825, 8345, 0, 32804, 8345, 0, 37161,
  8345, 0, 45076, 8345, 0, 45409, 8345, 0, 53817, 29337, 0, 53829, 8345, 0, 66181, 0, 0, 12537, 0, 36892, 32772, 32772,
  57348, 40988, 32772, 32772, 57348, 0, 287569, 8345, 0, 263129, 118788, 266249, 122908, 131076, 0, 0, 263185, 118788,
  266249
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "cchar",
  "dchar",
  "schar",
  "hex",
  "'#'",
  "'('",
  "'@'",
  "']'",
  "'^'",
  "'}'",
  "'~'",
  "END",
  "capital",
  "letter",
  "whitespace",
  "namestart1",
  "namefollower1",
  "'""'",
  "''''",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'.'",
  "':'",
  "';'",
  "'='",
  "'?'",
  "'['",
  "'_'",
  "'{'",
  "'|'"
);

(:~
 : The nonterminal name table.
 :)
declare variable $p:NONTERMINAL as xs:string+ :=
(
  "ixml",
  "s",
  "comment",
  "rule",
  "mark",
  "alts",
  "alt",
  "term",
  "factor",
  "repeat0",
  "repeat1",
  "option",
  "sep",
  "nonterminal",
  "terminal",
  "literal",
  "quoted",
  "name",
  "namestart",
  "namefollower",
  "tmark",
  "string",
  "dstring",
  "sstring",
  "encoded",
  "charset",
  "inclusion",
  "exclusion",
  "set",
  "member",
  "range",
  "from",
  "to",
  "character",
  "class",
  "code"
);

(:~
 : Predict the decision for a given decision point based on current
 : lookahead.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @param $dpi the decision point index.
 : @param $id the parsing thread id.
 : @return the updated parser state.
 :)
declare function p:predict($input as xs:string,
                           $state as item()+,
                           $dpi as xs:integer,
                           $id as xs:integer) as item()+
{
  let $state := p:lookahead1($p:TOKENSET[$dpi + 1], $input, $state, $id)
  return
    if ($state[$p:l1] lt 0) then
    (
      0,
      subsequence($state, $p:lk + 1)
    )
    else
      let $j10 := 48 * $dpi + $state[$p:l1]
      let $j11 := $j10 idiv 4
      let $j12 := $j11 idiv 4
      let $action := $p:CASEID[$j10 mod 4 + $p:CASEID[$j11 mod 4 + $p:CASEID[$j12 + 1] + 1] + 1]
      return ($action idiv 2, subsequence($state, $p:lk + 1))
};

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @param $id the parsing thread id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer,
                         $id as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 64,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 64
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 16
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 16 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 350)
    let $current := $current + 1
    let $i0 := 64 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 4
    let $next-state := $p:TRANSITION[$i0 mod 4 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 63) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 64, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Get GOTO table entry for given nonterminal and parser state.
 :
 : @param $nonterminal the nonterminal.
 : @param $state the LR parser state.
 : @return the GOTO table entry.
 :)
declare function p:goto($nonterminal as xs:integer, $state as xs:integer) as xs:integer
{
  let $i0 := 40 * $state + $nonterminal
  let $i1 := $i0 idiv 4
  let $i2 := $i1 idiv 4
  return $p:GOTO[$i0 mod 4 + $p:GOTO[$i1 mod 4 + $p:GOTO[$i2 + 1] + 1] + 1]
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 1
    let $i0 := $t * 53 + $state - 1
    return p:token((), $p:EXPECTED[$i0 + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[350 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[700 + $m]
};

(:~
 : Compare a lookback code to a sorted, zero-terminated list of pairs at
 : the given index into the LOOKBACK table. A matching first code in a
 : pair will cause its second code to be returned. The list is sorted in
 : descending order of first codes, so it is safe to stop when the first
 : code is less than what is searched for.
 :
 : @param $x the lookback code to search for.
 : @param $i the index into the LOOKBACK table.
 : @return the new lookback code as the second code from a pair with a
 : matching first code.
 :)
declare function p:lookback($x as xs:integer, $i as xs:integer)
{
  let $l := $p:LOOKBACK[$i + 1]
  return
    if ($l gt $x) then
      p:lookback($x, $i + 2)
    else if ($l eq $x) then
      $p:LOOKBACK[$i + 2]
    else
      0
};

(:~
 : Calculate number of symbols to remove from LR stack for reduction by
 : walking through lookback codes of reduction and stack entries. A single
 : invocation combines two of those, more are handled in tail recursion.
 :
 : @param $code the reduction lookback code.
 : @param $count the initial count value.
 : @param $stack the LR stack.
 : @param $t the stack running index.
 : @return the initial count value, increased by the number of calculations
 : yielding a non-zero lookback code.
 :)
declare function p:count($code as xs:integer, $count as xs:integer, $stack as xs:integer*, $t as xs:integer)
{
  if ($stack[$t] lt 0) then
    $count
  else
    let $code := p:lookback($stack[$t + 1], $p:LOOKBACK[$code + 1])
    return
      if ($code eq 0) then
        $count
      else
        p:count($code, $count + 1, $stack, $t - 3)
};

(:~
 : Determine index of the next thread that must be parsed, by comparing
 : threads in $threads starting at $i with the candidate at $thread.
 :
 : @param $threads the sequence of all current threads.
 : @param $thread the index of the next thread candidate.
 : @param $i the index where to start searching.
 : @return the index of the next thread.
 :)
declare function p:next-thread($threads as map(*)*, $thread as xs:integer, $i as xs:integer)
{
  if ($i gt count($threads)) then
    $thread
  else
    let $thread :=
      if ($threads[$thread]?accepted ne $threads[$i]?accepted) then
        if ($threads[$thread]?accepted) then $i else $thread
      else
        let $comp := $threads[$thread]?lexer-state[$p:e0] - $threads[$i]?lexer-state[$p:e0]
        return
          if ($comp ne 0) then
            if ($comp lt 0) then $thread else $i
          else
            let $comp := $threads[$thread]?id - $threads[$i]?id
            return if ($comp le 0) then $thread else $i
    return p:next-thread($threads, $thread, $i + 1)
};

(:~
 : Compare two parsing threads for equality. A result of false indicates an
 : ambiguity.
 :
 : @param $t1 the first thread data.
 : @param $t2 the second thread data.
 : @return true(), if threads are equal.
 :)
declare function p:thread-equals($t1 as map(*), $t2 as map(*)) as xs:boolean
{
  if ($t1?accepted ne $t2?accepted) then false() else
  if ($t1?b1 ne $t2?lexer-state[$p:b1]) then false() else
  if ($t1?e1 ne $t2?lexer-state[$p:e1]) then false() else
  if ($t1?l1 ne $t2?lexer-state[$p:l1]) then false() else
  if ($t1?state ne $t2?state) then false() else
  if ($t1?action ne $t2?action) then false() else deep-equal($t1?stack, $t2?stack)
};

(:~
 : Perform GLR parsing by selecting a thread and invoke the LR parse function
 : on it for a single token. Process result with respect to thread management.
 :
 : @param $input the input string.
 : @param $target the target symbol code.
 : @param $max-id the maximum thread id.
 : @param $threads the sequence of all current threads.
 : @return the lexer state of the accepting (or error) thread.
 :)
declare function p:parse-glr($input as xs:string,
                             $target as xs:integer,
                             $max-id as xs:integer,
                             $threads as map(*)+)
{
  let $i := p:next-thread($threads, 1, 2)
  let $thread := $threads[$i]
  let $lexer-state := $thread?lexer-state
  return
    if ($thread?accepted) then
      let $max-e0 := max($threads!?lexer-state[$p:e0])
      let $longest-accept := $threads[?lexer-state[$p:e0] eq $max-e0]
      return
        if (count($longest-accept) eq 1) then
          $longest-accept?lexer-state
        else
          p:reject-ambiguity($longest-accept[1], $longest-accept[2])
    else
      let $threads := (subsequence($threads, 1, $i - 1), subsequence($threads, $i + 1))
      let $other := if (exists($threads)) then $threads[p:next-thread($threads, 1, 2)] else ()
      return
        if (exists($other) and p:thread-equals($thread, $other)) then
          p:reject-ambiguity($thread, $other)
        else
          let $thread := p:parse($input, $target, $max-id, $thread)
          let $lexer-state := $thread?lexer-state
          return
            if (count($thread) gt 1) then
              p:parse-glr($input, $target, $max-id + 1, ($threads, $thread))
            else if (not($lexer-state[$p:error])) then
              p:parse-glr($input, $target, $max-id, ($threads, $thread))
            else if (exists($threads)) then
              p:parse-glr($input, $target, $max-id, $threads)
            else
              $lexer-state
};

(:~
 : Raise an error for ambiguous input.
 :
 : @param $thread the parsing thread data.
 : @param $other the parsing thread data of the other thread.
 : @return a lexer state containing an error element describing the ambiguity.
 :)
declare function p:reject-ambiguity($thread as map(*), $other as map(*)) as item()+
{
  let $lexer-state := $thread?lexer-state
  return
  (
    subsequence($lexer-state, 1, $p:error - 1),
    element error
    {
      attribute b {$thread?stack[last() - 2]},
      attribute e {$lexer-state[$p:e0]},
      attribute ambiguous-input {true()},
      let $first-tree := $lexer-state[last()]
      let $second-tree := $other?lexer-state[last()]
      return
        <AMBIGUOUS>
          <ALTERNATIVE>{p:rewrite-ambiguity($first-tree, $second-tree, true())}</ALTERNATIVE>
          <ALTERNATIVE>{p:rewrite-ambiguity($second-tree, $first-tree, true())}</ALTERNATIVE>
        </AMBIGUOUS>
    },
    subsequence($lexer-state, $p:error + 1)
  )
};

(:~
 : Rewrite a parse tree fragment $first, combining elements into an "UNAMBIGUOUS"
 : element as long as they match elements in $second, in node order.
 :
 : @param $first the first node.
 : @param $second the second node.
 : @return $first rewritten, with initial element nodes possibly combined.
 :)
declare function p:rewrite-ambiguity($first as node(), $second as node()?, $unambiguous as xs:boolean)
{
  typeswitch ($first)
  case element() return
    if ($unambiguous and deep-equal($first, $second)) then
      <UNAMBIGUOUS>{string($first)}</UNAMBIGUOUS>
    else
      element {node-name($first)}
      {
        for $node at $i in $first/node()
        let $unambiguous :=
          $unambiguous and
          (every $j in 1 to $i - 1 satisfies deep-equal($first/node()[$j], $second/node()[$j]))
        return p:rewrite-ambiguity($node, $second/node()[$i], $unambiguous)
      }
  default return
    $first
};

(:~
 : Construct a new map containing data for one parsing thread.
 :
 : @param $id the parsing thread id.
 : @param $accepted true(), if this thread has accepted.
 : @param $state the LR parser state number.
 : @param $action the action code.
 : @param $nonterminal current nonterminal, -1 if processing a terminal.
 : @param $bw the whitespace begin input index.
 : @param $bs the symbol begin input index.
 : @param $es the symbol end input index.
 : @param $stack the LR stack.
 : @param $lexer-state lexer state, error indicator, and result stack.
 : @return the thread data map.
 :)
declare function p:thread($id as xs:integer,
                          $accepted as xs:boolean,
                          $state as xs:integer,
                          $action as xs:integer,
                          $nonterminal as xs:integer,
                          $bw as xs:integer,
                          $bs as xs:integer,
                          $es as xs:integer,
                          $stack as xs:integer*,
                          $lexer-state as item()+) as map(*)
{
  map
  {
    "id": $id,
    "accepted": $accepted,
    "state": $state,
    "action": $action,
    "nonterminal": $nonterminal,
    "bw": $bw,
    "bs": $bs,
    "es": $es,
    "stack": $stack,
    "lexer-state": $lexer-state
  }
};

(:~
 : Parse input for given target symbol using LR tables. Each invocation
 : handles one parsing action (shift, reduce, shift+reduce, accept).
 : Subsequent actions are handled by tail-recursion.
 :
 : @param $input the input string.
 : @param $target the target symbol code.
 : @param $max-id the maximum thread id.
 : @param $thread the parsing thread data.
 : @return the updated state.
 :)
declare function p:parse($input as xs:string,
                         $target as xs:integer,
                         $max-id as xs:integer,
                         $thread as map(*))
{
  let $lexer-state := $thread?lexer-state
  return
    if ($lexer-state[$p:error]) then
      $thread
    else
      let $state := $thread?state
      let $action := $thread?action
      let $nonterminal := $thread?nonterminal
      let $bw := $thread?bw
      let $bs := $thread?bs
      let $es := $thread?es
      let $stack := $thread?stack
      let $argument := $action idiv 4096
      let $lookback := ($action idiv 8) mod 512
      let $action := $action mod 8
      return
        if ($action eq 6) then (: SHIFT+ACCEPT :)
          p:thread($thread?id, true(), $state, $action, $nonterminal, $bw, $bs, $es, $stack, $lexer-state)
        else if ($action eq 7) then (: FORK :)
          for $i in (1, 2)
          return p:thread(($max-id + 1, $thread?id)[$i], false(), $state, $p:APPENDIX[$argument + $i], -1, $bw, $bs, $es, $stack, $lexer-state)
        else
          let $shift-reduce-symbols :=
            if ($action eq 1) then (: SHIFT :)
              ($argument, -1, -1)
            else if ($action eq 2) then (: REDUCE :)
              (-1, $argument, $lookback)
            else if ($action eq 3) then (: REDUCE+LOOKBACK :)
              (-1, $argument, p:count($lookback, 0, $stack, count($stack) - 1))
            else if ($action eq 4) then (: SHIFT+REDUCE :)
              ($state, $argument, $lookback + 1)
            else if ($action eq 5) then (: SHIFT+REDUCE+LOOKBACK :)
              ($state, $argument, p:count($lookback, 1, $stack, count($stack) - 1))
            else (: ERROR :)
              (-1, -1, -1)
          let $shift := $shift-reduce-symbols[1]
          let $reduce := $shift-reduce-symbols[2]
          let $symbols := $shift-reduce-symbols[3]
          let $es := if ($shift lt 0 or $nonterminal ge 0) then $es else $lexer-state[$p:e1]
          let $lexer-state :=
            if ($shift lt 0 or $nonterminal ge 0) then
              $lexer-state
            else
              p:consume
              (
                $lexer-state[$p:l1],
                $input,
                $lexer-state
              )
          let $stack :=
            if ($shift lt 0) then
              $stack
            else
              ($stack, if ($nonterminal lt 0) then $lexer-state[$p:b0] else $bs, $state, $lookback)
          let $state := if ($shift lt 0) then $state else $shift
          return
            if ($reduce lt 0) then
              if ($shift lt 0) then
              (
                p:thread
                (
                  $thread?id, false(), $state, 0, -1, $bw, $bs, $es, $stack,
                  (
                    subsequence($lexer-state, 1, $p:error - 1),
                    element error
                    {
                      attribute b {$lexer-state[$p:b1]},
                      attribute e {$lexer-state[$p:e1]},
                      attribute o {$lexer-state[$p:l1]}[. > 0],
                      attribute s {$p:TOKENSET[$state + 1] + 1}
                    },
                    subsequence($lexer-state, $p:error + 1)
                  )
                )
              )
              else
                let $lexer-state := p:predict($input, $lexer-state, $state, $thread?id)
                return p:thread($thread?id, false(), $state, $lexer-state[$p:lk], -1, $bw, $bs, $es, $stack, $lexer-state)
            else
              let $state := if ($symbols gt 0) then $stack[last() - 3 * $symbols + 2] else $state
              let $bs := if ($symbols gt 0) then $stack[last() - 3 * $symbols + 1] else $lexer-state[$p:b1]
              let $es := if ($symbols gt 0) then $es else $bs
              let $stack := if ($symbols gt 0) then subsequence($stack, 1, count($stack) - 3 * $symbols) else $stack
              let $accept := $reduce eq $target and count($stack) eq 3
              let $bs := if ($accept) then $bw else $bs
              let $es := if ($accept) then $lexer-state[$p:b1] else $es
              let $bw := if ($accept) then $es else $bw
              let $index := if ($accept) then $p:result else p:first-child-node-index($lexer-state, count($lexer-state) + 1, $symbols)
              let $lexer-state :=
              (
                subsequence($lexer-state, 1, $index - 1),
                element {$p:NONTERMINAL[$reduce + 1]}
                {
                  (: bs, es :)
                  subsequence($lexer-state, $index)
                }
              )
              let $nonterminal := $reduce
              let $thread := p:thread($thread?id, false(), $state, p:goto($nonterminal, $state), $nonterminal, $bw, $bs, $es, $stack, $lexer-state)
              return p:parse($input, $target, $max-id, $thread)
};

(:~
 : Decrement given index by the given number of elements on the result
 : stack, skipping any non-element nodes.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $index the index into the result stack.
 : @param $element-count the number of elements to be handled.
 : @return the decremented index.
 :)
declare function p:first-child-node-index($state as item()+,
                                          $index as xs:integer,
                                          $element-count as xs:integer)
{
  if ($element-count eq 0) then
    $index
  else
    let $index := $index - 1
    let $element-count := $element-count - (if ($state[$index] instance of element()) then 1 else 0)
    return p:first-child-node-index($state, $index, $element-count)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@ambiguous-input) then
          "ambiguous input"
        else if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        if ($error/@ambiguous-input) then
          ()
        else
        (
          "while expecting ",
          if ($error/@x) then
            $p:TOKEN[$error/@x + 1]
          else
            let $expected := p:expected-token-set($error/@s)
            return
            (
              "["[exists($expected[2])],
              string-join($expected, ", "),
              "]"[exists($expected[2])]
            ),
          "&#10;",
          if ($error/@o or $error/@e = $begin) then
            ()
          else
            ("after successfully scanning ", string($error/@e - $begin), " characters beginning ")
        ),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 3),
    0, 0, 0,
    subsequence($state, 7),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @param $id the parsing thread id.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+, $id as xs:integer) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
        p:match($input, $state[$p:e0], $set, $id)
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 7)
    )
};

(:~
 : Parse start symbol ixml from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-ixml($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, false())
  let $state := p:predict($s, $state, 0, 0)
  let $state := p:parse-glr($s, 0, 0, p:thread(0, false(), 0, $state[$p:lk], -1, 1, 1, 1, (1, -1, 0), $state))
  let $error := $state[$p:error]
  return
    if ($error) then
    (
      $error/AMBIGUOUS,
      element ERROR {$error/@*, p:error-message($s, $error)}
    )
    else
      subsequence($state, $p:result)
};

(: End :)
