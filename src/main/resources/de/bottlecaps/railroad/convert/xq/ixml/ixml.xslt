<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Wed Dec 21, 2022 23:12 (UTC+01) by REx v5.56 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: -glalr 1 -tree -a none -xslt -name de/bottlecaps/railroad/convert/xq/ixml/ixml.xslt ..\..\..\..\..\..\..\..\main\java\de\bottlecaps\railroad\convert\ixml\ixml.ebnf -->

<xsl:stylesheet version="3.0"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:p="de/bottlecaps/railroad/convert/xq/ixml/ixml.xslt">
  <!--~
   ! The index of the lexer state for accessing the combined
   ! (i.e. level > 1) lookahead code.
  -->
  <xsl:variable name="p:lk" as="xs:integer" select="1"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the token that has been consumed.
  -->
  <xsl:variable name="p:b0" as="xs:integer" select="2"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the token that has been consumed.
  -->
  <xsl:variable name="p:e0" as="xs:integer" select="3"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-1-lookahead token.
  -->
  <xsl:variable name="p:l1" as="xs:integer" select="4"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-1-lookahead token.
  -->
  <xsl:variable name="p:b1" as="xs:integer" select="5"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-1-lookahead token.
  -->
  <xsl:variable name="p:e1" as="xs:integer" select="6"/>

  <!--~
   ! The index of the lexer state for accessing the token code that
   ! was expected when an error was found.
  -->
  <xsl:variable name="p:error" as="xs:integer" select="7"/>

  <!--~
   ! The index of the lexer state that points to the first entry
   ! used for collecting action results.
  -->
  <xsl:variable name="p:result" as="xs:integer" select="8"/>

  <!--~
   ! The codepoint to charclass mapping for 7 bit codepoints.
  -->
  <xsl:variable name="p:MAP0" as="xs:integer+" select="
    0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 2, 3, 4, 2, 2, 2, 5, 6, 7, 8, 9, 10, 11, 12, 2, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 2, 16, 2, 17, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 21, 2, 22, 23, 24, 2, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 28, 29, 30, 2
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints below the surrogate block.
  -->
  <xsl:variable name="p:MAP1" as="xs:integer+" select="
    432, 580, 1309, 1309, 1309, 463, 1245, 448, 1309, 493, 537, 512, 642, 1270, 688, 1201, 1339, 1351, 553, 596, 612, 628, 658, 674, 714, 749, 765, 796, 568,
    823, 839, 855, 871, 902, 1309, 1309, 698, 918, 945, 961, 1308, 1309, 1309, 1309, 496, 982, 998, 1014, 527, 1030, 1488, 1460, 1054, 1070, 1092, 1108, 1563,
    1076, 1309, 886, 1309, 1309, 1380, 1124, 1140, 477, 1156, 1172, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173, 1173,
    1173, 1173, 1173, 1173, 1173, 1189, 733, 1217, 1233, 807, 1173, 1173, 1173, 1261, 1286, 1302, 1325, 1173, 1173, 1173, 1173, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1038, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 966, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1367, 1309, 1309, 1396, 1412, 728, 1428, 1451, 780, 1476, 1504, 929, 1520, 1536,
    1435, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309,
    1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1552, 1585, 1579, 1585, 1585, 1593, 1601, 1625, 1631, 1639, 1646, 1646, 1651, 1659, 1666, 1666,
    1671, 2161, 1702, 1812, 1812, 1992, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1995, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 2080, 1812,
    1818, 2159, 1815, 2173, 2159, 2159, 1812, 1815, 2159, 2159, 2159, 2159, 2159, 2159, 2095, 2098, 2050, 2095, 2102, 2159, 1679, 1810, 1812, 1812, 1812, 1812,
    1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 2185, 1812, 1812, 1812, 2159, 2094, 2095, 2095, 2095, 2095, 1717, 1689, 2159, 1812, 1812, 1812,
    1817, 1817, 2159, 2052, 2095, 2101, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 2159, 1811, 1812, 1812, 1812, 1813, 2230, 1811, 1812,
    1812, 1812, 2061, 1812, 1812, 1812, 1812, 1812, 1812, 1731, 2094, 2258, 1715, 1812, 1771, 2095, 1811, 1811, 1812, 1812, 1812, 1812, 1812, 1897, 2100, 2129,
    2096, 2095, 2101, 2159, 2159, 2159, 2159, 2158, 2229, 1608, 2229, 1812, 1812, 1813, 1812, 1812, 1812, 1813, 1812, 1976, 2185, 1809, 1812, 1812, 1993, 1789,
    1804, 2114, 1826, 2159, 2205, 1771, 2095, 1818, 2159, 2217, 1835, 1809, 1812, 1812, 1993, 1882, 2318, 2309, 1937, 2246, 1889, 2035, 2095, 1844, 2159, 2217,
    1995, 1992, 1812, 1812, 1993, 1885, 1804, 1681, 2258, 2231, 2159, 1771, 2095, 2159, 2159, 2095, 2100, 1812, 1812, 1812, 1812, 1812, 2294, 2095, 2095, 2095,
    1941, 2128, 1812, 1976, 2185, 1809, 1812, 1812, 1993, 1885, 1855, 2114, 2234, 2233, 2205, 1771, 2095, 2230, 2159, 1829, 1873, 1832, 1878, 1737, 1873, 1812,
    1818, 2102, 2234, 2231, 2159, 2035, 2095, 2159, 2159, 2127, 1812, 1812, 1812, 2095, 2095, 2095, 1616, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812,
    1832, 1813, 1832, 1812, 1812, 1812, 1812, 1920, 1989, 1993, 1812, 1812, 1993, 1990, 2143, 2018, 2113, 2036, 1818, 1771, 2095, 2159, 2159, 2160, 1812, 1810,
    1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1815, 1781, 2078, 2159, 1920, 1989, 1993, 1812, 1812, 1993, 1990, 1855, 2233, 2037,
    2159, 2161, 1771, 2095, 1739, 2159, 1920, 1989, 1993, 1812, 1812, 1812, 1812, 1905, 2114, 1826, 2159, 2159, 1771, 2095, 2159, 1810, 1812, 1812, 1812, 1812,
    1812, 1816, 2159, 2235, 2159, 2095, 2101, 2095, 2095, 1747, 2228, 1920, 1812, 1813, 1810, 1812, 1812, 1992, 1997, 1813, 2245, 1952, 2159, 2159, 2159, 2159,
    2159, 2160, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1794, 1796, 1921, 1811, 1701, 1697, 1897, 1913, 1996, 2097, 2095, 1617, 2159, 2159,
    2159, 2159, 2231, 2159, 2159, 2101, 2095, 2101, 1930, 2246, 1812, 1811, 1812, 1812, 1812, 1815, 2094, 2096, 1718, 1750, 2095, 2094, 2095, 2095, 2095, 2098,
    2233, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1949, 2093, 1865, 2095, 2101, 1814, 1962, 1735, 1919, 1900, 1812, 1812, 1812,
    1812, 1812, 1812, 1812, 1812, 2095, 2095, 2095, 2095, 2096, 2159, 2159, 2020, 1847, 1826, 2095, 1972, 1812, 1812, 1812, 1812, 1995, 2162, 1812, 1812, 1812,
    1812, 1812, 1991, 1812, 1832, 1812, 1812, 1812, 1812, 1832, 1813, 1832, 1812, 1813, 1812, 1812, 1812, 1812, 1812, 1762, 1861, 2159, 2125, 2254, 2095, 2101,
    1812, 1812, 1813, 2229, 1812, 1812, 1832, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1949, 2159, 2159, 2159, 2159, 1812, 1812, 2159, 2159, 1812, 1812,
    1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1815, 2159, 2159, 2159, 2159, 2159, 2159, 1986, 1812, 1812, 1817, 1812, 1812, 1812, 1812, 1812, 1812, 1812,
    1812, 1812, 1817, 2159, 2159, 1812, 1989, 2005, 2159, 1812, 1812, 2005, 2159, 1812, 1812, 2015, 2159, 1812, 1989, 2308, 2159, 1812, 1812, 1812, 1812, 1812,
    1812, 1964, 2097, 2233, 2094, 2115, 2029, 2095, 2101, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 2282, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1814,
    2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 2129, 2102, 1812, 1812, 1812, 1812, 1812, 1812, 2045, 2096, 1935, 2098, 2021, 2297, 2095,
    2101, 2095, 2101, 2160, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2111, 2095, 2093, 2123, 2138, 2159, 2060, 1812, 1812, 1812, 1812,
    1812, 2070, 1954, 2261, 1816, 2095, 2101, 2159, 2021, 2099, 2159, 2062, 1812, 1812, 1812, 1613, 1693, 2095, 1747, 1812, 1812, 1812, 1812, 2130, 2088, 2101,
    2159, 1812, 1812, 1812, 1812, 1812, 1812, 1989, 1996, 2264, 1815, 2186, 1816, 1812, 1815, 2264, 1815, 2151, 2156, 2159, 2159, 2159, 2103, 2159, 2232, 2102,
    2159, 2159, 2103, 2159, 2159, 2230, 2160, 2170, 1810, 1997, 2184, 2173, 1888, 1812, 2194, 1920, 1836, 2159, 2159, 2159, 2159, 2159, 2159, 1737, 2159, 2159,
    2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1813, 1812, 1812, 1812, 1812, 1812, 1813,
    1812, 1812, 1812, 1812, 1749, 2095, 2283, 2159, 2095, 1747, 1812, 1812, 1812, 2294, 2076, 2229, 1812, 1812, 1812, 1812, 1995, 2162, 1812, 1812, 1812, 1812,
    1812, 1812, 1812, 2160, 2159, 2232, 1812, 1812, 1813, 2159, 1813, 1813, 1813, 1813, 1813, 1813, 1813, 1813, 2095, 2095, 2095, 2095, 2095, 2095, 2095, 2095,
    2095, 2095, 2095, 2095, 2095, 2095, 1989, 2196, 2204, 2159, 2159, 2159, 2159, 1775, 2184, 1737, 1811, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812,
    1812, 1710, 2297, 1726, 2074, 2095, 1903, 1812, 1812, 1813, 2217, 1811, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1991, 1920, 1812, 1812,
    1812, 1812, 1814, 1811, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1813, 2159, 2159, 1812, 1812,
    1812, 1817, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 1749, 1760, 1758, 2296, 2159, 2159, 1812, 1812, 1812, 2006, 2159, 2159, 2159, 2159, 1993, 1815,
    2159, 2159, 2159, 2159, 2159, 2159, 2020, 2095, 2095, 2096, 1812, 1815, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1814,
    1814, 1812, 1812, 1812, 1812, 1814, 1814, 1812, 2176, 1812, 1812, 1812, 1814, 1812, 1815, 1812, 1812, 2095, 2078, 2159, 2159, 1812, 1812, 1812, 1812, 1812,
    2129, 2020, 1763, 1812, 1812, 1812, 2232, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1812, 1814, 2159, 2101, 2159, 1812, 2195, 1816, 2159, 1812, 1817, 2159,
    2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 2317, 2258, 2095, 2101, 2277, 2125, 1812, 1812, 2213, 2159, 2159, 2159, 1812, 1812,
    1812, 1812, 1812, 1812, 1816, 2159, 2159, 1811, 2159, 2095, 2101, 2159, 2159, 2159, 2159, 2095, 1747, 1812, 1812, 1749, 2097, 1812, 1812, 2129, 2095, 2101,
    2159, 1812, 1812, 1812, 1815, 2007, 2102, 2245, 1939, 2035, 2095, 1812, 1812, 1812, 1814, 1815, 2159, 2061, 1812, 1812, 1812, 1812, 1812, 1846, 2243, 2159,
    2160, 2095, 2101, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1812, 1812, 2272, 2291, 2282, 2159, 2159, 1978, 1812, 2306, 2220, 2159, 1994, 1994, 1994,
    2159, 1813, 1813, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 2159, 1812, 1812, 1812, 1812, 1816, 2159, 1812, 1812, 1813, 1922, 1812, 1812, 1812,
    1812, 1812, 1816, 2020, 2298, 2159, 2095, 1779, 2095, 1747, 1812, 1812, 1812, 1814, 0, 33, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 33, 2, 3, 4, 2, 2, 2, 5, 6,
    7, 8, 9, 10, 11, 12, 2, 2, 2, 2, 2, 31, 2, 32, 32, 32, 32, 2, 2, 31, 31, 31, 31, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 2, 16, 2, 17, 18, 19, 19, 19, 19,
    19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 2, 22, 23, 24, 2, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 28, 29, 30, 2, 31, 31, 2, 32, 32,
    32, 32, 32, 2, 32, 2, 32, 32, 2, 32, 32, 2, 32, 2, 2, 31, 31, 2, 31, 31, 31, 2, 31, 2, 31, 31, 31, 31, 31, 31, 2, 31, 32, 32, 32, 32, 32, 32, 32, 2, 32, 32,
    32, 32, 32, 32, 32, 31, 31, 32, 2, 32, 31, 2, 2, 2, 31, 31, 2, 2, 2, 2, 2, 32, 32, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 31, 32, 32, 32, 32,
    32, 32, 2, 31, 31, 31, 32, 32, 2, 2, 32, 32, 32, 32, 2, 2, 2, 31, 31, 31, 31, 32, 31, 2, 31, 2, 2, 2, 31, 31, 2, 31, 2, 2, 31, 2, 2, 31, 31, 2, 2, 32, 31,
    2, 2, 31, 31, 31, 31, 31, 31, 31, 31, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 31, 2, 31, 31, 31, 31, 2, 2, 2, 2, 31, 2, 32, 32, 31, 31, 31, 32, 2, 2, 32, 32,
    2, 31, 31, 2, 2, 32, 31, 2, 32, 32, 2, 2, 32, 32, 2, 2, 32, 32, 31, 31, 31, 31, 2, 2, 2, 31, 31, 2, 31, 2, 31, 31, 2, 31, 31, 2, 31, 31, 31, 31, 2, 31, 2,
    31, 32, 31, 31, 32, 32, 32, 32, 31, 31, 31, 2, 2, 31, 2, 2, 32, 32, 2, 32, 32, 31, 2, 2, 2, 2, 2, 2, 31, 31, 31, 31, 31, 2, 2, 2, 2, 2, 32, 2, 32, 2, 2, 32,
    32, 32, 2, 2, 2, 2, 31, 31, 31, 31, 31, 2, 2, 32, 32, 32, 2, 32, 2, 2, 2, 32, 32, 31, 31, 31, 31, 32, 32, 2, 32, 32, 32, 2, 2, 2, 32, 2, 2, 2, 31, 31, 31,
    2, 2, 33, 31, 31, 31, 31, 31, 31, 31, 2, 31, 31, 31, 31, 31, 31, 2, 31, 2, 2, 31, 31, 32, 32, 32, 2, 2, 2, 2, 32, 31, 31, 32, 32, 2, 2, 2, 2, 2, 32, 32, 32,
    32, 32, 2, 2, 2, 2, 31, 32, 2, 2, 2, 2, 2, 2, 32, 32, 2, 2, 31, 31, 31, 31, 31, 2, 32, 2, 2, 2, 32, 32, 32, 33, 2, 32, 32, 32, 32, 2, 31, 31, 31, 31, 31,
    31, 31, 31, 31, 32, 2, 32, 32, 32, 32, 31, 31, 2, 2, 2, 2, 31, 31, 32, 32, 2, 2, 2, 32, 2, 32, 32, 32, 32, 32, 32, 32, 32, 2, 2, 2, 2, 2, 2, 2, 33, 32, 32,
    32, 2, 32, 32, 32, 32, 2, 2, 2, 31, 32, 31, 31, 31, 31, 32, 31, 31, 31, 31, 31, 31, 31, 32, 2, 31, 31, 2, 2, 32, 31, 31, 2, 2, 2, 31, 32, 32, 33, 33, 33,
    33, 33, 33, 33, 33, 2, 2, 2, 2, 2, 2, 2, 2, 31, 2, 2, 2, 2, 31, 2, 2, 2, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 31, 31, 31, 31, 2, 2, 31, 31, 31, 31, 2, 2, 31,
    31, 31, 31, 2, 2, 33, 2, 2, 2, 2, 31, 31, 2, 31, 31, 31, 31, 2, 2, 32, 32, 2, 2, 31, 31, 31, 2, 32, 2, 2, 2, 2, 31, 2, 2, 2, 2, 2, 2, 2, 32, 2, 2, 2, 32,
    32, 2, 2, 32, 2, 2, 2, 2, 2, 2, 31, 31, 31, 31, 32, 2, 2, 2, 2, 32, 2, 2, 31, 31, 31, 2, 31, 31, 32, 31, 32, 32, 32, 31, 31, 32, 31, 31, 31, 32, 31, 2, 2,
    2, 2, 2, 2, 32, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 2, 2, 32, 32, 31, 31, 31, 2, 32, 32, 2, 2, 2, 2, 32, 31, 31, 31, 2, 2, 32, 2, 2, 2
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints above the surrogate block.
  -->
  <xsl:variable name="p:MAP2" as="xs:integer+" select="
    57344, 63744, 64110, 64112, 64218, 64256, 64263, 64275, 64280, 64285, 64286, 64287, 64297, 64298, 64311, 64312, 64317, 64318, 64319, 64320, 64322, 64323,
    64325, 64326, 64434, 64467, 64830, 64848, 64912, 64914, 64968, 65008, 65020, 65024, 65040, 65056, 65063, 65136, 65141, 65142, 65277, 65296, 65306, 65313,
    65339, 65345, 65371, 65382, 65471, 65474, 65480, 65482, 65488, 65490, 65496, 65498, 65501, 65536, 65548, 65549, 65575, 65576, 65595, 65596, 65598, 65599,
    65614, 65616, 65630, 65664, 65787, 66045, 66046, 66176, 66205, 66208, 66257, 66304, 66335, 66352, 66369, 66370, 66378, 66432, 66462, 66464, 66500, 66504,
    66512, 66560, 66718, 66720, 66730, 67584, 67590, 67592, 67593, 67594, 67638, 67639, 67641, 67644, 67645, 67647, 67670, 67840, 67862, 67872, 67898, 67968,
    68024, 68030, 68032, 68096, 68097, 68100, 68101, 68103, 68108, 68112, 68116, 68117, 68120, 68121, 68148, 68152, 68155, 68159, 68160, 68192, 68221, 68352,
    68406, 68416, 68438, 68448, 68467, 68608, 68681, 69633, 69634, 69635, 69688, 69703, 69734, 69744, 69760, 69762, 69763, 69808, 69811, 69815, 69817, 69819,
    69840, 69865, 69872, 69882, 69888, 69891, 69927, 69932, 69933, 69941, 69942, 69952, 70016, 70018, 70019, 70067, 70070, 70079, 70081, 70085, 70096, 70106,
    71296, 71339, 71340, 71341, 71342, 71344, 71350, 71351, 71352, 71360, 71370, 73728, 74607, 77824, 78895, 92160, 92729, 93952, 94021, 94032, 94033, 94095,
    94099, 94112, 110592, 110594, 119143, 119146, 119163, 119171, 119173, 119180, 119210, 119214, 119362, 119365, 119808, 119893, 119894, 119965, 119966,
    119968, 119970, 119971, 119973, 119975, 119977, 119981, 119982, 119994, 119995, 119996, 119997, 120004, 120005, 120070, 120071, 120075, 120077, 120085,
    120086, 120093, 120094, 120122, 120123, 120127, 120128, 120133, 120134, 120135, 120138, 120145, 120146, 120486, 120488, 120513, 120514, 120539, 120540,
    120571, 120572, 120597, 120598, 120629, 120630, 120655, 120656, 120687, 120688, 120713, 120714, 120745, 120746, 120771, 120772, 120780, 120782, 120832,
    126464, 126468, 126469, 126496, 126497, 126499, 126500, 126501, 126503, 126504, 126505, 126515, 126516, 126520, 126521, 126522, 126523, 126524, 126530,
    126531, 126535, 126536, 126537, 126538, 126539, 126540, 126541, 126544, 126545, 126547, 126548, 126549, 126551, 126552, 126553, 126554, 126555, 126556,
    126557, 126558, 126559, 126560, 126561, 126563, 126564, 126565, 126567, 126571, 126572, 126579, 126580, 126584, 126585, 126589, 126590, 126591, 126592,
    126602, 126603, 126620, 126625, 126628, 126629, 126634, 126635, 126652, 131072, 173783, 173824, 177973, 177984, 178206, 194560, 195102, 917760, 918000,
    63743, 64109, 64111, 64217, 64255, 64262, 64274, 64279, 64284, 64285, 64286, 64296, 64297, 64310, 64311, 64316, 64317, 64318, 64319, 64321, 64322, 64324,
    64325, 64433, 64466, 64829, 64847, 64911, 64913, 64967, 65007, 65019, 65023, 65039, 65055, 65062, 65135, 65140, 65141, 65276, 65295, 65305, 65312, 65338,
    65344, 65370, 65381, 65470, 65473, 65479, 65481, 65487, 65489, 65495, 65497, 65500, 65533, 65547, 65548, 65574, 65575, 65594, 65595, 65597, 65598, 65613,
    65615, 65629, 65663, 65786, 66044, 66045, 66175, 66204, 66207, 66256, 66303, 66334, 66351, 66368, 66369, 66377, 66431, 66461, 66463, 66499, 66503, 66511,
    66559, 66717, 66719, 66729, 67583, 67589, 67591, 67592, 67593, 67637, 67638, 67640, 67643, 67644, 67646, 67669, 67839, 67861, 67871, 67897, 67967, 68023,
    68029, 68031, 68095, 68096, 68099, 68100, 68102, 68107, 68111, 68115, 68116, 68119, 68120, 68147, 68151, 68154, 68158, 68159, 68191, 68220, 68351, 68405,
    68415, 68437, 68447, 68466, 68607, 68680, 69632, 69633, 69634, 69687, 69702, 69733, 69743, 69759, 69761, 69762, 69807, 69810, 69814, 69816, 69818, 69839,
    69864, 69871, 69881, 69887, 69890, 69926, 69931, 69932, 69940, 69941, 69951, 70015, 70017, 70018, 70066, 70069, 70078, 70080, 70084, 70095, 70105, 71295,
    71338, 71339, 71340, 71341, 71343, 71349, 71350, 71351, 71359, 71369, 73727, 74606, 77823, 78894, 92159, 92728, 93951, 94020, 94031, 94032, 94094, 94098,
    94111, 110591, 110593, 119142, 119145, 119162, 119170, 119172, 119179, 119209, 119213, 119361, 119364, 119807, 119892, 119893, 119964, 119965, 119967,
    119969, 119970, 119972, 119974, 119976, 119980, 119981, 119993, 119994, 119995, 119996, 120003, 120004, 120069, 120070, 120074, 120076, 120084, 120085,
    120092, 120093, 120121, 120122, 120126, 120127, 120132, 120133, 120134, 120137, 120144, 120145, 120485, 120487, 120512, 120513, 120538, 120539, 120570,
    120571, 120596, 120597, 120628, 120629, 120654, 120655, 120686, 120687, 120712, 120713, 120744, 120745, 120770, 120771, 120779, 120781, 120831, 126463,
    126467, 126468, 126495, 126496, 126498, 126499, 126500, 126502, 126503, 126504, 126514, 126515, 126519, 126520, 126521, 126522, 126523, 126529, 126530,
    126534, 126535, 126536, 126537, 126538, 126539, 126540, 126543, 126544, 126546, 126547, 126548, 126550, 126551, 126552, 126553, 126554, 126555, 126556,
    126557, 126558, 126559, 126560, 126562, 126563, 126564, 126566, 126570, 126571, 126578, 126579, 126583, 126584, 126588, 126589, 126590, 126591, 126601,
    126602, 126619, 126624, 126627, 126628, 126633, 126634, 126651, 131071, 173782, 173823, 177972, 177983, 178205, 194559, 195101, 917759, 917999, 1114111, 2,
    31, 2, 31, 2, 31, 2, 31, 2, 31, 32, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 32, 2, 32, 2, 31, 2, 31, 2, 32, 2, 31, 2,
    31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
    31, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 32, 2, 32, 2, 32, 31, 2, 31, 2, 31, 2, 32, 2, 32, 2, 31, 2, 31, 2,
    31, 2, 31, 2, 31, 2, 32, 2, 31, 32, 2, 32, 2, 32, 2, 31, 2, 32, 2, 32, 2, 31, 2, 32, 2, 32, 31, 32, 2, 32, 2, 32, 2, 32, 2, 31, 2, 32, 2, 31, 2, 32, 2, 31,
    32, 2, 32, 2, 32, 2, 32, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 32, 31, 2, 31, 2, 32, 2, 32, 2, 32, 2, 32, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31,
    2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
    31, 2, 31, 2, 31, 2, 32, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2,
    31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 31, 2, 32, 2
  "/>

  <!--~
   ! The token-set-id to DFA-initial-state mapping.
  -->
  <xsl:variable name="p:INITIAL" as="xs:integer+" select="
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 861, 33, 34, 35, 36, 867, 37, 38, 39,
    40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 883
  "/>

  <!--~
   ! The DFA transition table.
  -->
  <xsl:variable name="p:TRANSITION" as="xs:integer+" select="
    546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 544, 551, 561, 558, 626, 558, 560, 545, 560, 560, 546, 546,
    546, 771, 546, 770, 565, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 572, 546, 581, 589, 546, 576, 590, 574, 591, 577, 596, 595, 597, 546,
    546, 546, 771, 546, 770, 601, 546, 609, 602, 607, 603, 610, 615, 614, 616, 546, 546, 546, 620, 640, 630, 638, 546, 645, 639, 650, 652, 646, 655, 654, 656,
    772, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 546, 547, 661, 660, 662, 546, 546, 546, 771, 787, 770, 565, 786, 785, 546, 785, 787, 668, 669, 667,
    666, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 783, 782, 546, 784, 780, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 807, 806, 546,
    808, 804, 546, 546, 546, 771, 546, 770, 565, 546, 809, 546, 809, 676, 675, 546, 677, 673, 546, 546, 546, 771, 711, 770, 565, 710, 546, 712, 683, 713, 710,
    681, 681, 682, 546, 546, 546, 771, 849, 770, 565, 850, 849, 546, 849, 851, 687, 825, 689, 691, 546, 546, 546, 695, 546, 770, 565, 546, 546, 546, 546, 546,
    546, 546, 709, 546, 546, 546, 546, 771, 546, 717, 565, 847, 546, 546, 546, 546, 546, 546, 848, 846, 546, 546, 546, 771, 546, 770, 721, 722, 728, 722, 872,
    730, 729, 723, 734, 724, 546, 546, 546, 771, 546, 738, 565, 870, 546, 546, 546, 546, 546, 546, 871, 869, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546,
    546, 887, 886, 546, 888, 884, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 742, 774, 773, 750, 749, 751, 546, 546, 546, 695, 546, 770, 565, 763, 546,
    762, 762, 756, 755, 760, 760, 761, 546, 546, 546, 771, 546, 770, 565, 763, 546, 762, 762, 756, 755, 760, 760, 761, 546, 546, 546, 771, 546, 767, 778, 546,
    584, 546, 584, 546, 585, 792, 791, 793, 546, 546, 546, 771, 546, 770, 797, 566, 568, 798, 568, 566, 567, 546, 546, 567, 546, 546, 546, 771, 546, 770, 565,
    546, 546, 802, 819, 816, 641, 813, 817, 818, 546, 546, 546, 771, 546, 770, 565, 823, 546, 823, 823, 633, 634, 829, 829, 830, 546, 546, 546, 695, 546, 770,
    565, 624, 546, 834, 624, 622, 835, 839, 839, 840, 546, 546, 546, 771, 546, 770, 565, 624, 546, 834, 624, 622, 835, 839, 839, 840, 546, 546, 546, 771, 546,
    770, 704, 844, 704, 701, 698, 701, 703, 705, 703, 703, 546, 546, 546, 771, 546, 770, 855, 890, 857, 890, 889, 859, 858, 891, 863, 892, 546, 546, 546, 771,
    546, 770, 867, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 771, 546, 770, 565, 546, 553, 546, 553, 546, 554, 877, 876, 878, 546, 546, 546,
    771, 546, 770, 565, 882, 546, 882, 882, 744, 745, 896, 896, 897, 546, 546, 546, 771, 546, 770, 565, 546, 546, 546, 546, 546, 546, 546, 709, 546, 546, 546,
    546, 771, 546, 770, 544, 551, 561, 558, 626, 558, 560, 545, 560, 560, 546, 546, 546, 128, 1024, 0, 0, 0, 0, 448, 0, 1024, 0, 0, 768, 0, 768, 1024, 0, 1024,
    1024, 1024, 0, 0, 128, 0, 0, 0, 576, 0, 0, 52, 256, 0, 1216, 1216, 0, 1216, 0, 1216, 0, 1268, 256, 0, 0, 1984, 0, 1984, 128, 0, 1216, 0, 0, 1216, 0, 1216,
    1216, 1216, 1216, 192, 128, 0, 384, 0, 0, 384, 0, 384, 384, 0, 384, 0, 384, 0, 384, 384, 384, 384, 0, 192, 53, 0, 0, 960, 0, 0, 0, 1024, 1024, 0, 192, 1333,
    0, 0, 2048, 0, 2048, 128, 0, 1280, 0, 0, 0, 640, 1280, 0, 1280, 0, 1280, 0, 1280, 1280, 0, 0, 1280, 1280, 1280, 1280, 0, 0, 448, 448, 448, 448, 0, 1344,
    1344, 1344, 0, 1344, 0, 1344, 0, 1536, 1536, 0, 1536, 0, 0, 1536, 1600, 1600, 1600, 1600, 0, 0, 1664, 0, 1664, 0, 1664, 1664, 1664, 0, 192, 256, 323, 0, 0,
    2112, 2112, 0, 2112, 2112, 2112, 0, 0, 0, 1152, 0, 0, 0, 1600, 0, 1600, 1600, 0, 192, 256, 1728, 128, 0, 0, 1792, 1792, 1792, 0, 0, 1792, 0, 1792, 0, 0,
    1792, 1792, 1792, 1792, 0, 192, 256, 1856, 512, 0, 0, 0, 1088, 0, 1088, 0, 512, 512, 512, 512, 0, 0, 896, 0, 896, 896, 896, 896, 896, 896, 0, 0, 0, 1984,
    192, 256, 0, 192, 256, 0, 0, 0, 512, 0, 128, 1984, 0, 0, 1408, 0, 1408, 0, 0, 0, 1344, 0, 0, 0, 1984, 1984, 1984, 1984, 0, 128, 0, 0, 576, 576, 0, 640, 0,
    0, 1472, 0, 1472, 0, 0, 0, 1536, 640, 640, 640, 640, 0, 640, 640, 640, 0, 0, 2048, 0, 0, 0, 1664, 1664, 2048, 2048, 2048, 2048, 0, 960, 0, 960, 0, 960, 960,
    960, 960, 960, 0, 0, 2112, 0, 0, 1728, 0, 0, 0, 1664, 0, 0, 128, 0, 0, 2176, 0, 2176, 0, 0, 2176, 2176, 2176, 2176, 704, 0, 0, 0, 1856, 0, 0, 0, 1792, 0,
    768, 768, 768, 768, 0, 1088, 0, 0, 0, 1920, 0, 1920, 0, 0, 0, 2176, 2176, 2176, 0, 1088, 1088, 1088, 1088, 0
  "/>

  <!--~
   ! The DFA-state to expected-token-set mapping.
  -->
  <xsl:variable name="p:EXPECTED" as="xs:integer+" select="
    4, 8, 16, 262144, 524288, 1048576, 16777216, 33554432, 1073741824, 262148, 524296, 335544320, 1026, 1073774592, 786464, 134217984, -2147393536, 335577088,
    168820736, 150995200, 819232, 134250752, 1074530336, 177209344, -2147360768, 17572384, 134267136, 151027968, -2130615680, 17572640, 1074563104, 177242112,
    17605152, 720371712, -2130582912, 17605408, 720404480, -1072830432, 720404736, -1056085280, -1056052512, -920818976, -888313120, -887264544, -1074536448,
    -920786208, -888280352, -878875936, -887231776, -878843168, -136224, 4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 2, 0, 1, 2, 2, 1, 3, 0, 2, 1, 0, 3,
    3, 0, 0, 1, 3, 1, 2, 1, 1, 3, 1, 3, 0, 1, 2, 2, 2, 3, 3, 3, 2, 3, 3, 3, 0, 0
  "/>

  <!--~
   ! The match-code to case-id map. Maps decision point and lookahead to next action code.
  -->
  <xsl:variable name="p:CASEID" as="xs:integer+" select="
    442, 228, 232, 407, 239, 233, 519, 243, 247, 252, 233, 232, 255, 228, 232, 264, 312, 232, 248, 235, 232, 286, 259, 263, 418, 239, 233, 298, 268, 233, 425,
    272, 247, 449, 281, 285, 264, 312, 232, 248, 432, 247, 336, 293, 232, 425, 290, 247, 297, 233, 233, 302, 233, 233, 248, 234, 232, 495, 310, 232, 298, 268,
    233, 425, 307, 247, 425, 317, 232, 425, 321, 247, 425, 321, 247, 248, 439, 247, 456, 325, 233, 449, 329, 285, 354, 432, 247, 233, 303, 233, 466, 333, 233,
    449, 340, 285, 449, 344, 233, 449, 348, 352, 449, 358, 362, 354, 432, 247, 354, 432, 247, 459, 275, 232, 354, 313, 247, 368, 233, 233, 374, 233, 233, 248,
    432, 247, 248, 432, 247, 529, 380, 233, 485, 310, 232, 459, 275, 232, 354, 364, 247, 541, 333, 233, 473, 386, 233, 354, 364, 247, 354, 364, 247, 354, 313,
    247, 233, 277, 233, 233, 370, 233, 233, 482, 392, 233, 492, 398, 233, 502, 404, 509, 411, 415, 516, 233, 233, 233, 422, 233, 297, 429, 233, 233, 436, 233,
    302, 446, 233, 233, 526, 233, 382, 531, 453, 233, 475, 233, 388, 376, 463, 538, 233, 233, 297, 470, 233, 302, 479, 233, 400, 394, 489, 499, 233, 233, 506,
    233, 233, 513, 233, 233, 233, 523, 233, 233, 535, 233, 550, 546, 550, 547, 545, 546, 546, 546, 546, 548, 550, 599, 546, 556, 622, 562, 564, 564, 564, 569,
    546, 546, 546, 551, 812, 546, 814, 546, 547, 549, 565, 587, 579, 593, 595, 581, 546, 546, 546, 572, 599, 546, 546, 622, 562, 546, 561, 571, 546, 546, 546,
    583, 692, 606, 546, 618, 644, 620, 546, 546, 546, 576, 562, 550, 570, 571, 546, 546, 548, 733, 546, 546, 546, 597, 772, 546, 546, 546, 634, 562, 550, 561,
    571, 546, 550, 546, 546, 547, 546, 562, 546, 550, 571, 562, 570, 561, 571, 628, 546, 546, 634, 606, 621, 638, 644, 699, 546, 649, 546, 549, 547, 551, 606,
    621, 618, 644, 606, 546, 660, 644, 606, 669, 666, 644, 668, 546, 546, 546, 550, 551, 606, 676, 673, 644, 675, 546, 546, 546, 570, 546, 739, 546, 546, 546,
    697, 546, 783, 546, 546, 546, 704, 546, 628, 546, 546, 546, 771, 546, 745, 546, 546, 546, 788, 688, 712, 546, 546, 546, 802, 546, 720, 546, 546, 546, 805,
    546, 731, 546, 546, 546, 557, 555, 597, 757, 546, 546, 662, 752, 546, 546, 546, 557, 555, 604, 682, 546, 546, 546, 563, 796, 572, 656, 546, 546, 546, 564,
    796, 549, 753, 546, 546, 546, 570, 796, 546, 547, 549, 572, 693, 546, 546, 546, 610, 614, 597, 776, 546, 546, 546, 632, 650, 546, 549, 546, 551, 787, 546,
    546, 546, 642, 648, 654, 589, 546, 546, 546, 686, 546, 546, 782, 546, 600, 546, 546, 546, 703, 708, 546, 549, 549, 798, 804, 546, 546, 546, 721, 718, 546,
    549, 626, 798, 778, 546, 546, 546, 725, 729, 737, 789, 546, 546, 546, 743, 661, 749, 546, 809, 546, 546, 761, 546, 546, 563, 561, 565, 714, 546, 546, 546,
    766, 546, 546, 632, 546, 546, 762, 546, 767, 546, 546, 546, 793, 546, 546, 642, 680, 654, 24946, 0, 0, 0, 0, 8406, 0, 0, 0, 16626, 0, 32776, 0, 0, 0, 32776,
    8406, 8406, 0, 8406, 8406, 8406, 8406, 16626, 24946, 8406, 0, 0, 8406, 8406, 16626, 0, 147464, 147464, 140630, 140630, 140630, 140630, 0, 0, 82610, 0,
    147464, 155656, 0, 0, 32782, 0, 155656, 14, 140630, 140630, 0, 147464, 147464, 0, 0, 0, 49166, 198, 147464, 147464, 0, 131090, 139282, 0, 476754, 122898,
    32776, 0, 466962, 0, 149282, 466962, 49156, 0, 49156, 0, 0, 0, 147464, 8406, 8406, 0, 0, 131090, 139282, 0, 476754, 0, 0, 157538, 0, 466962, 0, 0, 49156, 0,
    550498, 0, 0, 157538, 147464, 338002, 163848, 0, 0, 0, 149282, 0, 540690, 0, 0, 181654, 0, 466962, 0, 0, 0, 163860, 32788, 466962, 73780, 0, 73780, 0, 0,
    73780, 466962, 81972, 0, 81972, 0, 0, 81972, 0, 163848, 0, 0, 286738, 0, 0, 598034, 0, 0, 286744, 286740, 82594, 0, 0, 0, 189926, 0, 25322, 0, 0, 319506,
    327698, 41798, 0, 0, 0, 286740, 0, 41798, 0, 172882, 0, 172898, 0, 0, 401426, 0, 0, 50166, 0, 50166, 0, 0, 181250, 57364, 188434, 196626, 57364, 0, 57364,
    0, 57364, 0, 0, 492978, 0, 0, 204818, 0, 0, 558530, 0, 0, 163860, 0, 0, 581650, 589842, 0, 32788, 32788, 16398, 0, 0, 0, 294930, 32788, 0, 163860, 163860,
    231026, 0, 0, 0, 362466, 344082, 0, 0, 0, 409618, 338002, 0, 0, 0, 509442, 0, 362482, 0, 0, 606226, 0, 368658, 0, 0, 0, 566802, 286740, 286740, 0, 0, 0,
    614418, 378498, 0, 0, 0, 8406, 0, 8406, 0, 16626, 270388, 0, 0, 198326, 0, 0, 0, 417810, 0, 0, 0, 25010, 0, 0, 16938, 0
  "/>

  <!--~
   ! The parser tokenset table. Maps state to lookahead tokenset code.
  -->
  <xsl:variable name="p:TOKENSET" as="xs:integer+" select="
    35, 28, 52, 12, 37, 24, 17, 46, 32, 16, 48, 44, 24, 38, 30, 47, 0, 1, 13, 36, 16, 50, 42, 51, 51, 31, 22, 43, 40, 8, 29, 45, 41, 49, 49, 40, 40, 20, 21, 0,
    1, 38, 38, 14, 33, 20, 27, 25, 14, 27, 27, 21, 11, 7, 18, 23, 34, 39, 2, 3, 9, 4, 10, 5, 15, 6, 26, 2, 9, 10, 19, 0, 1, 2, 3, 4
  "/>

  <!--~
   ! The conflict action list table. Contains list of conflicting actions.
  -->
  <xsl:variable name="p:APPENDIX" as="xs:integer+" select="
    70315, 77828, 16394, 81930, 90827, 200713, 94963, 204809
  "/>

  <!--~
   ! The parser lookback table. Maps lookback code and itemset id to next lookback code.
  -->
  <xsl:variable name="p:LOOKBACK" as="xs:integer+" select="
    138, 138, 138, 136, 136, 136, 139, 144, 154, 154, 154, 149, 157, 160, 165, 165, 165, 165, 170, 170, 170, 170, 138, 138, 138, 138, 175, 175, 175, 175, 182,
    182, 182, 182, 189, 196, 138, 199, 202, 205, 205, 205, 208, 211, 214, 219, 222, 225, 138, 138, 138, 138, 228, 233, 238, 243, 248, 248, 248, 248, 138, 138,
    138, 251, 256, 261, 264, 264, 264, 138, 267, 270, 273, 276, 138, 138, 138, 279, 284, 289, 294, 299, 138, 138, 138, 302, 307, 307, 307, 312, 317, 317, 317,
    317, 322, 327, 327, 327, 327, 138, 332, 337, 337, 342, 347, 352, 357, 362, 138, 367, 370, 373, 138, 376, 379, 382, 385, 388, 138, 391, 391, 391, 394, 394,
    394, 394, 404, 409, 414, 419, 419, 419, 419, 397, 422, 425, 2, 2, 0, 9, 8, 4, 3, 0, 9, 9, 4, 4, 0, 9, 10, 4, 5, 0, 7, 6, 0, 7, 11, 0, 19, 18, 15, 14, 0, 19,
    20, 15, 16, 0, 19, 21, 15, 17, 0, 31, 30, 27, 26, 23, 22, 0, 31, 32, 27, 28, 23, 24, 0, 31, 33, 27, 29, 23, 25, 0, 34, 34, 0, 36, 36, 0, 37, 37, 0, 38, 38,
    0, 40, 39, 0, 40, 41, 0, 43, 43, 42, 42, 0, 44, 44, 0, 45, 45, 0, 46, 46, 0, 57, 56, 49, 48, 0, 57, 58, 49, 50, 0, 57, 59, 49, 51, 0, 54, 54, 53, 53, 0, 55,
    55, 0, 67, 66, 61, 60, 0, 67, 68, 61, 62, 0, 64, 64, 0, 65, 65, 0, 69, 69, 0, 70, 70, 0, 71, 71, 0, 72, 72, 0, 76, 74, 75, 74, 0, 76, 75, 75, 75, 0, 76, 76,
    75, 75, 0, 79, 77, 78, 77, 0, 80, 80, 0, 87, 86, 83, 82, 0, 87, 88, 83, 84, 0, 92, 90, 91, 90, 0, 92, 93, 91, 93, 0, 97, 95, 96, 95, 0, 97, 98, 96, 98, 0,
    76, 99, 75, 99, 0, 79, 100, 78, 100, 0, 102, 101, 101, 101, 0, 102, 102, 101, 101, 0, 104, 103, 103, 103, 0, 104, 104, 103, 103, 0, 106, 105, 105, 105, 0,
    76, 108, 0, 79, 109, 0, 110, 110, 0, 76, 112, 0, 79, 113, 0, 114, 114, 0, 115, 115, 0, 116, 116, 0, 118, 118, 0, 120, 119, 0, 130, 132, 123, 125, 120, 121,
    0, 130, 129, 123, 122, 0, 130, 131, 123, 124, 0, 127, 127, 126, 126, 0, 128, 128, 0, 133, 133, 0, 134, 134, 0
  "/>

  <!--~
   ! The parser goto table. Maps state and nonterminal to next action code.
  -->
  <xsl:variable name="p:GOTO" as="xs:integer+" select="
    130, 131, 234, 153, 131, 136, 131, 272, 131, 131, 141, 131, 254, 131, 131, 146, 131, 131, 194, 131, 151, 155, 131, 153, 131, 160, 131, 132, 228, 232, 165,
    131, 266, 131, 131, 170, 131, 176, 131, 131, 131, 180, 131, 147, 131, 186, 131, 188, 131, 131, 131, 192, 200, 131, 131, 198, 131, 206, 131, 131, 204, 131,
    260, 131, 131, 131, 210, 137, 228, 232, 214, 131, 131, 131, 220, 142, 278, 284, 228, 232, 226, 230, 156, 238, 232, 242, 230, 172, 131, 131, 174, 131, 222,
    131, 131, 246, 131, 131, 161, 131, 131, 252, 182, 131, 131, 258, 131, 131, 166, 131, 264, 131, 248, 131, 131, 270, 131, 131, 276, 282, 131, 131, 288, 131,
    131, 290, 131, 216, 131, 131, 294, 305, 305, 305, 305, 310, 351, 305, 305, 305, 364, 434, 305, 305, 305, 369, 431, 305, 305, 305, 374, 360, 304, 305, 305,
    297, 305, 305, 305, 392, 446, 305, 305, 305, 394, 321, 305, 305, 305, 455, 330, 305, 305, 305, 324, 305, 305, 305, 333, 305, 305, 394, 305, 305, 336, 305,
    339, 305, 305, 305, 342, 305, 449, 305, 305, 305, 380, 305, 404, 305, 305, 305, 401, 305, 416, 305, 305, 305, 407, 305, 305, 455, 305, 359, 327, 305, 305,
    305, 410, 305, 305, 368, 305, 305, 422, 305, 305, 388, 314, 300, 318, 349, 355, 359, 305, 305, 306, 304, 398, 461, 318, 349, 305, 392, 398, 465, 419, 305,
    305, 305, 428, 305, 305, 374, 305, 305, 440, 305, 437, 305, 305, 305, 443, 305, 425, 305, 305, 305, 452, 305, 469, 305, 305, 305, 457, 305, 305, 369, 373,
    378, 373, 472, 373, 479, 345, 305, 305, 384, 476, 305, 413, 305, 305, 305, 6, 4113, 8345, 0, 24881, 29337, 0, 32772, 32772, 57348, 20769, 0, 0, 0, 0, 16417,
    49705, 217449, 221577, 225769, 229385, 28676, 28676, 28676, 61444, 53817, 29337, 0, 82481, 8345, 0, 86044, 8345, 0, 99149, 8345, 0, 107129, 8345, 0, 110601,
    8345, 0, 115765, 8345, 0, 119705, 8345, 0, 123841, 8345, 0, 126980, 118788, 155657, 57953, 66181, 0, 0, 8345, 0, 61444, 57348, 102404, 102404, 107381, 0, 0,
    0, 16457, 49705, 258057, 221577, 225769, 111525, 0, 0, 0, 118788, 61444, 0, 0, 0, 249865, 152153, 66181, 0, 0, 77828, 29369, 49705, 0, 221641, 225769,
    49705, 0, 0, 225817, 49705, 0, 0, 0, 241673, 0, 49156, 0, 0, 0, 127417, 8345, 0, 131593, 8345, 0, 135177, 8345, 0, 135188, 8345, 0, 135196, 8345, 0, 139273,
    8345, 0, 139276, 8345, 0, 176753, 8345, 0, 193537, 8345, 0, 196617, 8345, 0, 213313, 8345, 0, 32825, 8345, 0, 32804, 8345, 0, 37161, 8345, 0, 45076, 8345,
    0, 45409, 8345, 0, 53817, 29337, 0, 53829, 8345, 0, 66181, 0, 0, 12537, 0, 36892, 32772, 32772, 57348, 40988, 32772, 32772, 57348, 0, 287569, 8345, 0,
    263129, 118788, 266249, 122908, 131076, 0, 0, 263185, 118788, 266249
  "/>

  <!--~
   ! The token-string table.
  -->
  <xsl:variable name="p:TOKEN" as="xs:string+" select="
    '(0)',
    'cchar',
    'dchar',
    'schar',
    'hex',
    &quot;'#'&quot;,
    &quot;'('&quot;,
    &quot;'@'&quot;,
    &quot;']'&quot;,
    &quot;'^'&quot;,
    &quot;'}'&quot;,
    &quot;'~'&quot;,
    'END',
    'capital',
    'letter',
    'whitespace',
    'namestart1',
    'namefollower1',
    &quot;'&quot;&quot;'&quot;,
    &quot;''''&quot;,
    &quot;')'&quot;,
    &quot;'*'&quot;,
    &quot;'+'&quot;,
    &quot;','&quot;,
    &quot;'-'&quot;,
    &quot;'.'&quot;,
    &quot;':'&quot;,
    &quot;';'&quot;,
    &quot;'='&quot;,
    &quot;'?'&quot;,
    &quot;'['&quot;,
    &quot;'_'&quot;,
    &quot;'{'&quot;,
    &quot;'|'&quot;
  "/>

  <!--~
   ! The nonterminal name table.
  -->
  <xsl:variable name="p:NONTERMINAL" as="xs:string+" select="
    'ixml',
    's',
    'comment',
    'rule',
    'mark',
    'alts',
    'alt',
    'term',
    'factor',
    'repeat0',
    'repeat1',
    'option',
    'sep',
    'nonterminal',
    'terminal',
    'literal',
    'quoted',
    'name',
    'namestart',
    'namefollower',
    'tmark',
    'string',
    'dstring',
    'sstring',
    'encoded',
    'charset',
    'inclusion',
    'exclusion',
    'set',
    'member',
    'range',
    'from',
    'to',
    'character',
    'class',
    'code'
  "/>

  <!--~
   ! Predict the decision for a given decision point based on current
   ! lookahead.
   !
   ! @param $input the input string.
   ! @param $state the parser state.
   ! @param $dpi the decision point index.
   : @param $id the parsing thread id.
   ! @return the updated parser state.
  -->
  <xsl:function name="p:predict" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="dpi" as="xs:integer"/>
    <xsl:param name="id" as="xs:integer"/>

    <xsl:variable name="state" select="p:lookahead1($p:TOKENSET[$dpi + 1], $input, $state, $id)"/>
    <xsl:choose>
      <xsl:when test="$state[$p:l1] lt 0">
        <xsl:variable name="node">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:attribute name="s" select="- $state[$p:l1]"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          0,
          subsequence($state, $p:lk + 1)
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="j10" select="48 * $dpi + $state[$p:l1]"/>
        <xsl:variable name="j11" select="$j10 idiv 4"/>
        <xsl:variable name="j12" select="$j11 idiv 4"/>
        <xsl:variable name="action" select="$p:CASEID[$j10 mod 4 + $p:CASEID[$j11 mod 4 + $p:CASEID[$j12 + 1] + 1] + 1]"/>
        <xsl:sequence select="$action idiv 2, subsequence($state, $p:lk + 1)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Match next token in input string, starting at given index, using
   ! the DFA entry state for the set of tokens that are expected in
   ! the current context.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start in input string.
   ! @param $token-set the expected token set id.
   : @param $id the parsing thread id.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:match" as="xs:integer+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>
    <xsl:param name="id" as="xs:integer"/>

    <xsl:variable name="result" select="$p:INITIAL[1 + $token-set]"/>
    <xsl:sequence select="p:transition($input, $begin, $begin, $begin, $result, $result mod 64, 0)"/>
  </xsl:function>

  <!--~
   ! The DFA state transition function. If we are in a valid DFA state, save
   ! it's result annotation, consume one input codepoint, calculate the next
   ! state, and use tail recursion to do the same again. Otherwise, return
   ! any valid result or a negative DFA state id in case of an error.
   !
   ! @param $input the input string.
   ! @param $begin the begin index of the current token in the input string.
   ! @param $current the index of the current position in the input string.
   ! @param $end the end index of the result in the input string.
   ! @param $result the result code.
   ! @param $current-state the current DFA state.
   ! @param $previous-state the  previous DFA state.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:transition">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="current" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>
    <xsl:param name="result" as="xs:integer"/>
    <xsl:param name="current-state" as="xs:integer"/>
    <xsl:param name="previous-state" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$current-state eq 0">
        <xsl:variable name="result" select="$result idiv 64"/>
        <xsl:variable name="end" select="if ($end gt string-length($input)) then string-length($input) + 1 else $end"/>
        <xsl:sequence select="
          if ($result ne 0) then
          (
            $result - 1,
            $begin,
            $end
          )
          else
          (
            - $previous-state,
            $begin,
            $current - 1
          )
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="c0" select="(string-to-codepoints(substring($input, $current, 1)), 0)[1]"/>
        <xsl:variable name="c1" as="xs:integer">
          <xsl:choose>
            <xsl:when test="$c0 &lt; 128">
              <xsl:sequence select="$p:MAP0[1 + $c0]"/>
            </xsl:when>
            <xsl:when test="$c0 &lt; 55296">
              <xsl:variable name="c1" select="$c0 idiv 8"/>
              <xsl:variable name="c2" select="$c1 idiv 16"/>
              <xsl:sequence select="$p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 16 + $p:MAP1[1 + $c2]]]"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="p:map2($c0, 1, 350)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="current" select="$current + 1"/>
        <xsl:variable name="i0" select="64 * $c1 + $current-state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 4"/>
        <xsl:variable name="next-state" select="$p:TRANSITION[$i0 mod 4 + $p:TRANSITION[$i1 + 1] + 1]"/>
        <xsl:sequence select="
          if ($next-state &gt; 63) then
            p:transition($input, $begin, $current, $current, $next-state, $next-state mod 64, $current-state)
          else
            p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Recursively translate one 32-bit chunk of an expected token bitset
   ! to the corresponding sequence of token strings.
   !
   ! @param $result the result of previous recursion levels.
   ! @param $chunk the 32-bit chunk of the expected token bitset.
   ! @param $base-token-code the token code of bit 0 in the current chunk.
   ! @return the set of token strings.
  -->
  <xsl:function name="p:token">
    <xsl:param name="result" as="xs:string*"/>
    <xsl:param name="chunk" as="xs:integer"/>
    <xsl:param name="base-token-code" as="xs:integer"/>

    <xsl:sequence select="
      if ($chunk = 0) then
        $result
      else
        p:token
        (
          ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
          if ($chunk &lt; 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
          $base-token-code + 1
        )
    "/>
  </xsl:function>

  <!--~
   ! Get GOTO table entry for given nonterminal and parser state.
   !
   ! @param $nonterminal the nonterminal.
   ! @param $state the LR parser state.
   ! @return the GOTO table entry.
  -->
  <xsl:function name="p:goto" as="xs:integer">
    <xsl:param name="nonterminal" as="xs:integer"/>
    <xsl:param name="state" as="xs:integer"/>

    <xsl:variable name="i0" select="40 * $state + $nonterminal"/>
    <xsl:variable name="i1" select="$i0 idiv 4"/>
    <xsl:variable name="i2" select="$i1 idiv 4"/>
    <xsl:sequence select="$p:GOTO[$i0 mod 4 + $p:GOTO[$i1 mod 4 + $p:GOTO[$i2 + 1] + 1] + 1]"/>
  </xsl:function>

  <!--~
   ! Calculate expected token set for a given DFA state as a sequence
   ! of strings.
   !
   ! @param $state the DFA state.
   ! @return the set of token strings
  -->
  <xsl:function name="p:expected-token-set" as="xs:string*">
    <xsl:param name="state" as="xs:integer"/>

    <xsl:if test="$state > 0">
      <xsl:for-each select="0 to 1">
        <xsl:variable name="i0" select=". * 53 + $state - 1"/>
        <xsl:sequence select="p:token((), $p:EXPECTED[$i0 + 1], . * 32 + 1)"/>
      </xsl:for-each>
    </xsl:if>
  </xsl:function>

  <!--~
   ! Classify codepoint by doing a tail recursive binary search for a
   ! matching codepoint range entry in MAP2, the codepoint to charclass
   ! map for codepoints above the surrogate block.
   !
   ! @param $c the codepoint.
   ! @param $lo the binary search lower bound map index.
   ! @param $hi the binary search upper bound map index.
   ! @return the character class.
  -->
  <xsl:function name="p:map2" as="xs:integer">
    <xsl:param name="c" as="xs:integer"/>
    <xsl:param name="lo" as="xs:integer"/>
    <xsl:param name="hi" as="xs:integer"/>

    <xsl:variable name="m" select="($hi + $lo) idiv 2"/>
    <xsl:choose>
      <xsl:when test="$lo &gt; $hi">
        <xsl:sequence select="0"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[$m] &gt; $c">
        <xsl:sequence select="p:map2($c, $lo, $m - 1)"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[350 + $m] &lt; $c">
        <xsl:sequence select="p:map2($c, $m + 1, $hi)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$p:MAP2[700 + $m]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Compare a lookback code to a sorted, zero-terminated list of pairs at
   ! the given index into the LOOKBACK table. A matching first code in a
   ! pair will cause its second code to be returned. The list is sorted in
   ! descending order of first codes, so it is safe to stop when the first
   ! code is less than what is searched for.
   !
   ! @param $x the lookback code to search for.
   ! @param $i the index into the LOOKBACK table.
   ! @return the new lookback code as the second code from a pair with a
   ! matching first code.
  -->
  <xsl:function name="p:lookback">
    <xsl:param name="x" as="xs:integer"/>
    <xsl:param name="i" as="xs:integer"/>

    <xsl:variable name="l" select="$p:LOOKBACK[$i + 1]"/>
    <xsl:sequence select="
      if ($l gt $x) then
        p:lookback($x, $i + 2)
      else if ($l eq $x) then
        $p:LOOKBACK[$i + 2]
      else
        0
    "/>
  </xsl:function>

  <!--~
   ! Calculate number of symbols to remove from LR stack for reduction by
   ! walking through lookback codes of reduction and stack entries. A single
   ! invocation combines two of those, more are handled in tail recursion.
   !
   ! @param $code the reduction lookback code.
   ! @param $count the initial count value.
   ! @param $stack the LR stack.
   ! @param $t the stack running index.
   ! @return the initial count value, increased by the number of calculations
   ! yielding a non-zero lookback code.
  -->
  <xsl:function name="p:count">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="count" as="xs:integer"/>
    <xsl:param name="stack" as="xs:integer*"/>
    <xsl:param name="t" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$stack[$t] lt 0">
        <xsl:sequence select="$count"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="code" select="p:lookback($stack[$t + 1], $p:LOOKBACK[$code + 1])"/>
        <xsl:sequence select="
          if ($code eq 0) then
            $count
          else
            p:count($code, $count + 1, $stack, $t - 3)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Determine index of the next thread that must be parsed, by comparing
   ! threads in $threads starting at $i with the candidate at $thread.
   !
   ! @param $threads the sequence of all current threads.
   ! @param $thread the index of the next thread candidate.
   ! @param $i the index where to start searching.
   ! @return the index of the next thread.
  -->
  <xsl:function name="p:next-thread">
    <xsl:param name="threads" as="map(*)*"/>
    <xsl:param name="thread" as="xs:integer"/>
    <xsl:param name="i" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$i gt count($threads)">
        <xsl:sequence select="$thread"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="thread">
          <xsl:choose>
            <xsl:when test="$threads[$thread]?accepted ne $threads[$i]?accepted">
              <xsl:sequence select="if ($threads[$thread]?accepted) then $i else $thread"/>
            </xsl:when>
            <xsl:when test="$threads[$thread]?lexer-state[$p:e0] ne $threads[$i]?lexer-state[$p:e0]">
              <xsl:sequence select="if ($threads[$thread]?lexer-state[$p:e0] lt $threads[$i]?lexer-state[$p:e0]) then $thread else $i"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="if ($threads[$thread]?id le $threads[$i]?id) then $thread else $i"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:sequence select="p:next-thread($threads, $thread, $i + 1)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Compare two parsing threads for equality. A result of false indicates an
   ! ambiguity.
   !
   ! @param $t1 the first thread data.
   ! @param $t2 the second thread data.
   ! @return true(), if threads are equal.
  -->
  <xsl:function name="p:thread-equals" as="xs:boolean">
    <xsl:param name="t1" as="map(*)"/>
    <xsl:param name="t2" as="map(*)"/>

    <xsl:sequence select="
      if ($t1?accepted ne $t2?accepted) then false() else
      if ($t1?b1 ne $t2?lexer-state[$p:b1]) then false() else
      if ($t1?e1 ne $t2?lexer-state[$p:e1]) then false() else
      if ($t1?l1 ne $t2?lexer-state[$p:l1]) then false() else
      if ($t1?state ne $t2?state) then false() else
      if ($t1?action ne $t2?action) then false() else deep-equal($t1?stack, $t2?stack)
    "/>
  </xsl:function>

  <!--~
   ! Perform GLR parsing by selecting a thread and invoke the LR parse function
   ! on it for a single token. Process result with respect to thread management.
   !
   ! @param $input the input string.
   ! @param $target the target symbol code.
   ! @param $max-id the maximum thread id.
   ! @param $threads the sequence of all current threads.
   ! @return the lexer state of the accepting (or error) thread.
  -->
  <xsl:function name="p:parse-glr">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="target" as="xs:integer"/>
    <xsl:param name="max-id" as="xs:integer"/>
    <xsl:param name="threads" as="map(*)+"/>

    <xsl:variable name="i" select="p:next-thread($threads, 1, 2)"/>
    <xsl:variable name="thread" select="$threads[$i]"/>
    <xsl:variable name="lexer-state" select="$thread?lexer-state"/>
    <xsl:choose>
      <xsl:when test="$thread?accepted">
        <xsl:variable name="max-e0" select="max($threads!?lexer-state[$p:e0])"/>
        <xsl:variable name="longest-accept" select="$threads[?lexer-state[$p:e0] eq $max-e0]"/>
        <xsl:choose>
          <xsl:when test="count($longest-accept) eq 1">
            <xsl:sequence select="$longest-accept?lexer-state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:reject-ambiguity($longest-accept[1], $longest-accept[2])"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="threads" select="(subsequence($threads, 1, $i - 1), subsequence($threads, $i + 1))"/>
        <xsl:variable name="other" select="if (exists($threads)) then $threads[p:next-thread($threads, 1, 2)] else ()"/>
        <xsl:choose>
          <xsl:when test="exists($other) and p:thread-equals($thread, $other)">
            <xsl:sequence select="p:reject-ambiguity($thread, $other)"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="thread" select="p:parse($input, $target, $max-id, $thread)"/>
            <xsl:variable name="lexer-state" select="$thread?lexer-state"/>
            <xsl:sequence select="
              if (count($thread) gt 1) then
                p:parse-glr($input, $target, $max-id + 1, ($threads, $thread))
              else if (not($lexer-state[$p:error])) then
                p:parse-glr($input, $target, $max-id, ($threads, $thread))
              else if (exists($threads)) then
                p:parse-glr($input, $target, $max-id, $threads)
              else
                $lexer-state
            "/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Raise an error for ambiguous input.
   !
   ! @param $thread the parsing thread data.
   ! @param $other the parsing thread data of the other thread.
   ! @return a lexer state containing an error element describing the ambiguity.
  -->
  <xsl:function name="p:reject-ambiguity" as="item()+">
    <xsl:param name="thread" as="map(*)"/>
    <xsl:param name="other" as="map(*)"/>

    <xsl:variable name="lexer-state" select="$thread?lexer-state"/>
    <xsl:variable name="first-tree" select="$lexer-state[last()]"/>
    <xsl:variable name="second-tree" select="$other?lexer-state[last()]"/>
    <xsl:variable name="node">
      <xsl:element name="error">
        <xsl:attribute name="b" select="$thread?stack[last() - 2]"/>
        <xsl:attribute name="e" select="$lexer-state[$p:e0]"/>
        <xsl:attribute name="ambiguous-input" select="true()"/>
        <xsl:element name="AMBIGUOUS">
          <xsl:element name="ALTERNATIVE">
            <xsl:sequence select="p:rewrite-ambiguity($first-tree, $second-tree, true())"/>
          </xsl:element>
          <xsl:element name="ALTERNATIVE">
            <xsl:sequence select="p:rewrite-ambiguity($second-tree, $first-tree, true())"/>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:variable>
    <xsl:sequence select="
      subsequence($lexer-state, 1, $p:error - 1),
      $node/node(),
      subsequence($lexer-state, $p:error + 1)
    "/>
  </xsl:function>

  <!--~
   ! Rewrite a parse tree fragment $first, combining elements into an "UNAMBIGUOUS"
   ! element as long as they match elements in $second, in node order.
   !
   ! @param $first the first node.
   ! @param $second the second node.
   ! @return $first rewritten, with initial element nodes possibly combined.
  -->
  <xsl:function name="p:rewrite-ambiguity">
    <xsl:param name="first" as="node()"/>
    <xsl:param name="second" as="node()?"/>
    <xsl:param name="unambiguous" as="xs:boolean"/>

    <xsl:choose>
      <xsl:when test="$first instance of element()">
        <xsl:choose>
          <xsl:when test="$unambiguous and deep-equal($first, $second)">
            <xsl:variable name="node">
              <xsl:element name="UNAMBIGUOUS">
                <xsl:sequence select="string($first)"/>
              </xsl:element>
            </xsl:variable>
            <xsl:sequence select="$node/node()"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="node">
              <xsl:element name="{node-name($first)}">
                <xsl:for-each select="1 to count($first/node())">
                  <xsl:variable name="i" select="."/>
                  <xsl:sequence select="
                    p:rewrite-ambiguity
                    (
                      $first/node()[$i], $second/node()[$i],
                      $unambiguous and (every $j in 1 to $i - 1 satisfies deep-equal($first/node()[$j], $second/node()[$j]))
                    )
                  "/>
                </xsl:for-each>
              </xsl:element>
            </xsl:variable>
            <xsl:sequence select="$node/node()"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$first"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Construct a new map containing data for one parsing thread.
   !
   ! @param $id the parsing thread id.
   ! @param $accepted true(), if this thread has accepted.
   ! @param $state the LR parser state number.
   ! @param $action the action code.
   ! @param $nonterminal current nonterminal, -1 if processing a terminal.
   ! @param $bw the whitespace begin input index.
   ! @param $bs the symbol begin input index.
   ! @param $es the symbol end input index.
   ! @param $stack the LR stack.
   ! @param $lexer-state lexer state, error indicator, and result stack.
   ! @return the thread data map.
  -->
  <xsl:function name="p:thread" as="map(*)">
    <xsl:param name="id" as="xs:integer"/>
    <xsl:param name="accepted" as="xs:boolean"/>
    <xsl:param name="state" as="xs:integer"/>
    <xsl:param name="action" as="xs:integer"/>
    <xsl:param name="nonterminal" as="xs:integer"/>
    <xsl:param name="bw" as="xs:integer"/>
    <xsl:param name="bs" as="xs:integer"/>
    <xsl:param name="es" as="xs:integer"/>
    <xsl:param name="stack" as="xs:integer*"/>
    <xsl:param name="lexer-state" as="item()+"/>

    <xsl:sequence select="
      map
      {
        'id': $id,
        'accepted': $accepted,
        'state': $state,
        'action': $action,
        'nonterminal': $nonterminal,
        'bw': $bw,
        'bs': $bs,
        'es': $es,
        'stack': $stack,
        'lexer-state': $lexer-state
      }
    "/>
  </xsl:function>

  <!--~
   ! Parse input for given target symbol using LR tables. Each invocation
   ! handles one parsing action (shift, reduce, shift+reduce, accept).
   ! Subsequent actions are handled by tail-recursion.
   !
   ! @param $input the input string.
   ! @param $target the target symbol code.
   ! @param $max-id the maximum thread id.
   ! @param $thread the parsing thread data.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="target" as="xs:integer"/>
    <xsl:param name="max-id" as="xs:integer"/>
    <xsl:param name="thread" as="map(*)"/>

    <xsl:variable name="lexer-state" select="$thread?lexer-state"/>
    <xsl:choose>
      <xsl:when test="$lexer-state[$p:error]">
        <xsl:sequence select="$thread"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="$thread?state"/>
        <xsl:variable name="action" select="$thread?action"/>
        <xsl:variable name="nonterminal" select="$thread?nonterminal"/>
        <xsl:variable name="bw" select="$thread?bw"/>
        <xsl:variable name="bs" select="$thread?bs"/>
        <xsl:variable name="es" select="$thread?es"/>
        <xsl:variable name="stack" select="$thread?stack"/>
        <xsl:variable name="argument" select="$action idiv 4096"/>
        <xsl:variable name="lookback" select="($action idiv 8) mod 512"/>
        <xsl:variable name="action" select="$action mod 8"/>
        <xsl:choose>
          <xsl:when test="$action eq 6"> <!-- SHIFT+ACCEPT -->
            <xsl:sequence select="p:thread($thread?id, true(), $state, $action, $nonterminal, $bw, $bs, $es, $stack, $lexer-state)"/>
          </xsl:when>
          <xsl:when test="$action eq 7"> <!-- FORK -->
            <xsl:sequence select="
              for $i in (1, 2)
              return p:thread(($max-id + 1, $thread?id)[$i], false(), $state, $p:APPENDIX[$argument + $i], -1, $bw, $bs, $es, $stack, $lexer-state)
            "/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="shift-reduce-symbols" select="
              if ($action eq 1) then (: SHIFT :)
                ($argument, -1, -1)
              else if ($action eq 2) then (: REDUCE :)
                (-1, $argument, $lookback)
              else if ($action eq 3) then (: REDUCE+LOOKBACK :)
                (-1, $argument, p:count($lookback, 0, $stack, count($stack) - 1))
              else if ($action eq 4) then (: SHIFT+REDUCE :)
                ($state, $argument, $lookback + 1)
              else if ($action eq 5) then (: SHIFT+REDUCE+LOOKBACK :)
                ($state, $argument, p:count($lookback, 1, $stack, count($stack) - 1))
              else (: ERROR :)
                (-1, -1, -1)
            "/>
            <xsl:variable name="shift" select="$shift-reduce-symbols[1]"/>
            <xsl:variable name="reduce" select="$shift-reduce-symbols[2]"/>
            <xsl:variable name="symbols" select="$shift-reduce-symbols[3]"/>
            <xsl:variable name="es" select="if ($shift lt 0 or $nonterminal ge 0) then $es else $lexer-state[$p:e1]"/>
            <xsl:variable name="lexer-state" select="
              if ($shift lt 0 or $nonterminal ge 0) then
                $lexer-state
              else
                p:consume
                (
                  $lexer-state[$p:l1],
                  $input,
                  $lexer-state
                )
            "/>
            <xsl:variable name="stack" select="
              if ($shift lt 0) then
                $stack
              else
                ($stack, if ($nonterminal lt 0) then $lexer-state[$p:b0] else $bs, $state, $lookback)
            "/>
            <xsl:variable name="state" select="if ($shift lt 0) then $state else $shift"/>
            <xsl:choose>
              <xsl:when test="$reduce lt 0">
                <xsl:choose>
                  <xsl:when test="$shift lt 0">
                    <xsl:variable name="node">
                      <xsl:element name="error">
                        <xsl:attribute name="b" select="$lexer-state[$p:b1]"/>
                        <xsl:attribute name="e" select="$lexer-state[$p:e1]"/>
                        <xsl:if test="$lexer-state[$p:l1] gt 0">
                          <xsl:attribute name="o" select="$lexer-state[$p:l1]"/>
                        </xsl:if>
                        <xsl:attribute name="s" select="$p:TOKENSET[$state + 1] + 1"/>
                      </xsl:element>
                    </xsl:variable>
                    <xsl:sequence select="
                      p:thread
                      (
                        $thread?id, false(), $state, 0, -1, $bw, $bs, $es, $stack,
                        (
                          subsequence($lexer-state, 1, $p:error - 1),
                          $node/node(),
                          subsequence($lexer-state, $p:error + 1)
                        )
                      )
                    "/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:variable name="lexer-state" select="p:predict($input, $lexer-state, $state, $thread?id)"/>
                    <xsl:sequence select="p:thread($thread?id, false(), $state, $lexer-state[$p:lk], -1, $bw, $bs, $es, $stack, $lexer-state)"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="if ($symbols gt 0) then $stack[last() - 3 * $symbols + 2] else $state"/>
                <xsl:variable name="bs" select="if ($symbols gt 0) then $stack[last() - 3 * $symbols + 1] else $lexer-state[$p:b1]"/>
                <xsl:variable name="es" select="if ($symbols gt 0) then $es else $bs"/>
                <xsl:variable name="stack" select="if ($symbols gt 0) then subsequence($stack, 1, count($stack) - 3 * $symbols) else $stack"/>
                <xsl:variable name="accept" select="$reduce eq $target and count($stack) eq 3"/>
                <xsl:variable name="bs" select="if ($accept) then $bw else $bs"/>
                <xsl:variable name="es" select="if ($accept) then $lexer-state[$p:b1] else $es"/>
                <xsl:variable name="bw" select="if ($accept) then $es else $bw"/>
                <xsl:variable name="index" select="if ($accept) then $p:result else p:first-child-node-index($lexer-state, count($lexer-state) + 1, $symbols)"/>
                <xsl:variable name="node">
                  <xsl:element name="{$p:NONTERMINAL[$reduce + 1]}">
                    <xsl:sequence select="subsequence($lexer-state, $index)"/>
                  </xsl:element>
                </xsl:variable>
                <xsl:variable name="lexer-state" select="subsequence($lexer-state, 1, $index - 1), $node/node()"/>
                <xsl:variable name="nonterminal" select="$reduce"/>
                <xsl:variable name="thread" select="p:thread($thread?id, false(), $state, p:goto($nonterminal, $state), $nonterminal, $bw, $bs, $es, $stack, $lexer-state)"/>
                <xsl:sequence select="p:parse($input, $target, $max-id, $thread)"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Decrement given index by the given number of elements on the result
   ! stack, skipping any non-element nodes.
   !
   ! @param $state lexer state, error indicator, and result stack.
   ! @param $index the index into the result stack.
   ! @param $element-count the number of elements to be handled.
   ! @return the decremented index.
  -->
  <xsl:function name="p:first-child-node-index">
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="index" as="xs:integer"/>
    <xsl:param name="element-count" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$element-count eq 0">
        <xsl:sequence select="$index"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="index" select="$index - 1"/>
        <xsl:variable name="element-count" select="$element-count - (if ($state[$index] instance of element()) then 1 else 0)"/>
        <xsl:sequence select="p:first-child-node-index($state, $index, $element-count)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Create a textual error message from a parsing error.
   !
   ! @param $input the input string.
   ! @param $error the parsing error descriptor.
   ! @return the error message.
  -->
  <xsl:function name="p:error-message" as="xs:string">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="error" as="element(error)"/>

    <xsl:variable name="begin" select="xs:integer($error/@b)"/>
    <xsl:variable name="context" select="string-to-codepoints(substring($input, 1, $begin - 1))"/>
    <xsl:variable name="linefeeds" select="index-of($context, 10)"/>
    <xsl:variable name="line" select="count($linefeeds) + 1"/>
    <xsl:variable name="column" select="($begin - $linefeeds[last()], $begin)[1]"/>
    <xsl:variable name="expected" select="if ($error/@x or $error/@ambiguous-input) then () else p:expected-token-set($error/@s)"/>
    <xsl:sequence select="
      string-join
      (
        (
          if ($error/@ambiguous-input) then
            'ambiguous input'
          else if ($error/@o) then
            ('syntax error, found ', $p:TOKEN[$error/@o + 1])
          else
            'lexical analysis failed',
          '&#10;',
          if ($error/@ambiguous-input) then
            ()
          else
          (
            'while expecting ',
            if ($error/@x) then
              $p:TOKEN[$error/@x + 1]
            else
            (
              '['[exists($expected[2])],
              string-join($expected, ', '),
              ']'[exists($expected[2])]
            ),
            '&#10;',
            if ($error/@o or $error/@e = $begin) then
              ()
            else
              ('after successfully scanning ', string($error/@e - $begin), ' characters beginning ')
          ),
          'at line ', string($line), ', column ', string($column), ':&#10;',
          '...', substring($input, $begin, 64), '...'
        ),
        ''
      )
    "/>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consume" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:variable name="begin" select="$state[$p:e0]"/>
        <xsl:variable name="end" select="$state[$p:b1]"/>
        <xsl:variable name="whitespace">
          <xsl:if test="$begin ne $end">
            <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="token" select="$p:TOKEN[1 + $state[$p:l1]]"/>
        <xsl:variable name="name" select="if (starts-with($token, &quot;'&quot;)) then 'TOKEN' else $token"/>
        <xsl:variable name="begin" select="$state[$p:b1]"/>
        <xsl:variable name="end" select="$state[$p:e1]"/>
        <xsl:variable name="node">
          <xsl:element name="{$name}">
            <xsl:sequence select="substring($input, $begin, $end - $begin)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, $p:l1, 3),
          0, 0, 0,
          subsequence($state, 7),
          $whitespace/node(),
          $node/node()
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @param $id the parsing thread id.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="id" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:match($input, $state[$p:e0], $set, $id)
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 7)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse start symbol ixml from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-ixml" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:predict($s, $state, 0, 0)"/>
    <xsl:variable name="state" select="p:parse-glr($s, 0, 0, p:thread(0, false(), 0, $state[$p:lk], -1, 1, 1, 1, (1, -1, 0), $state))"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$error/AMBIGUOUS, $ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</xsl:stylesheet>