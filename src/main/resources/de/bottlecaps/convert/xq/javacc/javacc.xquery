xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sat Oct 25, 2025 17:37 (UTC+02) by REx v6.2-SNAPSHOT which is Copyright (c) 1979-2025 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q -backtrack -tree -a none -xquery -name de/bottlecaps/convert/xq/javacc/javacc.xquery ../../../../../../../main/java/de/bottlecaps/convert/javacc/javacc.ebnf :)

(:~
 : The parser that was generated for the de/bottlecaps/convert/xq/javacc/javacc.xquery grammar.
 :)
module namespace p="de/bottlecaps/convert/xq/javacc/javacc.xquery";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 14;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 15;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  89, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 0, 4, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 22, 22, 23, 24, 23, 23, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
  35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 9, 49, 50, 51, 9, 52, 9, 53, 9, 9, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 9, 69, 70, 71, 72, 73, 74, 9, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 840, 308, 397, 491, 365, 711, 339, 953, 523, 555, 587, 619, 651, 683, 743, 775, 807, 246, 1031, 839, 840, 872,
  969, 459, 953, 953, 953, 953, 953, 904, 276, 428, 936, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953,
  953, 953, 1001, 1063, 953, 953, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 1095, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 1097, 840,
  840, 840, 840, 1129, 953, 953, 953, 953, 953, 953, 953, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 1161, 1193, 1202, 1194, 1208, 1216, 1224, 1232, 1240, 1248, 1256, 1264, 1281,
  1289, 1297, 1305, 1313, 1703, 1703, 1703, 1703, 1479, 1332, 1337, 1332, 1517, 1517, 1518, 1517, 1517, 1517, 1518,
  1517, 1517, 1517, 1517, 1517, 1517, 1517, 1518, 1545, 1518, 1545, 1517, 1517, 1517, 1517, 1518, 1545, 1517, 1517,
  1517, 1518, 1545, 1518, 1545, 1518, 1518, 1517, 1517, 1518, 1517, 1517, 1271, 1271, 1517, 1517, 1517, 1517, 1271,
  1271, 1517, 1661, 1517, 1517, 1517, 1271, 1517, 1517, 1517, 1517, 1517, 1517, 1520, 1617, 1669, 1417, 1273, 1418,
  1517, 1417, 1669, 1417, 1517, 1517, 1517, 1517, 1515, 1517, 1418, 1465, 1465, 1465, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1271, 1517, 1514, 1348, 1465, 1348, 1465, 1417, 1336, 1465, 1465, 1466, 1401,
  1517, 1517, 1417, 1703, 1703, 1703, 1462, 1465, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517, 1517, 1404, 1703,
  1464, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1516, 1517, 1517, 1517, 1518, 1333, 1516, 1517, 1517,
  1517, 1517, 1465, 1702, 1703, 1359, 1703, 1703, 1320, 1370, 1465, 1517, 1517, 1517, 1482, 1482, 1465, 1703, 1703,
  1703, 1703, 1703, 1703, 1703, 1703, 1703, 1704, 1465, 1465, 1462, 1465, 1465, 1332, 1336, 1682, 1517, 1517, 1585,
  1517, 1517, 1517, 1517, 1518, 1517, 1515, 1517, 1517, 1418, 1465, 1502, 1465, 1465, 1465, 1690, 1465, 1335, 1334,
  1465, 1465, 1465, 1465, 1701, 1465, 1335, 1465, 1465, 1465, 1465, 1517, 1517, 1465, 1465, 1465, 1465, 1703, 1706,
  1373, 1465, 1465, 1465, 1503, 1703, 1463, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1465,
  1517, 1517, 1517, 1517, 1517, 1654, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1627, 1377, 1517, 1517, 1517, 1517,
  1517, 1517, 1272, 1345, 1517, 1517, 1517, 1517, 1271, 1348, 1412, 1517, 1517, 1517, 1517, 1517, 1517, 1549, 1703,
  1705, 1597, 1517, 1427, 1703, 1465, 1465, 1412, 1272, 1514, 1517, 1517, 1586, 1441, 1455, 1692, 1430, 1466, 1581,
  1427, 1703, 1418, 1465, 1476, 1419, 1514, 1517, 1517, 1586, 1673, 1455, 1433, 1430, 1465, 1680, 1350, 1703, 1391,
  1465, 1412, 1681, 1585, 1517, 1517, 1586, 1676, 1549, 1491, 1324, 1334, 1465, 1500, 1703, 1465, 1465, 1412, 1272,
  1514, 1517, 1517, 1586, 1511, 1549, 1598, 1430, 1350, 1581, 1447, 1703, 1465, 1465, 1529, 1393, 1545, 1541, 1444,
  1393, 1519, 1447, 1599, 1459, 1466, 1465, 1466, 1703, 1465, 1465, 1412, 1520, 1586, 1517, 1517, 1586, 1521, 1447,
  1557, 1459, 1351, 1465, 1447, 1703, 1465, 1465, 1529, 1520, 1586, 1517, 1517, 1586, 1521, 1447, 1557, 1459, 1351,
  1336, 1447, 1703, 1465, 1465, 1529, 1520, 1586, 1517, 1517, 1586, 1517, 1447, 1693, 1459, 1466, 1465, 1447, 1703,
  1465, 1465, 1529, 1517, 1518, 1515, 1517, 1517, 1585, 1618, 1518, 1568, 1492, 1703, 1465, 1465, 1577, 1465, 1516,
  1517, 1517, 1517, 1517, 1517, 1594, 1708, 1403, 1704, 1703, 1463, 1465, 1465, 1465, 1465, 1607, 1609, 1377, 1516,
  1533, 1583, 1594, 1560, 1617, 1705, 1703, 1717, 1465, 1465, 1465, 1465, 1516, 1517, 1517, 1482, 1517, 1636, 1705,
  1465, 1703, 1463, 1402, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1385, 1692, 1362, 1459,
  1703, 1391, 1334, 1465, 1465, 1463, 1703, 1463, 1468, 1569, 1517, 1516, 1517, 1517, 1517, 1482, 1702, 1703, 1557,
  1418, 1703, 1702, 1703, 1703, 1703, 1706, 1467, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517, 1517,
  1585, 1626, 1599, 1463, 1703, 1463, 1404, 1463, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517,
  1517, 1271, 1465, 1517, 1517, 1517, 1517, 1518, 1465, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1483, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1482, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1348, 1516, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1272, 1518, 1465, 1516, 1517, 1517, 1482, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1482, 1465, 1465, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1418, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1348, 1646, 1515, 1618, 1416, 1658, 1679, 1585, 1348, 1465, 1465, 1465, 1465, 1517, 1517,
  1517, 1517, 1418, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465,
  1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517,
  1517, 1517, 1517, 1635, 1703, 1703, 1703, 1707, 1645, 1703, 1463, 1465, 1465, 1376, 1465, 1465, 1465, 1516, 1637,
  1416, 1482, 1516, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1417, 1716, 1516, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1518, 1545, 1518, 1517, 1517, 1517, 1517, 1518, 1517, 1517, 1482, 1465, 1702,
  1463, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1417, 1465, 1376,
  1517, 1517, 1517, 1517, 1417, 1516, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1518, 1465, 1465,
  1517, 1517, 1517, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1271, 1465, 1465, 1465,
  1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1517, 1517, 1517, 1417, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465,
  1465, 1465, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
  1517, 1517, 1517, 1418, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 1465, 89, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 2, 3, 0, 4, 5, 1, 1, 1, 1, 0, 0, 0, 0, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 22, 22,
  23, 24, 23, 23, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 9,
  49, 50, 51, 9, 52, 9, 9, 9, 9, 9, 9, 59, 59, 9, 9, 53, 9, 9, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
  68, 9, 69, 70, 71, 72, 73, 74, 9, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 88, 59, 88, 88, 88, 59, 88,
  88, 88, 59, 59, 59, 59, 9, 59, 59, 59, 59, 59, 59, 59, 9, 59, 59, 9, 59, 59, 9, 9, 59, 59, 59, 59, 59, 59, 88, 88, 59,
  88, 88, 59, 88, 88, 88, 88, 88, 9, 9, 88, 59, 88, 88, 59, 88, 59, 59, 59, 59, 59, 59, 9, 9, 9, 9, 9, 9, 9, 9, 59, 9,
  88, 88, 9, 9, 9, 59, 59, 59, 9, 9, 9, 88, 9, 9, 9, 9, 9, 9, 9, 88, 88, 59, 88, 88, 88, 59, 9, 9, 9, 9, 9, 59, 59, 59,
  59, 9, 9, 9, 88, 88, 59, 59, 88, 88, 88, 59, 59, 59, 59, 88, 9, 59, 9, 59, 59, 59, 9, 9, 59, 59, 59, 59, 88, 88, 9, 9,
  59, 59, 88, 59, 88, 88, 88, 88, 59, 59, 59, 59, 59, 59, 59, 59, 88, 59, 88, 59, 59, 88, 59, 59, 9, 9, 9, 9, 59, 59,
  59, 59, 59, 9, 88, 88, 88, 88, 88, 88, 59, 88, 59, 9, 59, 59, 59, 59, 59, 88, 88, 88, 88, 59, 9, 59, 9, 9, 59, 59, 9,
  9, 9, 9, 9, 9, 9, 9, 59, 9, 9, 9, 59, 59, 88, 88, 59, 9, 9, 9, 59, 9, 59, 9, 59, 9, 9, 59, 9, 59, 9, 9, 9, 9, 59, 59,
  88, 9, 88, 88, 88, 88, 88, 88, 88, 59, 88, 88, 9, 59, 59, 59, 59, 88, 59, 59, 59, 59, 88, 88, 59, 59, 88, 88, 59, 59,
  59, 59, 9, 9, 59, 9, 9, 9, 9, 9, 9, 9, 88, 9, 9, 88, 88, 88, 88, 59, 59, 59, 88, 88, 59, 9, 9, 59, 9, 59, 59, 9, 59,
  59, 9, 9, 9, 9, 9, 59, 9, 59, 59, 59, 9, 9, 59, 88, 88, 88, 88, 59, 9, 9, 9, 9, 88, 88, 88, 88, 88, 88, 59, 59, 59, 9,
  59, 59, 59, 59, 9, 9, 88, 59, 59, 59, 59, 59, 59, 9, 59, 9, 59, 9, 59, 9, 59, 59, 9, 9, 9, 59, 9, 9, 59, 9, 9, 59, 9,
  9, 9, 9, 59, 9, 59, 9, 9, 59, 59, 88, 88, 88, 88, 88, 59, 59, 88, 88, 59, 59, 88, 88, 88, 88, 88, 88, 88, 88, 59, 59,
  59, 59, 9, 59, 88, 88, 59, 59, 9, 9, 59, 59
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64046, 64256, 64263, 64275, 64280, 64285, 64286, 64287, 64297, 64298, 64311, 64312, 64317, 64318, 64319,
  64320, 64322, 64323, 64325, 64326, 64434, 64467, 64830, 64848, 64912, 64914, 64968, 65008, 65020, 65056, 65060, 65075,
  65077, 65101, 65104, 65129, 65130, 65136, 65139, 65140, 65141, 65142, 65277, 65279, 65280, 65284, 65285, 65296, 65306,
  65313, 65339, 65343, 65344, 65345, 65371, 65381, 65471, 65474, 65480, 65482, 65488, 65490, 65496, 65498, 65501, 65504,
  65506, 65509, 65511, 65529, 65532, 65536, 63743, 64045, 64255, 64262, 64274, 64279, 64284, 64285, 64286, 64296, 64297,
  64310, 64311, 64316, 64317, 64318, 64319, 64321, 64322, 64324, 64325, 64433, 64466, 64829, 64847, 64911, 64913, 64967,
  65007, 65019, 65055, 65059, 65074, 65076, 65100, 65103, 65128, 65129, 65135, 65138, 65139, 65140, 65141, 65276, 65278,
  65279, 65283, 65284, 65295, 65305, 65312, 65338, 65342, 65343, 65344, 65370, 65380, 65470, 65473, 65479, 65481, 65487,
  65489, 65495, 65497, 65500, 65503, 65505, 65508, 65510, 65528, 65531, 65533, 1114111, 59, 9, 59, 9, 59, 9, 59, 9, 88,
  9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 88, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9,
  59, 9, 59, 88, 59, 9, 59, 88, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 9, 59, 88, 59, 59
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
  62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
  91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,
  116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,
  139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161,
  162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 14034, 13149, 12913, 11715, 12019, 6555, 13417, 11713, 11716, 14037,
  7699, 11327, 11713, 12018, 12911, 11712, 12014, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457,
  12408, 13614, 12408, 16352, 12369, 12405, 16353, 11329, 9697, 11330, 14132, 6547, 7552, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760,
  5760, 5760, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 6340, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11243, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 5760,
  5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 5760, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 5760, 5760, 5760, 5760, 5760, 5760, 5760,
  5760, 5760, 5760, 5760, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 7225, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 13213, 5809, 5823, 5795,
  11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 11760, 12019, 5853, 5779, 11759, 11747, 12019, 12019, 5839, 5871, 5883, 5899, 12019, 12019, 12019,
  12019, 12019, 11561, 12019, 7763, 11761, 12019, 12019, 12019, 12019, 11556, 12019, 11190, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 5920, 6856, 12019, 5939,
  5939, 5937, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 11088, 12019, 12019, 12019, 12019, 12019, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019,
  7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002,
  16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327,
  11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614,
  12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 8411, 6062, 6077, 8863,
  6133, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 10678, 6173, 6201, 14912, 6185, 11758, 12019, 12019,
  12019, 12019, 16141, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019,
  5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 6248, 6262, 6274, 11758, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 7763, 11761, 12019, 12019, 12019, 12019, 6290, 12019, 11190, 12019, 12019, 12019, 12019, 6311, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 8162, 12019, 5778, 5778, 5776, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 7759, 12019, 6336, 7754, 6367,
  6356, 16544, 6383, 6413, 6424, 6425, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 16710, 16705, 6452, 11097, 16708, 6441, 6458, 10508, 6489,
  10511, 6475, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 8069, 8064, 12019, 12019, 12019, 7986, 12058, 6505, 6520, 6785, 6588, 6627, 12019, 12019,
  12019, 16823, 12019, 11561, 12019, 15658, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12440, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019,
  5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 8310, 10929, 6651, 6666, 6680, 6696, 11758, 12019, 12019, 12019, 15316, 12019, 6776,
  12019, 7763, 12019, 12019, 12019, 12019, 12019, 7660, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 6801, 12335, 12326,
  13736, 6849, 6828, 6872, 13723, 6842, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12527, 12019, 12019, 12255, 6901, 6916,
  6930, 6946, 11758, 12019, 12019, 12019, 11196, 12019, 6995, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 7660,
  12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 7047, 7069, 7042, 16424, 7031, 7063, 16940, 7085, 7100, 7114, 7130, 7179, 12019, 12019,
  12019, 12019, 12019, 7221, 12019, 7763, 14257, 12019, 12019, 12019, 12019, 14500, 12019, 11190, 12019, 12019, 12019,
  12019, 14560, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019,
  5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 7270,
  7270, 7270, 7270, 7270, 7270, 7273, 7241, 7256, 7289, 7301, 7317, 12019, 12019, 12019, 13968, 12019, 11561, 12019,
  7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 13207, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 7342, 5921, 12019, 12019, 7340, 12019,
  12019, 12019, 7360, 7374, 7386, 7402, 13149, 12913, 11715, 12019, 6555, 7425, 11713, 13888, 7453, 7699, 11327, 11713,
  12018, 7732, 11712, 8768, 8894, 12913, 11713, 12017, 7473, 8536, 7813, 12183, 12409, 15130, 15077, 13614, 12408,
  11980, 5995, 12405, 9286, 12400, 13251, 11330, 7521, 14813, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 7570, 6459, 12019, 12019, 7568, 12019, 12019, 12019, 7588, 7602, 7614, 7402,
  13149, 12913, 11715, 12019, 6555, 7425, 11713, 13888, 7453, 7699, 11327, 11713, 12018, 7732, 11712, 10789, 8894,
  12913, 11713, 12017, 7630, 10403, 7813, 12183, 12409, 10054, 15077, 13614, 12408, 11980, 5995, 12405, 9286, 12400,
  13251, 11330, 7676, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 7570, 6459, 12019, 12019, 7568, 12019, 12019, 12019, 7588, 7602, 7614, 7402, 13149, 12913, 11715, 12019, 6555,
  7425, 11713, 13888, 7453, 7699, 11327, 11713, 12018, 7840, 11712, 10789, 8894, 12913, 11713, 12017, 7630, 10403, 7813,
  12183, 12409, 10054, 15077, 13614, 12408, 11980, 5995, 12405, 9286, 12400, 11135, 11330, 7676, 11836, 6018, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 7570, 6459, 12019, 12019, 7568,
  12019, 12019, 12019, 7588, 7602, 7614, 7402, 13149, 12913, 11715, 12019, 6555, 7425, 11713, 13888, 7453, 7699, 11327,
  11713, 12018, 7840, 11712, 10789, 8894, 12913, 11713, 12017, 7630, 10403, 7813, 12183, 12409, 10054, 7163, 13614,
  12408, 15407, 5995, 12405, 9286, 12400, 11135, 11330, 7676, 11836, 7721, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 7570, 6459, 12019, 12019, 7568, 12019, 12019, 12019, 7588, 7602,
  7614, 16345, 13149, 12913, 11715, 12019, 6555, 7779, 11713, 13176, 7807, 7699, 11327, 11713, 12018, 12097, 11712,
  10789, 8894, 12913, 11713, 12017, 7829, 10403, 7813, 12183, 12409, 10054, 15077, 13614, 12408, 11980, 5995, 12405,
  9286, 12400, 9139, 11330, 7676, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 7894, 12019, 6046, 10631, 7892, 7895, 12019, 7867, 7872, 8777, 7888, 11758, 12019, 12019, 12019,
  12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778,
  5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12296, 6317,
  12297, 7953, 7955, 14553, 14542, 7924, 7911, 6320, 7940, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 10798, 12019, 7985, 10801, 7971, 8002, 6091,
  8028, 8043, 8012, 8085, 11758, 12019, 12019, 12019, 7344, 12019, 8126, 12019, 7763, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 6635, 12019, 12019, 12019, 15310, 8155, 6632, 8178, 12236, 12227, 8194, 11758,
  12019, 12019, 12019, 14511, 8235, 8265, 12019, 7763, 12019, 12019, 12019, 12019, 5904, 12019, 12019, 11190, 12019,
  12019, 12019, 12019, 8309, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762,
  12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 7324, 12019, 15881, 7322, 13798, 15884, 13125, 8326, 8342, 13806, 8384, 11758, 12019, 12019, 12019, 11562,
  12019, 6295, 12019, 7763, 12019, 12019, 12019, 12019, 7572, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778,
  5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12446, 12019, 11452, 8436, 8427, 8452, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 8496,
  8480, 8408, 8399, 8467, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787,
  14450, 13149, 12913, 8512, 8057, 6555, 5955, 11713, 13176, 7807, 7699, 11327, 11713, 12018, 15001, 11712, 10789, 8894,
  12913, 8534, 12017, 8552, 10403, 7813, 8580, 12409, 10054, 15077, 12656, 12408, 11980, 5995, 12405, 9286, 8602, 9139,
  8626, 7676, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955,
  11713, 13176, 7807, 7699, 11327, 11713, 12018, 15001, 11712, 10789, 8894, 12913, 11713, 12017, 8552, 10403, 7813,
  12183, 12409, 10054, 15077, 13614, 12408, 11980, 5995, 12405, 9286, 8654, 9139, 11330, 7676, 11836, 6018, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568,
  6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 7807, 7699,
  11327, 11713, 12018, 15001, 11712, 10789, 11309, 12913, 7157, 12017, 8552, 10403, 7813, 8805, 12409, 10054, 15077,
  13614, 12408, 11980, 5995, 12405, 9286, 8680, 9139, 11330, 7676, 11836, 8703, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518,
  11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 8745, 11713, 13176, 7807, 7699, 11327, 11713, 12018, 14888,
  11712, 10789, 8894, 12913, 11713, 12017, 8793, 10403, 7813, 12183, 12409, 10054, 15077, 13614, 12408, 11980, 5995,
  12885, 9286, 12400, 9139, 14398, 8840, 8879, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 6117, 6572, 12019, 6563, 6568, 8729, 8918, 16779, 8946, 8960, 8972, 13061, 13149, 12913,
  11715, 12019, 6555, 8988, 11713, 13176, 7807, 9000, 11327, 10309, 12018, 14153, 11712, 10789, 11822, 12913, 9036,
  12017, 8552, 10403, 9059, 8638, 12409, 8279, 16117, 8209, 12408, 11980, 9298, 12405, 9286, 9082, 15221, 9108, 7676,
  16017, 9155, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572,
  12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 8745, 11713,
  13176, 9183, 15343, 11327, 11713, 12018, 14888, 11712, 10789, 8894, 12913, 11713, 12017, 8793, 10403, 7813, 12183,
  12409, 10054, 15077, 13614, 12408, 11980, 5995, 12405, 9286, 12400, 9139, 11330, 7676, 11836, 6018, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002,
  16793, 16779, 8518, 11714, 16787, 14776, 15572, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327,
  11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614,
  12408, 16352, 12369, 12405, 16353, 9205, 9139, 11330, 9244, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714,
  16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712,
  6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 8100, 12408, 16352, 12369, 12405,
  16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 16227, 6572, 12019, 6563, 9904, 8824, 9274, 16779, 9314, 9328, 9340, 13061, 13149, 12913, 11715,
  12019, 6555, 5955, 11713, 13176, 14037, 9575, 11327, 15072, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017,
  7545, 11715, 9761, 8564, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 6739,
  6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019,
  6563, 6568, 16498, 9356, 9384, 9408, 9422, 9434, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037,
  7699, 11327, 11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457,
  12408, 13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779,
  8518, 11714, 16787, 13061, 15279, 12913, 14719, 12019, 6555, 5955, 11713, 13176, 14037, 8757, 11327, 16029, 12018,
  12911, 11712, 6040, 8894, 9450, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408, 16352,
  12369, 12405, 16353, 12400, 9139, 11330, 5983, 6725, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 12986, 12936, 9470, 16779, 9498, 9512, 9524, 9540, 13149,
  12913, 11715, 12019, 6555, 9563, 11713, 10031, 14037, 7699, 11327, 11713, 12018, 11683, 11712, 7652, 8894, 12913,
  11713, 12017, 16170, 11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408, 16352, 10762, 11673, 16353, 12400, 9139,
  11330, 5983, 11836, 9608, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12018, 6572, 12019, 6563, 14419, 14307, 9650, 9678, 9713, 9727, 9739, 13061, 13149, 12913, 11715, 12019, 6555, 5955,
  11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813,
  12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 14143, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568,
  6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 9755, 7791,
  11327, 11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 9189, 9228, 12409, 7457, 12408,
  13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 13157, 9777, 11836, 9805, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518,
  11714, 16787, 15123, 14219, 9833, 9857, 12019, 6555, 5955, 11713, 13176, 14037, 7437, 11327, 11713, 12018, 12911,
  11712, 7495, 10873, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 6711, 12408, 16352, 12369,
  12405, 16353, 12400, 9139, 11330, 9883, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 15752, 6572, 12019, 9899, 6568, 9482, 9920, 9935, 9963, 9977, 9989, 13061, 13912, 12913,
  14878, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712, 6040, 11483, 12913, 6974,
  12017, 13484, 11715, 7813, 12183, 12409, 7409, 12408, 13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330,
  5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018,
  6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713,
  13176, 10005, 10450, 11327, 10027, 14487, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 10047, 10070,
  12409, 7457, 12888, 13948, 12408, 8356, 12369, 12405, 16353, 12400, 9139, 14946, 5983, 11836, 6018, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 15518, 9662,
  10092, 10120, 10148, 10162, 10174, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327,
  11713, 12018, 12911, 11712, 7743, 8894, 12913, 13884, 15808, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614,
  12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330, 10190, 11836, 10219, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 12693, 10104, 10269, 10297, 10331, 10345,
  10357, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712,
  6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 12405,
  16353, 12400, 9139, 10373, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913,
  11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327, 10401, 12018, 12911, 11712, 6040, 8894, 12913, 11713,
  12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330,
  5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018,
  6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 10419, 13149, 12913, 11715, 12019, 6555, 10438,
  11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813,
  12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 10613, 10596, 10474, 10497, 10486,
  10566, 10596, 10527, 10575, 10537, 10553, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 10591, 12019, 12019, 12019, 12019, 12019, 10612, 12019, 7763, 11761, 12019, 12019, 12019, 12019, 11556,
  12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 10629, 13743, 12019, 10649, 10649, 10647, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 10675, 10711, 15830, 12019, 12019, 12019, 11250, 10665, 10694, 10707, 11758, 12019,
  12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020,
  12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 15240, 10727, 16084, 16075, 10739, 11758, 12019, 12019, 12019, 12019, 12019,
  11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563,
  6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037,
  7699, 11327, 11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457,
  12408, 13614, 10755, 16352, 9867, 12087, 16770, 10778, 9139, 11330, 5983, 10817, 6018, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 10843, 10858, 10889, 11714, 10385, 13061,
  11403, 12913, 13240, 10926, 10458, 10945, 10992, 11019, 11075, 5967, 11113, 8610, 12285, 15001, 8368, 10789, 11151,
  13997, 13641, 11175, 8552, 11212, 7813, 12183, 11228, 6812, 15077, 7145, 11266, 11980, 7688, 8586, 9286, 12400, 9139,
  11330, 7676, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12018, 6572, 12019, 6563, 6568, 11278, 12684, 11294, 11346, 11360, 11372, 13061, 13149, 12913, 16462, 12019, 6555,
  5955, 11713, 11388, 7453, 7699, 11327, 13650, 8855, 7484, 11712, 10789, 8894, 15059, 11713, 12017, 8552, 10403, 7813,
  12183, 12409, 10054, 15077, 13614, 12408, 11980, 5995, 12405, 9286, 12400, 10976, 11330, 7676, 11836, 6018, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 11431, 12019, 11159, 6568,
  11059, 13394, 11468, 11511, 11525, 11541, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 7807, 7699,
  11327, 11713, 12521, 11578, 11712, 10789, 8894, 12913, 9043, 8716, 8552, 11615, 7813, 12183, 12363, 11631, 9789, 7194,
  12735, 11661, 8817, 10827, 9368, 11707, 11732, 11330, 7676, 11836, 11779, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 11763, 8902, 6568, 9634, 12846, 11807, 11860, 11874,
  11886, 13061, 13149, 12913, 11715, 12019, 6555, 8745, 11713, 13176, 7807, 7699, 11327, 11713, 12018, 14888, 11712,
  10789, 8894, 12913, 11902, 12017, 8793, 10403, 7813, 12183, 12409, 10054, 15077, 11919, 12408, 11980, 5995, 12405,
  9286, 12400, 9139, 7705, 7676, 11836, 11957, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12018, 6572, 12019, 12787, 11996, 6002, 8687, 12036, 12074, 11714, 9392, 14121, 12113, 12913,
  11715, 12019, 6555, 12149, 12722, 15434, 7807, 7699, 11327, 11713, 12018, 14153, 9585, 11003, 12603, 12205, 11713,
  12252, 12271, 14850, 16671, 6752, 15030, 15366, 14284, 6961, 12313, 11980, 7533, 8110, 12351, 16003, 12385, 12425,
  7676, 9258, 12462, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018,
  6572, 12019, 6563, 11322, 13771, 12491, 12506, 12543, 12557, 12573, 13061, 13149, 12913, 11715, 12019, 6555, 8745,
  16191, 16199, 12641, 7699, 11327, 11713, 12018, 7641, 12189, 10789, 8894, 12913, 11713, 12017, 8793, 10403, 7813,
  12183, 12409, 10054, 6979, 13614, 13328, 11980, 5995, 15854, 12672, 12400, 10976, 11330, 7676, 15731, 6018, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568,
  6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699,
  11327, 11713, 12018, 12911, 11712, 6040, 8894, 12475, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408,
  13614, 14326, 16435, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518,
  11714, 16787, 13304, 12709, 12751, 11715, 12019, 12779, 12767, 12803, 12819, 14037, 7699, 11327, 11713, 12018, 12911,
  11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 9690, 12871, 12904, 13614, 12408, 16352, 12929,
  12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12018, 12952, 12019, 12981, 13002, 16640, 13031, 13046, 13080, 13094, 13106, 13061, 13149,
  12913, 15210, 13122, 13141, 5955, 13173, 13192, 6232, 14940, 11327, 13229, 12051, 14642, 9841, 6040, 15564, 12913,
  7205, 11047, 7545, 11715, 7813, 13267, 12009, 13289, 12126, 13614, 14024, 13344, 12369, 12405, 16353, 12400, 9139,
  9454, 13382, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955,
  11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 14066, 13410, 11715, 7813,
  12183, 12409, 7457, 13433, 13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568,
  6885, 14681, 13456, 13512, 13526, 13538, 13554, 13149, 14629, 11715, 12019, 13570, 13594, 13630, 13666, 14037, 12161,
  11327, 11903, 9622, 13871, 11712, 7851, 15271, 13682, 10910, 11970, 13708, 11930, 7813, 16182, 13759, 7457, 13787,
  13822, 12408, 9066, 16491, 13273, 12834, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518,
  11714, 16787, 13061, 13858, 12913, 11715, 12019, 13904, 13928, 11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911,
  11712, 6040, 8894, 12913, 11713, 13964, 13984, 11715, 7813, 12183, 12409, 7457, 12408, 14013, 12408, 9547, 12369,
  12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12018, 14053, 12019, 6563, 8293, 6002, 14091, 14106, 14169, 14183, 14195, 14388, 13149,
  12965, 16036, 12019, 14211, 14235, 15497, 13015, 13064, 7699, 8249, 14653, 15397, 6029, 10902, 14251, 8894, 12913,
  10315, 14691, 7545, 11715, 10011, 12183, 12409, 7457, 12408, 14273, 12408, 14783, 14300, 14323, 16353, 14342, 14358,
  11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12018, 6572, 12019, 14414, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 14435, 14474, 11446, 11844,
  5955, 15199, 14527, 14037, 7699, 14576, 13692, 12618, 12911, 11712, 6040, 14592, 12913, 11713, 12017, 14616, 12172,
  6157, 12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 15638, 14669, 12400, 9139, 11330, 14707, 11836, 6018,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563,
  6568, 6002, 14745, 14761, 14799, 11714, 11791, 13061, 14837, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 7505,
  14866, 11327, 11713, 13842, 13440, 11712, 6040, 8894, 12913, 11713, 12017, 13484, 11715, 7813, 12183, 12409, 7409,
  12408, 13614, 12408, 16352, 12369, 12405, 16353, 14373, 9167, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779,
  8518, 11714, 9817, 13061, 14600, 12913, 16524, 14904, 14821, 14928, 9947, 10132, 10422, 7699, 11327, 6760, 16066,
  6029, 8219, 6040, 8894, 14962, 11713, 12017, 7545, 11715, 14978, 15911, 12216, 8930, 14994, 13614, 9131, 15017, 12369,
  12405, 16353, 12400, 10976, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12018, 15046, 12019, 6563, 12855, 8139, 15093, 15108, 15146, 15160, 15172, 13061, 13149,
  12913, 11715, 12019, 6555, 5955, 16571, 16577, 14037, 15188, 11327, 15489, 15237, 12911, 15256, 15295, 15332, 12913,
  11713, 12017, 16684, 11715, 15359, 12183, 15800, 15382, 12408, 15423, 12408, 16352, 9020, 12405, 16353, 12400, 9139,
  11330, 15450, 15478, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12018, 11034, 5855, 15513, 11645, 6002, 15534, 15549, 15588, 15602, 15614, 13061, 13149, 15630, 8664, 15654, 13606,
  5955, 16112, 15462, 15674, 15690, 15717, 11589, 15768, 15789, 13318, 15824, 8894, 15846, 15701, 15870, 11495, 15900,
  7813, 9120, 13833, 12588, 12408, 13614, 15972, 15927, 14729, 9010, 15943, 15959, 15988, 16052, 16100, 11836, 6018,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563,
  6568, 6002, 16793, 16779, 8518, 11714, 16787, 13471, 13578, 12913, 11124, 16133, 11691, 16157, 13357, 13366, 16215,
  10957, 16243, 11713, 16280, 16299, 11415, 6040, 8894, 12913, 11713, 12017, 7545, 9217, 6148, 12183, 12409, 7457,
  15742, 13614, 12408, 16352, 12369, 12405, 14458, 12400, 11941, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 10281, 16315, 16330,
  16369, 16383, 16395, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327, 11713, 12018,
  12911, 11712, 6040, 8894, 12913, 11599, 16697, 7545, 11715, 7813, 12183, 16411, 7457, 12408, 13614, 12408, 16352,
  12369, 12405, 16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12018, 6534, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 13496, 13061,
  13149, 12913, 11715, 12019, 6555, 5955, 9592, 10203, 6105, 16451, 11327, 11713, 12018, 12911, 11712, 6040, 8894,
  12913, 11713, 12017, 7545, 11715, 6603, 12183, 12409, 7457, 10968, 13614, 12408, 16352, 12369, 12405, 16353, 12400,
  9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 10419, 16478, 12913, 11715, 12019,
  6555, 10438, 11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545,
  11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 11836,
  6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019,
  6563, 6568, 6002, 16793, 16779, 8518, 11714, 16787, 13061, 13149, 16514, 9092, 16540, 13940, 5955, 16255, 16264,
  14037, 7699, 11327, 11713, 12018, 12133, 10076, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409,
  7457, 12408, 13614, 12408, 16352, 12369, 12405, 6611, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12018, 6572, 12019, 6563, 6568, 6002, 16793,
  16779, 8518, 11714, 16787, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327, 11713,
  12018, 12911, 11712, 6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408,
  16352, 12369, 12405, 16353, 12400, 9139, 11330, 5983, 16560, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 10252, 10253, 16593, 16628, 10244, 12019, 15773, 10234, 16614, 16656,
  11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 6397, 6393, 7005, 16283, 16726, 16756, 7015, 16742, 11758, 12019, 12019, 12019,
  12019, 16598, 11561, 12019, 7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778,
  5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 14075,
  14073, 16854, 6215, 16820, 6225, 12625, 16809, 16839, 16867, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019,
  7763, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 16896,
  12019, 12019, 16920, 16883, 16912, 11758, 12019, 12019, 12019, 12019, 12019, 11561, 12019, 7763, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 11190, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 11762, 12020, 12019, 5778, 5778, 5776, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 13061, 13149, 12913, 11715, 12019, 6555, 5955, 11713, 13176, 14037, 7699, 11327, 11713, 12018, 12911, 11712,
  6040, 8894, 12913, 11713, 12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 12405,
  16353, 12400, 9139, 11330, 5983, 11836, 6018, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019,
  12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 16936, 12019, 12019, 12019, 14034, 13149, 12913,
  11715, 12019, 6555, 13417, 11713, 11716, 14037, 7699, 11327, 11713, 12018, 12911, 11712, 12014, 8894, 12913, 11713,
  12017, 7545, 11715, 7813, 12183, 12409, 7457, 12408, 13614, 12408, 16352, 12369, 12405, 16353, 11329, 9697, 11330,
  14132, 6547, 7552, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 12019, 3248,
  3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 3248, 0, 181, 0, 0, 0, 0, 0, 0, 0,
  181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11264, 0, 0, 265, 11264, 0, 0, 0, 0, 0, 0, 11264, 0, 265, 265, 0, 0, 11264, 0, 0, 265,
  0, 265, 265, 265, 11264, 0, 265, 11264, 11264, 11264, 11264, 11264, 0, 11264, 11264, 0, 265, 11264, 11264, 0, 11264,
  0, 265, 0, 181, 0, 181, 181, 181, 0, 181, 0, 0, 0, 181, 181, 0, 181, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  193, 0, 181, 181, 181, 181, 181, 181, 181, 181, 181, 0, 181, 181, 181, 181, 181, 0, 181, 181, 181, 181, 181, 181, 181,
  181, 181, 0, 181, 0, 0, 0, 0, 0, 8192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38912, 45056, 0, 8373, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 5299, 0, 8192, 0, 0, 0, 0, 0, 0, 0, 8192, 0, 0, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 2225, 2225,
  2225, 2225, 0, 0, 2225, 2225, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2514, 2225, 0, 0, 0, 0, 2225,
  0, 2225, 181, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 181, 181, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 2225, 2225,
  2225, 2225, 0, 0, 181, 0, 0, 2225, 2225, 2225, 2225, 0, 181, 0, 2225, 2225, 2225, 2225, 0, 405, 0, 0, 0, 0, 0, 2225,
  2225, 2225, 2225, 2225, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34816, 34816, 34816, 0, 0, 0, 249, 0, 249, 249, 0, 0,
  0, 0, 0, 249, 0, 0, 0, 249, 0, 0, 0, 0, 0, 249, 0, 14585, 14585, 14585, 0, 0, 14585, 0, 0, 0, 0, 0, 0, 0, 36864,
  36864, 0, 36864, 36864, 0, 255, 0, 0, 0, 0, 0, 0, 0, 94208, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 182, 0,
  0, 0, 0, 0, 0, 14585, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14585, 14585, 0, 0, 0, 0, 0, 0, 2225, 0, 626, 0, 0, 0, 0, 0, 0, 2225,
  0, 0, 627, 0, 0, 0, 0, 0, 2225, 0, 0, 250, 0, 250, 250, 0, 0, 0, 0, 0, 16650, 0, 0, 0, 16650, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 16650, 16650, 0, 16650, 0, 0, 0, 0, 0, 16650, 0, 16650, 16650, 16650, 0, 0, 16650, 0, 0, 0, 0, 0, 0, 0, 121856, 0,
  121856, 0, 0, 0, 0, 0, 121856, 121856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 447, 448, 0, 2225, 0, 0, 0, 0, 273, 0, 273, 273,
  273, 0, 273, 0, 0, 0, 273, 273, 0, 273, 273, 273, 273, 273, 273, 273, 273, 273, 0, 273, 273, 273, 273, 273, 0, 273,
  273, 273, 273, 273, 273, 273, 273, 273, 0, 273, 0, 0, 0, 0, 0, 7168, 405, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399, 0,
  0, 0, 0, 0, 0, 7168, 7168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35840, 0, 0, 0, 0, 0, 35840, 0, 0, 19456, 19456, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 9216, 0, 19456, 19456, 19456, 19456, 0, 0, 0, 19456, 19456, 19456, 0, 0, 0, 0,
  0, 19456, 19456, 0, 0, 0, 0, 0, 0, 0, 19456, 0, 0, 0, 0, 19456, 0, 19456, 19456, 0, 19456, 0, 19456, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 0, 0, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456,
  0, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 0,
  0, 0, 0, 0, 20480, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 20480, 20480, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  5300, 20480, 20480, 20480, 20480, 20480, 20480, 0, 0, 0, 0, 0, 0, 0, 20480, 20480, 0, 20480, 0, 0, 20480, 20480, 0,
  20480, 0, 20480, 0, 20480, 0, 20480, 0, 0, 0, 251, 0, 251, 251, 0, 0, 0, 0, 0, 251, 0, 0, 0, 251, 0, 0, 0, 0, 0, 251,
  0, 21755, 21755, 21755, 0, 0, 21755, 0, 0, 0, 0, 0, 0, 190, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 2225, 0,
  2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225,
  2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 21755, 0, 21504, 0, 0, 0, 0, 0, 0, 0, 21755, 21755, 0, 0, 0, 0, 0, 0, 2225,
  625, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 2225, 0, 2225, 83121, 2225, 2225, 0, 318, 0, 0, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 252, 0, 252, 252, 0, 0, 0, 0, 0, 267, 0, 0, 0, 267, 0, 0, 0, 281, 281, 267, 0,
  23804, 23804, 23819, 23833, 0, 23804, 23833, 23833, 23833, 23833, 23833, 0, 23833, 23833, 0, 23804, 23833, 23833, 0,
  23833, 0, 23804, 23833, 0, 0, 23804, 23833, 23552, 281, 281, 281, 281, 281, 23833, 281, 23804, 23804, 0, 0, 0, 0, 0,
  0, 2225, 2225, 2225, 0, 0, 2225, 2225, 2739, 2225, 2225, 0, 0, 2225, 0, 2225, 181, 0, 0, 804, 2225, 2225, 2854, 2225,
  2225, 0, 0, 2225, 0, 2225, 181, 0, 803, 0, 2225, 2853, 2225, 2225, 2225, 634, 0, 0, 0, 2684, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2542, 2225, 2225, 2225, 405, 0, 0, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 21755, 0, 0, 0, 0, 0, 21755, 0, 0, 0, 0, 26624, 0, 0, 26624, 26624, 26624, 26624, 0, 0, 0, 0, 0, 0, 0,
  0, 2713, 667, 667, 604, 2225, 2225, 669, 2718, 0, 0, 0, 0, 26624, 0, 0, 0, 0, 0, 0, 26624, 0, 0, 0, 26624, 26624,
  26624, 26624, 26624, 0, 0, 0, 0, 0, 0, 0, 26624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 0, 8373, 26624, 0, 26624,
  0, 0, 0, 26624, 0, 0, 0, 26624, 0, 26624, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 216, 2271, 2271, 2271, 2225, 0, 0, 0,
  253, 0, 253, 253, 0, 0, 0, 0, 0, 268, 0, 0, 0, 268, 0, 0, 0, 282, 282, 268, 0, 27901, 27901, 27916, 27930, 0, 27901,
  27930, 27930, 27930, 27930, 27930, 0, 27930, 27930, 0, 27901, 27930, 27930, 0, 27930, 0, 27901, 27930, 0, 0, 27901,
  27930, 0, 282, 282, 282, 282, 282, 27930, 282, 27901, 27901, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 0, 76800, 2225,
  76977, 2225, 2225, 2225, 2225, 56497, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 677, 677, 0,
  0, 681, 405, 0, 0, 0, 0, 0, 0, 0, 0, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 119054,
  0, 0, 118784, 0, 118784, 119054, 0, 30720, 0, 0, 30720, 30720, 30720, 0, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 0,
  30720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30720, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0,
  30720, 0, 30720, 30720, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 30911, 274, 30720, 274, 274, 274, 30911, 274, 30720, 30720, 0,
  274, 274, 30720, 274, 274, 274, 274, 274, 274, 274, 274, 30994, 30720, 274, 274, 274, 274, 30994, 30720, 274, 30994,
  274, 30720, 274, 274, 274, 274, 274, 274, 274, 274, 274, 30720, 30994, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 689, 0,
  2738, 2225, 2225, 2225, 2225, 2225, 2622, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 678, 677,
  0, 0, 0, 0, 0, 0, 0, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 332, 0, 0, 0, 0, 0, 0, 2225, 2225, 103601, 0, 0, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2626, 2225, 2225, 2225, 2630, 2225, 2225, 405, 0, 6551, 6551, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 318, 9655, 0, 178, 178, 254, 178, 254, 254, 178, 178, 178, 178, 178, 254, 178, 178, 178, 254,
  178, 178, 178, 178, 178, 254, 178, 33022, 33022, 33022, 178, 178, 33022, 178, 178, 178, 178, 178, 178, 178, 178, 178,
  178, 178, 178, 178, 178, 178, 178, 254, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 33022, 178, 178, 178,
  178, 178, 33022, 178, 178, 178, 178, 178, 178, 178, 178, 178, 33022, 33022, 0, 0, 319, 0, 0, 181, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 43008, 0, 0, 0, 0, 0, 0, 0, 5299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 398, 0, 0, 5395, 0,
  5395, 5395, 5395, 0, 5395, 0, 0, 0, 5395, 5395, 0, 5395, 5395, 5395, 5395, 5395, 5395, 5395, 5395, 5395, 0, 5395,
  5395, 5395, 5395, 5395, 0, 5395, 5395, 5395, 5395, 5395, 5395, 5395, 5395, 5395, 0, 5395, 0, 2225, 0, 5440, 5300, 181,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 410, 2225, 2225, 0, 2225, 405, 6551, 5528, 5396, 2225, 2225, 2225, 2225, 0,
  0, 2225, 2225, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2513, 2225, 2225, 5560, 181, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 2225, 0, 0, 0, 2225, 2225, 0, 2225, 0, 0, 2225, 2225, 518, 405, 602, 6665, 6665, 604, 5643, 2225, 2225, 2225,
  2225, 0, 405, 0, 0, 0, 0, 5643, 2225, 2225, 2225, 2225, 2225, 318, 0, 0, 0, 545, 0, 0, 0, 0, 0, 0, 0, 0, 446, 0, 0, 0,
  2225, 0, 0, 0, 0, 0, 0, 603, 2225, 0, 2225, 792, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 181, 181, 0, 0, 0, 0, 0, 725, 0,
  0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 0, 0, 0, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 5300, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 513, 0, 0, 5396, 0, 5396, 5396, 5396, 0, 5396, 0, 0, 0, 5396, 5396, 0, 5396, 5396,
  5396, 5396, 5396, 5396, 5396, 5396, 5396, 0, 5396, 5396, 5396, 5396, 5396, 0, 5396, 5396, 5396, 5396, 5396, 5396,
  5396, 5396, 5396, 0, 5396, 0, 0, 0, 2225, 2225, 518, 405, 603, 6665, 6665, 604, 5643, 2225, 2225, 2225, 2225, 0, 405,
  6144, 6144, 6144, 0, 5643, 2225, 2225, 2225, 2225, 2225, 318, 0, 5120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 520, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 603, 2225, 0, 2225, 181, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 181, 181, 0, 0, 724, 0, 0, 0, 0, 0, 2225,
  2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 99505, 2225, 2225, 2225, 99328, 0, 810, 0, 0, 2225, 2225,
  2225, 2225, 0, 181, 0, 2225, 2225, 2225, 2225, 0, 517, 6551, 5528, 409, 6665, 5643, 2225, 2225, 2225, 2225, 2225, 318,
  0, 0, 0, 0, 546, 0, 0, 0, 0, 0, 0, 0, 0, 19456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 319, 0, 405, 6551, 409,
  5396, 2225, 2225, 2225, 2225, 0, 0, 2225, 2225, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2512, 2225, 2225, 2225,
  5560, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 2225, 2225, 0, 0, 603, 6665, 6665,
  604, 5643, 2225, 2225, 2225, 2225, 0, 518, 6551, 5528, 409, 6665, 5643, 2225, 2225, 2225, 2225, 2225, 318, 0, 5120, 0,
  0, 0, 0, 0, 0, 0, 550, 0, 0, 34816, 0, 0, 34816, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 0, 0, 34816,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35840, 0, 35840, 0, 0, 0, 35840, 0, 0, 0, 35840, 0, 0,
  35840, 0, 35840, 0, 35840, 35840, 0, 0, 0, 0, 35840, 35840, 0, 0, 35840, 35840, 0, 0, 0, 35840, 0, 0, 35840, 35840,
  35840, 35840, 35840, 35840, 35840, 35840, 0, 0, 0, 0, 0, 0, 0, 0, 35840, 0, 0, 35840, 0, 0, 0, 0, 0, 0, 36864, 36864,
  0, 36864, 0, 36864, 0, 0, 0, 0, 36864, 0, 36864, 36864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21504, 36864, 0,
  0, 36864, 0, 36864, 0, 36864, 36864, 36864, 0, 0, 0, 0, 0, 36864, 0, 0, 36864, 37149, 0, 0, 36864, 36864, 36864,
  37149, 0, 36864, 37119, 36864, 37119, 37119, 0, 0, 0, 0, 0, 255, 36864, 36864, 36864, 255, 0, 36864, 0, 0, 0, 37119,
  36864, 37149, 37149, 37149, 0, 36864, 37149, 0, 0, 0, 0, 0, 0, 397, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21504, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 36864, 36864, 36864, 37149, 36864, 36864, 0, 0, 0, 0, 0, 0, 0, 37149, 37149, 0, 0, 0, 0, 0, 0, 2225,
  2736, 2225, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 98481, 2225, 2225, 2225, 2785, 2225, 2225, 0, 97280, 405, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 38286, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 217, 2272, 2272, 2272, 2225, 0, 0, 40960, 0,
  40960, 40960, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7573, 0, 0, 0, 0, 181, 0, 0, 40960, 0, 40960, 40960, 0, 0, 0, 0,
  0, 41229, 0, 0, 0, 41229, 0, 40960, 0, 41229, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41229, 41229, 0, 0, 0, 0, 0, 0, 2735, 2225,
  2225, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 85169, 2225, 2225, 2585, 2225, 2225, 2225, 2225, 63488, 119808,
  0, 0, 0, 0, 0, 0, 12288, 18432, 25600, 29696, 41984, 119808, 0, 0, 0, 0, 0, 0, 472, 0, 2225, 2225, 2225, 2225, 2225,
  2225, 2527, 2225, 405, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 39936, 44032, 0, 0, 0, 0, 0, 0, 663, 0, 2225, 667, 667, 604,
  2225, 2225, 0, 2225, 2247, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2247, 2225, 46080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 23552, 0, 0, 256, 0, 256, 256, 0, 0, 0, 0, 0, 256, 0, 0, 0, 256, 43264, 0, 0, 0, 0, 0, 43264, 0, 43294,
  43294, 43294, 0, 0, 43294, 0, 0, 0, 0, 0, 0, 711, 0, 2225, 0, 0, 2225, 0, 2225, 2225, 2225, 2544, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2544, 2225, 2225, 0, 0, 0, 43294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43294, 43294, 0, 0, 0, 0,
  0, 0, 48128, 0, 0, 0, 0, 48128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 0, 0, 0, 47104, 0, 0, 0, 0, 0, 0, 0,
  47104, 0, 0, 0, 0, 0, 47104, 0, 47104, 47104, 47104, 0, 0, 47104, 0, 0, 0, 0, 0, 47104, 0, 47104, 0, 0, 0, 0, 0, 0, 0,
  47104, 47104, 0, 0, 0, 0, 0, 0, 48128, 0, 48128, 48128, 48128, 48128, 48128, 48128, 0, 0, 0, 0, 0, 48128, 48128,
  48128, 48128, 48128, 0, 48128, 48128, 48128, 0, 0, 48128, 0, 0, 0, 48128, 48128, 0, 0, 48128, 0, 0, 48128, 0, 48128,
  48128, 2225, 2418, 2225, 2420, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 2225, 2225, 0,
  2225, 2225, 2225, 2620, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 620, 621,
  0, 0, 2225, 2225, 0, 0, 603, 0, 0, 604, 5643, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2688, 2225, 2225, 2225, 2680, 2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2787, 0, 0, 181, 0, 0, 0, 0, 0, 2225, 2807, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2514, 2225, 2544, 2225, 777, 0, 0, 0, 0, 2829, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0,
  2225, 2225, 2225, 2225, 2225, 2687, 2225, 2225, 2225, 181, 0, 754, 0, 0, 0, 2225, 2225, 2225, 2808, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2429, 2225, 2225, 2225, 0, 0, 181, 753, 0, 0, 0, 0, 2806, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 240, 2225, 2225, 240, 0, 240, 240, 0, 181, 0, 0, 2225, 2225, 2225, 2225, 0, 181,
  0, 2225, 2862, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 596, 0, 0, 0, 0, 0, 0, 0, 2225, 2258, 0, 0, 2225, 2225, 2225,
  2258, 0, 405, 0, 6144, 6144, 2225, 2225, 2225, 2225, 0, 0, 2225, 2225, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 462, 2225,
  2225, 2225, 2225, 2225, 318, 0, 5560, 543, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 34816, 0, 0, 2225, 2225,
  0, 0, 603, 0, 6144, 604, 5643, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2686, 2225, 2225, 2225,
  2225, 181, 721, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 2225, 2225, 2225, 2255, 0, 0, 0, 0, 603, 2225, 0, 2225, 181,
  0, 0, 0, 0, 2225, 2225, 55473, 2225, 0, 0, 0, 0, 0, 0, 506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14585, 0, 0, 0, 0, 0, 14585,
  2225, 2225, 0, 55296, 2225, 0, 2225, 181, 0, 0, 0, 2225, 2225, 2225, 2855, 2225, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0,
  0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 194, 2258, 2225, 2258, 2258, 2225, 2225, 2225, 2258, 2258, 0, 2258, 2258, 0, 0,
  0, 0, 0, 0, 0, 664, 2225, 0, 0, 0, 2225, 2225, 0, 2225, 2225, 2258, 2225, 2258, 2258, 2258, 2225, 2258, 0, 0, 0, 2258,
  2258, 0, 2258, 2258, 2258, 2258, 2258, 2258, 2258, 2258, 2258, 2225, 2258, 2258, 2258, 2258, 2258, 0, 2258, 2258,
  2258, 2258, 2258, 2258, 2258, 2258, 2258, 2225, 2258, 0, 405, 0, 410, 410, 2225, 2225, 2225, 2225, 0, 0, 2225, 2225,
  0, 0, 0, 2225, 2225, 0, 0, 0, 0, 461, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2782, 2225, 2225, 2225, 2225, 2225,
  0, 0, 0, 0, 0, 0, 96256, 0, 79872, 0, 2225, 2225, 2225, 2225, 53425, 2225, 2225, 2225, 2623, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2631, 2225, 0, 623, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 0,
  0, 2225, 0, 0, 2225, 0, 2225, 2766, 2225, 181, 0, 0, 0, 0, 0, 2225, 2225, 51377, 2809, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2430, 2225, 2225, 2225, 0, 0, 0, 778, 0, 0, 0, 2225, 2225, 2830, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 0, 0, 83968, 102400, 2225, 2225, 84145, 102577, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2747,
  2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 2225, 2225, 181, 0, 181, 0, 811, 2225, 2860, 2861, 2225, 0, 181, 0,
  2225, 2225, 2225, 2225, 0, 0, 104448, 0, 0, 0, 0, 0, 2225, 0, 2225, 2225, 181, 5560, 0, 49152, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 2225, 0, 0, 0, 0, 0, 0, 0, 58368, 2225, 181, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2811, 2225, 2225, 2225,
  2225, 2225, 2225, 2662, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 59009, 2225, 0, 0, 0, 0, 2225, 0, 2225, 181, 0, 794, 0, 0, 2225, 2845, 2225, 2225, 0, 0, 2225, 0, 2225, 181, 0,
  0, 0, 2225, 2225, 2225, 2225, 2856, 2255, 2225, 2255, 2255, 2225, 2225, 2225, 2255, 2255, 0, 2255, 2255, 0, 0, 0, 0,
  0, 0, 0, 2225, 405, 405, 2225, 0, 2225, 2225, 2225, 2225, 181, 181, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2776, 2225, 2255,
  2225, 2255, 2255, 2255, 2225, 2255, 0, 0, 0, 2255, 2255, 0, 2255, 2255, 2255, 2255, 2255, 2255, 2255, 2255, 2255,
  2225, 2255, 2255, 2255, 2255, 2255, 0, 2255, 2255, 2255, 2255, 2255, 2255, 2255, 2255, 2255, 2225, 2255, 0, 2274,
  2225, 2274, 2274, 2225, 2225, 2225, 2274, 2274, 0, 2274, 2274, 0, 0, 0, 0, 0, 0, 0, 2225, 405, 747, 2225, 749, 2798,
  2225, 2225, 2225, 0, 2274, 0, 2274, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2361, 2225, 2361, 2311, 2225, 0, 2225, 2274, 2225, 2274, 2274, 2274, 2225, 2274, 0, 0, 0, 2274, 2274, 0, 2274, 2274,
  2274, 2274, 2274, 2274, 2274, 2274, 2274, 2225, 2274, 2274, 2274, 2274, 2274, 0, 2274, 2274, 2274, 2274, 2274, 2274,
  2274, 2274, 2274, 2225, 2274, 0, 2610, 2225, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2834,
  2225, 2225, 0, 2256, 2225, 2256, 2256, 2225, 2225, 2225, 2256, 2256, 0, 2256, 2256, 0, 0, 0, 0, 0, 0, 0, 2225, 2225,
  0, 0, 2225, 2225, 2225, 2276, 0, 2225, 2256, 2225, 2256, 2256, 2256, 2225, 2256, 0, 0, 0, 2256, 2256, 0, 2256, 2256,
  2256, 2256, 2256, 2256, 2256, 2256, 2256, 2225, 2256, 2256, 2256, 2256, 2256, 0, 2256, 2256, 2256, 2256, 2256, 2256,
  2256, 2256, 2256, 2225, 2256, 0, 2225, 0, 5120, 5120, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 2763, 0, 2225,
  2225, 2225, 405, 0, 5120, 5120, 2225, 2225, 2225, 2225, 0, 0, 2225, 2225, 0, 0, 0, 2225, 2225, 0, 0, 0, 460, 0, 0,
  2225, 2225, 2225, 2225, 2225, 2581, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2475, 2225, 2225, 0, 181, 0, 0, 2225, 2225, 2225, 2225, 0, 181, 0, 2225, 2225, 2863, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 511, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 213, 2268, 2268, 2268, 2225, 0, 2275, 2225, 2275, 2275, 2225, 2225, 2225,
  2275, 2275, 0, 2275, 2275, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 2225, 2225, 2225, 2277, 0, 0, 2275, 0, 2275, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2696, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0,
  0, 0, 2225, 0, 2225, 2225, 0, 2225, 2275, 2225, 2275, 2275, 2275, 2225, 2275, 0, 0, 0, 2275, 2275, 0, 2275, 2275,
  2275, 2275, 2275, 2275, 2275, 2275, 2275, 2225, 2275, 2275, 2275, 2275, 2275, 0, 2275, 2275, 2275, 2275, 2275, 2275,
  2275, 2275, 2275, 2225, 2275, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 630, 0, 2225, 0, 0,
  788, 0, 2225, 0, 2225, 181, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2723, 2225, 2225, 2225, 2225, 677, 677, 0,
  0, 0, 0, 181, 54272, 0, 54449, 2225, 2225, 2225, 0, 181, 57344, 57521, 2225, 2225, 2225, 0, 2225, 2225, 2225, 2349,
  2349, 2349, 2349, 2349, 2349, 2225, 2225, 0, 2225, 2400, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2584, 2504, 2586, 2225, 2225, 2225, 2225, 2225, 2419, 2225, 2225, 2423, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 0, 0, 722, 723, 0, 0, 0, 0, 0, 0, 2775, 2225, 0, 0, 0, 0, 2225, 0, 2225, 181, 0, 0, 0, 795,
  2225, 2225, 2225, 2846, 0, 184, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2255, 2276, 2225,
  2276, 2276, 2225, 2225, 2225, 2276, 2276, 0, 2276, 2276, 247, 0, 0, 247, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2469, 2225, 2471, 2225, 2225, 2225, 2225, 2225, 2225, 2464, 2225, 2225,
  2276, 2225, 2276, 2276, 2276, 2225, 2276, 0, 0, 0, 2276, 2276, 0, 2276, 2276, 2276, 2276, 2276, 2276, 2276, 2276,
  2276, 2225, 2276, 2276, 2276, 2276, 2276, 0, 2276, 2276, 2276, 2276, 2276, 2276, 2276, 2276, 2276, 2225, 2276, 0, 0,
  0, 0, 0, 443, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 629, 0, 0, 0, 2225, 2225, 2225, 2531, 2532, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 318, 319, 5120, 622, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0,
  0, 0, 0, 2225, 667, 667, 604, 2225, 2225, 0, 2225, 2679, 2225, 2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 113841, 2225, 2225, 2277, 2225, 2277, 2277, 2225, 2225, 2225, 2277, 2277, 0, 2277,
  2277, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 2225, 2225, 2225, 2278, 0, 0, 2277, 0, 2277, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2478, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 318, 319, 0, 2225,
  2277, 2225, 2277, 2277, 2277, 2225, 2277, 0, 0, 0, 2277, 2277, 0, 2277, 2277, 2277, 2277, 2277, 2277, 2277, 2277,
  2277, 2225, 2277, 2277, 2277, 2277, 2277, 0, 2277, 2277, 2277, 2277, 2277, 2277, 2277, 2277, 2277, 2225, 2277, 0, 0,
  0, 0, 0, 2225, 0, 2225, 181, 793, 0, 0, 0, 2844, 2225, 2225, 2225, 2225, 2475, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 318, 319, 0, 0, 181, 0, 0, 2225, 2225, 2225, 2225, 0, 181, 0, 2225, 2225, 2225, 59569, 0, 0, 0, 0, 0, 0,
  117760, 117760, 0, 0, 0, 0, 117760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2278, 2225,
  2278, 2278, 2225, 2225, 2225, 2278, 2278, 0, 2278, 2278, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 2225, 2225, 2273,
  2225, 0, 0, 2278, 0, 2278, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2534, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2632, 2225, 2278, 2225, 2278,
  2278, 2278, 2225, 2278, 0, 0, 0, 2278, 2278, 0, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2225, 2278,
  2278, 2278, 2278, 2278, 0, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2225, 2278, 0, 0, 0, 0, 0, 780, 2225,
  2225, 2225, 2225, 2832, 2225, 2225, 2225, 2225, 2225, 0, 2225, 2225, 2279, 2343, 2353, 2353, 2353, 2353, 2353, 2279,
  2225, 0, 2225, 2530, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 621, 621,
  2225, 0, 321, 0, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 450, 0, 0, 405, 0, 411, 0, 2225, 2225, 2225, 2225, 0, 0,
  2225, 2225, 0, 0, 0, 2225, 2225, 0, 0, 459, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2451, 2225, 0, 0,
  0, 60416, 0, 60416, 0, 0, 0, 0, 0, 60416, 0, 60416, 0, 0, 60416, 60416, 60416, 0, 0, 0, 60416, 0, 0, 60416, 0, 0, 0,
  0, 60416, 60416, 0, 60416, 0, 0, 0, 0, 0, 0, 0, 0, 20480, 0, 0, 20480, 0, 0, 0, 20480, 0, 20480, 20480, 0, 0, 60416,
  0, 60416, 60416, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60416, 0, 0, 60416, 60416, 0, 0, 60416, 60416, 60416, 60416, 60416, 60416,
  60416, 60416, 60416, 60416, 0, 0, 0, 0, 0, 0, 0, 60416, 60416, 0, 60416, 60416, 60416, 60416, 60416, 60416, 60416, 0,
  0, 0, 0, 0, 60416, 60416, 60416, 60416, 0, 0, 60416, 60416, 0, 0, 0, 0, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 60416, 0, 0, 406, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60416, 752, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 34816, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 61440, 0, 0, 61440,
  61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 250, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0,
  61440, 61440, 61440, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 257, 0, 257, 257, 0, 0, 0, 0, 0,
  62721, 0, 0, 0, 62721, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62721, 62721, 0, 2742, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 726, 2225, 2225, 181, 0, 0, 0, 0, 757, 2225, 2225, 2225, 2225, 2810,
  2225, 2225, 2225, 2225, 2225, 318, 0, 5560, 544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2847,
  2225, 0, 0, 2225, 0, 2225, 181, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2781, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  740, 0, 2225, 2279, 2225, 2225, 2225, 2279, 2279, 2225, 2225, 239, 2225, 2225, 239, 0, 239, 239, 2225, 0, 2225, 2225,
  2225, 2279, 2279, 2279, 2279, 2279, 0, 2279, 2279, 2279, 2225, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 2225, 2609,
  2225, 2225, 2279, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 2225, 2225, 0, 2225, 2225, 2579, 2225, 2225, 2225, 2582,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2629, 2225, 2225, 2225, 0, 389, 390, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252, 0, 0, 405, 0, 0, 0, 2460, 2225, 2225, 2225, 0, 0, 2225, 2225, 0, 0, 0, 2225, 2225,
  0, 458, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 109745, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 405,
  2225, 0, 2225, 2225, 181, 2467, 2460, 2460, 2426, 2225, 2225, 2225, 2225, 2225, 2225, 2460, 2225, 2225, 2225, 2225,
  2225, 318, 0, 5560, 544, 0, 0, 0, 548, 549, 0, 0, 2225, 2225, 2460, 2225, 2225, 2225, 2479, 2225, 2225, 2482, 2460,
  2225, 2225, 318, 319, 0, 0, 0, 0, 0, 189, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 589, 0, 0, 0, 0, 0,
  595, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 212, 2267, 2267, 2267, 2225, 0, 5560, 0, 0, 0, 0, 444, 0, 0, 0, 0, 0, 0,
  2497, 0, 0, 0, 0, 0, 0, 0, 13312, 13312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20480, 20480, 0, 0, 0, 0, 0, 0, 0, 469, 0, 0, 0,
  0, 0, 2225, 2225, 2524, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2428, 2225, 2225, 2225, 2225, 0, 0, 0,
  0, 0, 0, 0, 518, 2225, 0, 2225, 2225, 181, 2225, 0, 553, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0,
  0, 0, 0, 198, 2633, 2225, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 0, 598, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 28672, 0, 0, 0, 2225, 2225, 2658, 2225, 2660, 2225, 2225, 2225, 2225, 2225, 2225, 2666, 2225, 2667, 621, 621,
  2225, 2225, 2692, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 654, 655, 0, 0, 0, 0, 0, 318, 9216, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 61440, 2225, 2743, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 703, 0,
  0, 0, 0, 0, 0, 0, 2225, 2225, 0, 211, 2266, 2266, 2266, 2225, 0, 0, 2266, 0, 2266, 2225, 2225, 2266, 2266, 2266, 2266,
  2266, 0, 2266, 2266, 2266, 2225, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 558, 0, 2225, 2225, 201, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 2225, 2266, 2266, 2266, 2266, 2266, 2225, 2266, 0,
  0, 0, 2266, 2266, 0, 2266, 2266, 2266, 2266, 2266, 2266, 2266, 2266, 2266, 2225, 2266, 2266, 2266, 2266, 2266, 0,
  2266, 2266, 2266, 2344, 2344, 2344, 2344, 2344, 2344, 2266, 2266, 0, 2424, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 318, 319, 0, 0, 0, 0, 0, 339, 2225, 2225, 342, 0, 0, 0, 0, 2225, 2225, 2225, 2574, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2574, 2225, 2225, 0, 185, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225,
  2240, 0, 0, 0, 0, 0, 396, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47104, 0, 0, 0, 47104, 185, 2267, 0, 2267, 2225, 2225,
  2267, 2267, 2267, 2267, 2310, 0, 2310, 2310, 2310, 2225, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 56320, 0, 0, 2225, 2225, 0,
  0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 607, 2225, 2267, 2310, 2267, 2267, 2267, 2225, 2267, 0, 0, 0, 2267, 2267, 0,
  2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2225, 2267, 2267, 2267, 2267, 2267, 0, 2267, 2267, 2337, 0,
  2267, 2267, 2267, 2345, 2354, 2359, 2359, 2354, 2362, 2310, 2267, 0, 0, 0, 0, 0, 405, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 399, 2225, 2225, 2564, 2225, 0, 0, 0, 0, 0, 0, 5643, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2538, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2627, 2225, 2225, 2225, 2225, 2225, 2225, 2657,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 621, 621, 0, 0, 659, 0, 0, 0, 0, 0, 2225, 667,
  667, 604, 2225, 2225, 0, 2225, 2248, 202, 0, 0, 0, 0, 0, 0, 193, 0, 0, 2225, 2248, 2225, 100352, 103424, 0, 0, 0, 0,
  0, 0, 2225, 713, 713, 2225, 0, 2225, 2225, 2225, 2779, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0,
  5120, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2428, 2225, 181, 0, 0, 755, 0, 0, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 2225, 2225, 2815, 0, 0, 0, 0,
  0, 0, 0, 0, 2225, 0, 2225, 2225, 181, 0, 0, 0, 0, 0, 0, 181, 181, 181, 0, 0, 0, 0, 0, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 194, 0, 181, 0, 0, 2225, 2225, 2225, 2225, 0, 721, 0, 2225, 2225, 2225, 2225, 0, 2225, 2225, 2282,
  2225, 2282, 2282, 2282, 2282, 2282, 2319, 2225, 0, 0, 2268, 0, 2268, 2225, 2225, 2268, 2268, 2268, 2268, 2268, 0,
  2268, 2268, 2268, 2225, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 53248, 0, 0, 559, 2225, 2225, 0, 0, 2225, 0, 2225, 181, 0, 0, 0,
  2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2452, 2225, 2268, 2268, 2268, 2268, 2268, 2225, 2268, 0, 0, 0,
  2268, 2268, 0, 2268, 2268, 2268, 2268, 2268, 2268, 2268, 2268, 2268, 2225, 2268, 2268, 2268, 2268, 2268, 0, 2268,
  2268, 2268, 2346, 2346, 2360, 2360, 2346, 2360, 2268, 2268, 0, 114865, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2545, 0, 0, 0, 0, 685, 0, 2225, 2225, 2225, 0, 0, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2665, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 772, 2225, 0, 2225, 2225, 776, 0,
  181, 0, 0, 2225, 2225, 2225, 107697, 107520, 181, 0, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 593, 0, 0, 0, 0, 0,
  0, 0, 0, 2225, 713, 713, 2225, 0, 2225, 2225, 2225, 197, 2225, 2225, 0, 0, 0, 0, 0, 197, 0, 0, 197, 0, 2225, 2225,
  2225, 2225, 2694, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 181, 240, 2225, 0,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2311, 0, 2311, 2311, 2311, 2225, 0, 0, 0, 0, 0, 504, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 21504, 0, 0, 251, 0, 0, 2225, 2225, 2311, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 2225, 2225, 0, 2225, 2225,
  2778, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 6551, 409, 409, 6665, 5643, 2225, 2225, 2225,
  2225, 2225, 0, 335, 0, 0, 0, 0, 2388, 2225, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2721, 2225, 2225, 2225, 2225, 2225,
  2225, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 113841, 405, 0, 410, 410, 2225, 2388, 2225, 2225, 0, 0, 2225, 2225,
  0, 0, 0, 2225, 2225, 457, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2664, 2225, 2225, 2225, 2225,
  2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2588, 2225,
  2225, 0, 68608, 0, 0, 0, 0, 0, 2225, 68785, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2699, 652, 0, 0, 0,
  0, 0, 0, 0, 0, 40960, 41229, 0, 0, 0, 0, 0, 41229, 0, 41229, 41229, 41229, 0, 0, 41229, 0, 0, 2225, 2634, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 0, 0, 0, 0, 2225, 2225, 0, 0, 603, 0, 0, 604, 5643, 2225, 2225, 112817, 2225, 0, 0,
  0, 0, 0, 0, 0, 507, 0, 510, 0, 0, 0, 0, 0, 0, 0, 0, 35840, 0, 0, 0, 0, 0, 0, 0, 35840, 2225, 2225, 93361, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 0, 93184, 0, 0, 0, 0, 0, 0, 0, 26624, 26624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 0,
  26624, 26624, 26624, 0, 0, 98304, 0, 0, 0, 744, 0, 0, 97457, 405, 405, 2796, 0, 2225, 2225, 2225, 2225, 2225, 2695,
  2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 115889, 2225, 0, 768, 0, 0, 0, 115712, 0, 0,
  2225, 774, 2823, 73905, 181, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 0, 0, 0, 0, 0, 0, 0, 0, 91136, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 91313, 0, 0, 0, 0, 0,
  438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47104, 0, 0, 47104, 809, 181, 0, 0, 2225, 2225, 2225, 2225, 0, 181, 0, 2225,
  2225, 2225, 2225, 0, 0, 0, 0, 0, 92160, 0, 2225, 2225, 2225, 2225, 2225, 92337, 2225, 2225, 2280, 2225, 2225, 2269,
  2280, 2280, 2225, 2225, 241, 2225, 2225, 241, 0, 241, 241, 2269, 0, 2269, 2225, 2225, 2308, 2308, 2308, 2308, 2308, 0,
  2308, 2308, 2308, 2225, 0, 0, 0, 0, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27648, 0, 0, 0, 0, 2225, 2325, 2308, 2325,
  2325, 2325, 2225, 2325, 0, 0, 0, 2325, 2325, 0, 2325, 2325, 2325, 2325, 2325, 2325, 2325, 2325, 2325, 2225, 2325,
  2325, 2325, 2325, 2325, 0, 2325, 2325, 2338, 0, 2325, 2325, 2339, 2347, 2355, 2355, 2355, 2355, 2363, 2308, 2325, 0,
  0, 0, 0, 0, 662, 0, 0, 2225, 0, 0, 0, 2225, 2225, 0, 2225, 0, 0, 0, 0, 556, 69632, 2225, 0, 112640, 0, 0, 0, 0, 2608,
  2225, 0, 0, 0, 0, 0, 505, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121856, 121856, 0, 0, 121856, 121856, 5560, 181, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 2225, 0, 451, 0, 0, 0, 0, 0, 686, 2225, 2225, 2225, 0, 0, 2225, 2225, 2225, 2225, 2741, 0, 0, 742,
  0, 0, 0, 0, 2225, 405, 405, 2225, 0, 2225, 2225, 2225, 2225, 2266, 2225, 2225, 2225, 2225, 0, 2225, 2225, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 205, 2225, 2225, 2225, 334, 0, 0, 0, 0, 0, 2225, 2389, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2388, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2474, 2225, 2225, 2225, 2225, 2745, 100529, 2225, 2225, 2225, 2225, 2225, 0,
  0, 0, 0, 706, 2225, 2225, 0, 355, 0, 0, 0, 0, 360, 2225, 2411, 2225, 2225, 2225, 2225, 2416, 405, 0, 0, 0, 2225, 2225,
  2416, 2389, 0, 0, 2225, 2389, 0, 0, 0, 2225, 2416, 2411, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 197,
  0, 0, 2411, 2225, 2225, 2225, 2416, 2389, 2225, 2225, 2411, 2225, 2225, 2225, 2225, 2416, 2476, 2477, 2225, 2411,
  2225, 2225, 2416, 2476, 2411, 2225, 2225, 2411, 2225, 2225, 2225, 318, 319, 0, 0, 0, 0, 0, 745, 0, 2225, 0, 0, 2225,
  0, 2225, 2225, 2225, 2225, 2268, 2225, 2225, 2225, 2225, 0, 2225, 2225, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 2225, 2254,
  2257, 0, 0, 0, 660, 0, 0, 0, 0, 2225, 0, 0, 0, 2225, 2225, 0, 2225, 2777, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 0, 0, 0, 680, 0, 70833, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0,
  0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 106673, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225,
  2225, 0, 0, 2225, 2225, 2225, 2256, 0, 0, 0, 186, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0,
  358, 0, 0, 2225, 2225, 2225, 2225, 2414, 2225, 2225, 0, 0, 0, 196, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2225, 2225, 2256, 196, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 196, 0, 2225, 2225, 2225, 2450, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2484, 2485, 318, 319, 0, 2225, 2225, 2286, 2225, 2270, 2225, 2225, 2225, 2225, 186, 2225, 2225, 186,
  0, 186, 259, 2270, 0, 2270, 2225, 2225, 2270, 2270, 2270, 2270, 2312, 0, 2312, 2312, 2312, 2225, 0, 0, 0, 181, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 2225, 2270, 2312, 2270, 2270, 2270, 2331, 2270, 287, 287, 287, 2270, 2270, 287,
  2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2336, 2270, 2270, 2270, 2270, 2270, 287, 2270, 2270, 2270, 2348,
  2356, 2356, 2356, 2356, 2356, 2364, 2365, 0, 388, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 256, 0, 0, 0, 0, 0,
  2425, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2831, 2225, 2225, 2225,
  2225, 2225, 2225, 0, 2225, 2468, 2425, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  318, 319, 0, 2225, 2225, 2425, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2483, 2225, 2225, 318, 319, 0, 0, 0, 0, 0,
  10240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 265, 0, 0, 0, 265, 2529, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2539, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2426, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 517,
  2225, 0, 2225, 2225, 181, 2225, 2225, 2681, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2786, 2225, 0, 0, 657, 658, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 2225, 2225, 0, 2225, 0, 0, 0, 181, 0, 0, 0, 0, 0,
  0, 0, 330, 331, 0, 2225, 2578, 2225, 2225, 2225, 2225, 2225, 2225, 2583, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2750, 0, 0, 0, 0, 0, 0, 0, 0, 0, 709, 710, 0, 0, 2225, 0, 0, 2225, 0, 2225, 2225, 2225, 2461, 2396,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2396, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 318, 319, 0,
  787, 0, 0, 0, 2225, 0, 2225, 181, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2267, 2225, 2225, 2240, 2225, 185, 2225, 2240,
  185, 0, 185, 185, 0, 0, 2225, 2649, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 0, 0, 2225, 2225, 0, 0, 0, 2225,
  2225, 2225, 2225, 67761, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2575, 2225,
  0, 2271, 0, 2271, 2225, 2225, 2271, 2271, 2271, 2271, 2271, 0, 2271, 2271, 2271, 2225, 0, 0, 0, 181, 0, 0, 0, 0, 0, 0,
  329, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 410, 2225, 2225, 2225, 2225, 0, 2225, 2225, 2225, 2352, 2352, 2352, 2352,
  2352, 2352, 2225, 2225, 0, 2225, 2271, 2271, 2271, 2271, 2271, 2225, 2271, 0, 0, 0, 2271, 2271, 0, 2271, 2271, 2271,
  2271, 2271, 2271, 2271, 2271, 2271, 2225, 2271, 2271, 2271, 2271, 2271, 0, 2271, 2271, 2271, 2271, 2271, 2271, 2271,
  2271, 2271, 2271, 2271, 0, 2225, 0, 5120, 5120, 181, 0, 0, 0, 326, 0, 0, 0, 0, 0, 0, 2381, 0, 0, 0, 2413, 2225, 2381,
  2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 2396, 2225, 2225, 405, 0, 5120, 5120, 2413, 2225, 2225, 2225,
  0, 0, 2225, 2225, 0, 0, 0, 2225, 2429, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 0, 0, 2225, 2225, 2225,
  2225, 2225, 2225, 2413, 2413, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2413, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2625, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2541, 2225, 2225, 2225, 2225,
  2225, 2381, 2413, 2225, 2225, 2225, 2381, 2225, 2481, 2381, 2413, 2225, 2225, 318, 319, 5120, 2225, 2225, 564, 0, 0,
  0, 0, 0, 0, 2616, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2540, 2225, 2225, 2225, 2225, 2225, 0,
  0, 2225, 2225, 0, 0, 0, 0, 0, 0, 5120, 2225, 95409, 2225, 2654, 0, 0, 0, 0, 0, 26624, 0, 0, 26624, 0, 26624, 0, 26624,
  0, 26624, 26624, 0, 26624, 26624, 26624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 0, 752, 82097, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 0, 81920, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 214, 2269, 2269, 2269, 2225, 0,
  2225, 2719, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 82591, 0, 0, 0, 0, 0, 0, 0, 0, 43008, 0, 0, 0, 0, 0, 0, 0,
  0, 43294, 0, 0, 0, 0, 0, 43294, 0, 682, 0, 0, 0, 0, 2225, 2225, 2225, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2698, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 514, 0, 0, 0, 337, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 2225,
  2225, 2225, 2545, 0, 0, 0, 5120, 0, 0, 0, 2572, 2573, 2225, 2225, 2225, 2621, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 318, 319, 5440, 0, 0, 400, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0,
  2225, 2225, 0, 0, 0, 346, 0, 2225, 2225, 2225, 405, 0, 0, 0, 2225, 2225, 2225, 2225, 0, 0, 2463, 2225, 0, 0, 0, 2225,
  2430, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 0, 0, 2225, 2225, 2225, 2740, 2225, 2225, 2225, 0, 78848,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 319, 0, 0, 0, 0, 79025, 2225, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 0,
  0, 0, 0, 566, 0, 0, 2225, 2225, 2225, 2225, 2618, 2225, 2225, 0, 0, 0, 684, 0, 0, 2225, 2225, 2225, 0, 0, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2748, 2749, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0,
  0, 187, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121856, 0,
  0, 0, 0, 0, 0, 121856, 2225, 2281, 2225, 2225, 2225, 2281, 2281, 2247, 2247, 242, 2247, 2247, 242, 0, 242, 242, 2225,
  0, 2225, 2225, 2225, 2281, 2281, 2281, 2281, 2281, 0, 2281, 2281, 2281, 2225, 0, 0, 0, 181, 0, 0, 0, 0, 0, 328, 0, 0,
  0, 0, 2225, 0, 2225, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2780, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0,
  0, 410, 410, 410, 0, 5643, 2225, 2225, 2225, 2225, 2225, 2225, 2326, 2281, 2326, 2326, 2326, 2225, 2326, 0, 0, 0,
  2326, 2326, 0, 2326, 2326, 2326, 2326, 2326, 2326, 2326, 2326, 2326, 2225, 2326, 2326, 2326, 2326, 2326, 0, 2326,
  2326, 2340, 2326, 2340, 2340, 2340, 2340, 2340, 2281, 2326, 0, 0, 0, 327, 2225, 2225, 2225, 2449, 2450, 0, 0, 0, 0, 0,
  0, 2225, 2225, 0, 0, 344, 0, 347, 2225, 2225, 2398, 405, 0, 0, 0, 2225, 2225, 2225, 2225, 0, 0, 2225, 2225, 0, 0, 417,
  2466, 2225, 2225, 2590, 2225, 2225, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31744, 0, 0, 0, 0, 0, 0, 683, 0, 0, 0, 2225,
  2225, 2225, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 116913, 2225, 2225, 677, 677, 0, 0, 0, 2767, 101553,
  2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 2225, 2225, 2225, 2275, 0, 66560, 66737, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 704, 0, 0, 181, 0, 0, 0, 756, 0, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2813, 2814, 2225, 2225, 0, 0, 0, 769, 770, 0, 0, 405, 2821, 0, 2225, 2225, 181, 0, 0, 0,
  0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 104625, 2225, 0, 0, 0, 181, 0, 0, 0, 0, 327, 0, 0, 0, 0, 0,
  2225, 52401, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 195, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 203, 2225, 2225, 2225, 2225, 2225, 353, 0, 356, 0, 0, 359, 0, 2409, 2225, 2412, 2225, 2225, 2415, 2225, 0, 0, 0,
  181, 0, 0, 325, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 2225, 0, 2225, 2225, 2799, 2225, 2417, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2432, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 512, 0, 0, 0, 0, 0, 0, 0, 6551, 6551,
  0, 522, 0, 0, 0, 0, 0, 0, 0, 0, 15360, 18432, 22528, 25600, 29696, 33792, 0, 0, 2225, 2472, 2473, 2225, 2225, 2225,
  2472, 76140, 2225, 2472, 2473, 2225, 2225, 318, 319, 0, 0, 0, 0, 0, 35840, 35840, 0, 0, 0, 0, 0, 35840, 35840, 0,
  35840, 0, 35840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 604, 0, 0, 0, 0, 0, 467, 0, 0, 0, 471, 0, 0, 473, 2522, 2225, 2225,
  2225, 2526, 2225, 2225, 2528, 2225, 552, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 343, 0, 0, 0, 2225,
  2225, 2225, 0, 600, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 0, 0, 0, 357, 0, 0, 0, 2225, 2225, 2225,
  2413, 2225, 2225, 2225, 2529, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2537, 2225, 2225,
  2225, 2225, 2543, 2225, 2225, 0, 0, 0, 743, 0, 0, 0, 2225, 0, 0, 2225, 0, 2225, 2225, 2225, 2225, 2271, 2225, 2225,
  2225, 2225, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 597, 0, 0, 0, 0, 0, 0, 2225, 790, 2839, 181, 0, 0, 0, 0,
  2225, 2225, 2225, 2225, 2421, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 74752, 0, 0, 0, 0,
  2225, 2225, 2225, 2282, 2225, 2225, 2282, 2282, 2282, 2225, 2225, 243, 2225, 2225, 248, 0, 243, 248, 243, 2282, 0,
  2282, 2225, 2225, 2282, 2282, 2282, 2282, 2282, 0, 2319, 2282, 2282, 2225, 0, 0, 0, 181, 0, 324, 0, 0, 0, 0, 0, 0, 0,
  0, 2225, 0, 0, 2225, 716, 2765, 2225, 2225, 2225, 2225, 2319, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 2225, 2225, 0,
  2225, 2225, 0, 0, 2225, 0, 2225, 802, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 2427, 2225, 0, 0, 336,
  0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2659, 2225, 2225, 2225, 2225, 2225, 2225, 69809, 2225, 78001,
  2225, 621, 621, 453, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 2511, 2225, 2225, 2225, 2225, 2422, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 0, 0, 6144, 6144, 6144, 0, 5643, 2225, 2225, 2225, 2225, 2225, 0, 0, 391, 0, 395, 0, 0,
  391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16650, 0, 0, 0, 0, 0, 16650, 405, 0, 0, 0, 2225, 2225, 2225, 2462, 0, 0, 2225, 2464,
  0, 0, 0, 2225, 2504, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2833, 2225, 2225, 2225, 2225, 0, 2225, 2225, 0,
  0, 71680, 0, 0, 0, 567, 2225, 2225, 71857, 2225, 2225, 2225, 2619, 0, 0, 0, 624, 105472, 0, 2225, 0, 0, 0, 0, 0, 0, 0,
  0, 105649, 2225, 2225, 2720, 2225, 2225, 2722, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 0, 0, 5643, 2225, 2225, 2225,
  2225, 2225, 0, 0, 0, 708, 0, 0, 0, 0, 2225, 0, 0, 2225, 0, 2225, 2225, 2225, 2693, 2225, 2225, 2225, 2225, 2225, 2225,
  0, 0, 0, 0, 0, 656, 0, 0, 0, 0, 188, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 565, 0, 0, 0, 2225,
  2225, 2225, 2617, 2225, 2225, 2225, 2225, 2533, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 677,
  677, 0, 0, 0, 2225, 2283, 2225, 2257, 2272, 2283, 2283, 2225, 2254, 244, 2254, 2254, 244, 0, 244, 244, 2272, 0, 2272,
  2225, 2225, 2309, 2309, 2309, 2309, 2309, 0, 2309, 2309, 2309, 2225, 0, 0, 0, 181, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2225, 666, 667, 604, 2225, 2225, 0, 2225, 2225, 2327, 2309, 2327, 2327, 2327, 2225, 2327, 0, 0, 0, 2327, 2327, 0,
  2327, 2327, 2327, 2327, 2327, 2327, 2327, 2327, 2327, 2225, 2327, 2327, 2327, 2327, 2327, 0, 2327, 2327, 2341, 2350,
  2357, 2357, 2357, 2357, 2357, 2309, 2327, 0, 0, 0, 455, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2409, 2472, 76140, 2473, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2425, 2225, 2225, 2225, 2225, 2225,
  2225, 0, 0, 0, 0, 0, 0, 771, 0, 2225, 0, 2225, 2225, 181, 2225, 499, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 257, 0,
  0, 528, 2577, 2225, 2225, 2225, 2580, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2587, 2225, 0, 0, 0, 555, 0, 0,
  2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 345, 0, 2225, 2225, 2225, 2589, 2587, 2225, 2577, 2577, 318, 0, 0, 0, 0,
  0, 547, 0, 0, 108544, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 2599, 0, 0, 0, 0, 0,
  0, 108721, 557, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 49329, 0, 0, 72704, 0, 0, 0,
  72881, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 667, 667, 604, 81073, 2716, 0, 2225, 0, 0, 0, 0, 661, 0, 0, 0, 2225, 0, 0, 0,
  2225, 2225, 0, 2225, 0, 0, 501, 0, 0, 0, 0, 0, 509, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 714, 713, 2225, 0, 2225, 2225, 2225,
  110592, 0, 0, 0, 0, 0, 2225, 2225, 2225, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2480, 2225, 2225, 2225, 2225,
  2225, 318, 319, 0, 0, 0, 0, 0, 2225, 0, 2225, 181, 0, 0, 87040, 0, 2225, 2225, 2225, 2225, 2429, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 318, 319, 0, 2225, 2225, 0, 0, 87217, 0, 2225, 181, 0, 0, 0, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2536, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2414, 2225, 2225, 2225,
  2225, 0, 0, 0, 0, 193, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 2225, 2225, 2225, 2225, 2284, 2225, 2225, 2225,
  2284, 2284, 2248, 2248, 245, 2248, 2248, 245, 0, 245, 245, 2225, 0, 2225, 2225, 2225, 2284, 2284, 2284, 2284, 2284, 0,
  2284, 2284, 2284, 2225, 0, 0, 554, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 0, 0, 0, 2225, 2397, 2225, 2225,
  2328, 2284, 2328, 2328, 2328, 2225, 2332, 0, 0, 0, 2328, 2332, 0, 2328, 2328, 2328, 2328, 2328, 2332, 2328, 2328,
  2332, 2225, 2328, 2328, 2332, 2332, 2332, 0, 2332, 2332, 2342, 2351, 2358, 2358, 2358, 2358, 2358, 2284, 2332, 0,
  2399, 2225, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2784, 2225, 2225, 2225, 0, 0,
  0, 0, 0, 393, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 438, 319, 0, 0, 181, 0, 0, 0, 0, 445, 0, 0, 0, 0, 0, 2225, 0, 0,
  452, 0, 454, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2624, 2225, 2225, 2225, 2628,
  2225, 2225, 2225, 2225, 0, 468, 0, 0, 0, 90112, 0, 0, 2225, 2523, 2225, 2225, 2225, 90289, 2225, 2225, 0, 0, 2225,
  89088, 89265, 181, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2724, 2225, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 184, 0, 2546, 0, 0, 0, 502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117760, 117760, 0, 2225, 90610,
  2225, 2225, 0, 405, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2697, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 599, 2225, 2578, 2225, 90610, 90289, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 2225,
  2611, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2783, 2225, 2225, 2225, 2225, 0, 0, 2225,
  2225, 587, 0, 0, 0, 0, 0, 592, 0, 594, 0, 0, 0, 0, 0, 0, 0, 0, 43008, 0, 0, 0, 43008, 0, 0, 0, 0, 0, 43008, 2656,
  2225, 2225, 2225, 2225, 2661, 2225, 2663, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 0, 0, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2690, 0, 0, 707, 0, 0, 0, 0, 88064, 2225, 0, 0, 2225, 0, 2225, 2225, 65713, 0, 741, 0, 0, 0,
  0, 0, 2225, 0, 0, 2225, 0, 2225, 2225, 2225, 74929, 181, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 64689,
  2225, 2225, 2225, 2744, 2225, 2225, 2746, 2225, 2225, 2225, 2225, 0, 0, 0, 705, 0, 2225, 2225, 2225, 64512, 0, 0, 0,
  0, 0, 0, 405, 2225, 0, 2225, 2225, 181, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2812, 2225, 2225, 0,
  0, 2225, 0, 2225, 181, 50176, 0, 0, 50353, 2225, 2225, 2225, 2225, 2225, 2225, 2535, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2433, 0, 387, 0, 0, 0, 779, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 111793, 2225, 0, 0, 0, 0, 0, 0, 0, 508, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62721, 0, 0, 0, 0, 0, 62721, 0, 62721,
  62721, 62721, 0, 0, 62721, 0, 0, 0, 111616, 0, 0, 2837, 0, 2225, 181, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2429, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 677, 677, 679, 0, 0, 0, 0, 392, 0, 0, 0, 0, 392, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 2225, 2461, 2396, 2225, 0, 0, 2225, 2225, 0, 0, 0, 2225,
  2225, 0, 0, 0, 0, 0, 0, 5120, 2225, 2225, 2225, 2225, 0, 635, 0, 0, 2225, 2685, 2225, 2225, 2225, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 86193, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 318, 319, 0, 0, 441, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 0, 0, 0, 0, 0, 470, 0, 0, 0, 0, 2225, 2225,
  2225, 2525, 2225, 2225, 2225, 2225, 2430, 2225, 2225, 2410, 2225, 2225, 2225, 2225, 2225, 2430, 2225, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 318, 319, 0, 2225, 0, 500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258, 0, 0, 2563, 2225,
  2225, 2225, 0, 519, 0, 0, 0, 0, 0, 2225, 2225, 2574, 2225, 2574, 2225, 2285, 2225, 2225, 2273, 2285, 2285, 2225, 2225,
  246, 2225, 2225, 246, 0, 246, 246, 2273, 0, 2273, 2225, 2225, 2285, 2285, 2285, 2285, 2285, 0, 2320, 2320, 2320, 2225,
  0, 0, 5300, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 0, 0, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2273, 2320, 2273,
  2273, 2273, 2225, 2273, 0, 0, 0, 2273, 2273, 0, 2273, 2273, 2273, 2273, 2273, 2273, 2273, 2273, 2273, 2225, 2273,
  2273, 2273, 2273, 2273, 0, 2273, 2273, 2320, 2273, 2320, 2320, 2320, 2320, 2320, 2320, 2273, 0, 2225, 2691, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 0, 653, 0, 0, 0, 0, 0, 0, 0, 30720, 30720, 0, 30720, 0, 0, 0, 0, 0, 0, 0,
  0, 2760, 0, 0, 2225, 0, 2225, 2225, 2225, 0, 0, 0, 94385, 2225, 0, 0, 0, 0, 0, 0, 2225, 2225, 2225, 2225, 2225, 2225,
  2424, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 386, 0, 0, 0, 0, 0, 338, 0, 2225, 2225, 0, 0, 0, 0, 0, 2225, 2225,
  2225, 2768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2225, 2225, 0, 0, 2225, 2225, 2225, 2274, 0, 2225, 2225, 354, 0, 0, 0, 0, 0,
  0, 2410, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2427, 2225, 2431, 2225, 2225, 0, 0, 0, 0, 0, 394, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19456, 19456, 0, 2225, 2848, 801, 0, 2225, 0, 2225, 181, 0, 0, 0, 2225, 2225, 2225,
  2225, 2225, 2225, 2470, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 318, 319, 0, 0, 0,
  117760, 117760, 117760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 0, 117760, 0, 117760, 117760,
  117760, 117760, 0, 117760, 117760, 117760, 117760, 117760, 0, 0, 0, 0, 0, 0, 117760, 0, 117760, 117760, 117760, 0, 0,
  0, 0, 0, 0, 0, 2225, 2225, 0, 215, 2270, 2270, 2270, 2225, 0, 117760, 117760, 117760, 117760, 117760, 117760, 0,
  117760, 117760, 117760, 117760, 117760, 117760, 117760, 117760, 0, 0, 0, 0, 0, 116736, 2225, 0, 0, 0, 628, 0, 80896,
  0, 0, 2225, 2225, 0, 0, 0, 0, 0, 0, 0, 2653, 2225, 2225, 2225, 0, 0, 0, 0, 0, 591, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20480,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258, 0, 258, 258, 0, 0, 0, 0, 0, 119054, 0, 0, 0, 119054, 0, 118784, 118784,
  119054, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 119054, 119054, 0, 0, 0, 0, 0, 119054, 0, 119054, 119054, 119054, 0, 0,
  119054, 0, 0, 0, 0, 0, 0, 746, 2225, 0, 0, 2225, 0, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 2225, 2225,
  2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 2225, 0, 2225, 2225, 0, 0, 0, 0, 121856, 0, 121856, 0, 0, 0, 121856,
  0, 0, 0, 121856, 0, 0, 121856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 121856, 0, 0, 121856, 0,
  121856, 121856, 121856, 121856, 0, 121856, 121856, 0, 0, 0, 0, 121856, 0, 0, 0, 0, 0, 0, 121856, 0, 121856, 121856,
  121856, 0, 121856, 0, 0, 121856, 121856, 121856, 121856, 121856, 121856, 0, 0, 122880, 122880, 122880, 122880, 122880,
  0, 122880, 122880, 0, 0, 122880, 122880, 0, 122880, 0, 0, 0, 0, 0, 0, 122880, 122880, 122880, 0, 0, 0, 0, 0, 122880,
  122880, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 122880, 122880, 0, 0, 0, 4096,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30720, 30720, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  815, 819, 835, 835, 835, 835, 893, 873, 826, 830, 846, 835, 835, 822, 859, 833, 839, 843, 834, 850, 856, 863, 866,
  852, 872, 877, 880, 890, 868, 897, 901, 883, 886, 905, 909, 918, 914, 912, 922, 926, 930, 934, 936, 940, 947, 951,
  1054, 1681, 1054, 1049, 1054, 1050, 1052, 1054, 1050, 1003, 1003, 1003, 1003, 1052, 1054, 1054, 956, 960, 1692, 1003,
  972, 1049, 993, 1003, 976, 1692, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 984, 950, 1054, 1549, 1053, 1692, 1053,
  1692, 1003, 1054, 1054, 1003, 1003, 1003, 1003, 1003, 1003, 1053, 1054, 1054, 1054, 1003, 992, 1000, 1003, 1050, 1003,
  1003, 1003, 1003, 984, 951, 1054, 1053, 1692, 1054, 1049, 1052, 1054, 1050, 1003, 1003, 1003, 1003, 1003, 1052, 1054,
  1054, 1054, 1049, 991, 1000, 1051, 1003, 1003, 1003, 1005, 1054, 1693, 1054, 1692, 1051, 1692, 1003, 1003, 1003, 1003,
  1052, 1054, 1054, 1054, 997, 978, 1003, 1003, 1004, 951, 1054, 1049, 1048, 1003, 1003, 1003, 1051, 1054, 1054, 1054,
  1009, 1050, 1003, 1492, 1054, 1049, 1050, 1003, 1003, 1052, 1054, 1692, 1010, 1003, 951, 1049, 1003, 1003, 1051, 1054,
  1200, 1447, 1054, 1050, 1003, 1051, 965, 979, 1054, 1003, 1052, 979, 1692, 1003, 1477, 1003, 1445, 1051, 1054, 1194,
  1014, 1229, 1054, 1054, 1402, 1033, 1018, 1020, 1024, 1028, 1032, 1594, 943, 1047, 1037, 1044, 1059, 1040, 1063, 1067,
  1071, 1076, 1102, 1083, 1087, 1091, 1095, 1099, 1112, 1115, 1133, 1079, 1119, 1126, 1130, 1122, 1137, 1144, 1141,
  1148, 1151, 1155, 1054, 1689, 1054, 1054, 1054, 1054, 1747, 1183, 1668, 1054, 1054, 1054, 1540, 1188, 1054, 1551,
  1054, 1400, 1054, 1162, 1054, 1054, 1254, 1054, 1054, 1054, 1223, 1176, 1054, 963, 1054, 1055, 1054, 1054, 1054, 1054,
  1688, 1054, 1054, 1054, 1054, 1355, 1181, 1523, 1054, 1054, 1054, 1054, 1207, 1187, 1054, 1054, 1552, 1054, 1398,
  1192, 1054, 1054, 1054, 1054, 1054, 964, 1054, 1054, 1054, 1054, 1690, 1054, 1054, 1054, 1356, 1182, 1054, 1054, 1054,
  1054, 1207, 1187, 1054, 1054, 1551, 1054, 1054, 1599, 1054, 1054, 1054, 1054, 962, 1054, 1054, 1265, 1691, 1054, 1054,
  1181, 1451, 1054, 1715, 1187, 1054, 1054, 1551, 1054, 1054, 1400, 1054, 1054, 963, 1054, 1054, 1690, 1054, 1768, 1054,
  1717, 1552, 1054, 1550, 1054, 1054, 1400, 1054, 962, 1054, 1725, 1054, 1768, 1716, 1198, 1054, 1551, 1054, 1400, 1054,
  1054, 1690, 1204, 1718, 1054, 1550, 1054, 1401, 1265, 1364, 1217, 1221, 1054, 1400, 1265, 1766, 1219, 1399, 1265,
  1227, 1221, 1763, 1221, 1233, 1239, 1054, 1054, 1054, 965, 1247, 1054, 1054, 1253, 1054, 1054, 1054, 1468, 1363, 1054,
  1329, 1534, 1259, 1072, 1269, 1248, 1054, 1054, 1275, 952, 1750, 1753, 1279, 1756, 1105, 1286, 1290, 1293, 1301, 1306,
  1297, 1312, 1312, 1302, 1312, 1296, 1310, 1316, 1320, 1324, 1054, 1261, 1248, 967, 1165, 1392, 1054, 1054, 1333, 1235,
  1334, 1222, 1054, 1108, 1514, 1580, 1338, 963, 1054, 1054, 1343, 1713, 1054, 1338, 1349, 1054, 1691, 1729, 1347, 1375,
  1353, 1249, 1360, 1368, 1372, 1054, 965, 1247, 966, 1386, 1391, 1054, 1054, 1494, 1334, 1421, 1334, 1222, 1054, 1107,
  964, 1515, 1581, 964, 1054, 1600, 1552, 1054, 1591, 1727, 1396, 1449, 1054, 1407, 1411, 1054, 1262, 966, 1386, 1168,
  1054, 1054, 1496, 1420, 1497, 1222, 1054, 1107, 964, 1514, 1580, 1482, 1054, 1398, 1425, 1054, 1591, 1429, 1489, 1054,
  1434, 1054, 1263, 968, 1442, 1054, 1537, 1537, 1054, 1107, 964, 1514, 1700, 964, 1054, 1456, 1271, 1430, 980, 1254,
  1437, 1516, 1387, 1553, 1465, 1054, 1597, 1054, 1472, 964, 1054, 1456, 1428, 1476, 1459, 1503, 1387, 1554, 1054, 963,
  1514, 1481, 1054, 1551, 1486, 1501, 1507, 1054, 1054, 1054, 1264, 1054, 1428, 951, 1508, 1054, 1054, 1264, 1427, 1513,
  1691, 1054, 1427, 1513, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1242, 1512, 1054, 1513, 1339,
  1438, 1325, 1520, 1531, 1054, 1544, 1210, 1548, 1561, 1770, 1558, 1054, 1565, 1568, 1585, 987, 1604, 1607, 1610, 1612,
  1616, 1627, 1620, 1637, 1624, 1634, 1631, 1644, 1648, 1651, 1655, 1640, 1659, 1663, 1054, 1054, 1054, 1243, 1327,
  1054, 1213, 966, 1706, 1054, 1381, 1054, 1667, 1054, 1670, 1675, 1669, 1674, 1679, 1054, 1362, 1571, 1054, 1461, 1437,
  1452, 1685, 1697, 1054, 1574, 1054, 1282, 1740, 1577, 1054, 1054, 1054, 1054, 1242, 1326, 1054, 1212, 1054, 1704,
  1054, 1054, 1382, 1054, 1667, 1054, 1553, 1710, 1397, 1553, 1710, 1397, 1054, 1437, 1054, 1072, 1722, 1588, 1403,
  1378, 1054, 1054, 1054, 1241, 1416, 1054, 1213, 965, 1705, 1054, 1381, 1054, 1667, 1054, 1054, 1527, 1675, 1054, 1171,
  1733, 1054, 1054, 1054, 1072, 1054, 1402, 1738, 1054, 1054, 1414, 1328, 1054, 1704, 1177, 1177, 1054, 1054, 1527,
  1675, 1054, 1172, 1734, 1054, 1054, 1054, 1403, 1739, 1054, 1327, 1054, 1706, 1054, 1054, 1526, 1734, 1054, 1172,
  1734, 1054, 1054, 1403, 1054, 1054, 1054, 1054, 1054, 1158, 1675, 1157, 1734, 1054, 1054, 1054, 1054, 1054, 1157,
  1734, 1158, 1675, 1054, 1054, 1054, 1054, 1744, 1744, 1054, 1054, 1054, 1255, 1054, 1054, 1054, 1760, 1054, 1760,
  1054, 774, 788, 900, 262916, 525060, 1049348, 536871684, 772, 772, 902, 536871686, 900, 900, 537133828, 262916,
  34079492, 525060, 525060, 33555204, 33555204, 772, 772, 772, 772, 772, 536871686, 774, 916, 537133828, 537133828,
  537395972, 33555204, 33555204, 33555204, 536871684, 772, 537133830, 774, 774, 774, 6030212, 263044, 33817348,
  33817348, 537133828, 34079492, 537395972, 100664068, 34079492, 570426116, 33555204, 267142, 787332, 772, 774,
  967197444, 782, 525062, 774, 774, 774, 788, 774, 774, 33555206, 774, 772, 1049350, 774, 774, 774, 1932249862, 263158,
  571212550, 264182, 772, 967197444, 537133828, 772, 525062, 1049350, 1073742598, 1000751878, 967197446, 774, 262918,
  525062, 537133830, 774, 321637124, 142869494, 143393782, 1932512006, 263158, -1107301628, -1107825916, -1753486588,
  214173686, 34341878, 214173686, 214173686, 214173686, 214173686, 34341878, -1107825916, 214697974, 214173686,
  571212790, -1107825914, 247728118, 214173686, 34341878, 214173686, 571212790, -1073747196, 214697974, 571212790,
  34341878, -1073747196, 248252406, 39584758, 142869494, 142869494, 142869494, 214173686, 142869494, -1073747194,
  -1107301386, 4, 67108864, 134217728, 4, 2, 768, 16, 16, 128, 0, 0, 0, -2080342016, 16384, 131072, 2097152, 25165824,
  402653184, 768, 0, 0, -2147483648, 0, 0, 0, 64, 0, 256, 536870912, 2048, 196608, 16777216, 268435456, 8388608,
  134217728, 2, 2, 0, 2, 128, 0, 2, 512, 256, 16, 32779, 4264243, 4264243, 64, 64, 64, 32, 48, 48, 2, 64, 64, 32, 32,
  48, 2, 2, 2, 2, 128, 128, 2, 64, 64, 2, 0, 8, 128, 512, 32768, 134217728, 0, 67108864, 0, 4, 512, 134217728, 0,
  67108864, 514, 67108866, 2, 4, 4, 1048576, 67108864, 0, 0, 8, 67108872, 8, 0, 67108872, 8, 327680, 67108872, 67108992,
  67108872, 4, 512, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, -1073741824, 2, 67108868, 8, 29884416, 67108996, 4, 67109000,
  67108996, 67109384, 67108998, 67108872, 67141640, 67109384, 0, 0, 8192, 0, 0, 67076096, 67117576, 67076096,
  1006648239, 134184968, 872431609, 1073758212, 1073758212, 67076104, 67076104, 1073758208, 67076104, 67076104,
  1075855364, 603986085, 1073758208, 1075855364, 1075855364, 63569928, 603986095, 63569928, 603986093, 603986095,
  1073758208, 1073758208, 1073758208, 67076096, 67076096, 0, -2105408475, 0, 0, 32768, 67108864, -2147483648,
  1073758208, 1073758212, 939538855, 1073758216, 1073758220, 1006647719, 1006648231, 1006649337, 939540479, 67076096,
  134184968, 67092480, 67076096, 134185096, 872431613, 67076096, 67076100, 67076608, 67084288, 201293824, 67076096,
  67076096, 1073758220, 67076096, 67076096, 872431615, 67076096, 67092480, 268402696, 268402824, 268402696, 1006649343,
  134184968, 268402696, 1006649343, 134184968, 268410888, 1140834308, -2080407548, -1006649340, -1006649340,
  -1006649340, -1006649340, 2080407551, 939507705, 0, 0, 1, 32, 256, 1, 32, 6144, 536870912, 1048576, 8192, 8, 0, 16384,
  0, 1, 2, 16, 32, 7168, 0, 0, 0, 8, 8388608, 16777216, 0, 65536, 262144, 0, 8388608, 50331648, 1073741824, 0, 0, 32,
  6144, 0, 0, 2, 4, 33554432, 1073741824, 0, 0, 64, 2, 8388608, 65536, 262144, 131072, 524288, 3145728, 4194304, 262144,
  0, 512, 0, 8192, 0, 65536, 262144, 1048576, 2097152, 8388608, 33554432, 0, 0, 0, 112, 1048576, 8388608, 65536,
  1048576, 67108864, 134217728, 0, 8388608, 8388608, 33554432, 0, 5, 33554432, 33554432, 0, 0, 64, 512, 131072, 0,
  16777216, 134217728, 0, 0, 0, 224, 64, 0, 0, 0, 256, 256, 134217728, 16384, 0, 0, 64, 16777216, 0, 0, 0, 65536, 0,
  1056768, 0, 0, 16384, 1048576, 42075173, 42075173, 42075173, 42075173, 134217728, 134217792, -2063560640, 0, 4, 456,
  26112, -2038266843, -2038266843, -2038266843, -2038266843, -2021485467, 0, -947743643, -2021485467, 0, 0, 444744741,
  4194304, 444744741, 444744741, 4194304, -947743643, 444744741, 444744741, 444744741, 4194304, 1048576, 444744741,
  4194304, 4194304, 444810293, 4194304, 444744741, 444744741, 444744741, 444744741, -1635597275, 445531815, -1618032921,
  -1618032657, -1618030609, -1618032921, -1617965057, -943549339, 448939045, 0, 0, 0, 2048, 0, 0, 0, 8192, 5, 32, 1024,
  131072, 8388608, -1073741824, 0, 0, 0, 262144, 18874368, 163840, 0, 96, 180224, 469762048, 0, 0, 147456, 402653184,
  409600, 8912896, 0, 0, 524288, 4194304, 8388608, 442368, 25690112, 0, 0, 1048576, 0, 0, 8388608, 232, 1792, 2048, 248,
  507904, 29360128, 12582912, 0, 7, 160, 1536, 131072, 28672, 0, 8, 0, 0, 0, 256, 536870912, 1048576, 8192, 0, 8,
  134217728, 0, 16384, 0, 16, 65536, 0, 0, 0, 2097152, 0, 0, 0, 4, 128, 8, 256, 2048, 24, 98304, 29360128, 12582912, 0,
  64, 131072, 0, 2048, 0, 131072, 33554432, 0, 1, 4, 4096, 1073741824, 0, 0, 1048576, 4194304, 4194304, 16, 65536, 8,
  256, 2048, 98304, 0, 0, 0, 4194304, 1048576, 8192, 16384, 0, 128, 0, 2, 2, 128, 262144, 0, 0, 0, 72, 0, 2097152,
  1073741824, 0, 256, 0, 0, 3145728, 3, 1024, 1, 1024, 0, 256, 0, 536870912, 16777216, 0, 67108864, 1073741824, 65536,
  0, 128, 0, 0, 0, 1073741824, -2147483648, 0, 0, 1048576, 4194304, 4194304, 65536, 0, 2, 128, 128, 0, 0, 1, 4, 32,
  1024, 131072, 128, 256, 0, 0, 16777216, 256, 0, 16777216, 1048576, 0, 0, 262144, 4194304, 0, 0, 0, 16777216, 0, 256,
  0, 4194304, 0, 262144, 0, 32768, 0, 1, 2, 32, 256, 262144, 264192, 4718592, 0, 264, 1056768, 0, 1, 1024, 131072,
  524288, 3145728, 12582912, 0, 4194304, 0, 4718592, 8192, 0, 0, 0, 1073741824, 0, 0, 0, 1, 1, 4194320, 8388608, 0,
  4456448, 64, 4980736, 264192, 8388608, 8388608, 8912896, 8, 8, 32776, 0, 312, 0, 0, 376, 12800, 0, 504, 30208, 0,
  4096, 32768, 67108864, 1073741824, 9175040, 0, 69939, 0, 12288, 0, 0, 16384, 268435456, 0, 8, 67108864, 67108864,
  -2147483648, 0, 0, 2097152, 4096, 25165824, 512, 576, 69939, 576, 69939, 1048576, 69939, 69939, 32779, 1048576,
  1048576, 69947, 69947, 69947, 69947, 4264251, 7864320, 7864320, 41544, 4297019, 320072, 3670016, 3670016, 7864320,
  102715, 364859, 4559163, 8430152, 8430152, 8430152, 8430152, 320072, 7864320, 8430152, 41544, 41544, 8126464, 8708680,
  5038664, 111483, 8692296, 12624456, 844360, 8692296, 12886600, 320072, 7864320, 12886600, 5038664, 8708680, 5038664,
  7864320, 8708680, 5038664, 5038664, 452556, 4716543, 4716543, 4716543, 13105151, 4716543, 8229179, 3990088, 8, 32768,
  0, 0, 0, 3, 304, 304, 4096, 65536, 0, 0, 3, 0, 0, 0, 1073741824, 2, 8704, 0, 0, 0, 32768, 65536, 1048576, 0, 0, 0, 2,
  0, 25088, 0, 0, 0, 32768, 67108864, 1073741824, 64, 0, 0, 16, 0, 0, 2, 48, 256, 4096, 25165824, 0, 0, 131072, 3145728,
  8388608, 33554432, 1073741824, 24576, 0, 0, 0, 65536, 1048576, 0, 4194304, 4194304, 48, 212992, 32, 256, 4096, 65536,
  0, 128, 1024, 131072, 0, 0, 0, 1, 256, 4096, 0, 524288, 12582912, 16777216, 0, -2105408475, -2080342016, 134217792,
  134217728, -989818816, -2061463488, -987721664, -2105408475, 256, 256, 0, 0, 1048576, 8388608, 1048576, 0, 8388608,
  65536, 262144, 0, 0, 576
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "%ERROR",
  "IDENTIFIER",
  "SKIP",
  "EOF",
  "INTEGER_LITERAL",
  "FLOATING_POINT_LITERAL",
  "CHARACTER_LITERAL",
  "STRING_LITERAL",
  "SINGLE_LINE_COMMENT",
  "MULTI_LINE_COMMENT",
  "'!'",
  "'!='",
  "'#'",
  "'%'",
  "'%='",
  "'&amp;'",
  "'&amp;&amp;'",
  "'&amp;='",
  "'('",
  "')'",
  "'*'",
  "'*='",
  "'+'",
  "'++'",
  "'+='",
  "','",
  "'-'",
  "'--'",
  "'-='",
  "'.'",
  "'...'",
  "'/'",
  "'/='",
  "':'",
  "';'",
  "'<'",
  "'<<'",
  "'<<='",
  "'<='",
  "'='",
  "'=='",
  "'>'",
  "'>='",
  "'>>='",
  "'>>>='",
  "'?'",
  "'@'",
  "'EOF'",
  "'IGNORE_CASE'",
  "'JAVACODE'",
  "'LOOKAHEAD'",
  "'MORE'",
  "'PARSER_BEGIN'",
  "'PARSER_END'",
  "'SKIP'",
  "'SPECIAL_TOKEN'",
  "'TOKEN'",
  "'TOKEN_MGR_DECLS'",
  "'['",
  "']'",
  "'^'",
  "'^='",
  "'abstract'",
  "'assert'",
  "'boolean'",
  "'break'",
  "'byte'",
  "'case'",
  "'catch'",
  "'char'",
  "'class'",
  "'continue'",
  "'default'",
  "'do'",
  "'double'",
  "'else'",
  "'enum'",
  "'extends'",
  "'false'",
  "'final'",
  "'finally'",
  "'float'",
  "'for'",
  "'if'",
  "'implements'",
  "'import'",
  "'instanceof'",
  "'int'",
  "'interface'",
  "'long'",
  "'native'",
  "'new'",
  "'null'",
  "'options'",
  "'package'",
  "'private'",
  "'protected'",
  "'public'",
  "'return'",
  "'short'",
  "'static'",
  "'strictfp'",
  "'super'",
  "'switch'",
  "'synchronized'",
  "'this'",
  "'throw'",
  "'throws'",
  "'transient'",
  "'true'",
  "'try'",
  "'void'",
  "'volatile'",
  "'while'",
  "'{'",
  "'|'",
  "'|='",
  "'||'",
  "'}'",
  "'~'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 1024
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 74)
    let $current := $current + 1
    let $i0 := 1024 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 3
    let $i0 := $t * 815 + $state - 1
    let $i1 := $i0 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[74 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[148 + $m]
};

(:~
 : Parse the 1st loop of production expansion_unit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expansion_unit-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(162, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'catch' | 'char' | 'double' |
                                                               'false' | 'finally' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' | '|' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: 'catch' :)
        $state
      else
        let $state := p:consume(68, $input, $state)         (: 'catch' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
        let $state := p:consume(18, $input, $state)         (: '(' :)
        let $state := p:lookahead1W(96, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ')' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 19) then                (: ')' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Name($input, $state)
            let $state := p:consume(1, $input, $state)      (: IDENTIFIER :)
            return $state
          else
            $state
        let $state := p:lookahead1W(4, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
        let $state := p:consume(19, $input, $state)         (: ')' :)
        let $state := p:lookahead1W(23, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Block($input, $state)
        return p:parse-expansion_unit-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production expansion_unit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expansion_unit-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(162, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'catch' | 'char' | 'double' |
                                                               'false' | 'finally' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' | '|' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: 'catch' :)
        $state
      else
        let $state := p:consumeT(68, $input, $state)        (: 'catch' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
        let $state := p:consumeT(18, $input, $state)        (: '(' :)
        let $state := p:lookahead1W(96, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ')' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 19) then                (: ')' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Name($input, $state)
            let $state := p:consumeT(1, $input, $state)     (: IDENTIFIER :)
            return $state
          else
            $state
        let $state := p:lookahead1W(4, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
        let $state := p:consumeT(19, $input, $state)        (: ')' :)
        let $state := p:lookahead1W(23, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Block($input, $state)
        return p:try-expansion_unit-1($input, $state)
};

(:~
 : Parse expansion_unit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expansion_unit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 18) then                           (: '(' :)
      let $state := p:lookahead2W(157, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 914) then                      (: '(' STRING_LITERAL :)
          let $state := p:lookahead3W(174, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                               '--' | '-=' | '.' | '/' | '/=' | '<' | '<<' | '<<=' |
                                                               '<=' | '=' | '==' | '>' | '>=' | '>>=' | '>>>=' | '?' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               '^' | '^=' | 'boolean' | 'byte' | 'char' | 'double' |
                                                               'false' | 'float' | 'instanceof' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'try' | 'void' | '{' | '|' | '|=' | '||' :)
          return $state
        else if ($state[$p:lk] eq 2322) then                (: '(' '(' :)
          let $state := p:lookahead3W(157, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else if ($state[$p:lk] eq 11666) then               (: '(' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] = (13074,                    (: '(' 'super' :)
                                  14226)) then              (: '(' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (146,                      (: '(' IDENTIFIER :)
                                  530,                      (: '(' INTEGER_LITERAL :)
                                  658,                      (: '(' FLOATING_POINT_LITERAL :)
                                  786,                      (: '(' CHARACTER_LITERAL :)
                                  6034,                     (: '(' 'EOF' :)
                                  6162,                     (: '(' 'IGNORE_CASE' :)
                                  6290,                     (: '(' 'JAVACODE' :)
                                  6418,                     (: '(' 'LOOKAHEAD' :)
                                  6546,                     (: '(' 'MORE' :)
                                  6674,                     (: '(' 'PARSER_BEGIN' :)
                                  6802,                     (: '(' 'PARSER_END' :)
                                  6930,                     (: '(' 'SKIP' :)
                                  7058,                     (: '(' 'SPECIAL_TOKEN' :)
                                  7186,                     (: '(' 'TOKEN' :)
                                  7314,                     (: '(' 'TOKEN_MGR_DECLS' :)
                                  10002,                    (: '(' 'false' :)
                                  11794,                    (: '(' 'null' :)
                                  13458,                    (: '(' 'this' :)
                                  13970)) then              (: '(' 'true' :)
          let $state := p:lookahead3W(136, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 50) then                      (: 'LOOKAHEAD' :)
      let $state := p:lookahead2W(69, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '=' | '[' :)
      let $state :=
        if ($state[$p:lk] eq 2354) then                     (: 'LOOKAHEAD' '(' :)
          let $state := p:lookahead3W(164, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | ',' |
                                                               '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18706                          (: '(' '(' IDENTIFIER :)
          or $state[$p:lk] = 18738                          (: 'LOOKAHEAD' '(' IDENTIFIER :)
          or $state[$p:lk] = 28050                          (: '(' 'new' IDENTIFIER :)
          or $state[$p:lk] = 67858                          (: '(' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 67890                          (: 'LOOKAHEAD' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 84242                          (: '(' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 84274                          (: 'LOOKAHEAD' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100626                         (: '(' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 100658                         (: 'LOOKAHEAD' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117010                         (: '(' '(' STRING_LITERAL :)
          or $state[$p:lk] = 117042                         (: 'LOOKAHEAD' '(' STRING_LITERAL :)
          or $state[$p:lk] = 166162                         (: '(' '(' '!' :)
          or $state[$p:lk] = 295058                         (: '(' IDENTIFIER '(' :)
          or $state[$p:lk] = 295442                         (: '(' INTEGER_LITERAL '(' :)
          or $state[$p:lk] = 295570                         (: '(' FLOATING_POINT_LITERAL '(' :)
          or $state[$p:lk] = 295698                         (: '(' CHARACTER_LITERAL '(' :)
          or $state[$p:lk] = 295826                         (: '(' STRING_LITERAL '(' :)
          or $state[$p:lk] = 297234                         (: '(' '(' '(' :)
          or $state[$p:lk] = 297266                         (: 'LOOKAHEAD' '(' '(' :)
          or $state[$p:lk] = 300946                         (: '(' 'EOF' '(' :)
          or $state[$p:lk] = 301074                         (: '(' 'IGNORE_CASE' '(' :)
          or $state[$p:lk] = 301202                         (: '(' 'JAVACODE' '(' :)
          or $state[$p:lk] = 301330                         (: '(' 'LOOKAHEAD' '(' :)
          or $state[$p:lk] = 301458                         (: '(' 'MORE' '(' :)
          or $state[$p:lk] = 301586                         (: '(' 'PARSER_BEGIN' '(' :)
          or $state[$p:lk] = 301714                         (: '(' 'PARSER_END' '(' :)
          or $state[$p:lk] = 301842                         (: '(' 'SKIP' '(' :)
          or $state[$p:lk] = 301970                         (: '(' 'SPECIAL_TOKEN' '(' :)
          or $state[$p:lk] = 302098                         (: '(' 'TOKEN' '(' :)
          or $state[$p:lk] = 302226                         (: '(' 'TOKEN_MGR_DECLS' '(' :)
          or $state[$p:lk] = 304914                         (: '(' 'false' '(' :)
          or $state[$p:lk] = 306706                         (: '(' 'null' '(' :)
          or $state[$p:lk] = 308370                         (: '(' 'this' '(' :)
          or $state[$p:lk] = 308882                         (: '(' 'true' '(' :)
          or $state[$p:lk] = 312210                         (: '(' STRING_LITERAL ')' :)
          or $state[$p:lk] = 313650                         (: 'LOOKAHEAD' '(' ')' :)
          or $state[$p:lk] = 362770                         (: '(' '(' '+' :)
          or $state[$p:lk] = 379154                         (: '(' '(' '++' :)
          or $state[$p:lk] = 428306                         (: '(' '(' '-' :)
          or $state[$p:lk] = 444690                         (: '(' '(' '--' :)
          or $state[$p:lk] = 475282                         (: '(' IDENTIFIER '.' :)
          or $state[$p:lk] = 475666                         (: '(' INTEGER_LITERAL '.' :)
          or $state[$p:lk] = 475794                         (: '(' FLOATING_POINT_LITERAL '.' :)
          or $state[$p:lk] = 475922                         (: '(' CHARACTER_LITERAL '.' :)
          or $state[$p:lk] = 476050                         (: '(' STRING_LITERAL '.' :)
          or $state[$p:lk] = 481170                         (: '(' 'EOF' '.' :)
          or $state[$p:lk] = 481298                         (: '(' 'IGNORE_CASE' '.' :)
          or $state[$p:lk] = 481426                         (: '(' 'JAVACODE' '.' :)
          or $state[$p:lk] = 481554                         (: '(' 'LOOKAHEAD' '.' :)
          or $state[$p:lk] = 481682                         (: '(' 'MORE' '.' :)
          or $state[$p:lk] = 481810                         (: '(' 'PARSER_BEGIN' '.' :)
          or $state[$p:lk] = 481938                         (: '(' 'PARSER_END' '.' :)
          or $state[$p:lk] = 482066                         (: '(' 'SKIP' '.' :)
          or $state[$p:lk] = 482194                         (: '(' 'SPECIAL_TOKEN' '.' :)
          or $state[$p:lk] = 482322                         (: '(' 'TOKEN' '.' :)
          or $state[$p:lk] = 482450                         (: '(' 'TOKEN_MGR_DECLS' '.' :)
          or $state[$p:lk] = 483346                         (: '(' 'boolean' '.' :)
          or $state[$p:lk] = 483602                         (: '(' 'byte' '.' :)
          or $state[$p:lk] = 483986                         (: '(' 'char' '.' :)
          or $state[$p:lk] = 484626                         (: '(' 'double' '.' :)
          or $state[$p:lk] = 485138                         (: '(' 'false' '.' :)
          or $state[$p:lk] = 485522                         (: '(' 'float' '.' :)
          or $state[$p:lk] = 486290                         (: '(' 'int' '.' :)
          or $state[$p:lk] = 486546                         (: '(' 'long' '.' :)
          or $state[$p:lk] = 486930                         (: '(' 'null' '.' :)
          or $state[$p:lk] = 487826                         (: '(' 'short' '.' :)
          or $state[$p:lk] = 488210                         (: '(' 'super' '.' :)
          or $state[$p:lk] = 488594                         (: '(' 'this' '.' :)
          or $state[$p:lk] = 489106                         (: '(' 'true' '.' :)
          or $state[$p:lk] = 489362                         (: '(' 'void' '.' :)
          or $state[$p:lk] = 573586                         (: '(' IDENTIFIER '<' :)
          or $state[$p:lk] = 574354                         (: '(' STRING_LITERAL '<' :)
          or $state[$p:lk] = 639122                         (: '(' IDENTIFIER '=' :)
          or $state[$p:lk] = 639506                         (: '(' INTEGER_LITERAL '=' :)
          or $state[$p:lk] = 639634                         (: '(' FLOATING_POINT_LITERAL '=' :)
          or $state[$p:lk] = 639762                         (: '(' CHARACTER_LITERAL '=' :)
          or $state[$p:lk] = 639890                         (: '(' STRING_LITERAL '=' :)
          or $state[$p:lk] = 645010                         (: '(' 'EOF' '=' :)
          or $state[$p:lk] = 645138                         (: '(' 'IGNORE_CASE' '=' :)
          or $state[$p:lk] = 645266                         (: '(' 'JAVACODE' '=' :)
          or $state[$p:lk] = 645394                         (: '(' 'LOOKAHEAD' '=' :)
          or $state[$p:lk] = 645522                         (: '(' 'MORE' '=' :)
          or $state[$p:lk] = 645650                         (: '(' 'PARSER_BEGIN' '=' :)
          or $state[$p:lk] = 645778                         (: '(' 'PARSER_END' '=' :)
          or $state[$p:lk] = 645906                         (: '(' 'SKIP' '=' :)
          or $state[$p:lk] = 646034                         (: '(' 'SPECIAL_TOKEN' '=' :)
          or $state[$p:lk] = 646162                         (: '(' 'TOKEN' '=' :)
          or $state[$p:lk] = 646290                         (: '(' 'TOKEN_MGR_DECLS' '=' :)
          or $state[$p:lk] = 648978                         (: '(' 'false' '=' :)
          or $state[$p:lk] = 650770                         (: '(' 'null' '=' :)
          or $state[$p:lk] = 652434                         (: '(' 'this' '=' :)
          or $state[$p:lk] = 652946                         (: '(' 'true' '=' :)
          or $state[$p:lk] = 772370                         (: '(' '(' 'EOF' :)
          or $state[$p:lk] = 772402                         (: 'LOOKAHEAD' '(' 'EOF' :)
          or $state[$p:lk] = 788754                         (: '(' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 788786                         (: 'LOOKAHEAD' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805138                         (: '(' '(' 'JAVACODE' :)
          or $state[$p:lk] = 805170                         (: 'LOOKAHEAD' '(' 'JAVACODE' :)
          or $state[$p:lk] = 821522                         (: '(' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 821554                         (: 'LOOKAHEAD' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 837906                         (: '(' '(' 'MORE' :)
          or $state[$p:lk] = 837938                         (: 'LOOKAHEAD' '(' 'MORE' :)
          or $state[$p:lk] = 854290                         (: '(' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 854322                         (: 'LOOKAHEAD' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870674                         (: '(' '(' 'PARSER_END' :)
          or $state[$p:lk] = 870706                         (: 'LOOKAHEAD' '(' 'PARSER_END' :)
          or $state[$p:lk] = 887058                         (: '(' '(' 'SKIP' :)
          or $state[$p:lk] = 887090                         (: 'LOOKAHEAD' '(' 'SKIP' :)
          or $state[$p:lk] = 903442                         (: '(' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 903474                         (: 'LOOKAHEAD' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919826                         (: '(' '(' 'TOKEN' :)
          or $state[$p:lk] = 919858                         (: 'LOOKAHEAD' '(' 'TOKEN' :)
          or $state[$p:lk] = 936210                         (: '(' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 936242                         (: 'LOOKAHEAD' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 950418                         (: '(' IDENTIFIER '[' :)
          or $state[$p:lk] = 950802                         (: '(' INTEGER_LITERAL '[' :)
          or $state[$p:lk] = 950930                         (: '(' FLOATING_POINT_LITERAL '[' :)
          or $state[$p:lk] = 951058                         (: '(' CHARACTER_LITERAL '[' :)
          or $state[$p:lk] = 951186                         (: '(' STRING_LITERAL '[' :)
          or $state[$p:lk] = 956306                         (: '(' 'EOF' '[' :)
          or $state[$p:lk] = 956434                         (: '(' 'IGNORE_CASE' '[' :)
          or $state[$p:lk] = 956562                         (: '(' 'JAVACODE' '[' :)
          or $state[$p:lk] = 956690                         (: '(' 'LOOKAHEAD' '[' :)
          or $state[$p:lk] = 956818                         (: '(' 'MORE' '[' :)
          or $state[$p:lk] = 956946                         (: '(' 'PARSER_BEGIN' '[' :)
          or $state[$p:lk] = 957074                         (: '(' 'PARSER_END' '[' :)
          or $state[$p:lk] = 957202                         (: '(' 'SKIP' '[' :)
          or $state[$p:lk] = 957330                         (: '(' 'SPECIAL_TOKEN' '[' :)
          or $state[$p:lk] = 957458                         (: '(' 'TOKEN' '[' :)
          or $state[$p:lk] = 957586                         (: '(' 'TOKEN_MGR_DECLS' '[' :)
          or $state[$p:lk] = 958482                         (: '(' 'boolean' '[' :)
          or $state[$p:lk] = 958738                         (: '(' 'byte' '[' :)
          or $state[$p:lk] = 959122                         (: '(' 'char' '[' :)
          or $state[$p:lk] = 959762                         (: '(' 'double' '[' :)
          or $state[$p:lk] = 960274                         (: '(' 'false' '[' :)
          or $state[$p:lk] = 960658                         (: '(' 'float' '[' :)
          or $state[$p:lk] = 961426                         (: '(' 'int' '[' :)
          or $state[$p:lk] = 961682                         (: '(' 'long' '[' :)
          or $state[$p:lk] = 962066                         (: '(' 'null' '[' :)
          or $state[$p:lk] = 962962                         (: '(' 'short' '[' :)
          or $state[$p:lk] = 963730                         (: '(' 'this' '[' :)
          or $state[$p:lk] = 964242                         (: '(' 'true' '[' :)
          or $state[$p:lk] = 1050898                        (: '(' '(' 'boolean' :)
          or $state[$p:lk] = 1050930                        (: 'LOOKAHEAD' '(' 'boolean' :)
          or $state[$p:lk] = 1060242                        (: '(' 'new' 'boolean' :)
          or $state[$p:lk] = 1083666                        (: '(' '(' 'byte' :)
          or $state[$p:lk] = 1083698                        (: 'LOOKAHEAD' '(' 'byte' :)
          or $state[$p:lk] = 1093010                        (: '(' 'new' 'byte' :)
          or $state[$p:lk] = 1132818                        (: '(' '(' 'char' :)
          or $state[$p:lk] = 1132850                        (: 'LOOKAHEAD' '(' 'char' :)
          or $state[$p:lk] = 1142162                        (: '(' 'new' 'char' :)
          or $state[$p:lk] = 1214738                        (: '(' '(' 'double' :)
          or $state[$p:lk] = 1214770                        (: 'LOOKAHEAD' '(' 'double' :)
          or $state[$p:lk] = 1224082                        (: '(' 'new' 'double' :)
          or $state[$p:lk] = 1280274                        (: '(' '(' 'false' :)
          or $state[$p:lk] = 1280306                        (: 'LOOKAHEAD' '(' 'false' :)
          or $state[$p:lk] = 1329426                        (: '(' '(' 'float' :)
          or $state[$p:lk] = 1329458                        (: 'LOOKAHEAD' '(' 'float' :)
          or $state[$p:lk] = 1338770                        (: '(' 'new' 'float' :)
          or $state[$p:lk] = 1427730                        (: '(' '(' 'int' :)
          or $state[$p:lk] = 1427762                        (: 'LOOKAHEAD' '(' 'int' :)
          or $state[$p:lk] = 1437074                        (: '(' 'new' 'int' :)
          or $state[$p:lk] = 1460498                        (: '(' '(' 'long' :)
          or $state[$p:lk] = 1460530                        (: 'LOOKAHEAD' '(' 'long' :)
          or $state[$p:lk] = 1469842                        (: '(' 'new' 'long' :)
          or $state[$p:lk] = 1493266                        (: '(' '(' 'new' :)
          or $state[$p:lk] = 1493298                        (: 'LOOKAHEAD' '(' 'new' :)
          or $state[$p:lk] = 1509650                        (: '(' '(' 'null' :)
          or $state[$p:lk] = 1509682                        (: 'LOOKAHEAD' '(' 'null' :)
          or $state[$p:lk] = 1624338                        (: '(' '(' 'short' :)
          or $state[$p:lk] = 1624370                        (: 'LOOKAHEAD' '(' 'short' :)
          or $state[$p:lk] = 1633682                        (: '(' 'new' 'short' :)
          or $state[$p:lk] = 1673490                        (: '(' '(' 'super' :)
          or $state[$p:lk] = 1673522                        (: 'LOOKAHEAD' '(' 'super' :)
          or $state[$p:lk] = 1722642                        (: '(' '(' 'this' :)
          or $state[$p:lk] = 1722674                        (: 'LOOKAHEAD' '(' 'this' :)
          or $state[$p:lk] = 1788178                        (: '(' '(' 'true' :)
          or $state[$p:lk] = 1788210                        (: 'LOOKAHEAD' '(' 'true' :)
          or $state[$p:lk] = 1820946                        (: '(' '(' 'void' :)
          or $state[$p:lk] = 1820978                        (: 'LOOKAHEAD' '(' 'void' :)
          or $state[$p:lk] = 1885074                        (: '(' STRING_LITERAL '|' :)
          or $state[$p:lk] = 1952018) then                  (: '(' '(' '~' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(50, $input, $state)      (: 'LOOKAHEAD' :)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state := p:consumeT(18, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(140, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-local_lookahead($input, $state)
          let $state := p:lookahead1W(4, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
          let $state := p:consumeT(19, $input, $state)      (: ')' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:l1] eq 1) then                (: IDENTIFIER :)
                  let $state := p:lookahead2W(83, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                     '(' | '.' | '<' | '=' | '[' :)
                  let $state :=
                    if ($state[$p:lk] eq 2305) then         (: IDENTIFIER '(' :)
                      let $state := p:lookahead3W(142, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                          FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                          STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                          MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' |
                                                                          '++' | '-' | '--' | 'EOF' | 'IGNORE_CASE' |
                                                                          'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                                          'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                          'SPECIAL_TOKEN' | 'TOKEN' |
                                                                          'TOKEN_MGR_DECLS' | 'boolean' | 'byte' |
                                                                          'char' | 'double' | 'false' | 'float' |
                                                                          'int' | 'long' | 'new' | 'null' | 'short' |
                                                                          'super' | 'this' | 'true' | 'void' | '~' :)
                      return $state
                    else
                      $state
                  return $state
                else if ($state[$p:l1] eq 7) then           (: STRING_LITERAL :)
                  let $state := p:lookahead2W(161, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                      FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                      STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                      MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' |
                                                                      '=' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                      'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                      'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' |
                                                                      'TOKEN' | 'TOKEN_MGR_DECLS' | '[' | ']' |
                                                                      'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                      'float' | 'int' | 'long' | 'new' | 'null' |
                                                                      'short' | 'super' | 'this' | 'true' | 'try' |
                                                                      'void' | '{' | '|' | '}' :)
                  let $state :=
                    if ($state[$p:lk] eq 2311) then         (: STRING_LITERAL '(' :)
                      let $state := p:lookahead3W(160, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                          FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                          STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                          MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' |
                                                                          '++' | '-' | '--' | '<' | 'EOF' |
                                                                          'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                                          'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                          'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                          'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                          'char' | 'double' | 'false' | 'float' |
                                                                          'int' | 'long' | 'new' | 'null' | 'short' |
                                                                          'super' | 'this' | 'true' | 'try' | 'void' |
                                                                          '{' | '~' :)
                      return $state
                    else if ($state[$p:lk] eq 3719) then    (: STRING_LITERAL '.' :)
                      let $state := p:lookahead3W(66, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                         MULTI_LINE_COMMENT | '<' | 'new' | 'this' :)
                      return $state
                    else if ($state[$p:lk] eq 7431) then    (: STRING_LITERAL '[' :)
                      let $state := p:lookahead3W(157, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                          FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                          STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                          MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' |
                                                                          '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                                          'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                                          'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                          'SPECIAL_TOKEN' | 'TOKEN' |
                                                                          'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                          'char' | 'double' | 'false' | 'float' |
                                                                          'int' | 'long' | 'new' | 'null' | 'short' |
                                                                          'super' | 'this' | 'true' | 'try' | 'void' |
                                                                          '{' | '~' :)
                      return $state
                    else
                      $state
                  return $state
                else
                  ($state[$p:l1], subsequence($state, $p:lk + 1))
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:lk] != 4                 (: INTEGER_LITERAL :)
                     and $state[$p:lk] != 5                 (: FLOATING_POINT_LITERAL :)
                     and $state[$p:lk] != 6                 (: CHARACTER_LITERAL :)
                     and $state[$p:lk] != 18                (: '(' :)
                     and $state[$p:lk] != 35                (: '<' :)
                     and $state[$p:lk] != 47                (: 'EOF' :)
                     and $state[$p:lk] != 48                (: 'IGNORE_CASE' :)
                     and $state[$p:lk] != 49                (: 'JAVACODE' :)
                     and $state[$p:lk] != 50                (: 'LOOKAHEAD' :)
                     and $state[$p:lk] != 51                (: 'MORE' :)
                     and $state[$p:lk] != 52                (: 'PARSER_BEGIN' :)
                     and $state[$p:lk] != 53                (: 'PARSER_END' :)
                     and $state[$p:lk] != 54                (: 'SKIP' :)
                     and $state[$p:lk] != 55                (: 'SPECIAL_TOKEN' :)
                     and $state[$p:lk] != 56                (: 'TOKEN' :)
                     and $state[$p:lk] != 57                (: 'TOKEN_MGR_DECLS' :)
                     and $state[$p:lk] != 64                (: 'boolean' :)
                     and $state[$p:lk] != 66                (: 'byte' :)
                     and $state[$p:lk] != 69                (: 'char' :)
                     and $state[$p:lk] != 74                (: 'double' :)
                     and $state[$p:lk] != 78                (: 'false' :)
                     and $state[$p:lk] != 81                (: 'float' :)
                     and $state[$p:lk] != 87                (: 'int' :)
                     and $state[$p:lk] != 89                (: 'long' :)
                     and $state[$p:lk] != 91                (: 'new' :)
                     and $state[$p:lk] != 92                (: 'null' :)
                     and $state[$p:lk] != 99                (: 'short' :)
                     and $state[$p:lk] != 102               (: 'super' :)
                     and $state[$p:lk] != 105               (: 'this' :)
                     and $state[$p:lk] != 109               (: 'true' :)
                     and $state[$p:lk] != 111               (: 'void' :)
                     and $state[$p:lk] != 135               (: STRING_LITERAL IDENTIFIER :)
                     and $state[$p:lk] != 519               (: STRING_LITERAL INTEGER_LITERAL :)
                     and $state[$p:lk] != 647               (: STRING_LITERAL FLOATING_POINT_LITERAL :)
                     and $state[$p:lk] != 775               (: STRING_LITERAL CHARACTER_LITERAL :)
                     and $state[$p:lk] != 903               (: STRING_LITERAL STRING_LITERAL :)
                     and $state[$p:lk] != 2439              (: STRING_LITERAL ')' :)
                     and $state[$p:lk] != 3207              (: STRING_LITERAL ',' :)
                     and $state[$p:lk] != 3713              (: IDENTIFIER '.' :)
                     and $state[$p:lk] != 4481              (: IDENTIFIER '<' :)
                     and $state[$p:lk] != 4487              (: STRING_LITERAL '<' :)
                     and $state[$p:lk] != 4993              (: IDENTIFIER '=' :)
                     and $state[$p:lk] != 4999              (: STRING_LITERAL '=' :)
                     and $state[$p:lk] != 6023              (: STRING_LITERAL 'EOF' :)
                     and $state[$p:lk] != 6151              (: STRING_LITERAL 'IGNORE_CASE' :)
                     and $state[$p:lk] != 6279              (: STRING_LITERAL 'JAVACODE' :)
                     and $state[$p:lk] != 6407              (: STRING_LITERAL 'LOOKAHEAD' :)
                     and $state[$p:lk] != 6535              (: STRING_LITERAL 'MORE' :)
                     and $state[$p:lk] != 6663              (: STRING_LITERAL 'PARSER_BEGIN' :)
                     and $state[$p:lk] != 6791              (: STRING_LITERAL 'PARSER_END' :)
                     and $state[$p:lk] != 6919              (: STRING_LITERAL 'SKIP' :)
                     and $state[$p:lk] != 7047              (: STRING_LITERAL 'SPECIAL_TOKEN' :)
                     and $state[$p:lk] != 7175              (: STRING_LITERAL 'TOKEN' :)
                     and $state[$p:lk] != 7303              (: STRING_LITERAL 'TOKEN_MGR_DECLS' :)
                     and $state[$p:lk] != 7425              (: IDENTIFIER '[' :)
                     and $state[$p:lk] != 7559              (: STRING_LITERAL ']' :)
                     and $state[$p:lk] != 8199              (: STRING_LITERAL 'boolean' :)
                     and $state[$p:lk] != 8455              (: STRING_LITERAL 'byte' :)
                     and $state[$p:lk] != 8839              (: STRING_LITERAL 'char' :)
                     and $state[$p:lk] != 9479              (: STRING_LITERAL 'double' :)
                     and $state[$p:lk] != 9991              (: STRING_LITERAL 'false' :)
                     and $state[$p:lk] != 10375             (: STRING_LITERAL 'float' :)
                     and $state[$p:lk] != 11143             (: STRING_LITERAL 'int' :)
                     and $state[$p:lk] != 11399             (: STRING_LITERAL 'long' :)
                     and $state[$p:lk] != 11655             (: STRING_LITERAL 'new' :)
                     and $state[$p:lk] != 11783             (: STRING_LITERAL 'null' :)
                     and $state[$p:lk] != 12679             (: STRING_LITERAL 'short' :)
                     and $state[$p:lk] != 13063             (: STRING_LITERAL 'super' :)
                     and $state[$p:lk] != 13447             (: STRING_LITERAL 'this' :)
                     and $state[$p:lk] != 13959             (: STRING_LITERAL 'true' :)
                     and $state[$p:lk] != 14087             (: STRING_LITERAL 'try' :)
                     and $state[$p:lk] != 14215             (: STRING_LITERAL 'void' :)
                     and $state[$p:lk] != 14599             (: STRING_LITERAL '{' :)
                     and $state[$p:lk] != 14727             (: STRING_LITERAL '|' :)
                     and $state[$p:lk] != 15111             (: STRING_LITERAL '}' :)
                     and $state[$p:lk] != 171271            (: STRING_LITERAL '[' '!' :)
                     and $state[$p:lk] != 313607            (: STRING_LITERAL '(' ')' :)
                     and $state[$p:lk] != 367879            (: STRING_LITERAL '[' '+' :)
                     and $state[$p:lk] != 384263            (: STRING_LITERAL '[' '++' :)
                     and $state[$p:lk] != 433415            (: STRING_LITERAL '[' '-' :)
                     and $state[$p:lk] != 449799            (: STRING_LITERAL '[' '--' :)
                     and $state[$p:lk] != 575751            (: STRING_LITERAL '(' '<' :)
                     and $state[$p:lk] != 577159            (: STRING_LITERAL '.' '<' :)
                     and $state[$p:lk] != 580871            (: STRING_LITERAL '[' '<' :)
                     and $state[$p:lk] != 952583            (: STRING_LITERAL '(' '[' :)
                     and $state[$p:lk] != 957703            (: STRING_LITERAL '[' '[' :)
                     and $state[$p:lk] != 1494663           (: STRING_LITERAL '.' 'new' :)
                     and $state[$p:lk] != 1724039           (: STRING_LITERAL '.' 'this' :)
                     and $state[$p:lk] != 1804551           (: STRING_LITERAL '(' 'try' :)
                     and $state[$p:lk] != 1809671           (: STRING_LITERAL '[' 'try' :)
                     and $state[$p:lk] != 1870087           (: STRING_LITERAL '(' '{' :)
                     and $state[$p:lk] != 1875207           (: STRING_LITERAL '[' '{' :)
                     and $state[$p:lk] != 1957127) then     (: STRING_LITERAL '[' '~' :)
                  let $state := p:memoized($state, 6)
                  return
                    if ($state[$p:lk] != 0) then
                      $state
                    else
                      let $backtrack := $state
                      let $state := p:strip-result($state)
                      let $state :=
                        if ($state[$p:error]) then
                          $state
                        else
                          p:try-PrimaryExpression($input, $state)
                      let $state := p:consumeT(39, $input, $state) (: '=' :)
                      return
                        if (not($state[$p:error])) then
                          p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
                        else
                          p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
                else
                  $state
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:lk] = -1
                      or $state[$p:lk] = 4                  (: INTEGER_LITERAL :)
                      or $state[$p:lk] = 5                  (: FLOATING_POINT_LITERAL :)
                      or $state[$p:lk] = 6                  (: CHARACTER_LITERAL :)
                      or $state[$p:lk] = 18                 (: '(' :)
                      or $state[$p:lk] = 47                 (: 'EOF' :)
                      or $state[$p:lk] = 48                 (: 'IGNORE_CASE' :)
                      or $state[$p:lk] = 49                 (: 'JAVACODE' :)
                      or $state[$p:lk] = 50                 (: 'LOOKAHEAD' :)
                      or $state[$p:lk] = 51                 (: 'MORE' :)
                      or $state[$p:lk] = 52                 (: 'PARSER_BEGIN' :)
                      or $state[$p:lk] = 53                 (: 'PARSER_END' :)
                      or $state[$p:lk] = 54                 (: 'SKIP' :)
                      or $state[$p:lk] = 55                 (: 'SPECIAL_TOKEN' :)
                      or $state[$p:lk] = 56                 (: 'TOKEN' :)
                      or $state[$p:lk] = 57                 (: 'TOKEN_MGR_DECLS' :)
                      or $state[$p:lk] = 64                 (: 'boolean' :)
                      or $state[$p:lk] = 66                 (: 'byte' :)
                      or $state[$p:lk] = 69                 (: 'char' :)
                      or $state[$p:lk] = 74                 (: 'double' :)
                      or $state[$p:lk] = 78                 (: 'false' :)
                      or $state[$p:lk] = 81                 (: 'float' :)
                      or $state[$p:lk] = 87                 (: 'int' :)
                      or $state[$p:lk] = 89                 (: 'long' :)
                      or $state[$p:lk] = 91                 (: 'new' :)
                      or $state[$p:lk] = 92                 (: 'null' :)
                      or $state[$p:lk] = 99                 (: 'short' :)
                      or $state[$p:lk] = 102                (: 'super' :)
                      or $state[$p:lk] = 105                (: 'this' :)
                      or $state[$p:lk] = 109                (: 'true' :)
                      or $state[$p:lk] = 111                (: 'void' :)
                      or $state[$p:lk] = 3713               (: IDENTIFIER '.' :)
                      or $state[$p:lk] = 4481               (: IDENTIFIER '<' :)
                      or $state[$p:lk] = 4993               (: IDENTIFIER '=' :)
                      or $state[$p:lk] = 4999               (: STRING_LITERAL '=' :)
                      or $state[$p:lk] = 7425               (: IDENTIFIER '[' :)
                      or $state[$p:lk] = 171271             (: STRING_LITERAL '[' '!' :)
                      or $state[$p:lk] = 313607             (: STRING_LITERAL '(' ')' :)
                      or $state[$p:lk] = 367879             (: STRING_LITERAL '[' '+' :)
                      or $state[$p:lk] = 384263             (: STRING_LITERAL '[' '++' :)
                      or $state[$p:lk] = 433415             (: STRING_LITERAL '[' '-' :)
                      or $state[$p:lk] = 449799             (: STRING_LITERAL '[' '--' :)
                      or $state[$p:lk] = 577159             (: STRING_LITERAL '.' '<' :)
                      or $state[$p:lk] = 1494663            (: STRING_LITERAL '.' 'new' :)
                      or $state[$p:lk] = 1724039            (: STRING_LITERAL '.' 'this' :)
                      or $state[$p:lk] = 1957127) then      (: STRING_LITERAL '[' '~' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-PrimaryExpression($input, $state)
                  let $state := p:consumeT(39, $input, $state) (: '=' :)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(54, $input, $state) (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                                 SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 1) then            (: IDENTIFIER :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-identifier($input, $state)
                  let $state := p:lookahead1W(3, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                    '(' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-Arguments($input, $state)
                  return $state
                else
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-regular_expression($input, $state)
                  let $state := p:lookahead1W(158, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                      FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                      STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                      MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' |
                                                                      'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                                      'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                      'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                      '[' | ']' | 'boolean' | 'byte' | 'char' |
                                                                      'double' | 'false' | 'float' | 'int' | 'long' |
                                                                      'new' | 'null' | 'short' | 'super' | 'this' |
                                                                      'true' | 'try' | 'void' | '{' | '|' | '}' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else if ($state[$p:l1] = 29) then       (: '.' :)
                      let $state := p:consumeT(29, $input, $state) (: '.' :)
                      let $state := p:lookahead1W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                        MULTI_LINE_COMMENT :)
                      let $state := p:consumeT(1, $input, $state) (: IDENTIFIER :)
                      return $state
                    else
                      $state
                  return $state
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -5, -5)
                else
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -6, -6)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 411954                              (: 'LOOKAHEAD' '(' ',' :)
     or $state[$p:lk] = 575794                              (: 'LOOKAHEAD' '(' '<' :)
     or $state[$p:lk] = 952626                              (: 'LOOKAHEAD' '(' '[' :)
     or $state[$p:lk] = 1804594                             (: 'LOOKAHEAD' '(' 'try' :)
     or $state[$p:lk] = 1870130) then                       (: 'LOOKAHEAD' '(' '{' :)
      let $state := p:consume(50, $input, $state)           (: 'LOOKAHEAD' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state := p:consume(18, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(140, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-local_lookahead($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consume(19, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Block($input, $state)
      return $state
    else if ($state[$p:lk] = 58) then                       (: '[' :)
      let $state := p:consume(58, $input, $state)           (: '[' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expansion_choices($input, $state)
      let $state := p:consume(59, $input, $state)           (: ']' :)
      return $state
    else if ($state[$p:lk] = 110) then                      (: 'try' :)
      let $state := p:consume(110, $input, $state)          (: 'try' :)
      let $state := p:lookahead1W(23, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
      let $state := p:consume(114, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expansion_choices($input, $state)
      let $state := p:consume(118, $input, $state)          (: '}' :)
      let $state := p:parse-expansion_unit-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'finally' :)
          let $state := p:consume(80, $input, $state)       (: 'finally' :)
          let $state := p:lookahead1W(23, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Block($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = -6
     or $state[$p:lk] = 4498                                (: '(' '<' :)
     or $state[$p:lk] = 7442                                (: '(' '[' :)
     or $state[$p:lk] = 14098                               (: '(' 'try' :)
     or $state[$p:lk] = 14610                               (: '(' '{' :)
     or $state[$p:lk] = 17298                               (: '(' STRING_LITERAL IDENTIFIER :)
     or $state[$p:lk] = 66450                               (: '(' STRING_LITERAL INTEGER_LITERAL :)
     or $state[$p:lk] = 82834                               (: '(' STRING_LITERAL FLOATING_POINT_LITERAL :)
     or $state[$p:lk] = 99218                               (: '(' STRING_LITERAL CHARACTER_LITERAL :)
     or $state[$p:lk] = 115602                              (: '(' STRING_LITERAL STRING_LITERAL :)
     or $state[$p:lk] = 575762                              (: '(' '(' '<' :)
     or $state[$p:lk] = 770962                              (: '(' STRING_LITERAL 'EOF' :)
     or $state[$p:lk] = 787346                              (: '(' STRING_LITERAL 'IGNORE_CASE' :)
     or $state[$p:lk] = 803730                              (: '(' STRING_LITERAL 'JAVACODE' :)
     or $state[$p:lk] = 820114                              (: '(' STRING_LITERAL 'LOOKAHEAD' :)
     or $state[$p:lk] = 836498                              (: '(' STRING_LITERAL 'MORE' :)
     or $state[$p:lk] = 852882                              (: '(' STRING_LITERAL 'PARSER_BEGIN' :)
     or $state[$p:lk] = 869266                              (: '(' STRING_LITERAL 'PARSER_END' :)
     or $state[$p:lk] = 885650                              (: '(' STRING_LITERAL 'SKIP' :)
     or $state[$p:lk] = 902034                              (: '(' STRING_LITERAL 'SPECIAL_TOKEN' :)
     or $state[$p:lk] = 918418                              (: '(' STRING_LITERAL 'TOKEN' :)
     or $state[$p:lk] = 934802                              (: '(' STRING_LITERAL 'TOKEN_MGR_DECLS' :)
     or $state[$p:lk] = 952594                              (: '(' '(' '[' :)
     or $state[$p:lk] = 1049490                             (: '(' STRING_LITERAL 'boolean' :)
     or $state[$p:lk] = 1082258                             (: '(' STRING_LITERAL 'byte' :)
     or $state[$p:lk] = 1131410                             (: '(' STRING_LITERAL 'char' :)
     or $state[$p:lk] = 1213330                             (: '(' STRING_LITERAL 'double' :)
     or $state[$p:lk] = 1278866                             (: '(' STRING_LITERAL 'false' :)
     or $state[$p:lk] = 1328018                             (: '(' STRING_LITERAL 'float' :)
     or $state[$p:lk] = 1426322                             (: '(' STRING_LITERAL 'int' :)
     or $state[$p:lk] = 1459090                             (: '(' STRING_LITERAL 'long' :)
     or $state[$p:lk] = 1491858                             (: '(' STRING_LITERAL 'new' :)
     or $state[$p:lk] = 1508242                             (: '(' STRING_LITERAL 'null' :)
     or $state[$p:lk] = 1622930                             (: '(' STRING_LITERAL 'short' :)
     or $state[$p:lk] = 1672082                             (: '(' STRING_LITERAL 'super' :)
     or $state[$p:lk] = 1721234                             (: '(' STRING_LITERAL 'this' :)
     or $state[$p:lk] = 1786770                             (: '(' STRING_LITERAL 'true' :)
     or $state[$p:lk] = 1803154                             (: '(' STRING_LITERAL 'try' :)
     or $state[$p:lk] = 1804562                             (: '(' '(' 'try' :)
     or $state[$p:lk] = 1819538                             (: '(' STRING_LITERAL 'void' :)
     or $state[$p:lk] = 1868690                             (: '(' STRING_LITERAL '{' :)
     or $state[$p:lk] = 1870098) then                       (: '(' '(' '{' :)
      let $state := p:consume(18, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expansion_choices($input, $state)
      let $state := p:consume(19, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(165, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '*' | '+' | ',' | '<' |
                                                               '?' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 20                         (: '*' :)
              or $state[$p:l1] = 22                         (: '+' :)
              or $state[$p:l1] = 45) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 22) then               (: '+' :)
              let $state := p:consume(22, $input, $state)   (: '+' :)
              return $state
            else if ($state[$p:l1] = 20) then               (: '*' :)
              let $state := p:consume(20, $input, $state)   (: '*' :)
              return $state
            else
              let $state := p:consume(45, $input, $state)   (: '?' :)
              return $state
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:l1] eq 1) then                        (: IDENTIFIER :)
          let $state := p:lookahead2W(83, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '<' | '=' | '[' :)
          let $state :=
            if ($state[$p:lk] eq 2305) then                 (: IDENTIFIER '(' :)
              let $state := p:lookahead3W(142, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' |
                                                                  '-' | '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                  'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                  'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                  'double' | 'false' | 'float' | 'int' | 'long' |
                                                                  'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                                  'void' | '~' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 7) then                   (: STRING_LITERAL :)
          let $state := p:lookahead2W(161, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' | '=' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
          let $state :=
            if ($state[$p:lk] eq 2311) then                 (: STRING_LITERAL '(' :)
              let $state := p:lookahead3W(160, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' |
                                                                  '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                                  'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                  'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                  'char' | 'double' | 'false' | 'float' | 'int' |
                                                                  'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                                  'true' | 'try' | 'void' | '{' | '~' :)
              return $state
            else if ($state[$p:lk] eq 3719) then            (: STRING_LITERAL '.' :)
              let $state := p:lookahead3W(66, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                 MULTI_LINE_COMMENT | '<' | 'new' | 'this' :)
              return $state
            else if ($state[$p:lk] eq 7431) then            (: STRING_LITERAL '[' :)
              let $state := p:lookahead3W(157, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                  '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                  'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                  'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                  'char' | 'double' | 'false' | 'float' | 'int' |
                                                                  'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                                  'true' | 'try' | 'void' | '{' | '~' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] != 4                         (: INTEGER_LITERAL :)
             and $state[$p:lk] != 5                         (: FLOATING_POINT_LITERAL :)
             and $state[$p:lk] != 6                         (: CHARACTER_LITERAL :)
             and $state[$p:lk] != 18                        (: '(' :)
             and $state[$p:lk] != 35                        (: '<' :)
             and $state[$p:lk] != 47                        (: 'EOF' :)
             and $state[$p:lk] != 48                        (: 'IGNORE_CASE' :)
             and $state[$p:lk] != 49                        (: 'JAVACODE' :)
             and $state[$p:lk] != 50                        (: 'LOOKAHEAD' :)
             and $state[$p:lk] != 51                        (: 'MORE' :)
             and $state[$p:lk] != 52                        (: 'PARSER_BEGIN' :)
             and $state[$p:lk] != 53                        (: 'PARSER_END' :)
             and $state[$p:lk] != 54                        (: 'SKIP' :)
             and $state[$p:lk] != 55                        (: 'SPECIAL_TOKEN' :)
             and $state[$p:lk] != 56                        (: 'TOKEN' :)
             and $state[$p:lk] != 57                        (: 'TOKEN_MGR_DECLS' :)
             and $state[$p:lk] != 64                        (: 'boolean' :)
             and $state[$p:lk] != 66                        (: 'byte' :)
             and $state[$p:lk] != 69                        (: 'char' :)
             and $state[$p:lk] != 74                        (: 'double' :)
             and $state[$p:lk] != 78                        (: 'false' :)
             and $state[$p:lk] != 81                        (: 'float' :)
             and $state[$p:lk] != 87                        (: 'int' :)
             and $state[$p:lk] != 89                        (: 'long' :)
             and $state[$p:lk] != 91                        (: 'new' :)
             and $state[$p:lk] != 92                        (: 'null' :)
             and $state[$p:lk] != 99                        (: 'short' :)
             and $state[$p:lk] != 102                       (: 'super' :)
             and $state[$p:lk] != 105                       (: 'this' :)
             and $state[$p:lk] != 109                       (: 'true' :)
             and $state[$p:lk] != 111                       (: 'void' :)
             and $state[$p:lk] != 135                       (: STRING_LITERAL IDENTIFIER :)
             and $state[$p:lk] != 519                       (: STRING_LITERAL INTEGER_LITERAL :)
             and $state[$p:lk] != 647                       (: STRING_LITERAL FLOATING_POINT_LITERAL :)
             and $state[$p:lk] != 775                       (: STRING_LITERAL CHARACTER_LITERAL :)
             and $state[$p:lk] != 903                       (: STRING_LITERAL STRING_LITERAL :)
             and $state[$p:lk] != 2439                      (: STRING_LITERAL ')' :)
             and $state[$p:lk] != 3207                      (: STRING_LITERAL ',' :)
             and $state[$p:lk] != 3713                      (: IDENTIFIER '.' :)
             and $state[$p:lk] != 4481                      (: IDENTIFIER '<' :)
             and $state[$p:lk] != 4487                      (: STRING_LITERAL '<' :)
             and $state[$p:lk] != 4993                      (: IDENTIFIER '=' :)
             and $state[$p:lk] != 4999                      (: STRING_LITERAL '=' :)
             and $state[$p:lk] != 6023                      (: STRING_LITERAL 'EOF' :)
             and $state[$p:lk] != 6151                      (: STRING_LITERAL 'IGNORE_CASE' :)
             and $state[$p:lk] != 6279                      (: STRING_LITERAL 'JAVACODE' :)
             and $state[$p:lk] != 6407                      (: STRING_LITERAL 'LOOKAHEAD' :)
             and $state[$p:lk] != 6535                      (: STRING_LITERAL 'MORE' :)
             and $state[$p:lk] != 6663                      (: STRING_LITERAL 'PARSER_BEGIN' :)
             and $state[$p:lk] != 6791                      (: STRING_LITERAL 'PARSER_END' :)
             and $state[$p:lk] != 6919                      (: STRING_LITERAL 'SKIP' :)
             and $state[$p:lk] != 7047                      (: STRING_LITERAL 'SPECIAL_TOKEN' :)
             and $state[$p:lk] != 7175                      (: STRING_LITERAL 'TOKEN' :)
             and $state[$p:lk] != 7303                      (: STRING_LITERAL 'TOKEN_MGR_DECLS' :)
             and $state[$p:lk] != 7425                      (: IDENTIFIER '[' :)
             and $state[$p:lk] != 7559                      (: STRING_LITERAL ']' :)
             and $state[$p:lk] != 8199                      (: STRING_LITERAL 'boolean' :)
             and $state[$p:lk] != 8455                      (: STRING_LITERAL 'byte' :)
             and $state[$p:lk] != 8839                      (: STRING_LITERAL 'char' :)
             and $state[$p:lk] != 9479                      (: STRING_LITERAL 'double' :)
             and $state[$p:lk] != 9991                      (: STRING_LITERAL 'false' :)
             and $state[$p:lk] != 10375                     (: STRING_LITERAL 'float' :)
             and $state[$p:lk] != 11143                     (: STRING_LITERAL 'int' :)
             and $state[$p:lk] != 11399                     (: STRING_LITERAL 'long' :)
             and $state[$p:lk] != 11655                     (: STRING_LITERAL 'new' :)
             and $state[$p:lk] != 11783                     (: STRING_LITERAL 'null' :)
             and $state[$p:lk] != 12679                     (: STRING_LITERAL 'short' :)
             and $state[$p:lk] != 13063                     (: STRING_LITERAL 'super' :)
             and $state[$p:lk] != 13447                     (: STRING_LITERAL 'this' :)
             and $state[$p:lk] != 13959                     (: STRING_LITERAL 'true' :)
             and $state[$p:lk] != 14087                     (: STRING_LITERAL 'try' :)
             and $state[$p:lk] != 14215                     (: STRING_LITERAL 'void' :)
             and $state[$p:lk] != 14599                     (: STRING_LITERAL '{' :)
             and $state[$p:lk] != 14727                     (: STRING_LITERAL '|' :)
             and $state[$p:lk] != 15111                     (: STRING_LITERAL '}' :)
             and $state[$p:lk] != 171271                    (: STRING_LITERAL '[' '!' :)
             and $state[$p:lk] != 313607                    (: STRING_LITERAL '(' ')' :)
             and $state[$p:lk] != 367879                    (: STRING_LITERAL '[' '+' :)
             and $state[$p:lk] != 384263                    (: STRING_LITERAL '[' '++' :)
             and $state[$p:lk] != 433415                    (: STRING_LITERAL '[' '-' :)
             and $state[$p:lk] != 449799                    (: STRING_LITERAL '[' '--' :)
             and $state[$p:lk] != 575751                    (: STRING_LITERAL '(' '<' :)
             and $state[$p:lk] != 577159                    (: STRING_LITERAL '.' '<' :)
             and $state[$p:lk] != 580871                    (: STRING_LITERAL '[' '<' :)
             and $state[$p:lk] != 952583                    (: STRING_LITERAL '(' '[' :)
             and $state[$p:lk] != 957703                    (: STRING_LITERAL '[' '[' :)
             and $state[$p:lk] != 1494663                   (: STRING_LITERAL '.' 'new' :)
             and $state[$p:lk] != 1724039                   (: STRING_LITERAL '.' 'this' :)
             and $state[$p:lk] != 1804551                   (: STRING_LITERAL '(' 'try' :)
             and $state[$p:lk] != 1809671                   (: STRING_LITERAL '[' 'try' :)
             and $state[$p:lk] != 1870087                   (: STRING_LITERAL '(' '{' :)
             and $state[$p:lk] != 1875207                   (: STRING_LITERAL '[' '{' :)
             and $state[$p:lk] != 1957127) then             (: STRING_LITERAL '[' '~' :)
          let $state := p:memoized($state, 6)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-PrimaryExpression($input, $state)
              let $state := p:consumeT(39, $input, $state)  (: '=' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 4                          (: INTEGER_LITERAL :)
              or $state[$p:lk] = 5                          (: FLOATING_POINT_LITERAL :)
              or $state[$p:lk] = 6                          (: CHARACTER_LITERAL :)
              or $state[$p:lk] = 18                         (: '(' :)
              or $state[$p:lk] = 47                         (: 'EOF' :)
              or $state[$p:lk] = 48                         (: 'IGNORE_CASE' :)
              or $state[$p:lk] = 49                         (: 'JAVACODE' :)
              or $state[$p:lk] = 50                         (: 'LOOKAHEAD' :)
              or $state[$p:lk] = 51                         (: 'MORE' :)
              or $state[$p:lk] = 52                         (: 'PARSER_BEGIN' :)
              or $state[$p:lk] = 53                         (: 'PARSER_END' :)
              or $state[$p:lk] = 54                         (: 'SKIP' :)
              or $state[$p:lk] = 55                         (: 'SPECIAL_TOKEN' :)
              or $state[$p:lk] = 56                         (: 'TOKEN' :)
              or $state[$p:lk] = 57                         (: 'TOKEN_MGR_DECLS' :)
              or $state[$p:lk] = 64                         (: 'boolean' :)
              or $state[$p:lk] = 66                         (: 'byte' :)
              or $state[$p:lk] = 69                         (: 'char' :)
              or $state[$p:lk] = 74                         (: 'double' :)
              or $state[$p:lk] = 78                         (: 'false' :)
              or $state[$p:lk] = 81                         (: 'float' :)
              or $state[$p:lk] = 87                         (: 'int' :)
              or $state[$p:lk] = 89                         (: 'long' :)
              or $state[$p:lk] = 91                         (: 'new' :)
              or $state[$p:lk] = 92                         (: 'null' :)
              or $state[$p:lk] = 99                         (: 'short' :)
              or $state[$p:lk] = 102                        (: 'super' :)
              or $state[$p:lk] = 105                        (: 'this' :)
              or $state[$p:lk] = 109                        (: 'true' :)
              or $state[$p:lk] = 111                        (: 'void' :)
              or $state[$p:lk] = 3713                       (: IDENTIFIER '.' :)
              or $state[$p:lk] = 4481                       (: IDENTIFIER '<' :)
              or $state[$p:lk] = 4993                       (: IDENTIFIER '=' :)
              or $state[$p:lk] = 4999                       (: STRING_LITERAL '=' :)
              or $state[$p:lk] = 7425                       (: IDENTIFIER '[' :)
              or $state[$p:lk] = 171271                     (: STRING_LITERAL '[' '!' :)
              or $state[$p:lk] = 313607                     (: STRING_LITERAL '(' ')' :)
              or $state[$p:lk] = 367879                     (: STRING_LITERAL '[' '+' :)
              or $state[$p:lk] = 384263                     (: STRING_LITERAL '[' '++' :)
              or $state[$p:lk] = 433415                     (: STRING_LITERAL '[' '-' :)
              or $state[$p:lk] = 449799                     (: STRING_LITERAL '[' '--' :)
              or $state[$p:lk] = 577159                     (: STRING_LITERAL '.' '<' :)
              or $state[$p:lk] = 1494663                    (: STRING_LITERAL '.' 'new' :)
              or $state[$p:lk] = 1724039                    (: STRING_LITERAL '.' 'this' :)
              or $state[$p:lk] = 1957127) then              (: STRING_LITERAL '[' '~' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-PrimaryExpression($input, $state)
          let $state := p:consume(39, $input, $state)       (: '=' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(54, $input, $state)       (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                               SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 1) then                    (: IDENTIFIER :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-identifier($input, $state)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Arguments($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-regular_expression($input, $state)
          let $state := p:lookahead1W(158, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 29) then               (: '.' :)
              let $state := p:consume(29, $input, $state)   (: '.' :)
              let $state := p:lookahead1W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              let $state := p:consume(1, $input, $state)    (: IDENTIFIER :)
              return $state
            else
              $state
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "expansion_unit", $count, $begin, $end)
};

(:~
 : Try parsing expansion_unit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expansion_unit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 18) then                           (: '(' :)
      let $state := p:lookahead2W(157, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 914) then                      (: '(' STRING_LITERAL :)
          let $state := p:lookahead3W(174, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                               '--' | '-=' | '.' | '/' | '/=' | '<' | '<<' | '<<=' |
                                                               '<=' | '=' | '==' | '>' | '>=' | '>>=' | '>>>=' | '?' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               '^' | '^=' | 'boolean' | 'byte' | 'char' | 'double' |
                                                               'false' | 'float' | 'instanceof' | 'int' | 'long' |
                                                               'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                               'try' | 'void' | '{' | '|' | '|=' | '||' :)
          return $state
        else if ($state[$p:lk] eq 2322) then                (: '(' '(' :)
          let $state := p:lookahead3W(157, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else if ($state[$p:lk] eq 11666) then               (: '(' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] = (13074,                    (: '(' 'super' :)
                                  14226)) then              (: '(' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (146,                      (: '(' IDENTIFIER :)
                                  530,                      (: '(' INTEGER_LITERAL :)
                                  658,                      (: '(' FLOATING_POINT_LITERAL :)
                                  786,                      (: '(' CHARACTER_LITERAL :)
                                  6034,                     (: '(' 'EOF' :)
                                  6162,                     (: '(' 'IGNORE_CASE' :)
                                  6290,                     (: '(' 'JAVACODE' :)
                                  6418,                     (: '(' 'LOOKAHEAD' :)
                                  6546,                     (: '(' 'MORE' :)
                                  6674,                     (: '(' 'PARSER_BEGIN' :)
                                  6802,                     (: '(' 'PARSER_END' :)
                                  6930,                     (: '(' 'SKIP' :)
                                  7058,                     (: '(' 'SPECIAL_TOKEN' :)
                                  7186,                     (: '(' 'TOKEN' :)
                                  7314,                     (: '(' 'TOKEN_MGR_DECLS' :)
                                  10002,                    (: '(' 'false' :)
                                  11794,                    (: '(' 'null' :)
                                  13458,                    (: '(' 'this' :)
                                  13970)) then              (: '(' 'true' :)
          let $state := p:lookahead3W(136, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 50) then                      (: 'LOOKAHEAD' :)
      let $state := p:lookahead2W(69, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '=' | '[' :)
      let $state :=
        if ($state[$p:lk] eq 2354) then                     (: 'LOOKAHEAD' '(' :)
          let $state := p:lookahead3W(164, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | ',' |
                                                               '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18706                          (: '(' '(' IDENTIFIER :)
          or $state[$p:lk] = 18738                          (: 'LOOKAHEAD' '(' IDENTIFIER :)
          or $state[$p:lk] = 28050                          (: '(' 'new' IDENTIFIER :)
          or $state[$p:lk] = 67858                          (: '(' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 67890                          (: 'LOOKAHEAD' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 84242                          (: '(' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 84274                          (: 'LOOKAHEAD' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100626                         (: '(' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 100658                         (: 'LOOKAHEAD' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117010                         (: '(' '(' STRING_LITERAL :)
          or $state[$p:lk] = 117042                         (: 'LOOKAHEAD' '(' STRING_LITERAL :)
          or $state[$p:lk] = 166162                         (: '(' '(' '!' :)
          or $state[$p:lk] = 295058                         (: '(' IDENTIFIER '(' :)
          or $state[$p:lk] = 295442                         (: '(' INTEGER_LITERAL '(' :)
          or $state[$p:lk] = 295570                         (: '(' FLOATING_POINT_LITERAL '(' :)
          or $state[$p:lk] = 295698                         (: '(' CHARACTER_LITERAL '(' :)
          or $state[$p:lk] = 295826                         (: '(' STRING_LITERAL '(' :)
          or $state[$p:lk] = 297234                         (: '(' '(' '(' :)
          or $state[$p:lk] = 297266                         (: 'LOOKAHEAD' '(' '(' :)
          or $state[$p:lk] = 300946                         (: '(' 'EOF' '(' :)
          or $state[$p:lk] = 301074                         (: '(' 'IGNORE_CASE' '(' :)
          or $state[$p:lk] = 301202                         (: '(' 'JAVACODE' '(' :)
          or $state[$p:lk] = 301330                         (: '(' 'LOOKAHEAD' '(' :)
          or $state[$p:lk] = 301458                         (: '(' 'MORE' '(' :)
          or $state[$p:lk] = 301586                         (: '(' 'PARSER_BEGIN' '(' :)
          or $state[$p:lk] = 301714                         (: '(' 'PARSER_END' '(' :)
          or $state[$p:lk] = 301842                         (: '(' 'SKIP' '(' :)
          or $state[$p:lk] = 301970                         (: '(' 'SPECIAL_TOKEN' '(' :)
          or $state[$p:lk] = 302098                         (: '(' 'TOKEN' '(' :)
          or $state[$p:lk] = 302226                         (: '(' 'TOKEN_MGR_DECLS' '(' :)
          or $state[$p:lk] = 304914                         (: '(' 'false' '(' :)
          or $state[$p:lk] = 306706                         (: '(' 'null' '(' :)
          or $state[$p:lk] = 308370                         (: '(' 'this' '(' :)
          or $state[$p:lk] = 308882                         (: '(' 'true' '(' :)
          or $state[$p:lk] = 312210                         (: '(' STRING_LITERAL ')' :)
          or $state[$p:lk] = 313650                         (: 'LOOKAHEAD' '(' ')' :)
          or $state[$p:lk] = 362770                         (: '(' '(' '+' :)
          or $state[$p:lk] = 379154                         (: '(' '(' '++' :)
          or $state[$p:lk] = 428306                         (: '(' '(' '-' :)
          or $state[$p:lk] = 444690                         (: '(' '(' '--' :)
          or $state[$p:lk] = 475282                         (: '(' IDENTIFIER '.' :)
          or $state[$p:lk] = 475666                         (: '(' INTEGER_LITERAL '.' :)
          or $state[$p:lk] = 475794                         (: '(' FLOATING_POINT_LITERAL '.' :)
          or $state[$p:lk] = 475922                         (: '(' CHARACTER_LITERAL '.' :)
          or $state[$p:lk] = 476050                         (: '(' STRING_LITERAL '.' :)
          or $state[$p:lk] = 481170                         (: '(' 'EOF' '.' :)
          or $state[$p:lk] = 481298                         (: '(' 'IGNORE_CASE' '.' :)
          or $state[$p:lk] = 481426                         (: '(' 'JAVACODE' '.' :)
          or $state[$p:lk] = 481554                         (: '(' 'LOOKAHEAD' '.' :)
          or $state[$p:lk] = 481682                         (: '(' 'MORE' '.' :)
          or $state[$p:lk] = 481810                         (: '(' 'PARSER_BEGIN' '.' :)
          or $state[$p:lk] = 481938                         (: '(' 'PARSER_END' '.' :)
          or $state[$p:lk] = 482066                         (: '(' 'SKIP' '.' :)
          or $state[$p:lk] = 482194                         (: '(' 'SPECIAL_TOKEN' '.' :)
          or $state[$p:lk] = 482322                         (: '(' 'TOKEN' '.' :)
          or $state[$p:lk] = 482450                         (: '(' 'TOKEN_MGR_DECLS' '.' :)
          or $state[$p:lk] = 483346                         (: '(' 'boolean' '.' :)
          or $state[$p:lk] = 483602                         (: '(' 'byte' '.' :)
          or $state[$p:lk] = 483986                         (: '(' 'char' '.' :)
          or $state[$p:lk] = 484626                         (: '(' 'double' '.' :)
          or $state[$p:lk] = 485138                         (: '(' 'false' '.' :)
          or $state[$p:lk] = 485522                         (: '(' 'float' '.' :)
          or $state[$p:lk] = 486290                         (: '(' 'int' '.' :)
          or $state[$p:lk] = 486546                         (: '(' 'long' '.' :)
          or $state[$p:lk] = 486930                         (: '(' 'null' '.' :)
          or $state[$p:lk] = 487826                         (: '(' 'short' '.' :)
          or $state[$p:lk] = 488210                         (: '(' 'super' '.' :)
          or $state[$p:lk] = 488594                         (: '(' 'this' '.' :)
          or $state[$p:lk] = 489106                         (: '(' 'true' '.' :)
          or $state[$p:lk] = 489362                         (: '(' 'void' '.' :)
          or $state[$p:lk] = 573586                         (: '(' IDENTIFIER '<' :)
          or $state[$p:lk] = 574354                         (: '(' STRING_LITERAL '<' :)
          or $state[$p:lk] = 639122                         (: '(' IDENTIFIER '=' :)
          or $state[$p:lk] = 639506                         (: '(' INTEGER_LITERAL '=' :)
          or $state[$p:lk] = 639634                         (: '(' FLOATING_POINT_LITERAL '=' :)
          or $state[$p:lk] = 639762                         (: '(' CHARACTER_LITERAL '=' :)
          or $state[$p:lk] = 639890                         (: '(' STRING_LITERAL '=' :)
          or $state[$p:lk] = 645010                         (: '(' 'EOF' '=' :)
          or $state[$p:lk] = 645138                         (: '(' 'IGNORE_CASE' '=' :)
          or $state[$p:lk] = 645266                         (: '(' 'JAVACODE' '=' :)
          or $state[$p:lk] = 645394                         (: '(' 'LOOKAHEAD' '=' :)
          or $state[$p:lk] = 645522                         (: '(' 'MORE' '=' :)
          or $state[$p:lk] = 645650                         (: '(' 'PARSER_BEGIN' '=' :)
          or $state[$p:lk] = 645778                         (: '(' 'PARSER_END' '=' :)
          or $state[$p:lk] = 645906                         (: '(' 'SKIP' '=' :)
          or $state[$p:lk] = 646034                         (: '(' 'SPECIAL_TOKEN' '=' :)
          or $state[$p:lk] = 646162                         (: '(' 'TOKEN' '=' :)
          or $state[$p:lk] = 646290                         (: '(' 'TOKEN_MGR_DECLS' '=' :)
          or $state[$p:lk] = 648978                         (: '(' 'false' '=' :)
          or $state[$p:lk] = 650770                         (: '(' 'null' '=' :)
          or $state[$p:lk] = 652434                         (: '(' 'this' '=' :)
          or $state[$p:lk] = 652946                         (: '(' 'true' '=' :)
          or $state[$p:lk] = 772370                         (: '(' '(' 'EOF' :)
          or $state[$p:lk] = 772402                         (: 'LOOKAHEAD' '(' 'EOF' :)
          or $state[$p:lk] = 788754                         (: '(' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 788786                         (: 'LOOKAHEAD' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805138                         (: '(' '(' 'JAVACODE' :)
          or $state[$p:lk] = 805170                         (: 'LOOKAHEAD' '(' 'JAVACODE' :)
          or $state[$p:lk] = 821522                         (: '(' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 821554                         (: 'LOOKAHEAD' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 837906                         (: '(' '(' 'MORE' :)
          or $state[$p:lk] = 837938                         (: 'LOOKAHEAD' '(' 'MORE' :)
          or $state[$p:lk] = 854290                         (: '(' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 854322                         (: 'LOOKAHEAD' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870674                         (: '(' '(' 'PARSER_END' :)
          or $state[$p:lk] = 870706                         (: 'LOOKAHEAD' '(' 'PARSER_END' :)
          or $state[$p:lk] = 887058                         (: '(' '(' 'SKIP' :)
          or $state[$p:lk] = 887090                         (: 'LOOKAHEAD' '(' 'SKIP' :)
          or $state[$p:lk] = 903442                         (: '(' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 903474                         (: 'LOOKAHEAD' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919826                         (: '(' '(' 'TOKEN' :)
          or $state[$p:lk] = 919858                         (: 'LOOKAHEAD' '(' 'TOKEN' :)
          or $state[$p:lk] = 936210                         (: '(' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 936242                         (: 'LOOKAHEAD' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 950418                         (: '(' IDENTIFIER '[' :)
          or $state[$p:lk] = 950802                         (: '(' INTEGER_LITERAL '[' :)
          or $state[$p:lk] = 950930                         (: '(' FLOATING_POINT_LITERAL '[' :)
          or $state[$p:lk] = 951058                         (: '(' CHARACTER_LITERAL '[' :)
          or $state[$p:lk] = 951186                         (: '(' STRING_LITERAL '[' :)
          or $state[$p:lk] = 956306                         (: '(' 'EOF' '[' :)
          or $state[$p:lk] = 956434                         (: '(' 'IGNORE_CASE' '[' :)
          or $state[$p:lk] = 956562                         (: '(' 'JAVACODE' '[' :)
          or $state[$p:lk] = 956690                         (: '(' 'LOOKAHEAD' '[' :)
          or $state[$p:lk] = 956818                         (: '(' 'MORE' '[' :)
          or $state[$p:lk] = 956946                         (: '(' 'PARSER_BEGIN' '[' :)
          or $state[$p:lk] = 957074                         (: '(' 'PARSER_END' '[' :)
          or $state[$p:lk] = 957202                         (: '(' 'SKIP' '[' :)
          or $state[$p:lk] = 957330                         (: '(' 'SPECIAL_TOKEN' '[' :)
          or $state[$p:lk] = 957458                         (: '(' 'TOKEN' '[' :)
          or $state[$p:lk] = 957586                         (: '(' 'TOKEN_MGR_DECLS' '[' :)
          or $state[$p:lk] = 958482                         (: '(' 'boolean' '[' :)
          or $state[$p:lk] = 958738                         (: '(' 'byte' '[' :)
          or $state[$p:lk] = 959122                         (: '(' 'char' '[' :)
          or $state[$p:lk] = 959762                         (: '(' 'double' '[' :)
          or $state[$p:lk] = 960274                         (: '(' 'false' '[' :)
          or $state[$p:lk] = 960658                         (: '(' 'float' '[' :)
          or $state[$p:lk] = 961426                         (: '(' 'int' '[' :)
          or $state[$p:lk] = 961682                         (: '(' 'long' '[' :)
          or $state[$p:lk] = 962066                         (: '(' 'null' '[' :)
          or $state[$p:lk] = 962962                         (: '(' 'short' '[' :)
          or $state[$p:lk] = 963730                         (: '(' 'this' '[' :)
          or $state[$p:lk] = 964242                         (: '(' 'true' '[' :)
          or $state[$p:lk] = 1050898                        (: '(' '(' 'boolean' :)
          or $state[$p:lk] = 1050930                        (: 'LOOKAHEAD' '(' 'boolean' :)
          or $state[$p:lk] = 1060242                        (: '(' 'new' 'boolean' :)
          or $state[$p:lk] = 1083666                        (: '(' '(' 'byte' :)
          or $state[$p:lk] = 1083698                        (: 'LOOKAHEAD' '(' 'byte' :)
          or $state[$p:lk] = 1093010                        (: '(' 'new' 'byte' :)
          or $state[$p:lk] = 1132818                        (: '(' '(' 'char' :)
          or $state[$p:lk] = 1132850                        (: 'LOOKAHEAD' '(' 'char' :)
          or $state[$p:lk] = 1142162                        (: '(' 'new' 'char' :)
          or $state[$p:lk] = 1214738                        (: '(' '(' 'double' :)
          or $state[$p:lk] = 1214770                        (: 'LOOKAHEAD' '(' 'double' :)
          or $state[$p:lk] = 1224082                        (: '(' 'new' 'double' :)
          or $state[$p:lk] = 1280274                        (: '(' '(' 'false' :)
          or $state[$p:lk] = 1280306                        (: 'LOOKAHEAD' '(' 'false' :)
          or $state[$p:lk] = 1329426                        (: '(' '(' 'float' :)
          or $state[$p:lk] = 1329458                        (: 'LOOKAHEAD' '(' 'float' :)
          or $state[$p:lk] = 1338770                        (: '(' 'new' 'float' :)
          or $state[$p:lk] = 1427730                        (: '(' '(' 'int' :)
          or $state[$p:lk] = 1427762                        (: 'LOOKAHEAD' '(' 'int' :)
          or $state[$p:lk] = 1437074                        (: '(' 'new' 'int' :)
          or $state[$p:lk] = 1460498                        (: '(' '(' 'long' :)
          or $state[$p:lk] = 1460530                        (: 'LOOKAHEAD' '(' 'long' :)
          or $state[$p:lk] = 1469842                        (: '(' 'new' 'long' :)
          or $state[$p:lk] = 1493266                        (: '(' '(' 'new' :)
          or $state[$p:lk] = 1493298                        (: 'LOOKAHEAD' '(' 'new' :)
          or $state[$p:lk] = 1509650                        (: '(' '(' 'null' :)
          or $state[$p:lk] = 1509682                        (: 'LOOKAHEAD' '(' 'null' :)
          or $state[$p:lk] = 1624338                        (: '(' '(' 'short' :)
          or $state[$p:lk] = 1624370                        (: 'LOOKAHEAD' '(' 'short' :)
          or $state[$p:lk] = 1633682                        (: '(' 'new' 'short' :)
          or $state[$p:lk] = 1673490                        (: '(' '(' 'super' :)
          or $state[$p:lk] = 1673522                        (: 'LOOKAHEAD' '(' 'super' :)
          or $state[$p:lk] = 1722642                        (: '(' '(' 'this' :)
          or $state[$p:lk] = 1722674                        (: 'LOOKAHEAD' '(' 'this' :)
          or $state[$p:lk] = 1788178                        (: '(' '(' 'true' :)
          or $state[$p:lk] = 1788210                        (: 'LOOKAHEAD' '(' 'true' :)
          or $state[$p:lk] = 1820946                        (: '(' '(' 'void' :)
          or $state[$p:lk] = 1820978                        (: 'LOOKAHEAD' '(' 'void' :)
          or $state[$p:lk] = 1885074                        (: '(' STRING_LITERAL '|' :)
          or $state[$p:lk] = 1952018) then                  (: '(' '(' '~' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(50, $input, $state)      (: 'LOOKAHEAD' :)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state := p:consumeT(18, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(140, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-local_lookahead($input, $state)
          let $state := p:lookahead1W(4, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
          let $state := p:consumeT(19, $input, $state)      (: ')' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:l1] eq 1) then                (: IDENTIFIER :)
                  let $state := p:lookahead2W(83, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                     '(' | '.' | '<' | '=' | '[' :)
                  let $state :=
                    if ($state[$p:lk] eq 2305) then         (: IDENTIFIER '(' :)
                      let $state := p:lookahead3W(142, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                          FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                          STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                          MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' |
                                                                          '++' | '-' | '--' | 'EOF' | 'IGNORE_CASE' |
                                                                          'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                                          'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                          'SPECIAL_TOKEN' | 'TOKEN' |
                                                                          'TOKEN_MGR_DECLS' | 'boolean' | 'byte' |
                                                                          'char' | 'double' | 'false' | 'float' |
                                                                          'int' | 'long' | 'new' | 'null' | 'short' |
                                                                          'super' | 'this' | 'true' | 'void' | '~' :)
                      return $state
                    else
                      $state
                  return $state
                else if ($state[$p:l1] eq 7) then           (: STRING_LITERAL :)
                  let $state := p:lookahead2W(161, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                      FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                      STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                      MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' |
                                                                      '=' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                      'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                      'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' |
                                                                      'TOKEN' | 'TOKEN_MGR_DECLS' | '[' | ']' |
                                                                      'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                      'float' | 'int' | 'long' | 'new' | 'null' |
                                                                      'short' | 'super' | 'this' | 'true' | 'try' |
                                                                      'void' | '{' | '|' | '}' :)
                  let $state :=
                    if ($state[$p:lk] eq 2311) then         (: STRING_LITERAL '(' :)
                      let $state := p:lookahead3W(160, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                          FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                          STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                          MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' |
                                                                          '++' | '-' | '--' | '<' | 'EOF' |
                                                                          'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                                          'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                          'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                          'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                          'char' | 'double' | 'false' | 'float' |
                                                                          'int' | 'long' | 'new' | 'null' | 'short' |
                                                                          'super' | 'this' | 'true' | 'try' | 'void' |
                                                                          '{' | '~' :)
                      return $state
                    else if ($state[$p:lk] eq 3719) then    (: STRING_LITERAL '.' :)
                      let $state := p:lookahead3W(66, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                         MULTI_LINE_COMMENT | '<' | 'new' | 'this' :)
                      return $state
                    else if ($state[$p:lk] eq 7431) then    (: STRING_LITERAL '[' :)
                      let $state := p:lookahead3W(157, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                          FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                          STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                          MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' |
                                                                          '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                                          'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                                          'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                          'SPECIAL_TOKEN' | 'TOKEN' |
                                                                          'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                          'char' | 'double' | 'false' | 'float' |
                                                                          'int' | 'long' | 'new' | 'null' | 'short' |
                                                                          'super' | 'this' | 'true' | 'try' | 'void' |
                                                                          '{' | '~' :)
                      return $state
                    else
                      $state
                  return $state
                else
                  ($state[$p:l1], subsequence($state, $p:lk + 1))
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:lk] != 4                 (: INTEGER_LITERAL :)
                     and $state[$p:lk] != 5                 (: FLOATING_POINT_LITERAL :)
                     and $state[$p:lk] != 6                 (: CHARACTER_LITERAL :)
                     and $state[$p:lk] != 18                (: '(' :)
                     and $state[$p:lk] != 35                (: '<' :)
                     and $state[$p:lk] != 47                (: 'EOF' :)
                     and $state[$p:lk] != 48                (: 'IGNORE_CASE' :)
                     and $state[$p:lk] != 49                (: 'JAVACODE' :)
                     and $state[$p:lk] != 50                (: 'LOOKAHEAD' :)
                     and $state[$p:lk] != 51                (: 'MORE' :)
                     and $state[$p:lk] != 52                (: 'PARSER_BEGIN' :)
                     and $state[$p:lk] != 53                (: 'PARSER_END' :)
                     and $state[$p:lk] != 54                (: 'SKIP' :)
                     and $state[$p:lk] != 55                (: 'SPECIAL_TOKEN' :)
                     and $state[$p:lk] != 56                (: 'TOKEN' :)
                     and $state[$p:lk] != 57                (: 'TOKEN_MGR_DECLS' :)
                     and $state[$p:lk] != 64                (: 'boolean' :)
                     and $state[$p:lk] != 66                (: 'byte' :)
                     and $state[$p:lk] != 69                (: 'char' :)
                     and $state[$p:lk] != 74                (: 'double' :)
                     and $state[$p:lk] != 78                (: 'false' :)
                     and $state[$p:lk] != 81                (: 'float' :)
                     and $state[$p:lk] != 87                (: 'int' :)
                     and $state[$p:lk] != 89                (: 'long' :)
                     and $state[$p:lk] != 91                (: 'new' :)
                     and $state[$p:lk] != 92                (: 'null' :)
                     and $state[$p:lk] != 99                (: 'short' :)
                     and $state[$p:lk] != 102               (: 'super' :)
                     and $state[$p:lk] != 105               (: 'this' :)
                     and $state[$p:lk] != 109               (: 'true' :)
                     and $state[$p:lk] != 111               (: 'void' :)
                     and $state[$p:lk] != 135               (: STRING_LITERAL IDENTIFIER :)
                     and $state[$p:lk] != 519               (: STRING_LITERAL INTEGER_LITERAL :)
                     and $state[$p:lk] != 647               (: STRING_LITERAL FLOATING_POINT_LITERAL :)
                     and $state[$p:lk] != 775               (: STRING_LITERAL CHARACTER_LITERAL :)
                     and $state[$p:lk] != 903               (: STRING_LITERAL STRING_LITERAL :)
                     and $state[$p:lk] != 2439              (: STRING_LITERAL ')' :)
                     and $state[$p:lk] != 3207              (: STRING_LITERAL ',' :)
                     and $state[$p:lk] != 3713              (: IDENTIFIER '.' :)
                     and $state[$p:lk] != 4481              (: IDENTIFIER '<' :)
                     and $state[$p:lk] != 4487              (: STRING_LITERAL '<' :)
                     and $state[$p:lk] != 4993              (: IDENTIFIER '=' :)
                     and $state[$p:lk] != 4999              (: STRING_LITERAL '=' :)
                     and $state[$p:lk] != 6023              (: STRING_LITERAL 'EOF' :)
                     and $state[$p:lk] != 6151              (: STRING_LITERAL 'IGNORE_CASE' :)
                     and $state[$p:lk] != 6279              (: STRING_LITERAL 'JAVACODE' :)
                     and $state[$p:lk] != 6407              (: STRING_LITERAL 'LOOKAHEAD' :)
                     and $state[$p:lk] != 6535              (: STRING_LITERAL 'MORE' :)
                     and $state[$p:lk] != 6663              (: STRING_LITERAL 'PARSER_BEGIN' :)
                     and $state[$p:lk] != 6791              (: STRING_LITERAL 'PARSER_END' :)
                     and $state[$p:lk] != 6919              (: STRING_LITERAL 'SKIP' :)
                     and $state[$p:lk] != 7047              (: STRING_LITERAL 'SPECIAL_TOKEN' :)
                     and $state[$p:lk] != 7175              (: STRING_LITERAL 'TOKEN' :)
                     and $state[$p:lk] != 7303              (: STRING_LITERAL 'TOKEN_MGR_DECLS' :)
                     and $state[$p:lk] != 7425              (: IDENTIFIER '[' :)
                     and $state[$p:lk] != 7559              (: STRING_LITERAL ']' :)
                     and $state[$p:lk] != 8199              (: STRING_LITERAL 'boolean' :)
                     and $state[$p:lk] != 8455              (: STRING_LITERAL 'byte' :)
                     and $state[$p:lk] != 8839              (: STRING_LITERAL 'char' :)
                     and $state[$p:lk] != 9479              (: STRING_LITERAL 'double' :)
                     and $state[$p:lk] != 9991              (: STRING_LITERAL 'false' :)
                     and $state[$p:lk] != 10375             (: STRING_LITERAL 'float' :)
                     and $state[$p:lk] != 11143             (: STRING_LITERAL 'int' :)
                     and $state[$p:lk] != 11399             (: STRING_LITERAL 'long' :)
                     and $state[$p:lk] != 11655             (: STRING_LITERAL 'new' :)
                     and $state[$p:lk] != 11783             (: STRING_LITERAL 'null' :)
                     and $state[$p:lk] != 12679             (: STRING_LITERAL 'short' :)
                     and $state[$p:lk] != 13063             (: STRING_LITERAL 'super' :)
                     and $state[$p:lk] != 13447             (: STRING_LITERAL 'this' :)
                     and $state[$p:lk] != 13959             (: STRING_LITERAL 'true' :)
                     and $state[$p:lk] != 14087             (: STRING_LITERAL 'try' :)
                     and $state[$p:lk] != 14215             (: STRING_LITERAL 'void' :)
                     and $state[$p:lk] != 14599             (: STRING_LITERAL '{' :)
                     and $state[$p:lk] != 14727             (: STRING_LITERAL '|' :)
                     and $state[$p:lk] != 15111             (: STRING_LITERAL '}' :)
                     and $state[$p:lk] != 171271            (: STRING_LITERAL '[' '!' :)
                     and $state[$p:lk] != 313607            (: STRING_LITERAL '(' ')' :)
                     and $state[$p:lk] != 367879            (: STRING_LITERAL '[' '+' :)
                     and $state[$p:lk] != 384263            (: STRING_LITERAL '[' '++' :)
                     and $state[$p:lk] != 433415            (: STRING_LITERAL '[' '-' :)
                     and $state[$p:lk] != 449799            (: STRING_LITERAL '[' '--' :)
                     and $state[$p:lk] != 575751            (: STRING_LITERAL '(' '<' :)
                     and $state[$p:lk] != 577159            (: STRING_LITERAL '.' '<' :)
                     and $state[$p:lk] != 580871            (: STRING_LITERAL '[' '<' :)
                     and $state[$p:lk] != 952583            (: STRING_LITERAL '(' '[' :)
                     and $state[$p:lk] != 957703            (: STRING_LITERAL '[' '[' :)
                     and $state[$p:lk] != 1494663           (: STRING_LITERAL '.' 'new' :)
                     and $state[$p:lk] != 1724039           (: STRING_LITERAL '.' 'this' :)
                     and $state[$p:lk] != 1804551           (: STRING_LITERAL '(' 'try' :)
                     and $state[$p:lk] != 1809671           (: STRING_LITERAL '[' 'try' :)
                     and $state[$p:lk] != 1870087           (: STRING_LITERAL '(' '{' :)
                     and $state[$p:lk] != 1875207           (: STRING_LITERAL '[' '{' :)
                     and $state[$p:lk] != 1957127) then     (: STRING_LITERAL '[' '~' :)
                  let $state := p:memoized($state, 6)
                  return
                    if ($state[$p:lk] != 0) then
                      $state
                    else
                      let $backtrack := $state
                      let $state := p:strip-result($state)
                      let $state :=
                        if ($state[$p:error]) then
                          $state
                        else
                          p:try-PrimaryExpression($input, $state)
                      let $state := p:consumeT(39, $input, $state) (: '=' :)
                      return
                        if (not($state[$p:error])) then
                          p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
                        else
                          p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
                else
                  $state
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:lk] = -1
                      or $state[$p:lk] = 4                  (: INTEGER_LITERAL :)
                      or $state[$p:lk] = 5                  (: FLOATING_POINT_LITERAL :)
                      or $state[$p:lk] = 6                  (: CHARACTER_LITERAL :)
                      or $state[$p:lk] = 18                 (: '(' :)
                      or $state[$p:lk] = 47                 (: 'EOF' :)
                      or $state[$p:lk] = 48                 (: 'IGNORE_CASE' :)
                      or $state[$p:lk] = 49                 (: 'JAVACODE' :)
                      or $state[$p:lk] = 50                 (: 'LOOKAHEAD' :)
                      or $state[$p:lk] = 51                 (: 'MORE' :)
                      or $state[$p:lk] = 52                 (: 'PARSER_BEGIN' :)
                      or $state[$p:lk] = 53                 (: 'PARSER_END' :)
                      or $state[$p:lk] = 54                 (: 'SKIP' :)
                      or $state[$p:lk] = 55                 (: 'SPECIAL_TOKEN' :)
                      or $state[$p:lk] = 56                 (: 'TOKEN' :)
                      or $state[$p:lk] = 57                 (: 'TOKEN_MGR_DECLS' :)
                      or $state[$p:lk] = 64                 (: 'boolean' :)
                      or $state[$p:lk] = 66                 (: 'byte' :)
                      or $state[$p:lk] = 69                 (: 'char' :)
                      or $state[$p:lk] = 74                 (: 'double' :)
                      or $state[$p:lk] = 78                 (: 'false' :)
                      or $state[$p:lk] = 81                 (: 'float' :)
                      or $state[$p:lk] = 87                 (: 'int' :)
                      or $state[$p:lk] = 89                 (: 'long' :)
                      or $state[$p:lk] = 91                 (: 'new' :)
                      or $state[$p:lk] = 92                 (: 'null' :)
                      or $state[$p:lk] = 99                 (: 'short' :)
                      or $state[$p:lk] = 102                (: 'super' :)
                      or $state[$p:lk] = 105                (: 'this' :)
                      or $state[$p:lk] = 109                (: 'true' :)
                      or $state[$p:lk] = 111                (: 'void' :)
                      or $state[$p:lk] = 3713               (: IDENTIFIER '.' :)
                      or $state[$p:lk] = 4481               (: IDENTIFIER '<' :)
                      or $state[$p:lk] = 4993               (: IDENTIFIER '=' :)
                      or $state[$p:lk] = 4999               (: STRING_LITERAL '=' :)
                      or $state[$p:lk] = 7425               (: IDENTIFIER '[' :)
                      or $state[$p:lk] = 171271             (: STRING_LITERAL '[' '!' :)
                      or $state[$p:lk] = 313607             (: STRING_LITERAL '(' ')' :)
                      or $state[$p:lk] = 367879             (: STRING_LITERAL '[' '+' :)
                      or $state[$p:lk] = 384263             (: STRING_LITERAL '[' '++' :)
                      or $state[$p:lk] = 433415             (: STRING_LITERAL '[' '-' :)
                      or $state[$p:lk] = 449799             (: STRING_LITERAL '[' '--' :)
                      or $state[$p:lk] = 577159             (: STRING_LITERAL '.' '<' :)
                      or $state[$p:lk] = 1494663            (: STRING_LITERAL '.' 'new' :)
                      or $state[$p:lk] = 1724039            (: STRING_LITERAL '.' 'this' :)
                      or $state[$p:lk] = 1957127) then      (: STRING_LITERAL '[' '~' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-PrimaryExpression($input, $state)
                  let $state := p:consumeT(39, $input, $state) (: '=' :)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(54, $input, $state) (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                                 SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 1) then            (: IDENTIFIER :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-identifier($input, $state)
                  let $state := p:lookahead1W(3, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                    '(' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-Arguments($input, $state)
                  return $state
                else
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-regular_expression($input, $state)
                  let $state := p:lookahead1W(158, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                      FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                      STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                      MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' |
                                                                      'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                                      'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                      'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                      '[' | ']' | 'boolean' | 'byte' | 'char' |
                                                                      'double' | 'false' | 'float' | 'int' | 'long' |
                                                                      'new' | 'null' | 'short' | 'super' | 'this' |
                                                                      'true' | 'try' | 'void' | '{' | '|' | '}' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else if ($state[$p:l1] = 29) then       (: '.' :)
                      let $state := p:consumeT(29, $input, $state) (: '.' :)
                      let $state := p:lookahead1W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                        MULTI_LINE_COMMENT :)
                      let $state := p:consumeT(1, $input, $state) (: IDENTIFIER :)
                      return $state
                    else
                      $state
                  return $state
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -5, -5)
                else
                  p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -6, -6)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 411954                              (: 'LOOKAHEAD' '(' ',' :)
     or $state[$p:lk] = 575794                              (: 'LOOKAHEAD' '(' '<' :)
     or $state[$p:lk] = 952626                              (: 'LOOKAHEAD' '(' '[' :)
     or $state[$p:lk] = 1804594                             (: 'LOOKAHEAD' '(' 'try' :)
     or $state[$p:lk] = 1870130) then                       (: 'LOOKAHEAD' '(' '{' :)
      let $state := p:consumeT(50, $input, $state)          (: 'LOOKAHEAD' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state := p:consumeT(18, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(140, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-local_lookahead($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consumeT(19, $input, $state)          (: ')' :)
      return $state
    else if ($state[$p:lk] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Block($input, $state)
      return $state
    else if ($state[$p:lk] = 58) then                       (: '[' :)
      let $state := p:consumeT(58, $input, $state)          (: '[' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expansion_choices($input, $state)
      let $state := p:consumeT(59, $input, $state)          (: ']' :)
      return $state
    else if ($state[$p:lk] = 110) then                      (: 'try' :)
      let $state := p:consumeT(110, $input, $state)         (: 'try' :)
      let $state := p:lookahead1W(23, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
      let $state := p:consumeT(114, $input, $state)         (: '{' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expansion_choices($input, $state)
      let $state := p:consumeT(118, $input, $state)         (: '}' :)
      let $state := p:try-expansion_unit-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'finally' :)
          let $state := p:consumeT(80, $input, $state)      (: 'finally' :)
          let $state := p:lookahead1W(23, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Block($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = -6
     or $state[$p:lk] = 4498                                (: '(' '<' :)
     or $state[$p:lk] = 7442                                (: '(' '[' :)
     or $state[$p:lk] = 14098                               (: '(' 'try' :)
     or $state[$p:lk] = 14610                               (: '(' '{' :)
     or $state[$p:lk] = 17298                               (: '(' STRING_LITERAL IDENTIFIER :)
     or $state[$p:lk] = 66450                               (: '(' STRING_LITERAL INTEGER_LITERAL :)
     or $state[$p:lk] = 82834                               (: '(' STRING_LITERAL FLOATING_POINT_LITERAL :)
     or $state[$p:lk] = 99218                               (: '(' STRING_LITERAL CHARACTER_LITERAL :)
     or $state[$p:lk] = 115602                              (: '(' STRING_LITERAL STRING_LITERAL :)
     or $state[$p:lk] = 575762                              (: '(' '(' '<' :)
     or $state[$p:lk] = 770962                              (: '(' STRING_LITERAL 'EOF' :)
     or $state[$p:lk] = 787346                              (: '(' STRING_LITERAL 'IGNORE_CASE' :)
     or $state[$p:lk] = 803730                              (: '(' STRING_LITERAL 'JAVACODE' :)
     or $state[$p:lk] = 820114                              (: '(' STRING_LITERAL 'LOOKAHEAD' :)
     or $state[$p:lk] = 836498                              (: '(' STRING_LITERAL 'MORE' :)
     or $state[$p:lk] = 852882                              (: '(' STRING_LITERAL 'PARSER_BEGIN' :)
     or $state[$p:lk] = 869266                              (: '(' STRING_LITERAL 'PARSER_END' :)
     or $state[$p:lk] = 885650                              (: '(' STRING_LITERAL 'SKIP' :)
     or $state[$p:lk] = 902034                              (: '(' STRING_LITERAL 'SPECIAL_TOKEN' :)
     or $state[$p:lk] = 918418                              (: '(' STRING_LITERAL 'TOKEN' :)
     or $state[$p:lk] = 934802                              (: '(' STRING_LITERAL 'TOKEN_MGR_DECLS' :)
     or $state[$p:lk] = 952594                              (: '(' '(' '[' :)
     or $state[$p:lk] = 1049490                             (: '(' STRING_LITERAL 'boolean' :)
     or $state[$p:lk] = 1082258                             (: '(' STRING_LITERAL 'byte' :)
     or $state[$p:lk] = 1131410                             (: '(' STRING_LITERAL 'char' :)
     or $state[$p:lk] = 1213330                             (: '(' STRING_LITERAL 'double' :)
     or $state[$p:lk] = 1278866                             (: '(' STRING_LITERAL 'false' :)
     or $state[$p:lk] = 1328018                             (: '(' STRING_LITERAL 'float' :)
     or $state[$p:lk] = 1426322                             (: '(' STRING_LITERAL 'int' :)
     or $state[$p:lk] = 1459090                             (: '(' STRING_LITERAL 'long' :)
     or $state[$p:lk] = 1491858                             (: '(' STRING_LITERAL 'new' :)
     or $state[$p:lk] = 1508242                             (: '(' STRING_LITERAL 'null' :)
     or $state[$p:lk] = 1622930                             (: '(' STRING_LITERAL 'short' :)
     or $state[$p:lk] = 1672082                             (: '(' STRING_LITERAL 'super' :)
     or $state[$p:lk] = 1721234                             (: '(' STRING_LITERAL 'this' :)
     or $state[$p:lk] = 1786770                             (: '(' STRING_LITERAL 'true' :)
     or $state[$p:lk] = 1803154                             (: '(' STRING_LITERAL 'try' :)
     or $state[$p:lk] = 1804562                             (: '(' '(' 'try' :)
     or $state[$p:lk] = 1819538                             (: '(' STRING_LITERAL 'void' :)
     or $state[$p:lk] = 1868690                             (: '(' STRING_LITERAL '{' :)
     or $state[$p:lk] = 1870098) then                       (: '(' '(' '{' :)
      let $state := p:consumeT(18, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expansion_choices($input, $state)
      let $state := p:consumeT(19, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(165, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '*' | '+' | ',' | '<' |
                                                               '?' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 20                         (: '*' :)
              or $state[$p:l1] = 22                         (: '+' :)
              or $state[$p:l1] = 45) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 22) then               (: '+' :)
              let $state := p:consumeT(22, $input, $state)  (: '+' :)
              return $state
            else if ($state[$p:l1] = 20) then               (: '*' :)
              let $state := p:consumeT(20, $input, $state)  (: '*' :)
              return $state
            else
              let $state := p:consumeT(45, $input, $state)  (: '?' :)
              return $state
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:l1] eq 1) then                        (: IDENTIFIER :)
          let $state := p:lookahead2W(83, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '<' | '=' | '[' :)
          let $state :=
            if ($state[$p:lk] eq 2305) then                 (: IDENTIFIER '(' :)
              let $state := p:lookahead3W(142, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' |
                                                                  '-' | '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                  'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                  'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                  'double' | 'false' | 'float' | 'int' | 'long' |
                                                                  'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                                  'void' | '~' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 7) then                   (: STRING_LITERAL :)
          let $state := p:lookahead2W(161, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' | '=' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
          let $state :=
            if ($state[$p:lk] eq 2311) then                 (: STRING_LITERAL '(' :)
              let $state := p:lookahead3W(160, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' |
                                                                  '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                                  'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                  'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                  'char' | 'double' | 'false' | 'float' | 'int' |
                                                                  'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                                  'true' | 'try' | 'void' | '{' | '~' :)
              return $state
            else if ($state[$p:lk] eq 3719) then            (: STRING_LITERAL '.' :)
              let $state := p:lookahead3W(66, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                 MULTI_LINE_COMMENT | '<' | 'new' | 'this' :)
              return $state
            else if ($state[$p:lk] eq 7431) then            (: STRING_LITERAL '[' :)
              let $state := p:lookahead3W(157, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                  '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                  'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                  'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' |
                                                                  'char' | 'double' | 'false' | 'float' | 'int' |
                                                                  'long' | 'new' | 'null' | 'short' | 'super' | 'this' |
                                                                  'true' | 'try' | 'void' | '{' | '~' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] != 4                         (: INTEGER_LITERAL :)
             and $state[$p:lk] != 5                         (: FLOATING_POINT_LITERAL :)
             and $state[$p:lk] != 6                         (: CHARACTER_LITERAL :)
             and $state[$p:lk] != 18                        (: '(' :)
             and $state[$p:lk] != 35                        (: '<' :)
             and $state[$p:lk] != 47                        (: 'EOF' :)
             and $state[$p:lk] != 48                        (: 'IGNORE_CASE' :)
             and $state[$p:lk] != 49                        (: 'JAVACODE' :)
             and $state[$p:lk] != 50                        (: 'LOOKAHEAD' :)
             and $state[$p:lk] != 51                        (: 'MORE' :)
             and $state[$p:lk] != 52                        (: 'PARSER_BEGIN' :)
             and $state[$p:lk] != 53                        (: 'PARSER_END' :)
             and $state[$p:lk] != 54                        (: 'SKIP' :)
             and $state[$p:lk] != 55                        (: 'SPECIAL_TOKEN' :)
             and $state[$p:lk] != 56                        (: 'TOKEN' :)
             and $state[$p:lk] != 57                        (: 'TOKEN_MGR_DECLS' :)
             and $state[$p:lk] != 64                        (: 'boolean' :)
             and $state[$p:lk] != 66                        (: 'byte' :)
             and $state[$p:lk] != 69                        (: 'char' :)
             and $state[$p:lk] != 74                        (: 'double' :)
             and $state[$p:lk] != 78                        (: 'false' :)
             and $state[$p:lk] != 81                        (: 'float' :)
             and $state[$p:lk] != 87                        (: 'int' :)
             and $state[$p:lk] != 89                        (: 'long' :)
             and $state[$p:lk] != 91                        (: 'new' :)
             and $state[$p:lk] != 92                        (: 'null' :)
             and $state[$p:lk] != 99                        (: 'short' :)
             and $state[$p:lk] != 102                       (: 'super' :)
             and $state[$p:lk] != 105                       (: 'this' :)
             and $state[$p:lk] != 109                       (: 'true' :)
             and $state[$p:lk] != 111                       (: 'void' :)
             and $state[$p:lk] != 135                       (: STRING_LITERAL IDENTIFIER :)
             and $state[$p:lk] != 519                       (: STRING_LITERAL INTEGER_LITERAL :)
             and $state[$p:lk] != 647                       (: STRING_LITERAL FLOATING_POINT_LITERAL :)
             and $state[$p:lk] != 775                       (: STRING_LITERAL CHARACTER_LITERAL :)
             and $state[$p:lk] != 903                       (: STRING_LITERAL STRING_LITERAL :)
             and $state[$p:lk] != 2439                      (: STRING_LITERAL ')' :)
             and $state[$p:lk] != 3207                      (: STRING_LITERAL ',' :)
             and $state[$p:lk] != 3713                      (: IDENTIFIER '.' :)
             and $state[$p:lk] != 4481                      (: IDENTIFIER '<' :)
             and $state[$p:lk] != 4487                      (: STRING_LITERAL '<' :)
             and $state[$p:lk] != 4993                      (: IDENTIFIER '=' :)
             and $state[$p:lk] != 4999                      (: STRING_LITERAL '=' :)
             and $state[$p:lk] != 6023                      (: STRING_LITERAL 'EOF' :)
             and $state[$p:lk] != 6151                      (: STRING_LITERAL 'IGNORE_CASE' :)
             and $state[$p:lk] != 6279                      (: STRING_LITERAL 'JAVACODE' :)
             and $state[$p:lk] != 6407                      (: STRING_LITERAL 'LOOKAHEAD' :)
             and $state[$p:lk] != 6535                      (: STRING_LITERAL 'MORE' :)
             and $state[$p:lk] != 6663                      (: STRING_LITERAL 'PARSER_BEGIN' :)
             and $state[$p:lk] != 6791                      (: STRING_LITERAL 'PARSER_END' :)
             and $state[$p:lk] != 6919                      (: STRING_LITERAL 'SKIP' :)
             and $state[$p:lk] != 7047                      (: STRING_LITERAL 'SPECIAL_TOKEN' :)
             and $state[$p:lk] != 7175                      (: STRING_LITERAL 'TOKEN' :)
             and $state[$p:lk] != 7303                      (: STRING_LITERAL 'TOKEN_MGR_DECLS' :)
             and $state[$p:lk] != 7425                      (: IDENTIFIER '[' :)
             and $state[$p:lk] != 7559                      (: STRING_LITERAL ']' :)
             and $state[$p:lk] != 8199                      (: STRING_LITERAL 'boolean' :)
             and $state[$p:lk] != 8455                      (: STRING_LITERAL 'byte' :)
             and $state[$p:lk] != 8839                      (: STRING_LITERAL 'char' :)
             and $state[$p:lk] != 9479                      (: STRING_LITERAL 'double' :)
             and $state[$p:lk] != 9991                      (: STRING_LITERAL 'false' :)
             and $state[$p:lk] != 10375                     (: STRING_LITERAL 'float' :)
             and $state[$p:lk] != 11143                     (: STRING_LITERAL 'int' :)
             and $state[$p:lk] != 11399                     (: STRING_LITERAL 'long' :)
             and $state[$p:lk] != 11655                     (: STRING_LITERAL 'new' :)
             and $state[$p:lk] != 11783                     (: STRING_LITERAL 'null' :)
             and $state[$p:lk] != 12679                     (: STRING_LITERAL 'short' :)
             and $state[$p:lk] != 13063                     (: STRING_LITERAL 'super' :)
             and $state[$p:lk] != 13447                     (: STRING_LITERAL 'this' :)
             and $state[$p:lk] != 13959                     (: STRING_LITERAL 'true' :)
             and $state[$p:lk] != 14087                     (: STRING_LITERAL 'try' :)
             and $state[$p:lk] != 14215                     (: STRING_LITERAL 'void' :)
             and $state[$p:lk] != 14599                     (: STRING_LITERAL '{' :)
             and $state[$p:lk] != 14727                     (: STRING_LITERAL '|' :)
             and $state[$p:lk] != 15111                     (: STRING_LITERAL '}' :)
             and $state[$p:lk] != 171271                    (: STRING_LITERAL '[' '!' :)
             and $state[$p:lk] != 313607                    (: STRING_LITERAL '(' ')' :)
             and $state[$p:lk] != 367879                    (: STRING_LITERAL '[' '+' :)
             and $state[$p:lk] != 384263                    (: STRING_LITERAL '[' '++' :)
             and $state[$p:lk] != 433415                    (: STRING_LITERAL '[' '-' :)
             and $state[$p:lk] != 449799                    (: STRING_LITERAL '[' '--' :)
             and $state[$p:lk] != 575751                    (: STRING_LITERAL '(' '<' :)
             and $state[$p:lk] != 577159                    (: STRING_LITERAL '.' '<' :)
             and $state[$p:lk] != 580871                    (: STRING_LITERAL '[' '<' :)
             and $state[$p:lk] != 952583                    (: STRING_LITERAL '(' '[' :)
             and $state[$p:lk] != 957703                    (: STRING_LITERAL '[' '[' :)
             and $state[$p:lk] != 1494663                   (: STRING_LITERAL '.' 'new' :)
             and $state[$p:lk] != 1724039                   (: STRING_LITERAL '.' 'this' :)
             and $state[$p:lk] != 1804551                   (: STRING_LITERAL '(' 'try' :)
             and $state[$p:lk] != 1809671                   (: STRING_LITERAL '[' 'try' :)
             and $state[$p:lk] != 1870087                   (: STRING_LITERAL '(' '{' :)
             and $state[$p:lk] != 1875207                   (: STRING_LITERAL '[' '{' :)
             and $state[$p:lk] != 1957127) then             (: STRING_LITERAL '[' '~' :)
          let $state := p:memoized($state, 6)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-PrimaryExpression($input, $state)
              let $state := p:consumeT(39, $input, $state)  (: '=' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 4                          (: INTEGER_LITERAL :)
              or $state[$p:lk] = 5                          (: FLOATING_POINT_LITERAL :)
              or $state[$p:lk] = 6                          (: CHARACTER_LITERAL :)
              or $state[$p:lk] = 18                         (: '(' :)
              or $state[$p:lk] = 47                         (: 'EOF' :)
              or $state[$p:lk] = 48                         (: 'IGNORE_CASE' :)
              or $state[$p:lk] = 49                         (: 'JAVACODE' :)
              or $state[$p:lk] = 50                         (: 'LOOKAHEAD' :)
              or $state[$p:lk] = 51                         (: 'MORE' :)
              or $state[$p:lk] = 52                         (: 'PARSER_BEGIN' :)
              or $state[$p:lk] = 53                         (: 'PARSER_END' :)
              or $state[$p:lk] = 54                         (: 'SKIP' :)
              or $state[$p:lk] = 55                         (: 'SPECIAL_TOKEN' :)
              or $state[$p:lk] = 56                         (: 'TOKEN' :)
              or $state[$p:lk] = 57                         (: 'TOKEN_MGR_DECLS' :)
              or $state[$p:lk] = 64                         (: 'boolean' :)
              or $state[$p:lk] = 66                         (: 'byte' :)
              or $state[$p:lk] = 69                         (: 'char' :)
              or $state[$p:lk] = 74                         (: 'double' :)
              or $state[$p:lk] = 78                         (: 'false' :)
              or $state[$p:lk] = 81                         (: 'float' :)
              or $state[$p:lk] = 87                         (: 'int' :)
              or $state[$p:lk] = 89                         (: 'long' :)
              or $state[$p:lk] = 91                         (: 'new' :)
              or $state[$p:lk] = 92                         (: 'null' :)
              or $state[$p:lk] = 99                         (: 'short' :)
              or $state[$p:lk] = 102                        (: 'super' :)
              or $state[$p:lk] = 105                        (: 'this' :)
              or $state[$p:lk] = 109                        (: 'true' :)
              or $state[$p:lk] = 111                        (: 'void' :)
              or $state[$p:lk] = 3713                       (: IDENTIFIER '.' :)
              or $state[$p:lk] = 4481                       (: IDENTIFIER '<' :)
              or $state[$p:lk] = 4993                       (: IDENTIFIER '=' :)
              or $state[$p:lk] = 4999                       (: STRING_LITERAL '=' :)
              or $state[$p:lk] = 7425                       (: IDENTIFIER '[' :)
              or $state[$p:lk] = 171271                     (: STRING_LITERAL '[' '!' :)
              or $state[$p:lk] = 313607                     (: STRING_LITERAL '(' ')' :)
              or $state[$p:lk] = 367879                     (: STRING_LITERAL '[' '+' :)
              or $state[$p:lk] = 384263                     (: STRING_LITERAL '[' '++' :)
              or $state[$p:lk] = 433415                     (: STRING_LITERAL '[' '-' :)
              or $state[$p:lk] = 449799                     (: STRING_LITERAL '[' '--' :)
              or $state[$p:lk] = 577159                     (: STRING_LITERAL '.' '<' :)
              or $state[$p:lk] = 1494663                    (: STRING_LITERAL '.' 'new' :)
              or $state[$p:lk] = 1724039                    (: STRING_LITERAL '.' 'this' :)
              or $state[$p:lk] = 1957127) then              (: STRING_LITERAL '[' '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-PrimaryExpression($input, $state)
          let $state := p:consumeT(39, $input, $state)      (: '=' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(54, $input, $state)       (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                               SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 1) then                    (: IDENTIFIER :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-identifier($input, $state)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Arguments($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-regular_expression($input, $state)
          let $state := p:lookahead1W(158, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 29) then               (: '.' :)
              let $state := p:consumeT(29, $input, $state)  (: '.' :)
              let $state := p:lookahead1W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              let $state := p:consumeT(1, $input, $state)   (: IDENTIFIER :)
              return $state
            else
              $state
          return $state
      return $state
  return $state
};

(:~
 : Parse local_lookahead.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-local_lookahead($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 4) then                            (: INTEGER_LITERAL :)
      let $state := p:lookahead2W(152, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' | '=' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state :=
        if ($state[$p:lk] eq 2308) then                     (: INTEGER_LITERAL '(' :)
          let $state := p:lookahead3W(160, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else if ($state[$p:lk] eq 7428) then                (: INTEGER_LITERAL '[' :)
          let $state := p:lookahead3W(157, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18692                          (: INTEGER_LITERAL '(' IDENTIFIER :)
          or $state[$p:lk] = 23812                          (: INTEGER_LITERAL '[' IDENTIFIER :)
          or $state[$p:lk] = 67844                          (: INTEGER_LITERAL '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 72964                          (: INTEGER_LITERAL '[' INTEGER_LITERAL :)
          or $state[$p:lk] = 84228                          (: INTEGER_LITERAL '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 89348                          (: INTEGER_LITERAL '[' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100612                         (: INTEGER_LITERAL '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 105732                         (: INTEGER_LITERAL '[' CHARACTER_LITERAL :)
          or $state[$p:lk] = 116996                         (: INTEGER_LITERAL '(' STRING_LITERAL :)
          or $state[$p:lk] = 122116                         (: INTEGER_LITERAL '[' STRING_LITERAL :)
          or $state[$p:lk] = 166148                         (: INTEGER_LITERAL '(' '!' :)
          or $state[$p:lk] = 297220                         (: INTEGER_LITERAL '(' '(' :)
          or $state[$p:lk] = 302340                         (: INTEGER_LITERAL '[' '(' :)
          or $state[$p:lk] = 362756                         (: INTEGER_LITERAL '(' '+' :)
          or $state[$p:lk] = 379140                         (: INTEGER_LITERAL '(' '++' :)
          or $state[$p:lk] = 428292                         (: INTEGER_LITERAL '(' '-' :)
          or $state[$p:lk] = 444676                         (: INTEGER_LITERAL '(' '--' :)
          or $state[$p:lk] = 772356                         (: INTEGER_LITERAL '(' 'EOF' :)
          or $state[$p:lk] = 777476                         (: INTEGER_LITERAL '[' 'EOF' :)
          or $state[$p:lk] = 788740                         (: INTEGER_LITERAL '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 793860                         (: INTEGER_LITERAL '[' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805124                         (: INTEGER_LITERAL '(' 'JAVACODE' :)
          or $state[$p:lk] = 810244                         (: INTEGER_LITERAL '[' 'JAVACODE' :)
          or $state[$p:lk] = 821508                         (: INTEGER_LITERAL '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 826628                         (: INTEGER_LITERAL '[' 'LOOKAHEAD' :)
          or $state[$p:lk] = 837892                         (: INTEGER_LITERAL '(' 'MORE' :)
          or $state[$p:lk] = 843012                         (: INTEGER_LITERAL '[' 'MORE' :)
          or $state[$p:lk] = 854276                         (: INTEGER_LITERAL '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 859396                         (: INTEGER_LITERAL '[' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870660                         (: INTEGER_LITERAL '(' 'PARSER_END' :)
          or $state[$p:lk] = 875780                         (: INTEGER_LITERAL '[' 'PARSER_END' :)
          or $state[$p:lk] = 887044                         (: INTEGER_LITERAL '(' 'SKIP' :)
          or $state[$p:lk] = 892164                         (: INTEGER_LITERAL '[' 'SKIP' :)
          or $state[$p:lk] = 903428                         (: INTEGER_LITERAL '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 908548                         (: INTEGER_LITERAL '[' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919812                         (: INTEGER_LITERAL '(' 'TOKEN' :)
          or $state[$p:lk] = 924932                         (: INTEGER_LITERAL '[' 'TOKEN' :)
          or $state[$p:lk] = 936196                         (: INTEGER_LITERAL '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 941316                         (: INTEGER_LITERAL '[' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 1050884                        (: INTEGER_LITERAL '(' 'boolean' :)
          or $state[$p:lk] = 1056004                        (: INTEGER_LITERAL '[' 'boolean' :)
          or $state[$p:lk] = 1083652                        (: INTEGER_LITERAL '(' 'byte' :)
          or $state[$p:lk] = 1088772                        (: INTEGER_LITERAL '[' 'byte' :)
          or $state[$p:lk] = 1132804                        (: INTEGER_LITERAL '(' 'char' :)
          or $state[$p:lk] = 1137924                        (: INTEGER_LITERAL '[' 'char' :)
          or $state[$p:lk] = 1214724                        (: INTEGER_LITERAL '(' 'double' :)
          or $state[$p:lk] = 1219844                        (: INTEGER_LITERAL '[' 'double' :)
          or $state[$p:lk] = 1280260                        (: INTEGER_LITERAL '(' 'false' :)
          or $state[$p:lk] = 1285380                        (: INTEGER_LITERAL '[' 'false' :)
          or $state[$p:lk] = 1329412                        (: INTEGER_LITERAL '(' 'float' :)
          or $state[$p:lk] = 1334532                        (: INTEGER_LITERAL '[' 'float' :)
          or $state[$p:lk] = 1427716                        (: INTEGER_LITERAL '(' 'int' :)
          or $state[$p:lk] = 1432836                        (: INTEGER_LITERAL '[' 'int' :)
          or $state[$p:lk] = 1460484                        (: INTEGER_LITERAL '(' 'long' :)
          or $state[$p:lk] = 1465604                        (: INTEGER_LITERAL '[' 'long' :)
          or $state[$p:lk] = 1493252                        (: INTEGER_LITERAL '(' 'new' :)
          or $state[$p:lk] = 1498372                        (: INTEGER_LITERAL '[' 'new' :)
          or $state[$p:lk] = 1509636                        (: INTEGER_LITERAL '(' 'null' :)
          or $state[$p:lk] = 1514756                        (: INTEGER_LITERAL '[' 'null' :)
          or $state[$p:lk] = 1624324                        (: INTEGER_LITERAL '(' 'short' :)
          or $state[$p:lk] = 1629444                        (: INTEGER_LITERAL '[' 'short' :)
          or $state[$p:lk] = 1673476                        (: INTEGER_LITERAL '(' 'super' :)
          or $state[$p:lk] = 1678596                        (: INTEGER_LITERAL '[' 'super' :)
          or $state[$p:lk] = 1722628                        (: INTEGER_LITERAL '(' 'this' :)
          or $state[$p:lk] = 1727748                        (: INTEGER_LITERAL '[' 'this' :)
          or $state[$p:lk] = 1788164                        (: INTEGER_LITERAL '(' 'true' :)
          or $state[$p:lk] = 1793284                        (: INTEGER_LITERAL '[' 'true' :)
          or $state[$p:lk] = 1820932                        (: INTEGER_LITERAL '(' 'void' :)
          or $state[$p:lk] = 1826052                        (: INTEGER_LITERAL '[' 'void' :)
          or $state[$p:lk] = 1952004) then                  (: INTEGER_LITERAL '(' '~' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-IntegerLiteral($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 132                            (: INTEGER_LITERAL IDENTIFIER :)
          or $state[$p:lk] = 516                            (: INTEGER_LITERAL INTEGER_LITERAL :)
          or $state[$p:lk] = 644                            (: INTEGER_LITERAL FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 772                            (: INTEGER_LITERAL CHARACTER_LITERAL :)
          or $state[$p:lk] = 900                            (: INTEGER_LITERAL STRING_LITERAL :)
          or $state[$p:lk] = 2436                           (: INTEGER_LITERAL ')' :)
          or $state[$p:lk] = 3204                           (: INTEGER_LITERAL ',' :)
          or $state[$p:lk] = 4484                           (: INTEGER_LITERAL '<' :)
          or $state[$p:lk] = 6020                           (: INTEGER_LITERAL 'EOF' :)
          or $state[$p:lk] = 6148                           (: INTEGER_LITERAL 'IGNORE_CASE' :)
          or $state[$p:lk] = 6276                           (: INTEGER_LITERAL 'JAVACODE' :)
          or $state[$p:lk] = 6404                           (: INTEGER_LITERAL 'LOOKAHEAD' :)
          or $state[$p:lk] = 6532                           (: INTEGER_LITERAL 'MORE' :)
          or $state[$p:lk] = 6660                           (: INTEGER_LITERAL 'PARSER_BEGIN' :)
          or $state[$p:lk] = 6788                           (: INTEGER_LITERAL 'PARSER_END' :)
          or $state[$p:lk] = 6916                           (: INTEGER_LITERAL 'SKIP' :)
          or $state[$p:lk] = 7044                           (: INTEGER_LITERAL 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 7172                           (: INTEGER_LITERAL 'TOKEN' :)
          or $state[$p:lk] = 7300                           (: INTEGER_LITERAL 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 8196                           (: INTEGER_LITERAL 'boolean' :)
          or $state[$p:lk] = 8452                           (: INTEGER_LITERAL 'byte' :)
          or $state[$p:lk] = 8836                           (: INTEGER_LITERAL 'char' :)
          or $state[$p:lk] = 9476                           (: INTEGER_LITERAL 'double' :)
          or $state[$p:lk] = 9988                           (: INTEGER_LITERAL 'false' :)
          or $state[$p:lk] = 10372                          (: INTEGER_LITERAL 'float' :)
          or $state[$p:lk] = 11140                          (: INTEGER_LITERAL 'int' :)
          or $state[$p:lk] = 11396                          (: INTEGER_LITERAL 'long' :)
          or $state[$p:lk] = 11652                          (: INTEGER_LITERAL 'new' :)
          or $state[$p:lk] = 11780                          (: INTEGER_LITERAL 'null' :)
          or $state[$p:lk] = 12676                          (: INTEGER_LITERAL 'short' :)
          or $state[$p:lk] = 13060                          (: INTEGER_LITERAL 'super' :)
          or $state[$p:lk] = 13444                          (: INTEGER_LITERAL 'this' :)
          or $state[$p:lk] = 13956                          (: INTEGER_LITERAL 'true' :)
          or $state[$p:lk] = 14084                          (: INTEGER_LITERAL 'try' :)
          or $state[$p:lk] = 14212                          (: INTEGER_LITERAL 'void' :)
          or $state[$p:lk] = 14596                          (: INTEGER_LITERAL '{' :)
          or $state[$p:lk] = 575748                         (: INTEGER_LITERAL '(' '<' :)
          or $state[$p:lk] = 580868                         (: INTEGER_LITERAL '[' '<' :)
          or $state[$p:lk] = 952580                         (: INTEGER_LITERAL '(' '[' :)
          or $state[$p:lk] = 957700                         (: INTEGER_LITERAL '[' '[' :)
          or $state[$p:lk] = 1804548                        (: INTEGER_LITERAL '(' 'try' :)
          or $state[$p:lk] = 1809668                        (: INTEGER_LITERAL '[' 'try' :)
          or $state[$p:lk] = 1870084                        (: INTEGER_LITERAL '(' '{' :)
          or $state[$p:lk] = 1875204) then                  (: INTEGER_LITERAL '[' '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IntegerLiteral($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
  let $state :=
    if ($state[$p:l1] eq 25) then                           (: ',' :)
      let $state := p:lookahead2W(140, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state :=
        if ($state[$p:lk] eq 2457) then                     (: ',' ')' :)
          let $state := p:lookahead3W(156, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
          return $state
        else if ($state[$p:lk] eq 14617) then               (: ',' '{' :)
          let $state := p:lookahead3W(171, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18841                          (: ',' ')' IDENTIFIER :)
          or $state[$p:lk] = 31001                          (: ',' '{' IDENTIFIER :)
          or $state[$p:lk] = 67993                          (: ',' ')' INTEGER_LITERAL :)
          or $state[$p:lk] = 80153                          (: ',' '{' INTEGER_LITERAL :)
          or $state[$p:lk] = 84377                          (: ',' ')' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 96537                          (: ',' '{' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100761                         (: ',' ')' CHARACTER_LITERAL :)
          or $state[$p:lk] = 112921                         (: ',' '{' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117145                         (: ',' ')' STRING_LITERAL :)
          or $state[$p:lk] = 129305                         (: ',' '{' STRING_LITERAL :)
          or $state[$p:lk] = 178457                         (: ',' '{' '!' :)
          or $state[$p:lk] = 297369                         (: ',' ')' '(' :)
          or $state[$p:lk] = 309529                         (: ',' '{' '(' :)
          or $state[$p:lk] = 313753                         (: ',' ')' ')' :)
          or $state[$p:lk] = 375065                         (: ',' '{' '+' :)
          or $state[$p:lk] = 391449                         (: ',' '{' '++' :)
          or $state[$p:lk] = 412057                         (: ',' ')' ',' :)
          or $state[$p:lk] = 440601                         (: ',' '{' '-' :)
          or $state[$p:lk] = 456985                         (: ',' '{' '--' :)
          or $state[$p:lk] = 575897                         (: ',' ')' '<' :)
          or $state[$p:lk] = 772505                         (: ',' ')' 'EOF' :)
          or $state[$p:lk] = 784665                         (: ',' '{' 'EOF' :)
          or $state[$p:lk] = 788889                         (: ',' ')' 'IGNORE_CASE' :)
          or $state[$p:lk] = 801049                         (: ',' '{' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805273                         (: ',' ')' 'JAVACODE' :)
          or $state[$p:lk] = 817433                         (: ',' '{' 'JAVACODE' :)
          or $state[$p:lk] = 821657                         (: ',' ')' 'LOOKAHEAD' :)
          or $state[$p:lk] = 833817                         (: ',' '{' 'LOOKAHEAD' :)
          or $state[$p:lk] = 838041                         (: ',' ')' 'MORE' :)
          or $state[$p:lk] = 850201                         (: ',' '{' 'MORE' :)
          or $state[$p:lk] = 854425                         (: ',' ')' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 866585                         (: ',' '{' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870809                         (: ',' ')' 'PARSER_END' :)
          or $state[$p:lk] = 882969                         (: ',' '{' 'PARSER_END' :)
          or $state[$p:lk] = 887193                         (: ',' ')' 'SKIP' :)
          or $state[$p:lk] = 899353                         (: ',' '{' 'SKIP' :)
          or $state[$p:lk] = 903577                         (: ',' ')' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 915737                         (: ',' '{' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919961                         (: ',' ')' 'TOKEN' :)
          or $state[$p:lk] = 932121                         (: ',' '{' 'TOKEN' :)
          or $state[$p:lk] = 936345                         (: ',' ')' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 948505                         (: ',' '{' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 952729                         (: ',' ')' '[' :)
          or $state[$p:lk] = 969113                         (: ',' ')' ']' :)
          or $state[$p:lk] = 1051033                        (: ',' ')' 'boolean' :)
          or $state[$p:lk] = 1063193                        (: ',' '{' 'boolean' :)
          or $state[$p:lk] = 1083801                        (: ',' ')' 'byte' :)
          or $state[$p:lk] = 1095961                        (: ',' '{' 'byte' :)
          or $state[$p:lk] = 1132953                        (: ',' ')' 'char' :)
          or $state[$p:lk] = 1145113                        (: ',' '{' 'char' :)
          or $state[$p:lk] = 1214873                        (: ',' ')' 'double' :)
          or $state[$p:lk] = 1227033                        (: ',' '{' 'double' :)
          or $state[$p:lk] = 1280409                        (: ',' ')' 'false' :)
          or $state[$p:lk] = 1292569                        (: ',' '{' 'false' :)
          or $state[$p:lk] = 1329561                        (: ',' ')' 'float' :)
          or $state[$p:lk] = 1341721                        (: ',' '{' 'float' :)
          or $state[$p:lk] = 1427865                        (: ',' ')' 'int' :)
          or $state[$p:lk] = 1440025                        (: ',' '{' 'int' :)
          or $state[$p:lk] = 1460633                        (: ',' ')' 'long' :)
          or $state[$p:lk] = 1472793                        (: ',' '{' 'long' :)
          or $state[$p:lk] = 1493401                        (: ',' ')' 'new' :)
          or $state[$p:lk] = 1505561                        (: ',' '{' 'new' :)
          or $state[$p:lk] = 1509785                        (: ',' ')' 'null' :)
          or $state[$p:lk] = 1521945                        (: ',' '{' 'null' :)
          or $state[$p:lk] = 1624473                        (: ',' ')' 'short' :)
          or $state[$p:lk] = 1636633                        (: ',' '{' 'short' :)
          or $state[$p:lk] = 1673625                        (: ',' ')' 'super' :)
          or $state[$p:lk] = 1685785                        (: ',' '{' 'super' :)
          or $state[$p:lk] = 1722777                        (: ',' ')' 'this' :)
          or $state[$p:lk] = 1734937                        (: ',' '{' 'this' :)
          or $state[$p:lk] = 1788313                        (: ',' ')' 'true' :)
          or $state[$p:lk] = 1800473                        (: ',' '{' 'true' :)
          or $state[$p:lk] = 1804697                        (: ',' ')' 'try' :)
          or $state[$p:lk] = 1821081                        (: ',' ')' 'void' :)
          or $state[$p:lk] = 1833241                        (: ',' '{' 'void' :)
          or $state[$p:lk] = 1870233                        (: ',' ')' '{' :)
          or $state[$p:lk] = 1886617                        (: ',' ')' '|' :)
          or $state[$p:lk] = 1935769                        (: ',' ')' '}' :)
          or $state[$p:lk] = 1947929                        (: ',' '{' '}' :)
          or $state[$p:lk] = 1964313) then                  (: ',' '{' '~' :)
      let $state := p:memoized($state, 3)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(25, $input, $state)      (: ',' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != -2
         and $state[$p:lk] != 1                             (: IDENTIFIER :)
         and $state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 19                            (: ')' :)
         and $state[$p:lk] != 35                            (: '<' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 58                            (: '[' :)
         and $state[$p:lk] != 64                            (: 'boolean' :)
         and $state[$p:lk] != 66                            (: 'byte' :)
         and $state[$p:lk] != 69                            (: 'char' :)
         and $state[$p:lk] != 74                            (: 'double' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 81                            (: 'float' :)
         and $state[$p:lk] != 87                            (: 'int' :)
         and $state[$p:lk] != 89                            (: 'long' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 99                            (: 'short' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 105                           (: 'this' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 110                           (: 'try' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 114) then                     (: '{' :)
      let $state := p:consume(25, $input, $state)           (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
  let $state :=
    if ($state[$p:l1] eq 114) then                          (: '{' :)
      let $state := p:lookahead2W(171, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 242) then                      (: '{' IDENTIFIER :)
          let $state := p:lookahead3W(153, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                               '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' | '<<' |
                                                               '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' | '>>>=' |
                                                               '?' | '[' | '^' | '^=' | 'instanceof' | '|' | '|=' |
                                                               '||' | '}' :)
          return $state
        else if ($state[$p:lk] eq 2418) then                (: '{' '(' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 11762) then               (: '{' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 15218) then               (: '{' '}' :)
          let $state := p:lookahead3W(149, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' :)
          return $state
        else if ($state[$p:lk] = (3058,                     (: '{' '++' :)
                                  3570)) then               (: '{' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (13170,                    (: '{' 'super' :)
                                  14322)) then              (: '{' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (8306,                     (: '{' 'boolean' :)
                                  8562,                     (: '{' 'byte' :)
                                  8946,                     (: '{' 'char' :)
                                  9586,                     (: '{' 'double' :)
                                  10482,                    (: '{' 'float' :)
                                  11250,                    (: '{' 'int' :)
                                  11506,                    (: '{' 'long' :)
                                  12786)) then              (: '{' 'short' :)
          let $state := p:lookahead3W(55, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
          return $state
        else if ($state[$p:lk] = (626,                      (: '{' INTEGER_LITERAL :)
                                  754,                      (: '{' FLOATING_POINT_LITERAL :)
                                  882,                      (: '{' CHARACTER_LITERAL :)
                                  1010,                     (: '{' STRING_LITERAL :)
                                  6130,                     (: '{' 'EOF' :)
                                  6258,                     (: '{' 'IGNORE_CASE' :)
                                  6386,                     (: '{' 'JAVACODE' :)
                                  6514,                     (: '{' 'LOOKAHEAD' :)
                                  6642,                     (: '{' 'MORE' :)
                                  6770,                     (: '{' 'PARSER_BEGIN' :)
                                  6898,                     (: '{' 'PARSER_END' :)
                                  7026,                     (: '{' 'SKIP' :)
                                  7154,                     (: '{' 'SPECIAL_TOKEN' :)
                                  7282,                     (: '{' 'TOKEN' :)
                                  7410,                     (: '{' 'TOKEN_MGR_DECLS' :)
                                  10098,                    (: '{' 'false' :)
                                  11890,                    (: '{' 'null' :)
                                  13554,                    (: '{' 'this' :)
                                  14066)) then              (: '{' 'true' :)
          let $state := p:lookahead3W(141, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18802                          (: '{' '(' IDENTIFIER :)
          or $state[$p:lk] = 19442                          (: '{' '++' IDENTIFIER :)
          or $state[$p:lk] = 19954                          (: '{' '--' IDENTIFIER :)
          or $state[$p:lk] = 28146                          (: '{' 'new' IDENTIFIER :)
          or $state[$p:lk] = 67954                          (: '{' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 68594                          (: '{' '++' INTEGER_LITERAL :)
          or $state[$p:lk] = 69106                          (: '{' '--' INTEGER_LITERAL :)
          or $state[$p:lk] = 84338                          (: '{' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 84978                          (: '{' '++' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 85490                          (: '{' '--' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100722                         (: '{' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 101362                         (: '{' '++' CHARACTER_LITERAL :)
          or $state[$p:lk] = 101874                         (: '{' '--' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117106                         (: '{' '(' STRING_LITERAL :)
          or $state[$p:lk] = 117746                         (: '{' '++' STRING_LITERAL :)
          or $state[$p:lk] = 118258                         (: '{' '--' STRING_LITERAL :)
          or $state[$p:lk] = 166258                         (: '{' '(' '!' :)
          or $state[$p:lk] = 229618                         (: '{' IDENTIFIER '%=' :)
          or $state[$p:lk] = 230002                         (: '{' INTEGER_LITERAL '%=' :)
          or $state[$p:lk] = 230130                         (: '{' FLOATING_POINT_LITERAL '%=' :)
          or $state[$p:lk] = 230258                         (: '{' CHARACTER_LITERAL '%=' :)
          or $state[$p:lk] = 230386                         (: '{' STRING_LITERAL '%=' :)
          or $state[$p:lk] = 235506                         (: '{' 'EOF' '%=' :)
          or $state[$p:lk] = 235634                         (: '{' 'IGNORE_CASE' '%=' :)
          or $state[$p:lk] = 235762                         (: '{' 'JAVACODE' '%=' :)
          or $state[$p:lk] = 235890                         (: '{' 'LOOKAHEAD' '%=' :)
          or $state[$p:lk] = 236018                         (: '{' 'MORE' '%=' :)
          or $state[$p:lk] = 236146                         (: '{' 'PARSER_BEGIN' '%=' :)
          or $state[$p:lk] = 236274                         (: '{' 'PARSER_END' '%=' :)
          or $state[$p:lk] = 236402                         (: '{' 'SKIP' '%=' :)
          or $state[$p:lk] = 236530                         (: '{' 'SPECIAL_TOKEN' '%=' :)
          or $state[$p:lk] = 236658                         (: '{' 'TOKEN' '%=' :)
          or $state[$p:lk] = 236786                         (: '{' 'TOKEN_MGR_DECLS' '%=' :)
          or $state[$p:lk] = 239474                         (: '{' 'false' '%=' :)
          or $state[$p:lk] = 241266                         (: '{' 'null' '%=' :)
          or $state[$p:lk] = 242930                         (: '{' 'this' '%=' :)
          or $state[$p:lk] = 243442                         (: '{' 'true' '%=' :)
          or $state[$p:lk] = 278770                         (: '{' IDENTIFIER '&=' :)
          or $state[$p:lk] = 279154                         (: '{' INTEGER_LITERAL '&=' :)
          or $state[$p:lk] = 279282                         (: '{' FLOATING_POINT_LITERAL '&=' :)
          or $state[$p:lk] = 279410                         (: '{' CHARACTER_LITERAL '&=' :)
          or $state[$p:lk] = 279538                         (: '{' STRING_LITERAL '&=' :)
          or $state[$p:lk] = 284658                         (: '{' 'EOF' '&=' :)
          or $state[$p:lk] = 284786                         (: '{' 'IGNORE_CASE' '&=' :)
          or $state[$p:lk] = 284914                         (: '{' 'JAVACODE' '&=' :)
          or $state[$p:lk] = 285042                         (: '{' 'LOOKAHEAD' '&=' :)
          or $state[$p:lk] = 285170                         (: '{' 'MORE' '&=' :)
          or $state[$p:lk] = 285298                         (: '{' 'PARSER_BEGIN' '&=' :)
          or $state[$p:lk] = 285426                         (: '{' 'PARSER_END' '&=' :)
          or $state[$p:lk] = 285554                         (: '{' 'SKIP' '&=' :)
          or $state[$p:lk] = 285682                         (: '{' 'SPECIAL_TOKEN' '&=' :)
          or $state[$p:lk] = 285810                         (: '{' 'TOKEN' '&=' :)
          or $state[$p:lk] = 285938                         (: '{' 'TOKEN_MGR_DECLS' '&=' :)
          or $state[$p:lk] = 288626                         (: '{' 'false' '&=' :)
          or $state[$p:lk] = 290418                         (: '{' 'null' '&=' :)
          or $state[$p:lk] = 292082                         (: '{' 'this' '&=' :)
          or $state[$p:lk] = 292594                         (: '{' 'true' '&=' :)
          or $state[$p:lk] = 295154                         (: '{' IDENTIFIER '(' :)
          or $state[$p:lk] = 295538                         (: '{' INTEGER_LITERAL '(' :)
          or $state[$p:lk] = 295666                         (: '{' FLOATING_POINT_LITERAL '(' :)
          or $state[$p:lk] = 295794                         (: '{' CHARACTER_LITERAL '(' :)
          or $state[$p:lk] = 295922                         (: '{' STRING_LITERAL '(' :)
          or $state[$p:lk] = 297330                         (: '{' '(' '(' :)
          or $state[$p:lk] = 297970                         (: '{' '++' '(' :)
          or $state[$p:lk] = 298482                         (: '{' '--' '(' :)
          or $state[$p:lk] = 301042                         (: '{' 'EOF' '(' :)
          or $state[$p:lk] = 301170                         (: '{' 'IGNORE_CASE' '(' :)
          or $state[$p:lk] = 301298                         (: '{' 'JAVACODE' '(' :)
          or $state[$p:lk] = 301426                         (: '{' 'LOOKAHEAD' '(' :)
          or $state[$p:lk] = 301554                         (: '{' 'MORE' '(' :)
          or $state[$p:lk] = 301682                         (: '{' 'PARSER_BEGIN' '(' :)
          or $state[$p:lk] = 301810                         (: '{' 'PARSER_END' '(' :)
          or $state[$p:lk] = 301938                         (: '{' 'SKIP' '(' :)
          or $state[$p:lk] = 302066                         (: '{' 'SPECIAL_TOKEN' '(' :)
          or $state[$p:lk] = 302194                         (: '{' 'TOKEN' '(' :)
          or $state[$p:lk] = 302322                         (: '{' 'TOKEN_MGR_DECLS' '(' :)
          or $state[$p:lk] = 305010                         (: '{' 'false' '(' :)
          or $state[$p:lk] = 306802                         (: '{' 'null' '(' :)
          or $state[$p:lk] = 308466                         (: '{' 'this' '(' :)
          or $state[$p:lk] = 308978                         (: '{' 'true' '(' :)
          or $state[$p:lk] = 326514                         (: '{' '}' ')' :)
          or $state[$p:lk] = 344306                         (: '{' IDENTIFIER '*=' :)
          or $state[$p:lk] = 344690                         (: '{' INTEGER_LITERAL '*=' :)
          or $state[$p:lk] = 344818                         (: '{' FLOATING_POINT_LITERAL '*=' :)
          or $state[$p:lk] = 344946                         (: '{' CHARACTER_LITERAL '*=' :)
          or $state[$p:lk] = 345074                         (: '{' STRING_LITERAL '*=' :)
          or $state[$p:lk] = 350194                         (: '{' 'EOF' '*=' :)
          or $state[$p:lk] = 350322                         (: '{' 'IGNORE_CASE' '*=' :)
          or $state[$p:lk] = 350450                         (: '{' 'JAVACODE' '*=' :)
          or $state[$p:lk] = 350578                         (: '{' 'LOOKAHEAD' '*=' :)
          or $state[$p:lk] = 350706                         (: '{' 'MORE' '*=' :)
          or $state[$p:lk] = 350834                         (: '{' 'PARSER_BEGIN' '*=' :)
          or $state[$p:lk] = 350962                         (: '{' 'PARSER_END' '*=' :)
          or $state[$p:lk] = 351090                         (: '{' 'SKIP' '*=' :)
          or $state[$p:lk] = 351218                         (: '{' 'SPECIAL_TOKEN' '*=' :)
          or $state[$p:lk] = 351346                         (: '{' 'TOKEN' '*=' :)
          or $state[$p:lk] = 351474                         (: '{' 'TOKEN_MGR_DECLS' '*=' :)
          or $state[$p:lk] = 354162                         (: '{' 'false' '*=' :)
          or $state[$p:lk] = 355954                         (: '{' 'null' '*=' :)
          or $state[$p:lk] = 357618                         (: '{' 'this' '*=' :)
          or $state[$p:lk] = 358130                         (: '{' 'true' '*=' :)
          or $state[$p:lk] = 362866                         (: '{' '(' '+' :)
          or $state[$p:lk] = 377074                         (: '{' IDENTIFIER '++' :)
          or $state[$p:lk] = 377458                         (: '{' INTEGER_LITERAL '++' :)
          or $state[$p:lk] = 377586                         (: '{' FLOATING_POINT_LITERAL '++' :)
          or $state[$p:lk] = 377714                         (: '{' CHARACTER_LITERAL '++' :)
          or $state[$p:lk] = 377842                         (: '{' STRING_LITERAL '++' :)
          or $state[$p:lk] = 379250                         (: '{' '(' '++' :)
          or $state[$p:lk] = 382962                         (: '{' 'EOF' '++' :)
          or $state[$p:lk] = 383090                         (: '{' 'IGNORE_CASE' '++' :)
          or $state[$p:lk] = 383218                         (: '{' 'JAVACODE' '++' :)
          or $state[$p:lk] = 383346                         (: '{' 'LOOKAHEAD' '++' :)
          or $state[$p:lk] = 383474                         (: '{' 'MORE' '++' :)
          or $state[$p:lk] = 383602                         (: '{' 'PARSER_BEGIN' '++' :)
          or $state[$p:lk] = 383730                         (: '{' 'PARSER_END' '++' :)
          or $state[$p:lk] = 383858                         (: '{' 'SKIP' '++' :)
          or $state[$p:lk] = 383986                         (: '{' 'SPECIAL_TOKEN' '++' :)
          or $state[$p:lk] = 384114                         (: '{' 'TOKEN' '++' :)
          or $state[$p:lk] = 384242                         (: '{' 'TOKEN_MGR_DECLS' '++' :)
          or $state[$p:lk] = 386930                         (: '{' 'false' '++' :)
          or $state[$p:lk] = 388722                         (: '{' 'null' '++' :)
          or $state[$p:lk] = 390386                         (: '{' 'this' '++' :)
          or $state[$p:lk] = 390898                         (: '{' 'true' '++' :)
          or $state[$p:lk] = 393458                         (: '{' IDENTIFIER '+=' :)
          or $state[$p:lk] = 393842                         (: '{' INTEGER_LITERAL '+=' :)
          or $state[$p:lk] = 393970                         (: '{' FLOATING_POINT_LITERAL '+=' :)
          or $state[$p:lk] = 394098                         (: '{' CHARACTER_LITERAL '+=' :)
          or $state[$p:lk] = 394226                         (: '{' STRING_LITERAL '+=' :)
          or $state[$p:lk] = 399346                         (: '{' 'EOF' '+=' :)
          or $state[$p:lk] = 399474                         (: '{' 'IGNORE_CASE' '+=' :)
          or $state[$p:lk] = 399602                         (: '{' 'JAVACODE' '+=' :)
          or $state[$p:lk] = 399730                         (: '{' 'LOOKAHEAD' '+=' :)
          or $state[$p:lk] = 399858                         (: '{' 'MORE' '+=' :)
          or $state[$p:lk] = 399986                         (: '{' 'PARSER_BEGIN' '+=' :)
          or $state[$p:lk] = 400114                         (: '{' 'PARSER_END' '+=' :)
          or $state[$p:lk] = 400242                         (: '{' 'SKIP' '+=' :)
          or $state[$p:lk] = 400370                         (: '{' 'SPECIAL_TOKEN' '+=' :)
          or $state[$p:lk] = 400498                         (: '{' 'TOKEN' '+=' :)
          or $state[$p:lk] = 400626                         (: '{' 'TOKEN_MGR_DECLS' '+=' :)
          or $state[$p:lk] = 403314                         (: '{' 'false' '+=' :)
          or $state[$p:lk] = 405106                         (: '{' 'null' '+=' :)
          or $state[$p:lk] = 406770                         (: '{' 'this' '+=' :)
          or $state[$p:lk] = 407282                         (: '{' 'true' '+=' :)
          or $state[$p:lk] = 428402                         (: '{' '(' '-' :)
          or $state[$p:lk] = 442610                         (: '{' IDENTIFIER '--' :)
          or $state[$p:lk] = 442994                         (: '{' INTEGER_LITERAL '--' :)
          or $state[$p:lk] = 443122                         (: '{' FLOATING_POINT_LITERAL '--' :)
          or $state[$p:lk] = 443250                         (: '{' CHARACTER_LITERAL '--' :)
          or $state[$p:lk] = 443378                         (: '{' STRING_LITERAL '--' :)
          or $state[$p:lk] = 444786                         (: '{' '(' '--' :)
          or $state[$p:lk] = 448498                         (: '{' 'EOF' '--' :)
          or $state[$p:lk] = 448626                         (: '{' 'IGNORE_CASE' '--' :)
          or $state[$p:lk] = 448754                         (: '{' 'JAVACODE' '--' :)
          or $state[$p:lk] = 448882                         (: '{' 'LOOKAHEAD' '--' :)
          or $state[$p:lk] = 449010                         (: '{' 'MORE' '--' :)
          or $state[$p:lk] = 449138                         (: '{' 'PARSER_BEGIN' '--' :)
          or $state[$p:lk] = 449266                         (: '{' 'PARSER_END' '--' :)
          or $state[$p:lk] = 449394                         (: '{' 'SKIP' '--' :)
          or $state[$p:lk] = 449522                         (: '{' 'SPECIAL_TOKEN' '--' :)
          or $state[$p:lk] = 449650                         (: '{' 'TOKEN' '--' :)
          or $state[$p:lk] = 449778                         (: '{' 'TOKEN_MGR_DECLS' '--' :)
          or $state[$p:lk] = 452466                         (: '{' 'false' '--' :)
          or $state[$p:lk] = 454258                         (: '{' 'null' '--' :)
          or $state[$p:lk] = 455922                         (: '{' 'this' '--' :)
          or $state[$p:lk] = 456434                         (: '{' 'true' '--' :)
          or $state[$p:lk] = 458994                         (: '{' IDENTIFIER '-=' :)
          or $state[$p:lk] = 459378                         (: '{' INTEGER_LITERAL '-=' :)
          or $state[$p:lk] = 459506                         (: '{' FLOATING_POINT_LITERAL '-=' :)
          or $state[$p:lk] = 459634                         (: '{' CHARACTER_LITERAL '-=' :)
          or $state[$p:lk] = 459762                         (: '{' STRING_LITERAL '-=' :)
          or $state[$p:lk] = 464882                         (: '{' 'EOF' '-=' :)
          or $state[$p:lk] = 465010                         (: '{' 'IGNORE_CASE' '-=' :)
          or $state[$p:lk] = 465138                         (: '{' 'JAVACODE' '-=' :)
          or $state[$p:lk] = 465266                         (: '{' 'LOOKAHEAD' '-=' :)
          or $state[$p:lk] = 465394                         (: '{' 'MORE' '-=' :)
          or $state[$p:lk] = 465522                         (: '{' 'PARSER_BEGIN' '-=' :)
          or $state[$p:lk] = 465650                         (: '{' 'PARSER_END' '-=' :)
          or $state[$p:lk] = 465778                         (: '{' 'SKIP' '-=' :)
          or $state[$p:lk] = 465906                         (: '{' 'SPECIAL_TOKEN' '-=' :)
          or $state[$p:lk] = 466034                         (: '{' 'TOKEN' '-=' :)
          or $state[$p:lk] = 466162                         (: '{' 'TOKEN_MGR_DECLS' '-=' :)
          or $state[$p:lk] = 468850                         (: '{' 'false' '-=' :)
          or $state[$p:lk] = 470642                         (: '{' 'null' '-=' :)
          or $state[$p:lk] = 472306                         (: '{' 'this' '-=' :)
          or $state[$p:lk] = 472818                         (: '{' 'true' '-=' :)
          or $state[$p:lk] = 475378                         (: '{' IDENTIFIER '.' :)
          or $state[$p:lk] = 475762                         (: '{' INTEGER_LITERAL '.' :)
          or $state[$p:lk] = 475890                         (: '{' FLOATING_POINT_LITERAL '.' :)
          or $state[$p:lk] = 476018                         (: '{' CHARACTER_LITERAL '.' :)
          or $state[$p:lk] = 476146                         (: '{' STRING_LITERAL '.' :)
          or $state[$p:lk] = 481266                         (: '{' 'EOF' '.' :)
          or $state[$p:lk] = 481394                         (: '{' 'IGNORE_CASE' '.' :)
          or $state[$p:lk] = 481522                         (: '{' 'JAVACODE' '.' :)
          or $state[$p:lk] = 481650                         (: '{' 'LOOKAHEAD' '.' :)
          or $state[$p:lk] = 481778                         (: '{' 'MORE' '.' :)
          or $state[$p:lk] = 481906                         (: '{' 'PARSER_BEGIN' '.' :)
          or $state[$p:lk] = 482034                         (: '{' 'PARSER_END' '.' :)
          or $state[$p:lk] = 482162                         (: '{' 'SKIP' '.' :)
          or $state[$p:lk] = 482290                         (: '{' 'SPECIAL_TOKEN' '.' :)
          or $state[$p:lk] = 482418                         (: '{' 'TOKEN' '.' :)
          or $state[$p:lk] = 482546                         (: '{' 'TOKEN_MGR_DECLS' '.' :)
          or $state[$p:lk] = 483442                         (: '{' 'boolean' '.' :)
          or $state[$p:lk] = 483698                         (: '{' 'byte' '.' :)
          or $state[$p:lk] = 484082                         (: '{' 'char' '.' :)
          or $state[$p:lk] = 484722                         (: '{' 'double' '.' :)
          or $state[$p:lk] = 485234                         (: '{' 'false' '.' :)
          or $state[$p:lk] = 485618                         (: '{' 'float' '.' :)
          or $state[$p:lk] = 486386                         (: '{' 'int' '.' :)
          or $state[$p:lk] = 486642                         (: '{' 'long' '.' :)
          or $state[$p:lk] = 487026                         (: '{' 'null' '.' :)
          or $state[$p:lk] = 487922                         (: '{' 'short' '.' :)
          or $state[$p:lk] = 488306                         (: '{' 'super' '.' :)
          or $state[$p:lk] = 488690                         (: '{' 'this' '.' :)
          or $state[$p:lk] = 489202                         (: '{' 'true' '.' :)
          or $state[$p:lk] = 489458                         (: '{' 'void' '.' :)
          or $state[$p:lk] = 524530                         (: '{' IDENTIFIER '/=' :)
          or $state[$p:lk] = 524914                         (: '{' INTEGER_LITERAL '/=' :)
          or $state[$p:lk] = 525042                         (: '{' FLOATING_POINT_LITERAL '/=' :)
          or $state[$p:lk] = 525170                         (: '{' CHARACTER_LITERAL '/=' :)
          or $state[$p:lk] = 525298                         (: '{' STRING_LITERAL '/=' :)
          or $state[$p:lk] = 530418                         (: '{' 'EOF' '/=' :)
          or $state[$p:lk] = 530546                         (: '{' 'IGNORE_CASE' '/=' :)
          or $state[$p:lk] = 530674                         (: '{' 'JAVACODE' '/=' :)
          or $state[$p:lk] = 530802                         (: '{' 'LOOKAHEAD' '/=' :)
          or $state[$p:lk] = 530930                         (: '{' 'MORE' '/=' :)
          or $state[$p:lk] = 531058                         (: '{' 'PARSER_BEGIN' '/=' :)
          or $state[$p:lk] = 531186                         (: '{' 'PARSER_END' '/=' :)
          or $state[$p:lk] = 531314                         (: '{' 'SKIP' '/=' :)
          or $state[$p:lk] = 531442                         (: '{' 'SPECIAL_TOKEN' '/=' :)
          or $state[$p:lk] = 531570                         (: '{' 'TOKEN' '/=' :)
          or $state[$p:lk] = 531698                         (: '{' 'TOKEN_MGR_DECLS' '/=' :)
          or $state[$p:lk] = 534386                         (: '{' 'false' '/=' :)
          or $state[$p:lk] = 536178                         (: '{' 'null' '/=' :)
          or $state[$p:lk] = 537842                         (: '{' 'this' '/=' :)
          or $state[$p:lk] = 538354                         (: '{' 'true' '/=' :)
          or $state[$p:lk] = 573682                         (: '{' IDENTIFIER '<' :)
          or $state[$p:lk] = 606450                         (: '{' IDENTIFIER '<<=' :)
          or $state[$p:lk] = 606834                         (: '{' INTEGER_LITERAL '<<=' :)
          or $state[$p:lk] = 606962                         (: '{' FLOATING_POINT_LITERAL '<<=' :)
          or $state[$p:lk] = 607090                         (: '{' CHARACTER_LITERAL '<<=' :)
          or $state[$p:lk] = 607218                         (: '{' STRING_LITERAL '<<=' :)
          or $state[$p:lk] = 612338                         (: '{' 'EOF' '<<=' :)
          or $state[$p:lk] = 612466                         (: '{' 'IGNORE_CASE' '<<=' :)
          or $state[$p:lk] = 612594                         (: '{' 'JAVACODE' '<<=' :)
          or $state[$p:lk] = 612722                         (: '{' 'LOOKAHEAD' '<<=' :)
          or $state[$p:lk] = 612850                         (: '{' 'MORE' '<<=' :)
          or $state[$p:lk] = 612978                         (: '{' 'PARSER_BEGIN' '<<=' :)
          or $state[$p:lk] = 613106                         (: '{' 'PARSER_END' '<<=' :)
          or $state[$p:lk] = 613234                         (: '{' 'SKIP' '<<=' :)
          or $state[$p:lk] = 613362                         (: '{' 'SPECIAL_TOKEN' '<<=' :)
          or $state[$p:lk] = 613490                         (: '{' 'TOKEN' '<<=' :)
          or $state[$p:lk] = 613618                         (: '{' 'TOKEN_MGR_DECLS' '<<=' :)
          or $state[$p:lk] = 616306                         (: '{' 'false' '<<=' :)
          or $state[$p:lk] = 618098                         (: '{' 'null' '<<=' :)
          or $state[$p:lk] = 619762                         (: '{' 'this' '<<=' :)
          or $state[$p:lk] = 620274                         (: '{' 'true' '<<=' :)
          or $state[$p:lk] = 639218                         (: '{' IDENTIFIER '=' :)
          or $state[$p:lk] = 639602                         (: '{' INTEGER_LITERAL '=' :)
          or $state[$p:lk] = 639730                         (: '{' FLOATING_POINT_LITERAL '=' :)
          or $state[$p:lk] = 639858                         (: '{' CHARACTER_LITERAL '=' :)
          or $state[$p:lk] = 639986                         (: '{' STRING_LITERAL '=' :)
          or $state[$p:lk] = 645106                         (: '{' 'EOF' '=' :)
          or $state[$p:lk] = 645234                         (: '{' 'IGNORE_CASE' '=' :)
          or $state[$p:lk] = 645362                         (: '{' 'JAVACODE' '=' :)
          or $state[$p:lk] = 645490                         (: '{' 'LOOKAHEAD' '=' :)
          or $state[$p:lk] = 645618                         (: '{' 'MORE' '=' :)
          or $state[$p:lk] = 645746                         (: '{' 'PARSER_BEGIN' '=' :)
          or $state[$p:lk] = 645874                         (: '{' 'PARSER_END' '=' :)
          or $state[$p:lk] = 646002                         (: '{' 'SKIP' '=' :)
          or $state[$p:lk] = 646130                         (: '{' 'SPECIAL_TOKEN' '=' :)
          or $state[$p:lk] = 646258                         (: '{' 'TOKEN' '=' :)
          or $state[$p:lk] = 646386                         (: '{' 'TOKEN_MGR_DECLS' '=' :)
          or $state[$p:lk] = 649074                         (: '{' 'false' '=' :)
          or $state[$p:lk] = 650866                         (: '{' 'null' '=' :)
          or $state[$p:lk] = 652530                         (: '{' 'this' '=' :)
          or $state[$p:lk] = 653042                         (: '{' 'true' '=' :)
          or $state[$p:lk] = 704754                         (: '{' IDENTIFIER '>>=' :)
          or $state[$p:lk] = 705138                         (: '{' INTEGER_LITERAL '>>=' :)
          or $state[$p:lk] = 705266                         (: '{' FLOATING_POINT_LITERAL '>>=' :)
          or $state[$p:lk] = 705394                         (: '{' CHARACTER_LITERAL '>>=' :)
          or $state[$p:lk] = 705522                         (: '{' STRING_LITERAL '>>=' :)
          or $state[$p:lk] = 710642                         (: '{' 'EOF' '>>=' :)
          or $state[$p:lk] = 710770                         (: '{' 'IGNORE_CASE' '>>=' :)
          or $state[$p:lk] = 710898                         (: '{' 'JAVACODE' '>>=' :)
          or $state[$p:lk] = 711026                         (: '{' 'LOOKAHEAD' '>>=' :)
          or $state[$p:lk] = 711154                         (: '{' 'MORE' '>>=' :)
          or $state[$p:lk] = 711282                         (: '{' 'PARSER_BEGIN' '>>=' :)
          or $state[$p:lk] = 711410                         (: '{' 'PARSER_END' '>>=' :)
          or $state[$p:lk] = 711538                         (: '{' 'SKIP' '>>=' :)
          or $state[$p:lk] = 711666                         (: '{' 'SPECIAL_TOKEN' '>>=' :)
          or $state[$p:lk] = 711794                         (: '{' 'TOKEN' '>>=' :)
          or $state[$p:lk] = 711922                         (: '{' 'TOKEN_MGR_DECLS' '>>=' :)
          or $state[$p:lk] = 714610                         (: '{' 'false' '>>=' :)
          or $state[$p:lk] = 716402                         (: '{' 'null' '>>=' :)
          or $state[$p:lk] = 718066                         (: '{' 'this' '>>=' :)
          or $state[$p:lk] = 718578                         (: '{' 'true' '>>=' :)
          or $state[$p:lk] = 721138                         (: '{' IDENTIFIER '>>>=' :)
          or $state[$p:lk] = 721522                         (: '{' INTEGER_LITERAL '>>>=' :)
          or $state[$p:lk] = 721650                         (: '{' FLOATING_POINT_LITERAL '>>>=' :)
          or $state[$p:lk] = 721778                         (: '{' CHARACTER_LITERAL '>>>=' :)
          or $state[$p:lk] = 721906                         (: '{' STRING_LITERAL '>>>=' :)
          or $state[$p:lk] = 727026                         (: '{' 'EOF' '>>>=' :)
          or $state[$p:lk] = 727154                         (: '{' 'IGNORE_CASE' '>>>=' :)
          or $state[$p:lk] = 727282                         (: '{' 'JAVACODE' '>>>=' :)
          or $state[$p:lk] = 727410                         (: '{' 'LOOKAHEAD' '>>>=' :)
          or $state[$p:lk] = 727538                         (: '{' 'MORE' '>>>=' :)
          or $state[$p:lk] = 727666                         (: '{' 'PARSER_BEGIN' '>>>=' :)
          or $state[$p:lk] = 727794                         (: '{' 'PARSER_END' '>>>=' :)
          or $state[$p:lk] = 727922                         (: '{' 'SKIP' '>>>=' :)
          or $state[$p:lk] = 728050                         (: '{' 'SPECIAL_TOKEN' '>>>=' :)
          or $state[$p:lk] = 728178                         (: '{' 'TOKEN' '>>>=' :)
          or $state[$p:lk] = 728306                         (: '{' 'TOKEN_MGR_DECLS' '>>>=' :)
          or $state[$p:lk] = 730994                         (: '{' 'false' '>>>=' :)
          or $state[$p:lk] = 732786                         (: '{' 'null' '>>>=' :)
          or $state[$p:lk] = 734450                         (: '{' 'this' '>>>=' :)
          or $state[$p:lk] = 734962                         (: '{' 'true' '>>>=' :)
          or $state[$p:lk] = 772466                         (: '{' '(' 'EOF' :)
          or $state[$p:lk] = 773106                         (: '{' '++' 'EOF' :)
          or $state[$p:lk] = 773618                         (: '{' '--' 'EOF' :)
          or $state[$p:lk] = 788850                         (: '{' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 789490                         (: '{' '++' 'IGNORE_CASE' :)
          or $state[$p:lk] = 790002                         (: '{' '--' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805234                         (: '{' '(' 'JAVACODE' :)
          or $state[$p:lk] = 805874                         (: '{' '++' 'JAVACODE' :)
          or $state[$p:lk] = 806386                         (: '{' '--' 'JAVACODE' :)
          or $state[$p:lk] = 821618                         (: '{' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 822258                         (: '{' '++' 'LOOKAHEAD' :)
          or $state[$p:lk] = 822770                         (: '{' '--' 'LOOKAHEAD' :)
          or $state[$p:lk] = 838002                         (: '{' '(' 'MORE' :)
          or $state[$p:lk] = 838642                         (: '{' '++' 'MORE' :)
          or $state[$p:lk] = 839154                         (: '{' '--' 'MORE' :)
          or $state[$p:lk] = 854386                         (: '{' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 855026                         (: '{' '++' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 855538                         (: '{' '--' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870770                         (: '{' '(' 'PARSER_END' :)
          or $state[$p:lk] = 871410                         (: '{' '++' 'PARSER_END' :)
          or $state[$p:lk] = 871922                         (: '{' '--' 'PARSER_END' :)
          or $state[$p:lk] = 887154                         (: '{' '(' 'SKIP' :)
          or $state[$p:lk] = 887794                         (: '{' '++' 'SKIP' :)
          or $state[$p:lk] = 888306                         (: '{' '--' 'SKIP' :)
          or $state[$p:lk] = 903538                         (: '{' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 904178                         (: '{' '++' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 904690                         (: '{' '--' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919922                         (: '{' '(' 'TOKEN' :)
          or $state[$p:lk] = 920562                         (: '{' '++' 'TOKEN' :)
          or $state[$p:lk] = 921074                         (: '{' '--' 'TOKEN' :)
          or $state[$p:lk] = 936306                         (: '{' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 936946                         (: '{' '++' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 937458                         (: '{' '--' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 950514                         (: '{' IDENTIFIER '[' :)
          or $state[$p:lk] = 950898                         (: '{' INTEGER_LITERAL '[' :)
          or $state[$p:lk] = 951026                         (: '{' FLOATING_POINT_LITERAL '[' :)
          or $state[$p:lk] = 951154                         (: '{' CHARACTER_LITERAL '[' :)
          or $state[$p:lk] = 951282                         (: '{' STRING_LITERAL '[' :)
          or $state[$p:lk] = 956402                         (: '{' 'EOF' '[' :)
          or $state[$p:lk] = 956530                         (: '{' 'IGNORE_CASE' '[' :)
          or $state[$p:lk] = 956658                         (: '{' 'JAVACODE' '[' :)
          or $state[$p:lk] = 956786                         (: '{' 'LOOKAHEAD' '[' :)
          or $state[$p:lk] = 956914                         (: '{' 'MORE' '[' :)
          or $state[$p:lk] = 957042                         (: '{' 'PARSER_BEGIN' '[' :)
          or $state[$p:lk] = 957170                         (: '{' 'PARSER_END' '[' :)
          or $state[$p:lk] = 957298                         (: '{' 'SKIP' '[' :)
          or $state[$p:lk] = 957426                         (: '{' 'SPECIAL_TOKEN' '[' :)
          or $state[$p:lk] = 957554                         (: '{' 'TOKEN' '[' :)
          or $state[$p:lk] = 957682                         (: '{' 'TOKEN_MGR_DECLS' '[' :)
          or $state[$p:lk] = 958578                         (: '{' 'boolean' '[' :)
          or $state[$p:lk] = 958834                         (: '{' 'byte' '[' :)
          or $state[$p:lk] = 959218                         (: '{' 'char' '[' :)
          or $state[$p:lk] = 959858                         (: '{' 'double' '[' :)
          or $state[$p:lk] = 960370                         (: '{' 'false' '[' :)
          or $state[$p:lk] = 960754                         (: '{' 'float' '[' :)
          or $state[$p:lk] = 961522                         (: '{' 'int' '[' :)
          or $state[$p:lk] = 961778                         (: '{' 'long' '[' :)
          or $state[$p:lk] = 962162                         (: '{' 'null' '[' :)
          or $state[$p:lk] = 963058                         (: '{' 'short' '[' :)
          or $state[$p:lk] = 963826                         (: '{' 'this' '[' :)
          or $state[$p:lk] = 964338                         (: '{' 'true' '[' :)
          or $state[$p:lk] = 999666                         (: '{' IDENTIFIER '^=' :)
          or $state[$p:lk] = 1000050                        (: '{' INTEGER_LITERAL '^=' :)
          or $state[$p:lk] = 1000178                        (: '{' FLOATING_POINT_LITERAL '^=' :)
          or $state[$p:lk] = 1000306                        (: '{' CHARACTER_LITERAL '^=' :)
          or $state[$p:lk] = 1000434                        (: '{' STRING_LITERAL '^=' :)
          or $state[$p:lk] = 1005554                        (: '{' 'EOF' '^=' :)
          or $state[$p:lk] = 1005682                        (: '{' 'IGNORE_CASE' '^=' :)
          or $state[$p:lk] = 1005810                        (: '{' 'JAVACODE' '^=' :)
          or $state[$p:lk] = 1005938                        (: '{' 'LOOKAHEAD' '^=' :)
          or $state[$p:lk] = 1006066                        (: '{' 'MORE' '^=' :)
          or $state[$p:lk] = 1006194                        (: '{' 'PARSER_BEGIN' '^=' :)
          or $state[$p:lk] = 1006322                        (: '{' 'PARSER_END' '^=' :)
          or $state[$p:lk] = 1006450                        (: '{' 'SKIP' '^=' :)
          or $state[$p:lk] = 1006578                        (: '{' 'SPECIAL_TOKEN' '^=' :)
          or $state[$p:lk] = 1006706                        (: '{' 'TOKEN' '^=' :)
          or $state[$p:lk] = 1006834                        (: '{' 'TOKEN_MGR_DECLS' '^=' :)
          or $state[$p:lk] = 1009522                        (: '{' 'false' '^=' :)
          or $state[$p:lk] = 1011314                        (: '{' 'null' '^=' :)
          or $state[$p:lk] = 1012978                        (: '{' 'this' '^=' :)
          or $state[$p:lk] = 1013490                        (: '{' 'true' '^=' :)
          or $state[$p:lk] = 1050994                        (: '{' '(' 'boolean' :)
          or $state[$p:lk] = 1051634                        (: '{' '++' 'boolean' :)
          or $state[$p:lk] = 1052146                        (: '{' '--' 'boolean' :)
          or $state[$p:lk] = 1060338                        (: '{' 'new' 'boolean' :)
          or $state[$p:lk] = 1083762                        (: '{' '(' 'byte' :)
          or $state[$p:lk] = 1084402                        (: '{' '++' 'byte' :)
          or $state[$p:lk] = 1084914                        (: '{' '--' 'byte' :)
          or $state[$p:lk] = 1093106                        (: '{' 'new' 'byte' :)
          or $state[$p:lk] = 1132914                        (: '{' '(' 'char' :)
          or $state[$p:lk] = 1133554                        (: '{' '++' 'char' :)
          or $state[$p:lk] = 1134066                        (: '{' '--' 'char' :)
          or $state[$p:lk] = 1142258                        (: '{' 'new' 'char' :)
          or $state[$p:lk] = 1214834                        (: '{' '(' 'double' :)
          or $state[$p:lk] = 1215474                        (: '{' '++' 'double' :)
          or $state[$p:lk] = 1215986                        (: '{' '--' 'double' :)
          or $state[$p:lk] = 1224178                        (: '{' 'new' 'double' :)
          or $state[$p:lk] = 1280370                        (: '{' '(' 'false' :)
          or $state[$p:lk] = 1281010                        (: '{' '++' 'false' :)
          or $state[$p:lk] = 1281522                        (: '{' '--' 'false' :)
          or $state[$p:lk] = 1329522                        (: '{' '(' 'float' :)
          or $state[$p:lk] = 1330162                        (: '{' '++' 'float' :)
          or $state[$p:lk] = 1330674                        (: '{' '--' 'float' :)
          or $state[$p:lk] = 1338866                        (: '{' 'new' 'float' :)
          or $state[$p:lk] = 1427826                        (: '{' '(' 'int' :)
          or $state[$p:lk] = 1428466                        (: '{' '++' 'int' :)
          or $state[$p:lk] = 1428978                        (: '{' '--' 'int' :)
          or $state[$p:lk] = 1437170                        (: '{' 'new' 'int' :)
          or $state[$p:lk] = 1460594                        (: '{' '(' 'long' :)
          or $state[$p:lk] = 1461234                        (: '{' '++' 'long' :)
          or $state[$p:lk] = 1461746                        (: '{' '--' 'long' :)
          or $state[$p:lk] = 1469938                        (: '{' 'new' 'long' :)
          or $state[$p:lk] = 1493362                        (: '{' '(' 'new' :)
          or $state[$p:lk] = 1494002                        (: '{' '++' 'new' :)
          or $state[$p:lk] = 1494514                        (: '{' '--' 'new' :)
          or $state[$p:lk] = 1509746                        (: '{' '(' 'null' :)
          or $state[$p:lk] = 1510386                        (: '{' '++' 'null' :)
          or $state[$p:lk] = 1510898                        (: '{' '--' 'null' :)
          or $state[$p:lk] = 1624434                        (: '{' '(' 'short' :)
          or $state[$p:lk] = 1625074                        (: '{' '++' 'short' :)
          or $state[$p:lk] = 1625586                        (: '{' '--' 'short' :)
          or $state[$p:lk] = 1633778                        (: '{' 'new' 'short' :)
          or $state[$p:lk] = 1673586                        (: '{' '(' 'super' :)
          or $state[$p:lk] = 1674226                        (: '{' '++' 'super' :)
          or $state[$p:lk] = 1674738                        (: '{' '--' 'super' :)
          or $state[$p:lk] = 1722738                        (: '{' '(' 'this' :)
          or $state[$p:lk] = 1723378                        (: '{' '++' 'this' :)
          or $state[$p:lk] = 1723890                        (: '{' '--' 'this' :)
          or $state[$p:lk] = 1788274                        (: '{' '(' 'true' :)
          or $state[$p:lk] = 1788914                        (: '{' '++' 'true' :)
          or $state[$p:lk] = 1789426                        (: '{' '--' 'true' :)
          or $state[$p:lk] = 1821042                        (: '{' '(' 'void' :)
          or $state[$p:lk] = 1821682                        (: '{' '++' 'void' :)
          or $state[$p:lk] = 1822194                        (: '{' '--' 'void' :)
          or $state[$p:lk] = 1900786                        (: '{' IDENTIFIER '|=' :)
          or $state[$p:lk] = 1901170                        (: '{' INTEGER_LITERAL '|=' :)
          or $state[$p:lk] = 1901298                        (: '{' FLOATING_POINT_LITERAL '|=' :)
          or $state[$p:lk] = 1901426                        (: '{' CHARACTER_LITERAL '|=' :)
          or $state[$p:lk] = 1901554                        (: '{' STRING_LITERAL '|=' :)
          or $state[$p:lk] = 1906674                        (: '{' 'EOF' '|=' :)
          or $state[$p:lk] = 1906802                        (: '{' 'IGNORE_CASE' '|=' :)
          or $state[$p:lk] = 1906930                        (: '{' 'JAVACODE' '|=' :)
          or $state[$p:lk] = 1907058                        (: '{' 'LOOKAHEAD' '|=' :)
          or $state[$p:lk] = 1907186                        (: '{' 'MORE' '|=' :)
          or $state[$p:lk] = 1907314                        (: '{' 'PARSER_BEGIN' '|=' :)
          or $state[$p:lk] = 1907442                        (: '{' 'PARSER_END' '|=' :)
          or $state[$p:lk] = 1907570                        (: '{' 'SKIP' '|=' :)
          or $state[$p:lk] = 1907698                        (: '{' 'SPECIAL_TOKEN' '|=' :)
          or $state[$p:lk] = 1907826                        (: '{' 'TOKEN' '|=' :)
          or $state[$p:lk] = 1907954                        (: '{' 'TOKEN_MGR_DECLS' '|=' :)
          or $state[$p:lk] = 1910642                        (: '{' 'false' '|=' :)
          or $state[$p:lk] = 1912434                        (: '{' 'null' '|=' :)
          or $state[$p:lk] = 1914098                        (: '{' 'this' '|=' :)
          or $state[$p:lk] = 1914610                        (: '{' 'true' '|=' :)
          or $state[$p:lk] = 1952114) then                  (: '{' '(' '~' :)
      let $state := p:memoized($state, 4)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expansion_choices($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 1                              (: IDENTIFIER :)
          or $state[$p:lk] = 4                              (: INTEGER_LITERAL :)
          or $state[$p:lk] = 5                              (: FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 6                              (: CHARACTER_LITERAL :)
          or $state[$p:lk] = 7                              (: STRING_LITERAL :)
          or $state[$p:lk] = 18                             (: '(' :)
          or $state[$p:lk] = 35                             (: '<' :)
          or $state[$p:lk] = 47                             (: 'EOF' :)
          or $state[$p:lk] = 48                             (: 'IGNORE_CASE' :)
          or $state[$p:lk] = 49                             (: 'JAVACODE' :)
          or $state[$p:lk] = 50                             (: 'LOOKAHEAD' :)
          or $state[$p:lk] = 51                             (: 'MORE' :)
          or $state[$p:lk] = 52                             (: 'PARSER_BEGIN' :)
          or $state[$p:lk] = 53                             (: 'PARSER_END' :)
          or $state[$p:lk] = 54                             (: 'SKIP' :)
          or $state[$p:lk] = 55                             (: 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 56                             (: 'TOKEN' :)
          or $state[$p:lk] = 57                             (: 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 58                             (: '[' :)
          or $state[$p:lk] = 64                             (: 'boolean' :)
          or $state[$p:lk] = 66                             (: 'byte' :)
          or $state[$p:lk] = 69                             (: 'char' :)
          or $state[$p:lk] = 74                             (: 'double' :)
          or $state[$p:lk] = 78                             (: 'false' :)
          or $state[$p:lk] = 81                             (: 'float' :)
          or $state[$p:lk] = 87                             (: 'int' :)
          or $state[$p:lk] = 89                             (: 'long' :)
          or $state[$p:lk] = 91                             (: 'new' :)
          or $state[$p:lk] = 92                             (: 'null' :)
          or $state[$p:lk] = 99                             (: 'short' :)
          or $state[$p:lk] = 102                            (: 'super' :)
          or $state[$p:lk] = 105                            (: 'this' :)
          or $state[$p:lk] = 109                            (: 'true' :)
          or $state[$p:lk] = 110                            (: 'try' :)
          or $state[$p:lk] = 111                            (: 'void' :)
          or $state[$p:lk] = 4466                           (: '{' ';' :)
          or $state[$p:lk] = 6002                           (: '{' '@' :)
          or $state[$p:lk] = 8050                           (: '{' 'abstract' :)
          or $state[$p:lk] = 8178                           (: '{' 'assert' :)
          or $state[$p:lk] = 8434                           (: '{' 'break' :)
          or $state[$p:lk] = 9074                           (: '{' 'class' :)
          or $state[$p:lk] = 9202                           (: '{' 'continue' :)
          or $state[$p:lk] = 9458                           (: '{' 'do' :)
          or $state[$p:lk] = 10226                          (: '{' 'final' :)
          or $state[$p:lk] = 10610                          (: '{' 'for' :)
          or $state[$p:lk] = 10738                          (: '{' 'if' :)
          or $state[$p:lk] = 11378                          (: '{' 'interface' :)
          or $state[$p:lk] = 11634                          (: '{' 'native' :)
          or $state[$p:lk] = 12274                          (: '{' 'private' :)
          or $state[$p:lk] = 12402                          (: '{' 'protected' :)
          or $state[$p:lk] = 12530                          (: '{' 'public' :)
          or $state[$p:lk] = 12658                          (: '{' 'return' :)
          or $state[$p:lk] = 12914                          (: '{' 'static' :)
          or $state[$p:lk] = 13042                          (: '{' 'strictfp' :)
          or $state[$p:lk] = 13298                          (: '{' 'switch' :)
          or $state[$p:lk] = 13426                          (: '{' 'synchronized' :)
          or $state[$p:lk] = 13682                          (: '{' 'throw' :)
          or $state[$p:lk] = 13938                          (: '{' 'transient' :)
          or $state[$p:lk] = 14194                          (: '{' 'try' :)
          or $state[$p:lk] = 14450                          (: '{' 'volatile' :)
          or $state[$p:lk] = 14578                          (: '{' 'while' :)
          or $state[$p:lk] = 14706                          (: '{' '{' :)
          or $state[$p:lk] = 16626                          (: '{' IDENTIFIER IDENTIFIER :)
          or $state[$p:lk] = 24690                          (: '{' 'boolean' IDENTIFIER :)
          or $state[$p:lk] = 24946                          (: '{' 'byte' IDENTIFIER :)
          or $state[$p:lk] = 25330                          (: '{' 'char' IDENTIFIER :)
          or $state[$p:lk] = 25970                          (: '{' 'double' IDENTIFIER :)
          or $state[$p:lk] = 26866                          (: '{' 'float' IDENTIFIER :)
          or $state[$p:lk] = 27634                          (: '{' 'int' IDENTIFIER :)
          or $state[$p:lk] = 27890                          (: '{' 'long' IDENTIFIER :)
          or $state[$p:lk] = 29170                          (: '{' 'short' IDENTIFIER :)
          or $state[$p:lk] = 31602                          (: '{' '}' IDENTIFIER :)
          or $state[$p:lk] = 80754                          (: '{' '}' INTEGER_LITERAL :)
          or $state[$p:lk] = 97138                          (: '{' '}' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 113522                         (: '{' '}' CHARACTER_LITERAL :)
          or $state[$p:lk] = 129906                         (: '{' '}' STRING_LITERAL :)
          or $state[$p:lk] = 310130                         (: '{' '}' '(' :)
          or $state[$p:lk] = 424818                         (: '{' '}' ',' :)
          or $state[$p:lk] = 540914                         (: '{' IDENTIFIER ':' :)
          or $state[$p:lk] = 557298                         (: '{' IDENTIFIER ';' :)
          or $state[$p:lk] = 557682                         (: '{' INTEGER_LITERAL ';' :)
          or $state[$p:lk] = 557810                         (: '{' FLOATING_POINT_LITERAL ';' :)
          or $state[$p:lk] = 557938                         (: '{' CHARACTER_LITERAL ';' :)
          or $state[$p:lk] = 558066                         (: '{' STRING_LITERAL ';' :)
          or $state[$p:lk] = 563186                         (: '{' 'EOF' ';' :)
          or $state[$p:lk] = 563314                         (: '{' 'IGNORE_CASE' ';' :)
          or $state[$p:lk] = 563442                         (: '{' 'JAVACODE' ';' :)
          or $state[$p:lk] = 563570                         (: '{' 'LOOKAHEAD' ';' :)
          or $state[$p:lk] = 563698                         (: '{' 'MORE' ';' :)
          or $state[$p:lk] = 563826                         (: '{' 'PARSER_BEGIN' ';' :)
          or $state[$p:lk] = 563954                         (: '{' 'PARSER_END' ';' :)
          or $state[$p:lk] = 564082                         (: '{' 'SKIP' ';' :)
          or $state[$p:lk] = 564210                         (: '{' 'SPECIAL_TOKEN' ';' :)
          or $state[$p:lk] = 564338                         (: '{' 'TOKEN' ';' :)
          or $state[$p:lk] = 564466                         (: '{' 'TOKEN_MGR_DECLS' ';' :)
          or $state[$p:lk] = 567154                         (: '{' 'false' ';' :)
          or $state[$p:lk] = 568946                         (: '{' 'null' ';' :)
          or $state[$p:lk] = 570610                         (: '{' 'this' ';' :)
          or $state[$p:lk] = 571122                         (: '{' 'true' ';' :)
          or $state[$p:lk] = 588658                         (: '{' '}' '<' :)
          or $state[$p:lk] = 785266                         (: '{' '}' 'EOF' :)
          or $state[$p:lk] = 801650                         (: '{' '}' 'IGNORE_CASE' :)
          or $state[$p:lk] = 818034                         (: '{' '}' 'JAVACODE' :)
          or $state[$p:lk] = 834418                         (: '{' '}' 'LOOKAHEAD' :)
          or $state[$p:lk] = 850802                         (: '{' '}' 'MORE' :)
          or $state[$p:lk] = 867186                         (: '{' '}' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 883570                         (: '{' '}' 'PARSER_END' :)
          or $state[$p:lk] = 899954                         (: '{' '}' 'SKIP' :)
          or $state[$p:lk] = 916338                         (: '{' '}' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 932722                         (: '{' '}' 'TOKEN' :)
          or $state[$p:lk] = 949106                         (: '{' '}' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 965490                         (: '{' '}' '[' :)
          or $state[$p:lk] = 1063794                        (: '{' '}' 'boolean' :)
          or $state[$p:lk] = 1096562                        (: '{' '}' 'byte' :)
          or $state[$p:lk] = 1145714                        (: '{' '}' 'char' :)
          or $state[$p:lk] = 1227634                        (: '{' '}' 'double' :)
          or $state[$p:lk] = 1293170                        (: '{' '}' 'false' :)
          or $state[$p:lk] = 1342322                        (: '{' '}' 'float' :)
          or $state[$p:lk] = 1440626                        (: '{' '}' 'int' :)
          or $state[$p:lk] = 1473394                        (: '{' '}' 'long' :)
          or $state[$p:lk] = 1506162                        (: '{' '}' 'new' :)
          or $state[$p:lk] = 1522546                        (: '{' '}' 'null' :)
          or $state[$p:lk] = 1637234                        (: '{' '}' 'short' :)
          or $state[$p:lk] = 1686386                        (: '{' '}' 'super' :)
          or $state[$p:lk] = 1735538                        (: '{' '}' 'this' :)
          or $state[$p:lk] = 1801074                        (: '{' '}' 'true' :)
          or $state[$p:lk] = 1817458                        (: '{' '}' 'try' :)
          or $state[$p:lk] = 1833842                        (: '{' '}' 'void' :)
          or $state[$p:lk] = 1882994                        (: '{' '}' '{' :)
          or $state[$p:lk] = 1899378) then                  (: '{' '}' '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expansion_choices($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consume(25, $input, $state)           (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state := p:consume(114, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(148, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '}' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 118) then                 (: '}' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(118, $input, $state)          (: '}' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "local_lookahead", $count, $begin, $end)
};

(:~
 : Try parsing local_lookahead.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-local_lookahead($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 4) then                            (: INTEGER_LITERAL :)
      let $state := p:lookahead2W(152, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | '<' | '=' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state :=
        if ($state[$p:lk] eq 2308) then                     (: INTEGER_LITERAL '(' :)
          let $state := p:lookahead3W(160, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else if ($state[$p:lk] eq 7428) then                (: INTEGER_LITERAL '[' :)
          let $state := p:lookahead3W(157, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18692                          (: INTEGER_LITERAL '(' IDENTIFIER :)
          or $state[$p:lk] = 23812                          (: INTEGER_LITERAL '[' IDENTIFIER :)
          or $state[$p:lk] = 67844                          (: INTEGER_LITERAL '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 72964                          (: INTEGER_LITERAL '[' INTEGER_LITERAL :)
          or $state[$p:lk] = 84228                          (: INTEGER_LITERAL '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 89348                          (: INTEGER_LITERAL '[' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100612                         (: INTEGER_LITERAL '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 105732                         (: INTEGER_LITERAL '[' CHARACTER_LITERAL :)
          or $state[$p:lk] = 116996                         (: INTEGER_LITERAL '(' STRING_LITERAL :)
          or $state[$p:lk] = 122116                         (: INTEGER_LITERAL '[' STRING_LITERAL :)
          or $state[$p:lk] = 166148                         (: INTEGER_LITERAL '(' '!' :)
          or $state[$p:lk] = 297220                         (: INTEGER_LITERAL '(' '(' :)
          or $state[$p:lk] = 302340                         (: INTEGER_LITERAL '[' '(' :)
          or $state[$p:lk] = 362756                         (: INTEGER_LITERAL '(' '+' :)
          or $state[$p:lk] = 379140                         (: INTEGER_LITERAL '(' '++' :)
          or $state[$p:lk] = 428292                         (: INTEGER_LITERAL '(' '-' :)
          or $state[$p:lk] = 444676                         (: INTEGER_LITERAL '(' '--' :)
          or $state[$p:lk] = 772356                         (: INTEGER_LITERAL '(' 'EOF' :)
          or $state[$p:lk] = 777476                         (: INTEGER_LITERAL '[' 'EOF' :)
          or $state[$p:lk] = 788740                         (: INTEGER_LITERAL '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 793860                         (: INTEGER_LITERAL '[' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805124                         (: INTEGER_LITERAL '(' 'JAVACODE' :)
          or $state[$p:lk] = 810244                         (: INTEGER_LITERAL '[' 'JAVACODE' :)
          or $state[$p:lk] = 821508                         (: INTEGER_LITERAL '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 826628                         (: INTEGER_LITERAL '[' 'LOOKAHEAD' :)
          or $state[$p:lk] = 837892                         (: INTEGER_LITERAL '(' 'MORE' :)
          or $state[$p:lk] = 843012                         (: INTEGER_LITERAL '[' 'MORE' :)
          or $state[$p:lk] = 854276                         (: INTEGER_LITERAL '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 859396                         (: INTEGER_LITERAL '[' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870660                         (: INTEGER_LITERAL '(' 'PARSER_END' :)
          or $state[$p:lk] = 875780                         (: INTEGER_LITERAL '[' 'PARSER_END' :)
          or $state[$p:lk] = 887044                         (: INTEGER_LITERAL '(' 'SKIP' :)
          or $state[$p:lk] = 892164                         (: INTEGER_LITERAL '[' 'SKIP' :)
          or $state[$p:lk] = 903428                         (: INTEGER_LITERAL '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 908548                         (: INTEGER_LITERAL '[' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919812                         (: INTEGER_LITERAL '(' 'TOKEN' :)
          or $state[$p:lk] = 924932                         (: INTEGER_LITERAL '[' 'TOKEN' :)
          or $state[$p:lk] = 936196                         (: INTEGER_LITERAL '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 941316                         (: INTEGER_LITERAL '[' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 1050884                        (: INTEGER_LITERAL '(' 'boolean' :)
          or $state[$p:lk] = 1056004                        (: INTEGER_LITERAL '[' 'boolean' :)
          or $state[$p:lk] = 1083652                        (: INTEGER_LITERAL '(' 'byte' :)
          or $state[$p:lk] = 1088772                        (: INTEGER_LITERAL '[' 'byte' :)
          or $state[$p:lk] = 1132804                        (: INTEGER_LITERAL '(' 'char' :)
          or $state[$p:lk] = 1137924                        (: INTEGER_LITERAL '[' 'char' :)
          or $state[$p:lk] = 1214724                        (: INTEGER_LITERAL '(' 'double' :)
          or $state[$p:lk] = 1219844                        (: INTEGER_LITERAL '[' 'double' :)
          or $state[$p:lk] = 1280260                        (: INTEGER_LITERAL '(' 'false' :)
          or $state[$p:lk] = 1285380                        (: INTEGER_LITERAL '[' 'false' :)
          or $state[$p:lk] = 1329412                        (: INTEGER_LITERAL '(' 'float' :)
          or $state[$p:lk] = 1334532                        (: INTEGER_LITERAL '[' 'float' :)
          or $state[$p:lk] = 1427716                        (: INTEGER_LITERAL '(' 'int' :)
          or $state[$p:lk] = 1432836                        (: INTEGER_LITERAL '[' 'int' :)
          or $state[$p:lk] = 1460484                        (: INTEGER_LITERAL '(' 'long' :)
          or $state[$p:lk] = 1465604                        (: INTEGER_LITERAL '[' 'long' :)
          or $state[$p:lk] = 1493252                        (: INTEGER_LITERAL '(' 'new' :)
          or $state[$p:lk] = 1498372                        (: INTEGER_LITERAL '[' 'new' :)
          or $state[$p:lk] = 1509636                        (: INTEGER_LITERAL '(' 'null' :)
          or $state[$p:lk] = 1514756                        (: INTEGER_LITERAL '[' 'null' :)
          or $state[$p:lk] = 1624324                        (: INTEGER_LITERAL '(' 'short' :)
          or $state[$p:lk] = 1629444                        (: INTEGER_LITERAL '[' 'short' :)
          or $state[$p:lk] = 1673476                        (: INTEGER_LITERAL '(' 'super' :)
          or $state[$p:lk] = 1678596                        (: INTEGER_LITERAL '[' 'super' :)
          or $state[$p:lk] = 1722628                        (: INTEGER_LITERAL '(' 'this' :)
          or $state[$p:lk] = 1727748                        (: INTEGER_LITERAL '[' 'this' :)
          or $state[$p:lk] = 1788164                        (: INTEGER_LITERAL '(' 'true' :)
          or $state[$p:lk] = 1793284                        (: INTEGER_LITERAL '[' 'true' :)
          or $state[$p:lk] = 1820932                        (: INTEGER_LITERAL '(' 'void' :)
          or $state[$p:lk] = 1826052                        (: INTEGER_LITERAL '[' 'void' :)
          or $state[$p:lk] = 1952004) then                  (: INTEGER_LITERAL '(' '~' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-IntegerLiteral($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 132                            (: INTEGER_LITERAL IDENTIFIER :)
          or $state[$p:lk] = 516                            (: INTEGER_LITERAL INTEGER_LITERAL :)
          or $state[$p:lk] = 644                            (: INTEGER_LITERAL FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 772                            (: INTEGER_LITERAL CHARACTER_LITERAL :)
          or $state[$p:lk] = 900                            (: INTEGER_LITERAL STRING_LITERAL :)
          or $state[$p:lk] = 2436                           (: INTEGER_LITERAL ')' :)
          or $state[$p:lk] = 3204                           (: INTEGER_LITERAL ',' :)
          or $state[$p:lk] = 4484                           (: INTEGER_LITERAL '<' :)
          or $state[$p:lk] = 6020                           (: INTEGER_LITERAL 'EOF' :)
          or $state[$p:lk] = 6148                           (: INTEGER_LITERAL 'IGNORE_CASE' :)
          or $state[$p:lk] = 6276                           (: INTEGER_LITERAL 'JAVACODE' :)
          or $state[$p:lk] = 6404                           (: INTEGER_LITERAL 'LOOKAHEAD' :)
          or $state[$p:lk] = 6532                           (: INTEGER_LITERAL 'MORE' :)
          or $state[$p:lk] = 6660                           (: INTEGER_LITERAL 'PARSER_BEGIN' :)
          or $state[$p:lk] = 6788                           (: INTEGER_LITERAL 'PARSER_END' :)
          or $state[$p:lk] = 6916                           (: INTEGER_LITERAL 'SKIP' :)
          or $state[$p:lk] = 7044                           (: INTEGER_LITERAL 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 7172                           (: INTEGER_LITERAL 'TOKEN' :)
          or $state[$p:lk] = 7300                           (: INTEGER_LITERAL 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 8196                           (: INTEGER_LITERAL 'boolean' :)
          or $state[$p:lk] = 8452                           (: INTEGER_LITERAL 'byte' :)
          or $state[$p:lk] = 8836                           (: INTEGER_LITERAL 'char' :)
          or $state[$p:lk] = 9476                           (: INTEGER_LITERAL 'double' :)
          or $state[$p:lk] = 9988                           (: INTEGER_LITERAL 'false' :)
          or $state[$p:lk] = 10372                          (: INTEGER_LITERAL 'float' :)
          or $state[$p:lk] = 11140                          (: INTEGER_LITERAL 'int' :)
          or $state[$p:lk] = 11396                          (: INTEGER_LITERAL 'long' :)
          or $state[$p:lk] = 11652                          (: INTEGER_LITERAL 'new' :)
          or $state[$p:lk] = 11780                          (: INTEGER_LITERAL 'null' :)
          or $state[$p:lk] = 12676                          (: INTEGER_LITERAL 'short' :)
          or $state[$p:lk] = 13060                          (: INTEGER_LITERAL 'super' :)
          or $state[$p:lk] = 13444                          (: INTEGER_LITERAL 'this' :)
          or $state[$p:lk] = 13956                          (: INTEGER_LITERAL 'true' :)
          or $state[$p:lk] = 14084                          (: INTEGER_LITERAL 'try' :)
          or $state[$p:lk] = 14212                          (: INTEGER_LITERAL 'void' :)
          or $state[$p:lk] = 14596                          (: INTEGER_LITERAL '{' :)
          or $state[$p:lk] = 575748                         (: INTEGER_LITERAL '(' '<' :)
          or $state[$p:lk] = 580868                         (: INTEGER_LITERAL '[' '<' :)
          or $state[$p:lk] = 952580                         (: INTEGER_LITERAL '(' '[' :)
          or $state[$p:lk] = 957700                         (: INTEGER_LITERAL '[' '[' :)
          or $state[$p:lk] = 1804548                        (: INTEGER_LITERAL '(' 'try' :)
          or $state[$p:lk] = 1809668                        (: INTEGER_LITERAL '[' 'try' :)
          or $state[$p:lk] = 1870084                        (: INTEGER_LITERAL '(' '{' :)
          or $state[$p:lk] = 1875204) then                  (: INTEGER_LITERAL '[' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-IntegerLiteral($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
  let $state :=
    if ($state[$p:l1] eq 25) then                           (: ',' :)
      let $state := p:lookahead2W(140, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state :=
        if ($state[$p:lk] eq 2457) then                     (: ',' ')' :)
          let $state := p:lookahead3W(156, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
          return $state
        else if ($state[$p:lk] eq 14617) then               (: ',' '{' :)
          let $state := p:lookahead3W(171, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18841                          (: ',' ')' IDENTIFIER :)
          or $state[$p:lk] = 31001                          (: ',' '{' IDENTIFIER :)
          or $state[$p:lk] = 67993                          (: ',' ')' INTEGER_LITERAL :)
          or $state[$p:lk] = 80153                          (: ',' '{' INTEGER_LITERAL :)
          or $state[$p:lk] = 84377                          (: ',' ')' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 96537                          (: ',' '{' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100761                         (: ',' ')' CHARACTER_LITERAL :)
          or $state[$p:lk] = 112921                         (: ',' '{' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117145                         (: ',' ')' STRING_LITERAL :)
          or $state[$p:lk] = 129305                         (: ',' '{' STRING_LITERAL :)
          or $state[$p:lk] = 178457                         (: ',' '{' '!' :)
          or $state[$p:lk] = 297369                         (: ',' ')' '(' :)
          or $state[$p:lk] = 309529                         (: ',' '{' '(' :)
          or $state[$p:lk] = 313753                         (: ',' ')' ')' :)
          or $state[$p:lk] = 375065                         (: ',' '{' '+' :)
          or $state[$p:lk] = 391449                         (: ',' '{' '++' :)
          or $state[$p:lk] = 412057                         (: ',' ')' ',' :)
          or $state[$p:lk] = 440601                         (: ',' '{' '-' :)
          or $state[$p:lk] = 456985                         (: ',' '{' '--' :)
          or $state[$p:lk] = 575897                         (: ',' ')' '<' :)
          or $state[$p:lk] = 772505                         (: ',' ')' 'EOF' :)
          or $state[$p:lk] = 784665                         (: ',' '{' 'EOF' :)
          or $state[$p:lk] = 788889                         (: ',' ')' 'IGNORE_CASE' :)
          or $state[$p:lk] = 801049                         (: ',' '{' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805273                         (: ',' ')' 'JAVACODE' :)
          or $state[$p:lk] = 817433                         (: ',' '{' 'JAVACODE' :)
          or $state[$p:lk] = 821657                         (: ',' ')' 'LOOKAHEAD' :)
          or $state[$p:lk] = 833817                         (: ',' '{' 'LOOKAHEAD' :)
          or $state[$p:lk] = 838041                         (: ',' ')' 'MORE' :)
          or $state[$p:lk] = 850201                         (: ',' '{' 'MORE' :)
          or $state[$p:lk] = 854425                         (: ',' ')' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 866585                         (: ',' '{' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870809                         (: ',' ')' 'PARSER_END' :)
          or $state[$p:lk] = 882969                         (: ',' '{' 'PARSER_END' :)
          or $state[$p:lk] = 887193                         (: ',' ')' 'SKIP' :)
          or $state[$p:lk] = 899353                         (: ',' '{' 'SKIP' :)
          or $state[$p:lk] = 903577                         (: ',' ')' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 915737                         (: ',' '{' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919961                         (: ',' ')' 'TOKEN' :)
          or $state[$p:lk] = 932121                         (: ',' '{' 'TOKEN' :)
          or $state[$p:lk] = 936345                         (: ',' ')' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 948505                         (: ',' '{' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 952729                         (: ',' ')' '[' :)
          or $state[$p:lk] = 969113                         (: ',' ')' ']' :)
          or $state[$p:lk] = 1051033                        (: ',' ')' 'boolean' :)
          or $state[$p:lk] = 1063193                        (: ',' '{' 'boolean' :)
          or $state[$p:lk] = 1083801                        (: ',' ')' 'byte' :)
          or $state[$p:lk] = 1095961                        (: ',' '{' 'byte' :)
          or $state[$p:lk] = 1132953                        (: ',' ')' 'char' :)
          or $state[$p:lk] = 1145113                        (: ',' '{' 'char' :)
          or $state[$p:lk] = 1214873                        (: ',' ')' 'double' :)
          or $state[$p:lk] = 1227033                        (: ',' '{' 'double' :)
          or $state[$p:lk] = 1280409                        (: ',' ')' 'false' :)
          or $state[$p:lk] = 1292569                        (: ',' '{' 'false' :)
          or $state[$p:lk] = 1329561                        (: ',' ')' 'float' :)
          or $state[$p:lk] = 1341721                        (: ',' '{' 'float' :)
          or $state[$p:lk] = 1427865                        (: ',' ')' 'int' :)
          or $state[$p:lk] = 1440025                        (: ',' '{' 'int' :)
          or $state[$p:lk] = 1460633                        (: ',' ')' 'long' :)
          or $state[$p:lk] = 1472793                        (: ',' '{' 'long' :)
          or $state[$p:lk] = 1493401                        (: ',' ')' 'new' :)
          or $state[$p:lk] = 1505561                        (: ',' '{' 'new' :)
          or $state[$p:lk] = 1509785                        (: ',' ')' 'null' :)
          or $state[$p:lk] = 1521945                        (: ',' '{' 'null' :)
          or $state[$p:lk] = 1624473                        (: ',' ')' 'short' :)
          or $state[$p:lk] = 1636633                        (: ',' '{' 'short' :)
          or $state[$p:lk] = 1673625                        (: ',' ')' 'super' :)
          or $state[$p:lk] = 1685785                        (: ',' '{' 'super' :)
          or $state[$p:lk] = 1722777                        (: ',' ')' 'this' :)
          or $state[$p:lk] = 1734937                        (: ',' '{' 'this' :)
          or $state[$p:lk] = 1788313                        (: ',' ')' 'true' :)
          or $state[$p:lk] = 1800473                        (: ',' '{' 'true' :)
          or $state[$p:lk] = 1804697                        (: ',' ')' 'try' :)
          or $state[$p:lk] = 1821081                        (: ',' ')' 'void' :)
          or $state[$p:lk] = 1833241                        (: ',' '{' 'void' :)
          or $state[$p:lk] = 1870233                        (: ',' ')' '{' :)
          or $state[$p:lk] = 1886617                        (: ',' ')' '|' :)
          or $state[$p:lk] = 1935769                        (: ',' ')' '}' :)
          or $state[$p:lk] = 1947929                        (: ',' '{' '}' :)
          or $state[$p:lk] = 1964313) then                  (: ',' '{' '~' :)
      let $state := p:memoized($state, 3)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(25, $input, $state)      (: ',' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != -2
         and $state[$p:lk] != 1                             (: IDENTIFIER :)
         and $state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 19                            (: ')' :)
         and $state[$p:lk] != 35                            (: '<' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 58                            (: '[' :)
         and $state[$p:lk] != 64                            (: 'boolean' :)
         and $state[$p:lk] != 66                            (: 'byte' :)
         and $state[$p:lk] != 69                            (: 'char' :)
         and $state[$p:lk] != 74                            (: 'double' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 81                            (: 'float' :)
         and $state[$p:lk] != 87                            (: 'int' :)
         and $state[$p:lk] != 89                            (: 'long' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 99                            (: 'short' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 105                           (: 'this' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 110                           (: 'try' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 114) then                     (: '{' :)
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
  let $state :=
    if ($state[$p:l1] eq 114) then                          (: '{' :)
      let $state := p:lookahead2W(171, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 242) then                      (: '{' IDENTIFIER :)
          let $state := p:lookahead3W(153, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                               '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' | '<<' |
                                                               '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' | '>>>=' |
                                                               '?' | '[' | '^' | '^=' | 'instanceof' | '|' | '|=' |
                                                               '||' | '}' :)
          return $state
        else if ($state[$p:lk] eq 2418) then                (: '{' '(' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 11762) then               (: '{' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 15218) then               (: '{' '}' :)
          let $state := p:lookahead3W(149, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' :)
          return $state
        else if ($state[$p:lk] = (3058,                     (: '{' '++' :)
                                  3570)) then               (: '{' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (13170,                    (: '{' 'super' :)
                                  14322)) then              (: '{' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (8306,                     (: '{' 'boolean' :)
                                  8562,                     (: '{' 'byte' :)
                                  8946,                     (: '{' 'char' :)
                                  9586,                     (: '{' 'double' :)
                                  10482,                    (: '{' 'float' :)
                                  11250,                    (: '{' 'int' :)
                                  11506,                    (: '{' 'long' :)
                                  12786)) then              (: '{' 'short' :)
          let $state := p:lookahead3W(55, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
          return $state
        else if ($state[$p:lk] = (626,                      (: '{' INTEGER_LITERAL :)
                                  754,                      (: '{' FLOATING_POINT_LITERAL :)
                                  882,                      (: '{' CHARACTER_LITERAL :)
                                  1010,                     (: '{' STRING_LITERAL :)
                                  6130,                     (: '{' 'EOF' :)
                                  6258,                     (: '{' 'IGNORE_CASE' :)
                                  6386,                     (: '{' 'JAVACODE' :)
                                  6514,                     (: '{' 'LOOKAHEAD' :)
                                  6642,                     (: '{' 'MORE' :)
                                  6770,                     (: '{' 'PARSER_BEGIN' :)
                                  6898,                     (: '{' 'PARSER_END' :)
                                  7026,                     (: '{' 'SKIP' :)
                                  7154,                     (: '{' 'SPECIAL_TOKEN' :)
                                  7282,                     (: '{' 'TOKEN' :)
                                  7410,                     (: '{' 'TOKEN_MGR_DECLS' :)
                                  10098,                    (: '{' 'false' :)
                                  11890,                    (: '{' 'null' :)
                                  13554,                    (: '{' 'this' :)
                                  14066)) then              (: '{' 'true' :)
          let $state := p:lookahead3W(141, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' | '+' |
                                                               '++' | '+=' | '-' | '--' | '-=' | '.' | '/' | '/=' |
                                                               ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18802                          (: '{' '(' IDENTIFIER :)
          or $state[$p:lk] = 19442                          (: '{' '++' IDENTIFIER :)
          or $state[$p:lk] = 19954                          (: '{' '--' IDENTIFIER :)
          or $state[$p:lk] = 28146                          (: '{' 'new' IDENTIFIER :)
          or $state[$p:lk] = 67954                          (: '{' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 68594                          (: '{' '++' INTEGER_LITERAL :)
          or $state[$p:lk] = 69106                          (: '{' '--' INTEGER_LITERAL :)
          or $state[$p:lk] = 84338                          (: '{' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 84978                          (: '{' '++' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 85490                          (: '{' '--' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100722                         (: '{' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 101362                         (: '{' '++' CHARACTER_LITERAL :)
          or $state[$p:lk] = 101874                         (: '{' '--' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117106                         (: '{' '(' STRING_LITERAL :)
          or $state[$p:lk] = 117746                         (: '{' '++' STRING_LITERAL :)
          or $state[$p:lk] = 118258                         (: '{' '--' STRING_LITERAL :)
          or $state[$p:lk] = 166258                         (: '{' '(' '!' :)
          or $state[$p:lk] = 229618                         (: '{' IDENTIFIER '%=' :)
          or $state[$p:lk] = 230002                         (: '{' INTEGER_LITERAL '%=' :)
          or $state[$p:lk] = 230130                         (: '{' FLOATING_POINT_LITERAL '%=' :)
          or $state[$p:lk] = 230258                         (: '{' CHARACTER_LITERAL '%=' :)
          or $state[$p:lk] = 230386                         (: '{' STRING_LITERAL '%=' :)
          or $state[$p:lk] = 235506                         (: '{' 'EOF' '%=' :)
          or $state[$p:lk] = 235634                         (: '{' 'IGNORE_CASE' '%=' :)
          or $state[$p:lk] = 235762                         (: '{' 'JAVACODE' '%=' :)
          or $state[$p:lk] = 235890                         (: '{' 'LOOKAHEAD' '%=' :)
          or $state[$p:lk] = 236018                         (: '{' 'MORE' '%=' :)
          or $state[$p:lk] = 236146                         (: '{' 'PARSER_BEGIN' '%=' :)
          or $state[$p:lk] = 236274                         (: '{' 'PARSER_END' '%=' :)
          or $state[$p:lk] = 236402                         (: '{' 'SKIP' '%=' :)
          or $state[$p:lk] = 236530                         (: '{' 'SPECIAL_TOKEN' '%=' :)
          or $state[$p:lk] = 236658                         (: '{' 'TOKEN' '%=' :)
          or $state[$p:lk] = 236786                         (: '{' 'TOKEN_MGR_DECLS' '%=' :)
          or $state[$p:lk] = 239474                         (: '{' 'false' '%=' :)
          or $state[$p:lk] = 241266                         (: '{' 'null' '%=' :)
          or $state[$p:lk] = 242930                         (: '{' 'this' '%=' :)
          or $state[$p:lk] = 243442                         (: '{' 'true' '%=' :)
          or $state[$p:lk] = 278770                         (: '{' IDENTIFIER '&=' :)
          or $state[$p:lk] = 279154                         (: '{' INTEGER_LITERAL '&=' :)
          or $state[$p:lk] = 279282                         (: '{' FLOATING_POINT_LITERAL '&=' :)
          or $state[$p:lk] = 279410                         (: '{' CHARACTER_LITERAL '&=' :)
          or $state[$p:lk] = 279538                         (: '{' STRING_LITERAL '&=' :)
          or $state[$p:lk] = 284658                         (: '{' 'EOF' '&=' :)
          or $state[$p:lk] = 284786                         (: '{' 'IGNORE_CASE' '&=' :)
          or $state[$p:lk] = 284914                         (: '{' 'JAVACODE' '&=' :)
          or $state[$p:lk] = 285042                         (: '{' 'LOOKAHEAD' '&=' :)
          or $state[$p:lk] = 285170                         (: '{' 'MORE' '&=' :)
          or $state[$p:lk] = 285298                         (: '{' 'PARSER_BEGIN' '&=' :)
          or $state[$p:lk] = 285426                         (: '{' 'PARSER_END' '&=' :)
          or $state[$p:lk] = 285554                         (: '{' 'SKIP' '&=' :)
          or $state[$p:lk] = 285682                         (: '{' 'SPECIAL_TOKEN' '&=' :)
          or $state[$p:lk] = 285810                         (: '{' 'TOKEN' '&=' :)
          or $state[$p:lk] = 285938                         (: '{' 'TOKEN_MGR_DECLS' '&=' :)
          or $state[$p:lk] = 288626                         (: '{' 'false' '&=' :)
          or $state[$p:lk] = 290418                         (: '{' 'null' '&=' :)
          or $state[$p:lk] = 292082                         (: '{' 'this' '&=' :)
          or $state[$p:lk] = 292594                         (: '{' 'true' '&=' :)
          or $state[$p:lk] = 295154                         (: '{' IDENTIFIER '(' :)
          or $state[$p:lk] = 295538                         (: '{' INTEGER_LITERAL '(' :)
          or $state[$p:lk] = 295666                         (: '{' FLOATING_POINT_LITERAL '(' :)
          or $state[$p:lk] = 295794                         (: '{' CHARACTER_LITERAL '(' :)
          or $state[$p:lk] = 295922                         (: '{' STRING_LITERAL '(' :)
          or $state[$p:lk] = 297330                         (: '{' '(' '(' :)
          or $state[$p:lk] = 297970                         (: '{' '++' '(' :)
          or $state[$p:lk] = 298482                         (: '{' '--' '(' :)
          or $state[$p:lk] = 301042                         (: '{' 'EOF' '(' :)
          or $state[$p:lk] = 301170                         (: '{' 'IGNORE_CASE' '(' :)
          or $state[$p:lk] = 301298                         (: '{' 'JAVACODE' '(' :)
          or $state[$p:lk] = 301426                         (: '{' 'LOOKAHEAD' '(' :)
          or $state[$p:lk] = 301554                         (: '{' 'MORE' '(' :)
          or $state[$p:lk] = 301682                         (: '{' 'PARSER_BEGIN' '(' :)
          or $state[$p:lk] = 301810                         (: '{' 'PARSER_END' '(' :)
          or $state[$p:lk] = 301938                         (: '{' 'SKIP' '(' :)
          or $state[$p:lk] = 302066                         (: '{' 'SPECIAL_TOKEN' '(' :)
          or $state[$p:lk] = 302194                         (: '{' 'TOKEN' '(' :)
          or $state[$p:lk] = 302322                         (: '{' 'TOKEN_MGR_DECLS' '(' :)
          or $state[$p:lk] = 305010                         (: '{' 'false' '(' :)
          or $state[$p:lk] = 306802                         (: '{' 'null' '(' :)
          or $state[$p:lk] = 308466                         (: '{' 'this' '(' :)
          or $state[$p:lk] = 308978                         (: '{' 'true' '(' :)
          or $state[$p:lk] = 326514                         (: '{' '}' ')' :)
          or $state[$p:lk] = 344306                         (: '{' IDENTIFIER '*=' :)
          or $state[$p:lk] = 344690                         (: '{' INTEGER_LITERAL '*=' :)
          or $state[$p:lk] = 344818                         (: '{' FLOATING_POINT_LITERAL '*=' :)
          or $state[$p:lk] = 344946                         (: '{' CHARACTER_LITERAL '*=' :)
          or $state[$p:lk] = 345074                         (: '{' STRING_LITERAL '*=' :)
          or $state[$p:lk] = 350194                         (: '{' 'EOF' '*=' :)
          or $state[$p:lk] = 350322                         (: '{' 'IGNORE_CASE' '*=' :)
          or $state[$p:lk] = 350450                         (: '{' 'JAVACODE' '*=' :)
          or $state[$p:lk] = 350578                         (: '{' 'LOOKAHEAD' '*=' :)
          or $state[$p:lk] = 350706                         (: '{' 'MORE' '*=' :)
          or $state[$p:lk] = 350834                         (: '{' 'PARSER_BEGIN' '*=' :)
          or $state[$p:lk] = 350962                         (: '{' 'PARSER_END' '*=' :)
          or $state[$p:lk] = 351090                         (: '{' 'SKIP' '*=' :)
          or $state[$p:lk] = 351218                         (: '{' 'SPECIAL_TOKEN' '*=' :)
          or $state[$p:lk] = 351346                         (: '{' 'TOKEN' '*=' :)
          or $state[$p:lk] = 351474                         (: '{' 'TOKEN_MGR_DECLS' '*=' :)
          or $state[$p:lk] = 354162                         (: '{' 'false' '*=' :)
          or $state[$p:lk] = 355954                         (: '{' 'null' '*=' :)
          or $state[$p:lk] = 357618                         (: '{' 'this' '*=' :)
          or $state[$p:lk] = 358130                         (: '{' 'true' '*=' :)
          or $state[$p:lk] = 362866                         (: '{' '(' '+' :)
          or $state[$p:lk] = 377074                         (: '{' IDENTIFIER '++' :)
          or $state[$p:lk] = 377458                         (: '{' INTEGER_LITERAL '++' :)
          or $state[$p:lk] = 377586                         (: '{' FLOATING_POINT_LITERAL '++' :)
          or $state[$p:lk] = 377714                         (: '{' CHARACTER_LITERAL '++' :)
          or $state[$p:lk] = 377842                         (: '{' STRING_LITERAL '++' :)
          or $state[$p:lk] = 379250                         (: '{' '(' '++' :)
          or $state[$p:lk] = 382962                         (: '{' 'EOF' '++' :)
          or $state[$p:lk] = 383090                         (: '{' 'IGNORE_CASE' '++' :)
          or $state[$p:lk] = 383218                         (: '{' 'JAVACODE' '++' :)
          or $state[$p:lk] = 383346                         (: '{' 'LOOKAHEAD' '++' :)
          or $state[$p:lk] = 383474                         (: '{' 'MORE' '++' :)
          or $state[$p:lk] = 383602                         (: '{' 'PARSER_BEGIN' '++' :)
          or $state[$p:lk] = 383730                         (: '{' 'PARSER_END' '++' :)
          or $state[$p:lk] = 383858                         (: '{' 'SKIP' '++' :)
          or $state[$p:lk] = 383986                         (: '{' 'SPECIAL_TOKEN' '++' :)
          or $state[$p:lk] = 384114                         (: '{' 'TOKEN' '++' :)
          or $state[$p:lk] = 384242                         (: '{' 'TOKEN_MGR_DECLS' '++' :)
          or $state[$p:lk] = 386930                         (: '{' 'false' '++' :)
          or $state[$p:lk] = 388722                         (: '{' 'null' '++' :)
          or $state[$p:lk] = 390386                         (: '{' 'this' '++' :)
          or $state[$p:lk] = 390898                         (: '{' 'true' '++' :)
          or $state[$p:lk] = 393458                         (: '{' IDENTIFIER '+=' :)
          or $state[$p:lk] = 393842                         (: '{' INTEGER_LITERAL '+=' :)
          or $state[$p:lk] = 393970                         (: '{' FLOATING_POINT_LITERAL '+=' :)
          or $state[$p:lk] = 394098                         (: '{' CHARACTER_LITERAL '+=' :)
          or $state[$p:lk] = 394226                         (: '{' STRING_LITERAL '+=' :)
          or $state[$p:lk] = 399346                         (: '{' 'EOF' '+=' :)
          or $state[$p:lk] = 399474                         (: '{' 'IGNORE_CASE' '+=' :)
          or $state[$p:lk] = 399602                         (: '{' 'JAVACODE' '+=' :)
          or $state[$p:lk] = 399730                         (: '{' 'LOOKAHEAD' '+=' :)
          or $state[$p:lk] = 399858                         (: '{' 'MORE' '+=' :)
          or $state[$p:lk] = 399986                         (: '{' 'PARSER_BEGIN' '+=' :)
          or $state[$p:lk] = 400114                         (: '{' 'PARSER_END' '+=' :)
          or $state[$p:lk] = 400242                         (: '{' 'SKIP' '+=' :)
          or $state[$p:lk] = 400370                         (: '{' 'SPECIAL_TOKEN' '+=' :)
          or $state[$p:lk] = 400498                         (: '{' 'TOKEN' '+=' :)
          or $state[$p:lk] = 400626                         (: '{' 'TOKEN_MGR_DECLS' '+=' :)
          or $state[$p:lk] = 403314                         (: '{' 'false' '+=' :)
          or $state[$p:lk] = 405106                         (: '{' 'null' '+=' :)
          or $state[$p:lk] = 406770                         (: '{' 'this' '+=' :)
          or $state[$p:lk] = 407282                         (: '{' 'true' '+=' :)
          or $state[$p:lk] = 428402                         (: '{' '(' '-' :)
          or $state[$p:lk] = 442610                         (: '{' IDENTIFIER '--' :)
          or $state[$p:lk] = 442994                         (: '{' INTEGER_LITERAL '--' :)
          or $state[$p:lk] = 443122                         (: '{' FLOATING_POINT_LITERAL '--' :)
          or $state[$p:lk] = 443250                         (: '{' CHARACTER_LITERAL '--' :)
          or $state[$p:lk] = 443378                         (: '{' STRING_LITERAL '--' :)
          or $state[$p:lk] = 444786                         (: '{' '(' '--' :)
          or $state[$p:lk] = 448498                         (: '{' 'EOF' '--' :)
          or $state[$p:lk] = 448626                         (: '{' 'IGNORE_CASE' '--' :)
          or $state[$p:lk] = 448754                         (: '{' 'JAVACODE' '--' :)
          or $state[$p:lk] = 448882                         (: '{' 'LOOKAHEAD' '--' :)
          or $state[$p:lk] = 449010                         (: '{' 'MORE' '--' :)
          or $state[$p:lk] = 449138                         (: '{' 'PARSER_BEGIN' '--' :)
          or $state[$p:lk] = 449266                         (: '{' 'PARSER_END' '--' :)
          or $state[$p:lk] = 449394                         (: '{' 'SKIP' '--' :)
          or $state[$p:lk] = 449522                         (: '{' 'SPECIAL_TOKEN' '--' :)
          or $state[$p:lk] = 449650                         (: '{' 'TOKEN' '--' :)
          or $state[$p:lk] = 449778                         (: '{' 'TOKEN_MGR_DECLS' '--' :)
          or $state[$p:lk] = 452466                         (: '{' 'false' '--' :)
          or $state[$p:lk] = 454258                         (: '{' 'null' '--' :)
          or $state[$p:lk] = 455922                         (: '{' 'this' '--' :)
          or $state[$p:lk] = 456434                         (: '{' 'true' '--' :)
          or $state[$p:lk] = 458994                         (: '{' IDENTIFIER '-=' :)
          or $state[$p:lk] = 459378                         (: '{' INTEGER_LITERAL '-=' :)
          or $state[$p:lk] = 459506                         (: '{' FLOATING_POINT_LITERAL '-=' :)
          or $state[$p:lk] = 459634                         (: '{' CHARACTER_LITERAL '-=' :)
          or $state[$p:lk] = 459762                         (: '{' STRING_LITERAL '-=' :)
          or $state[$p:lk] = 464882                         (: '{' 'EOF' '-=' :)
          or $state[$p:lk] = 465010                         (: '{' 'IGNORE_CASE' '-=' :)
          or $state[$p:lk] = 465138                         (: '{' 'JAVACODE' '-=' :)
          or $state[$p:lk] = 465266                         (: '{' 'LOOKAHEAD' '-=' :)
          or $state[$p:lk] = 465394                         (: '{' 'MORE' '-=' :)
          or $state[$p:lk] = 465522                         (: '{' 'PARSER_BEGIN' '-=' :)
          or $state[$p:lk] = 465650                         (: '{' 'PARSER_END' '-=' :)
          or $state[$p:lk] = 465778                         (: '{' 'SKIP' '-=' :)
          or $state[$p:lk] = 465906                         (: '{' 'SPECIAL_TOKEN' '-=' :)
          or $state[$p:lk] = 466034                         (: '{' 'TOKEN' '-=' :)
          or $state[$p:lk] = 466162                         (: '{' 'TOKEN_MGR_DECLS' '-=' :)
          or $state[$p:lk] = 468850                         (: '{' 'false' '-=' :)
          or $state[$p:lk] = 470642                         (: '{' 'null' '-=' :)
          or $state[$p:lk] = 472306                         (: '{' 'this' '-=' :)
          or $state[$p:lk] = 472818                         (: '{' 'true' '-=' :)
          or $state[$p:lk] = 475378                         (: '{' IDENTIFIER '.' :)
          or $state[$p:lk] = 475762                         (: '{' INTEGER_LITERAL '.' :)
          or $state[$p:lk] = 475890                         (: '{' FLOATING_POINT_LITERAL '.' :)
          or $state[$p:lk] = 476018                         (: '{' CHARACTER_LITERAL '.' :)
          or $state[$p:lk] = 476146                         (: '{' STRING_LITERAL '.' :)
          or $state[$p:lk] = 481266                         (: '{' 'EOF' '.' :)
          or $state[$p:lk] = 481394                         (: '{' 'IGNORE_CASE' '.' :)
          or $state[$p:lk] = 481522                         (: '{' 'JAVACODE' '.' :)
          or $state[$p:lk] = 481650                         (: '{' 'LOOKAHEAD' '.' :)
          or $state[$p:lk] = 481778                         (: '{' 'MORE' '.' :)
          or $state[$p:lk] = 481906                         (: '{' 'PARSER_BEGIN' '.' :)
          or $state[$p:lk] = 482034                         (: '{' 'PARSER_END' '.' :)
          or $state[$p:lk] = 482162                         (: '{' 'SKIP' '.' :)
          or $state[$p:lk] = 482290                         (: '{' 'SPECIAL_TOKEN' '.' :)
          or $state[$p:lk] = 482418                         (: '{' 'TOKEN' '.' :)
          or $state[$p:lk] = 482546                         (: '{' 'TOKEN_MGR_DECLS' '.' :)
          or $state[$p:lk] = 483442                         (: '{' 'boolean' '.' :)
          or $state[$p:lk] = 483698                         (: '{' 'byte' '.' :)
          or $state[$p:lk] = 484082                         (: '{' 'char' '.' :)
          or $state[$p:lk] = 484722                         (: '{' 'double' '.' :)
          or $state[$p:lk] = 485234                         (: '{' 'false' '.' :)
          or $state[$p:lk] = 485618                         (: '{' 'float' '.' :)
          or $state[$p:lk] = 486386                         (: '{' 'int' '.' :)
          or $state[$p:lk] = 486642                         (: '{' 'long' '.' :)
          or $state[$p:lk] = 487026                         (: '{' 'null' '.' :)
          or $state[$p:lk] = 487922                         (: '{' 'short' '.' :)
          or $state[$p:lk] = 488306                         (: '{' 'super' '.' :)
          or $state[$p:lk] = 488690                         (: '{' 'this' '.' :)
          or $state[$p:lk] = 489202                         (: '{' 'true' '.' :)
          or $state[$p:lk] = 489458                         (: '{' 'void' '.' :)
          or $state[$p:lk] = 524530                         (: '{' IDENTIFIER '/=' :)
          or $state[$p:lk] = 524914                         (: '{' INTEGER_LITERAL '/=' :)
          or $state[$p:lk] = 525042                         (: '{' FLOATING_POINT_LITERAL '/=' :)
          or $state[$p:lk] = 525170                         (: '{' CHARACTER_LITERAL '/=' :)
          or $state[$p:lk] = 525298                         (: '{' STRING_LITERAL '/=' :)
          or $state[$p:lk] = 530418                         (: '{' 'EOF' '/=' :)
          or $state[$p:lk] = 530546                         (: '{' 'IGNORE_CASE' '/=' :)
          or $state[$p:lk] = 530674                         (: '{' 'JAVACODE' '/=' :)
          or $state[$p:lk] = 530802                         (: '{' 'LOOKAHEAD' '/=' :)
          or $state[$p:lk] = 530930                         (: '{' 'MORE' '/=' :)
          or $state[$p:lk] = 531058                         (: '{' 'PARSER_BEGIN' '/=' :)
          or $state[$p:lk] = 531186                         (: '{' 'PARSER_END' '/=' :)
          or $state[$p:lk] = 531314                         (: '{' 'SKIP' '/=' :)
          or $state[$p:lk] = 531442                         (: '{' 'SPECIAL_TOKEN' '/=' :)
          or $state[$p:lk] = 531570                         (: '{' 'TOKEN' '/=' :)
          or $state[$p:lk] = 531698                         (: '{' 'TOKEN_MGR_DECLS' '/=' :)
          or $state[$p:lk] = 534386                         (: '{' 'false' '/=' :)
          or $state[$p:lk] = 536178                         (: '{' 'null' '/=' :)
          or $state[$p:lk] = 537842                         (: '{' 'this' '/=' :)
          or $state[$p:lk] = 538354                         (: '{' 'true' '/=' :)
          or $state[$p:lk] = 573682                         (: '{' IDENTIFIER '<' :)
          or $state[$p:lk] = 606450                         (: '{' IDENTIFIER '<<=' :)
          or $state[$p:lk] = 606834                         (: '{' INTEGER_LITERAL '<<=' :)
          or $state[$p:lk] = 606962                         (: '{' FLOATING_POINT_LITERAL '<<=' :)
          or $state[$p:lk] = 607090                         (: '{' CHARACTER_LITERAL '<<=' :)
          or $state[$p:lk] = 607218                         (: '{' STRING_LITERAL '<<=' :)
          or $state[$p:lk] = 612338                         (: '{' 'EOF' '<<=' :)
          or $state[$p:lk] = 612466                         (: '{' 'IGNORE_CASE' '<<=' :)
          or $state[$p:lk] = 612594                         (: '{' 'JAVACODE' '<<=' :)
          or $state[$p:lk] = 612722                         (: '{' 'LOOKAHEAD' '<<=' :)
          or $state[$p:lk] = 612850                         (: '{' 'MORE' '<<=' :)
          or $state[$p:lk] = 612978                         (: '{' 'PARSER_BEGIN' '<<=' :)
          or $state[$p:lk] = 613106                         (: '{' 'PARSER_END' '<<=' :)
          or $state[$p:lk] = 613234                         (: '{' 'SKIP' '<<=' :)
          or $state[$p:lk] = 613362                         (: '{' 'SPECIAL_TOKEN' '<<=' :)
          or $state[$p:lk] = 613490                         (: '{' 'TOKEN' '<<=' :)
          or $state[$p:lk] = 613618                         (: '{' 'TOKEN_MGR_DECLS' '<<=' :)
          or $state[$p:lk] = 616306                         (: '{' 'false' '<<=' :)
          or $state[$p:lk] = 618098                         (: '{' 'null' '<<=' :)
          or $state[$p:lk] = 619762                         (: '{' 'this' '<<=' :)
          or $state[$p:lk] = 620274                         (: '{' 'true' '<<=' :)
          or $state[$p:lk] = 639218                         (: '{' IDENTIFIER '=' :)
          or $state[$p:lk] = 639602                         (: '{' INTEGER_LITERAL '=' :)
          or $state[$p:lk] = 639730                         (: '{' FLOATING_POINT_LITERAL '=' :)
          or $state[$p:lk] = 639858                         (: '{' CHARACTER_LITERAL '=' :)
          or $state[$p:lk] = 639986                         (: '{' STRING_LITERAL '=' :)
          or $state[$p:lk] = 645106                         (: '{' 'EOF' '=' :)
          or $state[$p:lk] = 645234                         (: '{' 'IGNORE_CASE' '=' :)
          or $state[$p:lk] = 645362                         (: '{' 'JAVACODE' '=' :)
          or $state[$p:lk] = 645490                         (: '{' 'LOOKAHEAD' '=' :)
          or $state[$p:lk] = 645618                         (: '{' 'MORE' '=' :)
          or $state[$p:lk] = 645746                         (: '{' 'PARSER_BEGIN' '=' :)
          or $state[$p:lk] = 645874                         (: '{' 'PARSER_END' '=' :)
          or $state[$p:lk] = 646002                         (: '{' 'SKIP' '=' :)
          or $state[$p:lk] = 646130                         (: '{' 'SPECIAL_TOKEN' '=' :)
          or $state[$p:lk] = 646258                         (: '{' 'TOKEN' '=' :)
          or $state[$p:lk] = 646386                         (: '{' 'TOKEN_MGR_DECLS' '=' :)
          or $state[$p:lk] = 649074                         (: '{' 'false' '=' :)
          or $state[$p:lk] = 650866                         (: '{' 'null' '=' :)
          or $state[$p:lk] = 652530                         (: '{' 'this' '=' :)
          or $state[$p:lk] = 653042                         (: '{' 'true' '=' :)
          or $state[$p:lk] = 704754                         (: '{' IDENTIFIER '>>=' :)
          or $state[$p:lk] = 705138                         (: '{' INTEGER_LITERAL '>>=' :)
          or $state[$p:lk] = 705266                         (: '{' FLOATING_POINT_LITERAL '>>=' :)
          or $state[$p:lk] = 705394                         (: '{' CHARACTER_LITERAL '>>=' :)
          or $state[$p:lk] = 705522                         (: '{' STRING_LITERAL '>>=' :)
          or $state[$p:lk] = 710642                         (: '{' 'EOF' '>>=' :)
          or $state[$p:lk] = 710770                         (: '{' 'IGNORE_CASE' '>>=' :)
          or $state[$p:lk] = 710898                         (: '{' 'JAVACODE' '>>=' :)
          or $state[$p:lk] = 711026                         (: '{' 'LOOKAHEAD' '>>=' :)
          or $state[$p:lk] = 711154                         (: '{' 'MORE' '>>=' :)
          or $state[$p:lk] = 711282                         (: '{' 'PARSER_BEGIN' '>>=' :)
          or $state[$p:lk] = 711410                         (: '{' 'PARSER_END' '>>=' :)
          or $state[$p:lk] = 711538                         (: '{' 'SKIP' '>>=' :)
          or $state[$p:lk] = 711666                         (: '{' 'SPECIAL_TOKEN' '>>=' :)
          or $state[$p:lk] = 711794                         (: '{' 'TOKEN' '>>=' :)
          or $state[$p:lk] = 711922                         (: '{' 'TOKEN_MGR_DECLS' '>>=' :)
          or $state[$p:lk] = 714610                         (: '{' 'false' '>>=' :)
          or $state[$p:lk] = 716402                         (: '{' 'null' '>>=' :)
          or $state[$p:lk] = 718066                         (: '{' 'this' '>>=' :)
          or $state[$p:lk] = 718578                         (: '{' 'true' '>>=' :)
          or $state[$p:lk] = 721138                         (: '{' IDENTIFIER '>>>=' :)
          or $state[$p:lk] = 721522                         (: '{' INTEGER_LITERAL '>>>=' :)
          or $state[$p:lk] = 721650                         (: '{' FLOATING_POINT_LITERAL '>>>=' :)
          or $state[$p:lk] = 721778                         (: '{' CHARACTER_LITERAL '>>>=' :)
          or $state[$p:lk] = 721906                         (: '{' STRING_LITERAL '>>>=' :)
          or $state[$p:lk] = 727026                         (: '{' 'EOF' '>>>=' :)
          or $state[$p:lk] = 727154                         (: '{' 'IGNORE_CASE' '>>>=' :)
          or $state[$p:lk] = 727282                         (: '{' 'JAVACODE' '>>>=' :)
          or $state[$p:lk] = 727410                         (: '{' 'LOOKAHEAD' '>>>=' :)
          or $state[$p:lk] = 727538                         (: '{' 'MORE' '>>>=' :)
          or $state[$p:lk] = 727666                         (: '{' 'PARSER_BEGIN' '>>>=' :)
          or $state[$p:lk] = 727794                         (: '{' 'PARSER_END' '>>>=' :)
          or $state[$p:lk] = 727922                         (: '{' 'SKIP' '>>>=' :)
          or $state[$p:lk] = 728050                         (: '{' 'SPECIAL_TOKEN' '>>>=' :)
          or $state[$p:lk] = 728178                         (: '{' 'TOKEN' '>>>=' :)
          or $state[$p:lk] = 728306                         (: '{' 'TOKEN_MGR_DECLS' '>>>=' :)
          or $state[$p:lk] = 730994                         (: '{' 'false' '>>>=' :)
          or $state[$p:lk] = 732786                         (: '{' 'null' '>>>=' :)
          or $state[$p:lk] = 734450                         (: '{' 'this' '>>>=' :)
          or $state[$p:lk] = 734962                         (: '{' 'true' '>>>=' :)
          or $state[$p:lk] = 772466                         (: '{' '(' 'EOF' :)
          or $state[$p:lk] = 773106                         (: '{' '++' 'EOF' :)
          or $state[$p:lk] = 773618                         (: '{' '--' 'EOF' :)
          or $state[$p:lk] = 788850                         (: '{' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 789490                         (: '{' '++' 'IGNORE_CASE' :)
          or $state[$p:lk] = 790002                         (: '{' '--' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805234                         (: '{' '(' 'JAVACODE' :)
          or $state[$p:lk] = 805874                         (: '{' '++' 'JAVACODE' :)
          or $state[$p:lk] = 806386                         (: '{' '--' 'JAVACODE' :)
          or $state[$p:lk] = 821618                         (: '{' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 822258                         (: '{' '++' 'LOOKAHEAD' :)
          or $state[$p:lk] = 822770                         (: '{' '--' 'LOOKAHEAD' :)
          or $state[$p:lk] = 838002                         (: '{' '(' 'MORE' :)
          or $state[$p:lk] = 838642                         (: '{' '++' 'MORE' :)
          or $state[$p:lk] = 839154                         (: '{' '--' 'MORE' :)
          or $state[$p:lk] = 854386                         (: '{' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 855026                         (: '{' '++' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 855538                         (: '{' '--' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870770                         (: '{' '(' 'PARSER_END' :)
          or $state[$p:lk] = 871410                         (: '{' '++' 'PARSER_END' :)
          or $state[$p:lk] = 871922                         (: '{' '--' 'PARSER_END' :)
          or $state[$p:lk] = 887154                         (: '{' '(' 'SKIP' :)
          or $state[$p:lk] = 887794                         (: '{' '++' 'SKIP' :)
          or $state[$p:lk] = 888306                         (: '{' '--' 'SKIP' :)
          or $state[$p:lk] = 903538                         (: '{' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 904178                         (: '{' '++' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 904690                         (: '{' '--' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919922                         (: '{' '(' 'TOKEN' :)
          or $state[$p:lk] = 920562                         (: '{' '++' 'TOKEN' :)
          or $state[$p:lk] = 921074                         (: '{' '--' 'TOKEN' :)
          or $state[$p:lk] = 936306                         (: '{' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 936946                         (: '{' '++' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 937458                         (: '{' '--' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 950514                         (: '{' IDENTIFIER '[' :)
          or $state[$p:lk] = 950898                         (: '{' INTEGER_LITERAL '[' :)
          or $state[$p:lk] = 951026                         (: '{' FLOATING_POINT_LITERAL '[' :)
          or $state[$p:lk] = 951154                         (: '{' CHARACTER_LITERAL '[' :)
          or $state[$p:lk] = 951282                         (: '{' STRING_LITERAL '[' :)
          or $state[$p:lk] = 956402                         (: '{' 'EOF' '[' :)
          or $state[$p:lk] = 956530                         (: '{' 'IGNORE_CASE' '[' :)
          or $state[$p:lk] = 956658                         (: '{' 'JAVACODE' '[' :)
          or $state[$p:lk] = 956786                         (: '{' 'LOOKAHEAD' '[' :)
          or $state[$p:lk] = 956914                         (: '{' 'MORE' '[' :)
          or $state[$p:lk] = 957042                         (: '{' 'PARSER_BEGIN' '[' :)
          or $state[$p:lk] = 957170                         (: '{' 'PARSER_END' '[' :)
          or $state[$p:lk] = 957298                         (: '{' 'SKIP' '[' :)
          or $state[$p:lk] = 957426                         (: '{' 'SPECIAL_TOKEN' '[' :)
          or $state[$p:lk] = 957554                         (: '{' 'TOKEN' '[' :)
          or $state[$p:lk] = 957682                         (: '{' 'TOKEN_MGR_DECLS' '[' :)
          or $state[$p:lk] = 958578                         (: '{' 'boolean' '[' :)
          or $state[$p:lk] = 958834                         (: '{' 'byte' '[' :)
          or $state[$p:lk] = 959218                         (: '{' 'char' '[' :)
          or $state[$p:lk] = 959858                         (: '{' 'double' '[' :)
          or $state[$p:lk] = 960370                         (: '{' 'false' '[' :)
          or $state[$p:lk] = 960754                         (: '{' 'float' '[' :)
          or $state[$p:lk] = 961522                         (: '{' 'int' '[' :)
          or $state[$p:lk] = 961778                         (: '{' 'long' '[' :)
          or $state[$p:lk] = 962162                         (: '{' 'null' '[' :)
          or $state[$p:lk] = 963058                         (: '{' 'short' '[' :)
          or $state[$p:lk] = 963826                         (: '{' 'this' '[' :)
          or $state[$p:lk] = 964338                         (: '{' 'true' '[' :)
          or $state[$p:lk] = 999666                         (: '{' IDENTIFIER '^=' :)
          or $state[$p:lk] = 1000050                        (: '{' INTEGER_LITERAL '^=' :)
          or $state[$p:lk] = 1000178                        (: '{' FLOATING_POINT_LITERAL '^=' :)
          or $state[$p:lk] = 1000306                        (: '{' CHARACTER_LITERAL '^=' :)
          or $state[$p:lk] = 1000434                        (: '{' STRING_LITERAL '^=' :)
          or $state[$p:lk] = 1005554                        (: '{' 'EOF' '^=' :)
          or $state[$p:lk] = 1005682                        (: '{' 'IGNORE_CASE' '^=' :)
          or $state[$p:lk] = 1005810                        (: '{' 'JAVACODE' '^=' :)
          or $state[$p:lk] = 1005938                        (: '{' 'LOOKAHEAD' '^=' :)
          or $state[$p:lk] = 1006066                        (: '{' 'MORE' '^=' :)
          or $state[$p:lk] = 1006194                        (: '{' 'PARSER_BEGIN' '^=' :)
          or $state[$p:lk] = 1006322                        (: '{' 'PARSER_END' '^=' :)
          or $state[$p:lk] = 1006450                        (: '{' 'SKIP' '^=' :)
          or $state[$p:lk] = 1006578                        (: '{' 'SPECIAL_TOKEN' '^=' :)
          or $state[$p:lk] = 1006706                        (: '{' 'TOKEN' '^=' :)
          or $state[$p:lk] = 1006834                        (: '{' 'TOKEN_MGR_DECLS' '^=' :)
          or $state[$p:lk] = 1009522                        (: '{' 'false' '^=' :)
          or $state[$p:lk] = 1011314                        (: '{' 'null' '^=' :)
          or $state[$p:lk] = 1012978                        (: '{' 'this' '^=' :)
          or $state[$p:lk] = 1013490                        (: '{' 'true' '^=' :)
          or $state[$p:lk] = 1050994                        (: '{' '(' 'boolean' :)
          or $state[$p:lk] = 1051634                        (: '{' '++' 'boolean' :)
          or $state[$p:lk] = 1052146                        (: '{' '--' 'boolean' :)
          or $state[$p:lk] = 1060338                        (: '{' 'new' 'boolean' :)
          or $state[$p:lk] = 1083762                        (: '{' '(' 'byte' :)
          or $state[$p:lk] = 1084402                        (: '{' '++' 'byte' :)
          or $state[$p:lk] = 1084914                        (: '{' '--' 'byte' :)
          or $state[$p:lk] = 1093106                        (: '{' 'new' 'byte' :)
          or $state[$p:lk] = 1132914                        (: '{' '(' 'char' :)
          or $state[$p:lk] = 1133554                        (: '{' '++' 'char' :)
          or $state[$p:lk] = 1134066                        (: '{' '--' 'char' :)
          or $state[$p:lk] = 1142258                        (: '{' 'new' 'char' :)
          or $state[$p:lk] = 1214834                        (: '{' '(' 'double' :)
          or $state[$p:lk] = 1215474                        (: '{' '++' 'double' :)
          or $state[$p:lk] = 1215986                        (: '{' '--' 'double' :)
          or $state[$p:lk] = 1224178                        (: '{' 'new' 'double' :)
          or $state[$p:lk] = 1280370                        (: '{' '(' 'false' :)
          or $state[$p:lk] = 1281010                        (: '{' '++' 'false' :)
          or $state[$p:lk] = 1281522                        (: '{' '--' 'false' :)
          or $state[$p:lk] = 1329522                        (: '{' '(' 'float' :)
          or $state[$p:lk] = 1330162                        (: '{' '++' 'float' :)
          or $state[$p:lk] = 1330674                        (: '{' '--' 'float' :)
          or $state[$p:lk] = 1338866                        (: '{' 'new' 'float' :)
          or $state[$p:lk] = 1427826                        (: '{' '(' 'int' :)
          or $state[$p:lk] = 1428466                        (: '{' '++' 'int' :)
          or $state[$p:lk] = 1428978                        (: '{' '--' 'int' :)
          or $state[$p:lk] = 1437170                        (: '{' 'new' 'int' :)
          or $state[$p:lk] = 1460594                        (: '{' '(' 'long' :)
          or $state[$p:lk] = 1461234                        (: '{' '++' 'long' :)
          or $state[$p:lk] = 1461746                        (: '{' '--' 'long' :)
          or $state[$p:lk] = 1469938                        (: '{' 'new' 'long' :)
          or $state[$p:lk] = 1493362                        (: '{' '(' 'new' :)
          or $state[$p:lk] = 1494002                        (: '{' '++' 'new' :)
          or $state[$p:lk] = 1494514                        (: '{' '--' 'new' :)
          or $state[$p:lk] = 1509746                        (: '{' '(' 'null' :)
          or $state[$p:lk] = 1510386                        (: '{' '++' 'null' :)
          or $state[$p:lk] = 1510898                        (: '{' '--' 'null' :)
          or $state[$p:lk] = 1624434                        (: '{' '(' 'short' :)
          or $state[$p:lk] = 1625074                        (: '{' '++' 'short' :)
          or $state[$p:lk] = 1625586                        (: '{' '--' 'short' :)
          or $state[$p:lk] = 1633778                        (: '{' 'new' 'short' :)
          or $state[$p:lk] = 1673586                        (: '{' '(' 'super' :)
          or $state[$p:lk] = 1674226                        (: '{' '++' 'super' :)
          or $state[$p:lk] = 1674738                        (: '{' '--' 'super' :)
          or $state[$p:lk] = 1722738                        (: '{' '(' 'this' :)
          or $state[$p:lk] = 1723378                        (: '{' '++' 'this' :)
          or $state[$p:lk] = 1723890                        (: '{' '--' 'this' :)
          or $state[$p:lk] = 1788274                        (: '{' '(' 'true' :)
          or $state[$p:lk] = 1788914                        (: '{' '++' 'true' :)
          or $state[$p:lk] = 1789426                        (: '{' '--' 'true' :)
          or $state[$p:lk] = 1821042                        (: '{' '(' 'void' :)
          or $state[$p:lk] = 1821682                        (: '{' '++' 'void' :)
          or $state[$p:lk] = 1822194                        (: '{' '--' 'void' :)
          or $state[$p:lk] = 1900786                        (: '{' IDENTIFIER '|=' :)
          or $state[$p:lk] = 1901170                        (: '{' INTEGER_LITERAL '|=' :)
          or $state[$p:lk] = 1901298                        (: '{' FLOATING_POINT_LITERAL '|=' :)
          or $state[$p:lk] = 1901426                        (: '{' CHARACTER_LITERAL '|=' :)
          or $state[$p:lk] = 1901554                        (: '{' STRING_LITERAL '|=' :)
          or $state[$p:lk] = 1906674                        (: '{' 'EOF' '|=' :)
          or $state[$p:lk] = 1906802                        (: '{' 'IGNORE_CASE' '|=' :)
          or $state[$p:lk] = 1906930                        (: '{' 'JAVACODE' '|=' :)
          or $state[$p:lk] = 1907058                        (: '{' 'LOOKAHEAD' '|=' :)
          or $state[$p:lk] = 1907186                        (: '{' 'MORE' '|=' :)
          or $state[$p:lk] = 1907314                        (: '{' 'PARSER_BEGIN' '|=' :)
          or $state[$p:lk] = 1907442                        (: '{' 'PARSER_END' '|=' :)
          or $state[$p:lk] = 1907570                        (: '{' 'SKIP' '|=' :)
          or $state[$p:lk] = 1907698                        (: '{' 'SPECIAL_TOKEN' '|=' :)
          or $state[$p:lk] = 1907826                        (: '{' 'TOKEN' '|=' :)
          or $state[$p:lk] = 1907954                        (: '{' 'TOKEN_MGR_DECLS' '|=' :)
          or $state[$p:lk] = 1910642                        (: '{' 'false' '|=' :)
          or $state[$p:lk] = 1912434                        (: '{' 'null' '|=' :)
          or $state[$p:lk] = 1914098                        (: '{' 'this' '|=' :)
          or $state[$p:lk] = 1914610                        (: '{' 'true' '|=' :)
          or $state[$p:lk] = 1952114) then                  (: '{' '(' '~' :)
      let $state := p:memoized($state, 4)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-expansion_choices($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 1                              (: IDENTIFIER :)
          or $state[$p:lk] = 4                              (: INTEGER_LITERAL :)
          or $state[$p:lk] = 5                              (: FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 6                              (: CHARACTER_LITERAL :)
          or $state[$p:lk] = 7                              (: STRING_LITERAL :)
          or $state[$p:lk] = 18                             (: '(' :)
          or $state[$p:lk] = 35                             (: '<' :)
          or $state[$p:lk] = 47                             (: 'EOF' :)
          or $state[$p:lk] = 48                             (: 'IGNORE_CASE' :)
          or $state[$p:lk] = 49                             (: 'JAVACODE' :)
          or $state[$p:lk] = 50                             (: 'LOOKAHEAD' :)
          or $state[$p:lk] = 51                             (: 'MORE' :)
          or $state[$p:lk] = 52                             (: 'PARSER_BEGIN' :)
          or $state[$p:lk] = 53                             (: 'PARSER_END' :)
          or $state[$p:lk] = 54                             (: 'SKIP' :)
          or $state[$p:lk] = 55                             (: 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 56                             (: 'TOKEN' :)
          or $state[$p:lk] = 57                             (: 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 58                             (: '[' :)
          or $state[$p:lk] = 64                             (: 'boolean' :)
          or $state[$p:lk] = 66                             (: 'byte' :)
          or $state[$p:lk] = 69                             (: 'char' :)
          or $state[$p:lk] = 74                             (: 'double' :)
          or $state[$p:lk] = 78                             (: 'false' :)
          or $state[$p:lk] = 81                             (: 'float' :)
          or $state[$p:lk] = 87                             (: 'int' :)
          or $state[$p:lk] = 89                             (: 'long' :)
          or $state[$p:lk] = 91                             (: 'new' :)
          or $state[$p:lk] = 92                             (: 'null' :)
          or $state[$p:lk] = 99                             (: 'short' :)
          or $state[$p:lk] = 102                            (: 'super' :)
          or $state[$p:lk] = 105                            (: 'this' :)
          or $state[$p:lk] = 109                            (: 'true' :)
          or $state[$p:lk] = 110                            (: 'try' :)
          or $state[$p:lk] = 111                            (: 'void' :)
          or $state[$p:lk] = 4466                           (: '{' ';' :)
          or $state[$p:lk] = 6002                           (: '{' '@' :)
          or $state[$p:lk] = 8050                           (: '{' 'abstract' :)
          or $state[$p:lk] = 8178                           (: '{' 'assert' :)
          or $state[$p:lk] = 8434                           (: '{' 'break' :)
          or $state[$p:lk] = 9074                           (: '{' 'class' :)
          or $state[$p:lk] = 9202                           (: '{' 'continue' :)
          or $state[$p:lk] = 9458                           (: '{' 'do' :)
          or $state[$p:lk] = 10226                          (: '{' 'final' :)
          or $state[$p:lk] = 10610                          (: '{' 'for' :)
          or $state[$p:lk] = 10738                          (: '{' 'if' :)
          or $state[$p:lk] = 11378                          (: '{' 'interface' :)
          or $state[$p:lk] = 11634                          (: '{' 'native' :)
          or $state[$p:lk] = 12274                          (: '{' 'private' :)
          or $state[$p:lk] = 12402                          (: '{' 'protected' :)
          or $state[$p:lk] = 12530                          (: '{' 'public' :)
          or $state[$p:lk] = 12658                          (: '{' 'return' :)
          or $state[$p:lk] = 12914                          (: '{' 'static' :)
          or $state[$p:lk] = 13042                          (: '{' 'strictfp' :)
          or $state[$p:lk] = 13298                          (: '{' 'switch' :)
          or $state[$p:lk] = 13426                          (: '{' 'synchronized' :)
          or $state[$p:lk] = 13682                          (: '{' 'throw' :)
          or $state[$p:lk] = 13938                          (: '{' 'transient' :)
          or $state[$p:lk] = 14194                          (: '{' 'try' :)
          or $state[$p:lk] = 14450                          (: '{' 'volatile' :)
          or $state[$p:lk] = 14578                          (: '{' 'while' :)
          or $state[$p:lk] = 14706                          (: '{' '{' :)
          or $state[$p:lk] = 16626                          (: '{' IDENTIFIER IDENTIFIER :)
          or $state[$p:lk] = 24690                          (: '{' 'boolean' IDENTIFIER :)
          or $state[$p:lk] = 24946                          (: '{' 'byte' IDENTIFIER :)
          or $state[$p:lk] = 25330                          (: '{' 'char' IDENTIFIER :)
          or $state[$p:lk] = 25970                          (: '{' 'double' IDENTIFIER :)
          or $state[$p:lk] = 26866                          (: '{' 'float' IDENTIFIER :)
          or $state[$p:lk] = 27634                          (: '{' 'int' IDENTIFIER :)
          or $state[$p:lk] = 27890                          (: '{' 'long' IDENTIFIER :)
          or $state[$p:lk] = 29170                          (: '{' 'short' IDENTIFIER :)
          or $state[$p:lk] = 31602                          (: '{' '}' IDENTIFIER :)
          or $state[$p:lk] = 80754                          (: '{' '}' INTEGER_LITERAL :)
          or $state[$p:lk] = 97138                          (: '{' '}' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 113522                         (: '{' '}' CHARACTER_LITERAL :)
          or $state[$p:lk] = 129906                         (: '{' '}' STRING_LITERAL :)
          or $state[$p:lk] = 310130                         (: '{' '}' '(' :)
          or $state[$p:lk] = 424818                         (: '{' '}' ',' :)
          or $state[$p:lk] = 540914                         (: '{' IDENTIFIER ':' :)
          or $state[$p:lk] = 557298                         (: '{' IDENTIFIER ';' :)
          or $state[$p:lk] = 557682                         (: '{' INTEGER_LITERAL ';' :)
          or $state[$p:lk] = 557810                         (: '{' FLOATING_POINT_LITERAL ';' :)
          or $state[$p:lk] = 557938                         (: '{' CHARACTER_LITERAL ';' :)
          or $state[$p:lk] = 558066                         (: '{' STRING_LITERAL ';' :)
          or $state[$p:lk] = 563186                         (: '{' 'EOF' ';' :)
          or $state[$p:lk] = 563314                         (: '{' 'IGNORE_CASE' ';' :)
          or $state[$p:lk] = 563442                         (: '{' 'JAVACODE' ';' :)
          or $state[$p:lk] = 563570                         (: '{' 'LOOKAHEAD' ';' :)
          or $state[$p:lk] = 563698                         (: '{' 'MORE' ';' :)
          or $state[$p:lk] = 563826                         (: '{' 'PARSER_BEGIN' ';' :)
          or $state[$p:lk] = 563954                         (: '{' 'PARSER_END' ';' :)
          or $state[$p:lk] = 564082                         (: '{' 'SKIP' ';' :)
          or $state[$p:lk] = 564210                         (: '{' 'SPECIAL_TOKEN' ';' :)
          or $state[$p:lk] = 564338                         (: '{' 'TOKEN' ';' :)
          or $state[$p:lk] = 564466                         (: '{' 'TOKEN_MGR_DECLS' ';' :)
          or $state[$p:lk] = 567154                         (: '{' 'false' ';' :)
          or $state[$p:lk] = 568946                         (: '{' 'null' ';' :)
          or $state[$p:lk] = 570610                         (: '{' 'this' ';' :)
          or $state[$p:lk] = 571122                         (: '{' 'true' ';' :)
          or $state[$p:lk] = 588658                         (: '{' '}' '<' :)
          or $state[$p:lk] = 785266                         (: '{' '}' 'EOF' :)
          or $state[$p:lk] = 801650                         (: '{' '}' 'IGNORE_CASE' :)
          or $state[$p:lk] = 818034                         (: '{' '}' 'JAVACODE' :)
          or $state[$p:lk] = 834418                         (: '{' '}' 'LOOKAHEAD' :)
          or $state[$p:lk] = 850802                         (: '{' '}' 'MORE' :)
          or $state[$p:lk] = 867186                         (: '{' '}' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 883570                         (: '{' '}' 'PARSER_END' :)
          or $state[$p:lk] = 899954                         (: '{' '}' 'SKIP' :)
          or $state[$p:lk] = 916338                         (: '{' '}' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 932722                         (: '{' '}' 'TOKEN' :)
          or $state[$p:lk] = 949106                         (: '{' '}' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 965490                         (: '{' '}' '[' :)
          or $state[$p:lk] = 1063794                        (: '{' '}' 'boolean' :)
          or $state[$p:lk] = 1096562                        (: '{' '}' 'byte' :)
          or $state[$p:lk] = 1145714                        (: '{' '}' 'char' :)
          or $state[$p:lk] = 1227634                        (: '{' '}' 'double' :)
          or $state[$p:lk] = 1293170                        (: '{' '}' 'false' :)
          or $state[$p:lk] = 1342322                        (: '{' '}' 'float' :)
          or $state[$p:lk] = 1440626                        (: '{' '}' 'int' :)
          or $state[$p:lk] = 1473394                        (: '{' '}' 'long' :)
          or $state[$p:lk] = 1506162                        (: '{' '}' 'new' :)
          or $state[$p:lk] = 1522546                        (: '{' '}' 'null' :)
          or $state[$p:lk] = 1637234                        (: '{' '}' 'short' :)
          or $state[$p:lk] = 1686386                        (: '{' '}' 'super' :)
          or $state[$p:lk] = 1735538                        (: '{' '}' 'this' :)
          or $state[$p:lk] = 1801074                        (: '{' '}' 'true' :)
          or $state[$p:lk] = 1817458                        (: '{' '}' 'try' :)
          or $state[$p:lk] = 1833842                        (: '{' '}' 'void' :)
          or $state[$p:lk] = 1882994                        (: '{' '}' '{' :)
          or $state[$p:lk] = 1899378) then                  (: '{' '}' '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expansion_choices($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state := p:consumeT(114, $input, $state)         (: '{' :)
      let $state := p:lookahead1W(148, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '}' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 118) then                 (: '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(118, $input, $state)         (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production expansion (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expansion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-expansion_unit($input, $state)
    let $state := p:lookahead1W(156, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
    let $state :=
      if ($state[$p:l1] eq 114) then                        (: '{' :)
        let $state := p:lookahead2W(171, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' | '~' :)
        let $state :=
          if ($state[$p:lk] eq 242) then                    (: '{' IDENTIFIER :)
            let $state := p:lookahead3W(153, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                                '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                                '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                                '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' |
                                                                '>>>=' | '?' | '[' | '^' | '^=' | 'instanceof' | '|' |
                                                                '|=' | '||' | '}' :)
            return $state
          else if ($state[$p:lk] eq 2418) then              (: '{' '(' :)
            let $state := p:lookahead3W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'void' | '~' :)
            return $state
          else if ($state[$p:lk] eq 11762) then             (: '{' 'new' :)
            let $state := p:lookahead3W(91, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
            return $state
          else if ($state[$p:lk] eq 15218) then             (: '{' '}' :)
            let $state := p:lookahead3W(156, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                                'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                                'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                                ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                                '}' :)
            return $state
          else if ($state[$p:lk] = (3058,                   (: '{' '++' :)
                                    3570)) then             (: '{' '--' :)
            let $state := p:lookahead3W(129, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                                'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                                'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
            return $state
          else if ($state[$p:lk] = (13170,                  (: '{' 'super' :)
                                    14322)) then            (: '{' 'void' :)
            let $state := p:lookahead3W(6, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
            return $state
          else if ($state[$p:lk] = (8306,                   (: '{' 'boolean' :)
                                    8562,                   (: '{' 'byte' :)
                                    8946,                   (: '{' 'char' :)
                                    9586,                   (: '{' 'double' :)
                                    10482,                  (: '{' 'float' :)
                                    11250,                  (: '{' 'int' :)
                                    11506,                  (: '{' 'long' :)
                                    12786)) then            (: '{' 'short' :)
            let $state := p:lookahead3W(55, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
            return $state
          else if ($state[$p:lk] = (626,                    (: '{' INTEGER_LITERAL :)
                                    754,                    (: '{' FLOATING_POINT_LITERAL :)
                                    882,                    (: '{' CHARACTER_LITERAL :)
                                    1010,                   (: '{' STRING_LITERAL :)
                                    6130,                   (: '{' 'EOF' :)
                                    6258,                   (: '{' 'IGNORE_CASE' :)
                                    6386,                   (: '{' 'JAVACODE' :)
                                    6514,                   (: '{' 'LOOKAHEAD' :)
                                    6642,                   (: '{' 'MORE' :)
                                    6770,                   (: '{' 'PARSER_BEGIN' :)
                                    6898,                   (: '{' 'PARSER_END' :)
                                    7026,                   (: '{' 'SKIP' :)
                                    7154,                   (: '{' 'SPECIAL_TOKEN' :)
                                    7282,                   (: '{' 'TOKEN' :)
                                    7410,                   (: '{' 'TOKEN_MGR_DECLS' :)
                                    10098,                  (: '{' 'false' :)
                                    11890,                  (: '{' 'null' :)
                                    13554,                  (: '{' 'this' :)
                                    14066)) then            (: '{' 'true' :)
            let $state := p:lookahead3W(141, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                                '%' | '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' |
                                                                '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                                '/=' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                                '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                                'instanceof' | '|' | '|=' | '||' | '}' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 18802                        (: '{' '(' IDENTIFIER :)
            or $state[$p:lk] = 19442                        (: '{' '++' IDENTIFIER :)
            or $state[$p:lk] = 19954                        (: '{' '--' IDENTIFIER :)
            or $state[$p:lk] = 28146                        (: '{' 'new' IDENTIFIER :)
            or $state[$p:lk] = 67954                        (: '{' '(' INTEGER_LITERAL :)
            or $state[$p:lk] = 68594                        (: '{' '++' INTEGER_LITERAL :)
            or $state[$p:lk] = 69106                        (: '{' '--' INTEGER_LITERAL :)
            or $state[$p:lk] = 84338                        (: '{' '(' FLOATING_POINT_LITERAL :)
            or $state[$p:lk] = 84978                        (: '{' '++' FLOATING_POINT_LITERAL :)
            or $state[$p:lk] = 85490                        (: '{' '--' FLOATING_POINT_LITERAL :)
            or $state[$p:lk] = 100722                       (: '{' '(' CHARACTER_LITERAL :)
            or $state[$p:lk] = 101362                       (: '{' '++' CHARACTER_LITERAL :)
            or $state[$p:lk] = 101874                       (: '{' '--' CHARACTER_LITERAL :)
            or $state[$p:lk] = 117106                       (: '{' '(' STRING_LITERAL :)
            or $state[$p:lk] = 117746                       (: '{' '++' STRING_LITERAL :)
            or $state[$p:lk] = 118258                       (: '{' '--' STRING_LITERAL :)
            or $state[$p:lk] = 166258                       (: '{' '(' '!' :)
            or $state[$p:lk] = 229618                       (: '{' IDENTIFIER '%=' :)
            or $state[$p:lk] = 230002                       (: '{' INTEGER_LITERAL '%=' :)
            or $state[$p:lk] = 230130                       (: '{' FLOATING_POINT_LITERAL '%=' :)
            or $state[$p:lk] = 230258                       (: '{' CHARACTER_LITERAL '%=' :)
            or $state[$p:lk] = 230386                       (: '{' STRING_LITERAL '%=' :)
            or $state[$p:lk] = 235506                       (: '{' 'EOF' '%=' :)
            or $state[$p:lk] = 235634                       (: '{' 'IGNORE_CASE' '%=' :)
            or $state[$p:lk] = 235762                       (: '{' 'JAVACODE' '%=' :)
            or $state[$p:lk] = 235890                       (: '{' 'LOOKAHEAD' '%=' :)
            or $state[$p:lk] = 236018                       (: '{' 'MORE' '%=' :)
            or $state[$p:lk] = 236146                       (: '{' 'PARSER_BEGIN' '%=' :)
            or $state[$p:lk] = 236274                       (: '{' 'PARSER_END' '%=' :)
            or $state[$p:lk] = 236402                       (: '{' 'SKIP' '%=' :)
            or $state[$p:lk] = 236530                       (: '{' 'SPECIAL_TOKEN' '%=' :)
            or $state[$p:lk] = 236658                       (: '{' 'TOKEN' '%=' :)
            or $state[$p:lk] = 236786                       (: '{' 'TOKEN_MGR_DECLS' '%=' :)
            or $state[$p:lk] = 239474                       (: '{' 'false' '%=' :)
            or $state[$p:lk] = 241266                       (: '{' 'null' '%=' :)
            or $state[$p:lk] = 242930                       (: '{' 'this' '%=' :)
            or $state[$p:lk] = 243442                       (: '{' 'true' '%=' :)
            or $state[$p:lk] = 278770                       (: '{' IDENTIFIER '&=' :)
            or $state[$p:lk] = 279154                       (: '{' INTEGER_LITERAL '&=' :)
            or $state[$p:lk] = 279282                       (: '{' FLOATING_POINT_LITERAL '&=' :)
            or $state[$p:lk] = 279410                       (: '{' CHARACTER_LITERAL '&=' :)
            or $state[$p:lk] = 279538                       (: '{' STRING_LITERAL '&=' :)
            or $state[$p:lk] = 284658                       (: '{' 'EOF' '&=' :)
            or $state[$p:lk] = 284786                       (: '{' 'IGNORE_CASE' '&=' :)
            or $state[$p:lk] = 284914                       (: '{' 'JAVACODE' '&=' :)
            or $state[$p:lk] = 285042                       (: '{' 'LOOKAHEAD' '&=' :)
            or $state[$p:lk] = 285170                       (: '{' 'MORE' '&=' :)
            or $state[$p:lk] = 285298                       (: '{' 'PARSER_BEGIN' '&=' :)
            or $state[$p:lk] = 285426                       (: '{' 'PARSER_END' '&=' :)
            or $state[$p:lk] = 285554                       (: '{' 'SKIP' '&=' :)
            or $state[$p:lk] = 285682                       (: '{' 'SPECIAL_TOKEN' '&=' :)
            or $state[$p:lk] = 285810                       (: '{' 'TOKEN' '&=' :)
            or $state[$p:lk] = 285938                       (: '{' 'TOKEN_MGR_DECLS' '&=' :)
            or $state[$p:lk] = 288626                       (: '{' 'false' '&=' :)
            or $state[$p:lk] = 290418                       (: '{' 'null' '&=' :)
            or $state[$p:lk] = 292082                       (: '{' 'this' '&=' :)
            or $state[$p:lk] = 292594                       (: '{' 'true' '&=' :)
            or $state[$p:lk] = 295154                       (: '{' IDENTIFIER '(' :)
            or $state[$p:lk] = 295538                       (: '{' INTEGER_LITERAL '(' :)
            or $state[$p:lk] = 295666                       (: '{' FLOATING_POINT_LITERAL '(' :)
            or $state[$p:lk] = 295794                       (: '{' CHARACTER_LITERAL '(' :)
            or $state[$p:lk] = 295922                       (: '{' STRING_LITERAL '(' :)
            or $state[$p:lk] = 297330                       (: '{' '(' '(' :)
            or $state[$p:lk] = 297970                       (: '{' '++' '(' :)
            or $state[$p:lk] = 298482                       (: '{' '--' '(' :)
            or $state[$p:lk] = 301042                       (: '{' 'EOF' '(' :)
            or $state[$p:lk] = 301170                       (: '{' 'IGNORE_CASE' '(' :)
            or $state[$p:lk] = 301298                       (: '{' 'JAVACODE' '(' :)
            or $state[$p:lk] = 301426                       (: '{' 'LOOKAHEAD' '(' :)
            or $state[$p:lk] = 301554                       (: '{' 'MORE' '(' :)
            or $state[$p:lk] = 301682                       (: '{' 'PARSER_BEGIN' '(' :)
            or $state[$p:lk] = 301810                       (: '{' 'PARSER_END' '(' :)
            or $state[$p:lk] = 301938                       (: '{' 'SKIP' '(' :)
            or $state[$p:lk] = 302066                       (: '{' 'SPECIAL_TOKEN' '(' :)
            or $state[$p:lk] = 302194                       (: '{' 'TOKEN' '(' :)
            or $state[$p:lk] = 302322                       (: '{' 'TOKEN_MGR_DECLS' '(' :)
            or $state[$p:lk] = 305010                       (: '{' 'false' '(' :)
            or $state[$p:lk] = 306802                       (: '{' 'null' '(' :)
            or $state[$p:lk] = 308466                       (: '{' 'this' '(' :)
            or $state[$p:lk] = 308978                       (: '{' 'true' '(' :)
            or $state[$p:lk] = 326514                       (: '{' '}' ')' :)
            or $state[$p:lk] = 344306                       (: '{' IDENTIFIER '*=' :)
            or $state[$p:lk] = 344690                       (: '{' INTEGER_LITERAL '*=' :)
            or $state[$p:lk] = 344818                       (: '{' FLOATING_POINT_LITERAL '*=' :)
            or $state[$p:lk] = 344946                       (: '{' CHARACTER_LITERAL '*=' :)
            or $state[$p:lk] = 345074                       (: '{' STRING_LITERAL '*=' :)
            or $state[$p:lk] = 350194                       (: '{' 'EOF' '*=' :)
            or $state[$p:lk] = 350322                       (: '{' 'IGNORE_CASE' '*=' :)
            or $state[$p:lk] = 350450                       (: '{' 'JAVACODE' '*=' :)
            or $state[$p:lk] = 350578                       (: '{' 'LOOKAHEAD' '*=' :)
            or $state[$p:lk] = 350706                       (: '{' 'MORE' '*=' :)
            or $state[$p:lk] = 350834                       (: '{' 'PARSER_BEGIN' '*=' :)
            or $state[$p:lk] = 350962                       (: '{' 'PARSER_END' '*=' :)
            or $state[$p:lk] = 351090                       (: '{' 'SKIP' '*=' :)
            or $state[$p:lk] = 351218                       (: '{' 'SPECIAL_TOKEN' '*=' :)
            or $state[$p:lk] = 351346                       (: '{' 'TOKEN' '*=' :)
            or $state[$p:lk] = 351474                       (: '{' 'TOKEN_MGR_DECLS' '*=' :)
            or $state[$p:lk] = 354162                       (: '{' 'false' '*=' :)
            or $state[$p:lk] = 355954                       (: '{' 'null' '*=' :)
            or $state[$p:lk] = 357618                       (: '{' 'this' '*=' :)
            or $state[$p:lk] = 358130                       (: '{' 'true' '*=' :)
            or $state[$p:lk] = 362866                       (: '{' '(' '+' :)
            or $state[$p:lk] = 377074                       (: '{' IDENTIFIER '++' :)
            or $state[$p:lk] = 377458                       (: '{' INTEGER_LITERAL '++' :)
            or $state[$p:lk] = 377586                       (: '{' FLOATING_POINT_LITERAL '++' :)
            or $state[$p:lk] = 377714                       (: '{' CHARACTER_LITERAL '++' :)
            or $state[$p:lk] = 377842                       (: '{' STRING_LITERAL '++' :)
            or $state[$p:lk] = 379250                       (: '{' '(' '++' :)
            or $state[$p:lk] = 382962                       (: '{' 'EOF' '++' :)
            or $state[$p:lk] = 383090                       (: '{' 'IGNORE_CASE' '++' :)
            or $state[$p:lk] = 383218                       (: '{' 'JAVACODE' '++' :)
            or $state[$p:lk] = 383346                       (: '{' 'LOOKAHEAD' '++' :)
            or $state[$p:lk] = 383474                       (: '{' 'MORE' '++' :)
            or $state[$p:lk] = 383602                       (: '{' 'PARSER_BEGIN' '++' :)
            or $state[$p:lk] = 383730                       (: '{' 'PARSER_END' '++' :)
            or $state[$p:lk] = 383858                       (: '{' 'SKIP' '++' :)
            or $state[$p:lk] = 383986                       (: '{' 'SPECIAL_TOKEN' '++' :)
            or $state[$p:lk] = 384114                       (: '{' 'TOKEN' '++' :)
            or $state[$p:lk] = 384242                       (: '{' 'TOKEN_MGR_DECLS' '++' :)
            or $state[$p:lk] = 386930                       (: '{' 'false' '++' :)
            or $state[$p:lk] = 388722                       (: '{' 'null' '++' :)
            or $state[$p:lk] = 390386                       (: '{' 'this' '++' :)
            or $state[$p:lk] = 390898                       (: '{' 'true' '++' :)
            or $state[$p:lk] = 393458                       (: '{' IDENTIFIER '+=' :)
            or $state[$p:lk] = 393842                       (: '{' INTEGER_LITERAL '+=' :)
            or $state[$p:lk] = 393970                       (: '{' FLOATING_POINT_LITERAL '+=' :)
            or $state[$p:lk] = 394098                       (: '{' CHARACTER_LITERAL '+=' :)
            or $state[$p:lk] = 394226                       (: '{' STRING_LITERAL '+=' :)
            or $state[$p:lk] = 399346                       (: '{' 'EOF' '+=' :)
            or $state[$p:lk] = 399474                       (: '{' 'IGNORE_CASE' '+=' :)
            or $state[$p:lk] = 399602                       (: '{' 'JAVACODE' '+=' :)
            or $state[$p:lk] = 399730                       (: '{' 'LOOKAHEAD' '+=' :)
            or $state[$p:lk] = 399858                       (: '{' 'MORE' '+=' :)
            or $state[$p:lk] = 399986                       (: '{' 'PARSER_BEGIN' '+=' :)
            or $state[$p:lk] = 400114                       (: '{' 'PARSER_END' '+=' :)
            or $state[$p:lk] = 400242                       (: '{' 'SKIP' '+=' :)
            or $state[$p:lk] = 400370                       (: '{' 'SPECIAL_TOKEN' '+=' :)
            or $state[$p:lk] = 400498                       (: '{' 'TOKEN' '+=' :)
            or $state[$p:lk] = 400626                       (: '{' 'TOKEN_MGR_DECLS' '+=' :)
            or $state[$p:lk] = 403314                       (: '{' 'false' '+=' :)
            or $state[$p:lk] = 405106                       (: '{' 'null' '+=' :)
            or $state[$p:lk] = 406770                       (: '{' 'this' '+=' :)
            or $state[$p:lk] = 407282                       (: '{' 'true' '+=' :)
            or $state[$p:lk] = 428402                       (: '{' '(' '-' :)
            or $state[$p:lk] = 442610                       (: '{' IDENTIFIER '--' :)
            or $state[$p:lk] = 442994                       (: '{' INTEGER_LITERAL '--' :)
            or $state[$p:lk] = 443122                       (: '{' FLOATING_POINT_LITERAL '--' :)
            or $state[$p:lk] = 443250                       (: '{' CHARACTER_LITERAL '--' :)
            or $state[$p:lk] = 443378                       (: '{' STRING_LITERAL '--' :)
            or $state[$p:lk] = 444786                       (: '{' '(' '--' :)
            or $state[$p:lk] = 448498                       (: '{' 'EOF' '--' :)
            or $state[$p:lk] = 448626                       (: '{' 'IGNORE_CASE' '--' :)
            or $state[$p:lk] = 448754                       (: '{' 'JAVACODE' '--' :)
            or $state[$p:lk] = 448882                       (: '{' 'LOOKAHEAD' '--' :)
            or $state[$p:lk] = 449010                       (: '{' 'MORE' '--' :)
            or $state[$p:lk] = 449138                       (: '{' 'PARSER_BEGIN' '--' :)
            or $state[$p:lk] = 449266                       (: '{' 'PARSER_END' '--' :)
            or $state[$p:lk] = 449394                       (: '{' 'SKIP' '--' :)
            or $state[$p:lk] = 449522                       (: '{' 'SPECIAL_TOKEN' '--' :)
            or $state[$p:lk] = 449650                       (: '{' 'TOKEN' '--' :)
            or $state[$p:lk] = 449778                       (: '{' 'TOKEN_MGR_DECLS' '--' :)
            or $state[$p:lk] = 452466                       (: '{' 'false' '--' :)
            or $state[$p:lk] = 454258                       (: '{' 'null' '--' :)
            or $state[$p:lk] = 455922                       (: '{' 'this' '--' :)
            or $state[$p:lk] = 456434                       (: '{' 'true' '--' :)
            or $state[$p:lk] = 458994                       (: '{' IDENTIFIER '-=' :)
            or $state[$p:lk] = 459378                       (: '{' INTEGER_LITERAL '-=' :)
            or $state[$p:lk] = 459506                       (: '{' FLOATING_POINT_LITERAL '-=' :)
            or $state[$p:lk] = 459634                       (: '{' CHARACTER_LITERAL '-=' :)
            or $state[$p:lk] = 459762                       (: '{' STRING_LITERAL '-=' :)
            or $state[$p:lk] = 464882                       (: '{' 'EOF' '-=' :)
            or $state[$p:lk] = 465010                       (: '{' 'IGNORE_CASE' '-=' :)
            or $state[$p:lk] = 465138                       (: '{' 'JAVACODE' '-=' :)
            or $state[$p:lk] = 465266                       (: '{' 'LOOKAHEAD' '-=' :)
            or $state[$p:lk] = 465394                       (: '{' 'MORE' '-=' :)
            or $state[$p:lk] = 465522                       (: '{' 'PARSER_BEGIN' '-=' :)
            or $state[$p:lk] = 465650                       (: '{' 'PARSER_END' '-=' :)
            or $state[$p:lk] = 465778                       (: '{' 'SKIP' '-=' :)
            or $state[$p:lk] = 465906                       (: '{' 'SPECIAL_TOKEN' '-=' :)
            or $state[$p:lk] = 466034                       (: '{' 'TOKEN' '-=' :)
            or $state[$p:lk] = 466162                       (: '{' 'TOKEN_MGR_DECLS' '-=' :)
            or $state[$p:lk] = 468850                       (: '{' 'false' '-=' :)
            or $state[$p:lk] = 470642                       (: '{' 'null' '-=' :)
            or $state[$p:lk] = 472306                       (: '{' 'this' '-=' :)
            or $state[$p:lk] = 472818                       (: '{' 'true' '-=' :)
            or $state[$p:lk] = 475378                       (: '{' IDENTIFIER '.' :)
            or $state[$p:lk] = 475762                       (: '{' INTEGER_LITERAL '.' :)
            or $state[$p:lk] = 475890                       (: '{' FLOATING_POINT_LITERAL '.' :)
            or $state[$p:lk] = 476018                       (: '{' CHARACTER_LITERAL '.' :)
            or $state[$p:lk] = 476146                       (: '{' STRING_LITERAL '.' :)
            or $state[$p:lk] = 481266                       (: '{' 'EOF' '.' :)
            or $state[$p:lk] = 481394                       (: '{' 'IGNORE_CASE' '.' :)
            or $state[$p:lk] = 481522                       (: '{' 'JAVACODE' '.' :)
            or $state[$p:lk] = 481650                       (: '{' 'LOOKAHEAD' '.' :)
            or $state[$p:lk] = 481778                       (: '{' 'MORE' '.' :)
            or $state[$p:lk] = 481906                       (: '{' 'PARSER_BEGIN' '.' :)
            or $state[$p:lk] = 482034                       (: '{' 'PARSER_END' '.' :)
            or $state[$p:lk] = 482162                       (: '{' 'SKIP' '.' :)
            or $state[$p:lk] = 482290                       (: '{' 'SPECIAL_TOKEN' '.' :)
            or $state[$p:lk] = 482418                       (: '{' 'TOKEN' '.' :)
            or $state[$p:lk] = 482546                       (: '{' 'TOKEN_MGR_DECLS' '.' :)
            or $state[$p:lk] = 483442                       (: '{' 'boolean' '.' :)
            or $state[$p:lk] = 483698                       (: '{' 'byte' '.' :)
            or $state[$p:lk] = 484082                       (: '{' 'char' '.' :)
            or $state[$p:lk] = 484722                       (: '{' 'double' '.' :)
            or $state[$p:lk] = 485234                       (: '{' 'false' '.' :)
            or $state[$p:lk] = 485618                       (: '{' 'float' '.' :)
            or $state[$p:lk] = 486386                       (: '{' 'int' '.' :)
            or $state[$p:lk] = 486642                       (: '{' 'long' '.' :)
            or $state[$p:lk] = 487026                       (: '{' 'null' '.' :)
            or $state[$p:lk] = 487922                       (: '{' 'short' '.' :)
            or $state[$p:lk] = 488306                       (: '{' 'super' '.' :)
            or $state[$p:lk] = 488690                       (: '{' 'this' '.' :)
            or $state[$p:lk] = 489202                       (: '{' 'true' '.' :)
            or $state[$p:lk] = 489458                       (: '{' 'void' '.' :)
            or $state[$p:lk] = 524530                       (: '{' IDENTIFIER '/=' :)
            or $state[$p:lk] = 524914                       (: '{' INTEGER_LITERAL '/=' :)
            or $state[$p:lk] = 525042                       (: '{' FLOATING_POINT_LITERAL '/=' :)
            or $state[$p:lk] = 525170                       (: '{' CHARACTER_LITERAL '/=' :)
            or $state[$p:lk] = 525298                       (: '{' STRING_LITERAL '/=' :)
            or $state[$p:lk] = 530418                       (: '{' 'EOF' '/=' :)
            or $state[$p:lk] = 530546                       (: '{' 'IGNORE_CASE' '/=' :)
            or $state[$p:lk] = 530674                       (: '{' 'JAVACODE' '/=' :)
            or $state[$p:lk] = 530802                       (: '{' 'LOOKAHEAD' '/=' :)
            or $state[$p:lk] = 530930                       (: '{' 'MORE' '/=' :)
            or $state[$p:lk] = 531058                       (: '{' 'PARSER_BEGIN' '/=' :)
            or $state[$p:lk] = 531186                       (: '{' 'PARSER_END' '/=' :)
            or $state[$p:lk] = 531314                       (: '{' 'SKIP' '/=' :)
            or $state[$p:lk] = 531442                       (: '{' 'SPECIAL_TOKEN' '/=' :)
            or $state[$p:lk] = 531570                       (: '{' 'TOKEN' '/=' :)
            or $state[$p:lk] = 531698                       (: '{' 'TOKEN_MGR_DECLS' '/=' :)
            or $state[$p:lk] = 534386                       (: '{' 'false' '/=' :)
            or $state[$p:lk] = 536178                       (: '{' 'null' '/=' :)
            or $state[$p:lk] = 537842                       (: '{' 'this' '/=' :)
            or $state[$p:lk] = 538354                       (: '{' 'true' '/=' :)
            or $state[$p:lk] = 573682                       (: '{' IDENTIFIER '<' :)
            or $state[$p:lk] = 606450                       (: '{' IDENTIFIER '<<=' :)
            or $state[$p:lk] = 606834                       (: '{' INTEGER_LITERAL '<<=' :)
            or $state[$p:lk] = 606962                       (: '{' FLOATING_POINT_LITERAL '<<=' :)
            or $state[$p:lk] = 607090                       (: '{' CHARACTER_LITERAL '<<=' :)
            or $state[$p:lk] = 607218                       (: '{' STRING_LITERAL '<<=' :)
            or $state[$p:lk] = 612338                       (: '{' 'EOF' '<<=' :)
            or $state[$p:lk] = 612466                       (: '{' 'IGNORE_CASE' '<<=' :)
            or $state[$p:lk] = 612594                       (: '{' 'JAVACODE' '<<=' :)
            or $state[$p:lk] = 612722                       (: '{' 'LOOKAHEAD' '<<=' :)
            or $state[$p:lk] = 612850                       (: '{' 'MORE' '<<=' :)
            or $state[$p:lk] = 612978                       (: '{' 'PARSER_BEGIN' '<<=' :)
            or $state[$p:lk] = 613106                       (: '{' 'PARSER_END' '<<=' :)
            or $state[$p:lk] = 613234                       (: '{' 'SKIP' '<<=' :)
            or $state[$p:lk] = 613362                       (: '{' 'SPECIAL_TOKEN' '<<=' :)
            or $state[$p:lk] = 613490                       (: '{' 'TOKEN' '<<=' :)
            or $state[$p:lk] = 613618                       (: '{' 'TOKEN_MGR_DECLS' '<<=' :)
            or $state[$p:lk] = 616306                       (: '{' 'false' '<<=' :)
            or $state[$p:lk] = 618098                       (: '{' 'null' '<<=' :)
            or $state[$p:lk] = 619762                       (: '{' 'this' '<<=' :)
            or $state[$p:lk] = 620274                       (: '{' 'true' '<<=' :)
            or $state[$p:lk] = 639218                       (: '{' IDENTIFIER '=' :)
            or $state[$p:lk] = 639602                       (: '{' INTEGER_LITERAL '=' :)
            or $state[$p:lk] = 639730                       (: '{' FLOATING_POINT_LITERAL '=' :)
            or $state[$p:lk] = 639858                       (: '{' CHARACTER_LITERAL '=' :)
            or $state[$p:lk] = 639986                       (: '{' STRING_LITERAL '=' :)
            or $state[$p:lk] = 645106                       (: '{' 'EOF' '=' :)
            or $state[$p:lk] = 645234                       (: '{' 'IGNORE_CASE' '=' :)
            or $state[$p:lk] = 645362                       (: '{' 'JAVACODE' '=' :)
            or $state[$p:lk] = 645490                       (: '{' 'LOOKAHEAD' '=' :)
            or $state[$p:lk] = 645618                       (: '{' 'MORE' '=' :)
            or $state[$p:lk] = 645746                       (: '{' 'PARSER_BEGIN' '=' :)
            or $state[$p:lk] = 645874                       (: '{' 'PARSER_END' '=' :)
            or $state[$p:lk] = 646002                       (: '{' 'SKIP' '=' :)
            or $state[$p:lk] = 646130                       (: '{' 'SPECIAL_TOKEN' '=' :)
            or $state[$p:lk] = 646258                       (: '{' 'TOKEN' '=' :)
            or $state[$p:lk] = 646386                       (: '{' 'TOKEN_MGR_DECLS' '=' :)
            or $state[$p:lk] = 649074                       (: '{' 'false' '=' :)
            or $state[$p:lk] = 650866                       (: '{' 'null' '=' :)
            or $state[$p:lk] = 652530                       (: '{' 'this' '=' :)
            or $state[$p:lk] = 653042                       (: '{' 'true' '=' :)
            or $state[$p:lk] = 704754                       (: '{' IDENTIFIER '>>=' :)
            or $state[$p:lk] = 705138                       (: '{' INTEGER_LITERAL '>>=' :)
            or $state[$p:lk] = 705266                       (: '{' FLOATING_POINT_LITERAL '>>=' :)
            or $state[$p:lk] = 705394                       (: '{' CHARACTER_LITERAL '>>=' :)
            or $state[$p:lk] = 705522                       (: '{' STRING_LITERAL '>>=' :)
            or $state[$p:lk] = 710642                       (: '{' 'EOF' '>>=' :)
            or $state[$p:lk] = 710770                       (: '{' 'IGNORE_CASE' '>>=' :)
            or $state[$p:lk] = 710898                       (: '{' 'JAVACODE' '>>=' :)
            or $state[$p:lk] = 711026                       (: '{' 'LOOKAHEAD' '>>=' :)
            or $state[$p:lk] = 711154                       (: '{' 'MORE' '>>=' :)
            or $state[$p:lk] = 711282                       (: '{' 'PARSER_BEGIN' '>>=' :)
            or $state[$p:lk] = 711410                       (: '{' 'PARSER_END' '>>=' :)
            or $state[$p:lk] = 711538                       (: '{' 'SKIP' '>>=' :)
            or $state[$p:lk] = 711666                       (: '{' 'SPECIAL_TOKEN' '>>=' :)
            or $state[$p:lk] = 711794                       (: '{' 'TOKEN' '>>=' :)
            or $state[$p:lk] = 711922                       (: '{' 'TOKEN_MGR_DECLS' '>>=' :)
            or $state[$p:lk] = 714610                       (: '{' 'false' '>>=' :)
            or $state[$p:lk] = 716402                       (: '{' 'null' '>>=' :)
            or $state[$p:lk] = 718066                       (: '{' 'this' '>>=' :)
            or $state[$p:lk] = 718578                       (: '{' 'true' '>>=' :)
            or $state[$p:lk] = 721138                       (: '{' IDENTIFIER '>>>=' :)
            or $state[$p:lk] = 721522                       (: '{' INTEGER_LITERAL '>>>=' :)
            or $state[$p:lk] = 721650                       (: '{' FLOATING_POINT_LITERAL '>>>=' :)
            or $state[$p:lk] = 721778                       (: '{' CHARACTER_LITERAL '>>>=' :)
            or $state[$p:lk] = 721906                       (: '{' STRING_LITERAL '>>>=' :)
            or $state[$p:lk] = 727026                       (: '{' 'EOF' '>>>=' :)
            or $state[$p:lk] = 727154                       (: '{' 'IGNORE_CASE' '>>>=' :)
            or $state[$p:lk] = 727282                       (: '{' 'JAVACODE' '>>>=' :)
            or $state[$p:lk] = 727410                       (: '{' 'LOOKAHEAD' '>>>=' :)
            or $state[$p:lk] = 727538                       (: '{' 'MORE' '>>>=' :)
            or $state[$p:lk] = 727666                       (: '{' 'PARSER_BEGIN' '>>>=' :)
            or $state[$p:lk] = 727794                       (: '{' 'PARSER_END' '>>>=' :)
            or $state[$p:lk] = 727922                       (: '{' 'SKIP' '>>>=' :)
            or $state[$p:lk] = 728050                       (: '{' 'SPECIAL_TOKEN' '>>>=' :)
            or $state[$p:lk] = 728178                       (: '{' 'TOKEN' '>>>=' :)
            or $state[$p:lk] = 728306                       (: '{' 'TOKEN_MGR_DECLS' '>>>=' :)
            or $state[$p:lk] = 730994                       (: '{' 'false' '>>>=' :)
            or $state[$p:lk] = 732786                       (: '{' 'null' '>>>=' :)
            or $state[$p:lk] = 734450                       (: '{' 'this' '>>>=' :)
            or $state[$p:lk] = 734962                       (: '{' 'true' '>>>=' :)
            or $state[$p:lk] = 772466                       (: '{' '(' 'EOF' :)
            or $state[$p:lk] = 773106                       (: '{' '++' 'EOF' :)
            or $state[$p:lk] = 773618                       (: '{' '--' 'EOF' :)
            or $state[$p:lk] = 788850                       (: '{' '(' 'IGNORE_CASE' :)
            or $state[$p:lk] = 789490                       (: '{' '++' 'IGNORE_CASE' :)
            or $state[$p:lk] = 790002                       (: '{' '--' 'IGNORE_CASE' :)
            or $state[$p:lk] = 805234                       (: '{' '(' 'JAVACODE' :)
            or $state[$p:lk] = 805874                       (: '{' '++' 'JAVACODE' :)
            or $state[$p:lk] = 806386                       (: '{' '--' 'JAVACODE' :)
            or $state[$p:lk] = 821618                       (: '{' '(' 'LOOKAHEAD' :)
            or $state[$p:lk] = 822258                       (: '{' '++' 'LOOKAHEAD' :)
            or $state[$p:lk] = 822770                       (: '{' '--' 'LOOKAHEAD' :)
            or $state[$p:lk] = 838002                       (: '{' '(' 'MORE' :)
            or $state[$p:lk] = 838642                       (: '{' '++' 'MORE' :)
            or $state[$p:lk] = 839154                       (: '{' '--' 'MORE' :)
            or $state[$p:lk] = 854386                       (: '{' '(' 'PARSER_BEGIN' :)
            or $state[$p:lk] = 855026                       (: '{' '++' 'PARSER_BEGIN' :)
            or $state[$p:lk] = 855538                       (: '{' '--' 'PARSER_BEGIN' :)
            or $state[$p:lk] = 870770                       (: '{' '(' 'PARSER_END' :)
            or $state[$p:lk] = 871410                       (: '{' '++' 'PARSER_END' :)
            or $state[$p:lk] = 871922                       (: '{' '--' 'PARSER_END' :)
            or $state[$p:lk] = 887154                       (: '{' '(' 'SKIP' :)
            or $state[$p:lk] = 887794                       (: '{' '++' 'SKIP' :)
            or $state[$p:lk] = 888306                       (: '{' '--' 'SKIP' :)
            or $state[$p:lk] = 903538                       (: '{' '(' 'SPECIAL_TOKEN' :)
            or $state[$p:lk] = 904178                       (: '{' '++' 'SPECIAL_TOKEN' :)
            or $state[$p:lk] = 904690                       (: '{' '--' 'SPECIAL_TOKEN' :)
            or $state[$p:lk] = 919922                       (: '{' '(' 'TOKEN' :)
            or $state[$p:lk] = 920562                       (: '{' '++' 'TOKEN' :)
            or $state[$p:lk] = 921074                       (: '{' '--' 'TOKEN' :)
            or $state[$p:lk] = 936306                       (: '{' '(' 'TOKEN_MGR_DECLS' :)
            or $state[$p:lk] = 936946                       (: '{' '++' 'TOKEN_MGR_DECLS' :)
            or $state[$p:lk] = 937458                       (: '{' '--' 'TOKEN_MGR_DECLS' :)
            or $state[$p:lk] = 950514                       (: '{' IDENTIFIER '[' :)
            or $state[$p:lk] = 950898                       (: '{' INTEGER_LITERAL '[' :)
            or $state[$p:lk] = 951026                       (: '{' FLOATING_POINT_LITERAL '[' :)
            or $state[$p:lk] = 951154                       (: '{' CHARACTER_LITERAL '[' :)
            or $state[$p:lk] = 951282                       (: '{' STRING_LITERAL '[' :)
            or $state[$p:lk] = 956402                       (: '{' 'EOF' '[' :)
            or $state[$p:lk] = 956530                       (: '{' 'IGNORE_CASE' '[' :)
            or $state[$p:lk] = 956658                       (: '{' 'JAVACODE' '[' :)
            or $state[$p:lk] = 956786                       (: '{' 'LOOKAHEAD' '[' :)
            or $state[$p:lk] = 956914                       (: '{' 'MORE' '[' :)
            or $state[$p:lk] = 957042                       (: '{' 'PARSER_BEGIN' '[' :)
            or $state[$p:lk] = 957170                       (: '{' 'PARSER_END' '[' :)
            or $state[$p:lk] = 957298                       (: '{' 'SKIP' '[' :)
            or $state[$p:lk] = 957426                       (: '{' 'SPECIAL_TOKEN' '[' :)
            or $state[$p:lk] = 957554                       (: '{' 'TOKEN' '[' :)
            or $state[$p:lk] = 957682                       (: '{' 'TOKEN_MGR_DECLS' '[' :)
            or $state[$p:lk] = 958578                       (: '{' 'boolean' '[' :)
            or $state[$p:lk] = 958834                       (: '{' 'byte' '[' :)
            or $state[$p:lk] = 959218                       (: '{' 'char' '[' :)
            or $state[$p:lk] = 959858                       (: '{' 'double' '[' :)
            or $state[$p:lk] = 960370                       (: '{' 'false' '[' :)
            or $state[$p:lk] = 960754                       (: '{' 'float' '[' :)
            or $state[$p:lk] = 961522                       (: '{' 'int' '[' :)
            or $state[$p:lk] = 961778                       (: '{' 'long' '[' :)
            or $state[$p:lk] = 962162                       (: '{' 'null' '[' :)
            or $state[$p:lk] = 963058                       (: '{' 'short' '[' :)
            or $state[$p:lk] = 963826                       (: '{' 'this' '[' :)
            or $state[$p:lk] = 964338                       (: '{' 'true' '[' :)
            or $state[$p:lk] = 999666                       (: '{' IDENTIFIER '^=' :)
            or $state[$p:lk] = 1000050                      (: '{' INTEGER_LITERAL '^=' :)
            or $state[$p:lk] = 1000178                      (: '{' FLOATING_POINT_LITERAL '^=' :)
            or $state[$p:lk] = 1000306                      (: '{' CHARACTER_LITERAL '^=' :)
            or $state[$p:lk] = 1000434                      (: '{' STRING_LITERAL '^=' :)
            or $state[$p:lk] = 1005554                      (: '{' 'EOF' '^=' :)
            or $state[$p:lk] = 1005682                      (: '{' 'IGNORE_CASE' '^=' :)
            or $state[$p:lk] = 1005810                      (: '{' 'JAVACODE' '^=' :)
            or $state[$p:lk] = 1005938                      (: '{' 'LOOKAHEAD' '^=' :)
            or $state[$p:lk] = 1006066                      (: '{' 'MORE' '^=' :)
            or $state[$p:lk] = 1006194                      (: '{' 'PARSER_BEGIN' '^=' :)
            or $state[$p:lk] = 1006322                      (: '{' 'PARSER_END' '^=' :)
            or $state[$p:lk] = 1006450                      (: '{' 'SKIP' '^=' :)
            or $state[$p:lk] = 1006578                      (: '{' 'SPECIAL_TOKEN' '^=' :)
            or $state[$p:lk] = 1006706                      (: '{' 'TOKEN' '^=' :)
            or $state[$p:lk] = 1006834                      (: '{' 'TOKEN_MGR_DECLS' '^=' :)
            or $state[$p:lk] = 1009522                      (: '{' 'false' '^=' :)
            or $state[$p:lk] = 1011314                      (: '{' 'null' '^=' :)
            or $state[$p:lk] = 1012978                      (: '{' 'this' '^=' :)
            or $state[$p:lk] = 1013490                      (: '{' 'true' '^=' :)
            or $state[$p:lk] = 1050994                      (: '{' '(' 'boolean' :)
            or $state[$p:lk] = 1051634                      (: '{' '++' 'boolean' :)
            or $state[$p:lk] = 1052146                      (: '{' '--' 'boolean' :)
            or $state[$p:lk] = 1060338                      (: '{' 'new' 'boolean' :)
            or $state[$p:lk] = 1083762                      (: '{' '(' 'byte' :)
            or $state[$p:lk] = 1084402                      (: '{' '++' 'byte' :)
            or $state[$p:lk] = 1084914                      (: '{' '--' 'byte' :)
            or $state[$p:lk] = 1093106                      (: '{' 'new' 'byte' :)
            or $state[$p:lk] = 1132914                      (: '{' '(' 'char' :)
            or $state[$p:lk] = 1133554                      (: '{' '++' 'char' :)
            or $state[$p:lk] = 1134066                      (: '{' '--' 'char' :)
            or $state[$p:lk] = 1142258                      (: '{' 'new' 'char' :)
            or $state[$p:lk] = 1214834                      (: '{' '(' 'double' :)
            or $state[$p:lk] = 1215474                      (: '{' '++' 'double' :)
            or $state[$p:lk] = 1215986                      (: '{' '--' 'double' :)
            or $state[$p:lk] = 1224178                      (: '{' 'new' 'double' :)
            or $state[$p:lk] = 1280370                      (: '{' '(' 'false' :)
            or $state[$p:lk] = 1281010                      (: '{' '++' 'false' :)
            or $state[$p:lk] = 1281522                      (: '{' '--' 'false' :)
            or $state[$p:lk] = 1329522                      (: '{' '(' 'float' :)
            or $state[$p:lk] = 1330162                      (: '{' '++' 'float' :)
            or $state[$p:lk] = 1330674                      (: '{' '--' 'float' :)
            or $state[$p:lk] = 1338866                      (: '{' 'new' 'float' :)
            or $state[$p:lk] = 1427826                      (: '{' '(' 'int' :)
            or $state[$p:lk] = 1428466                      (: '{' '++' 'int' :)
            or $state[$p:lk] = 1428978                      (: '{' '--' 'int' :)
            or $state[$p:lk] = 1437170                      (: '{' 'new' 'int' :)
            or $state[$p:lk] = 1460594                      (: '{' '(' 'long' :)
            or $state[$p:lk] = 1461234                      (: '{' '++' 'long' :)
            or $state[$p:lk] = 1461746                      (: '{' '--' 'long' :)
            or $state[$p:lk] = 1469938                      (: '{' 'new' 'long' :)
            or $state[$p:lk] = 1493362                      (: '{' '(' 'new' :)
            or $state[$p:lk] = 1494002                      (: '{' '++' 'new' :)
            or $state[$p:lk] = 1494514                      (: '{' '--' 'new' :)
            or $state[$p:lk] = 1509746                      (: '{' '(' 'null' :)
            or $state[$p:lk] = 1510386                      (: '{' '++' 'null' :)
            or $state[$p:lk] = 1510898                      (: '{' '--' 'null' :)
            or $state[$p:lk] = 1624434                      (: '{' '(' 'short' :)
            or $state[$p:lk] = 1625074                      (: '{' '++' 'short' :)
            or $state[$p:lk] = 1625586                      (: '{' '--' 'short' :)
            or $state[$p:lk] = 1633778                      (: '{' 'new' 'short' :)
            or $state[$p:lk] = 1673586                      (: '{' '(' 'super' :)
            or $state[$p:lk] = 1674226                      (: '{' '++' 'super' :)
            or $state[$p:lk] = 1674738                      (: '{' '--' 'super' :)
            or $state[$p:lk] = 1722738                      (: '{' '(' 'this' :)
            or $state[$p:lk] = 1723378                      (: '{' '++' 'this' :)
            or $state[$p:lk] = 1723890                      (: '{' '--' 'this' :)
            or $state[$p:lk] = 1788274                      (: '{' '(' 'true' :)
            or $state[$p:lk] = 1788914                      (: '{' '++' 'true' :)
            or $state[$p:lk] = 1789426                      (: '{' '--' 'true' :)
            or $state[$p:lk] = 1821042                      (: '{' '(' 'void' :)
            or $state[$p:lk] = 1821682                      (: '{' '++' 'void' :)
            or $state[$p:lk] = 1822194                      (: '{' '--' 'void' :)
            or $state[$p:lk] = 1900786                      (: '{' IDENTIFIER '|=' :)
            or $state[$p:lk] = 1901170                      (: '{' INTEGER_LITERAL '|=' :)
            or $state[$p:lk] = 1901298                      (: '{' FLOATING_POINT_LITERAL '|=' :)
            or $state[$p:lk] = 1901426                      (: '{' CHARACTER_LITERAL '|=' :)
            or $state[$p:lk] = 1901554                      (: '{' STRING_LITERAL '|=' :)
            or $state[$p:lk] = 1906674                      (: '{' 'EOF' '|=' :)
            or $state[$p:lk] = 1906802                      (: '{' 'IGNORE_CASE' '|=' :)
            or $state[$p:lk] = 1906930                      (: '{' 'JAVACODE' '|=' :)
            or $state[$p:lk] = 1907058                      (: '{' 'LOOKAHEAD' '|=' :)
            or $state[$p:lk] = 1907186                      (: '{' 'MORE' '|=' :)
            or $state[$p:lk] = 1907314                      (: '{' 'PARSER_BEGIN' '|=' :)
            or $state[$p:lk] = 1907442                      (: '{' 'PARSER_END' '|=' :)
            or $state[$p:lk] = 1907570                      (: '{' 'SKIP' '|=' :)
            or $state[$p:lk] = 1907698                      (: '{' 'SPECIAL_TOKEN' '|=' :)
            or $state[$p:lk] = 1907826                      (: '{' 'TOKEN' '|=' :)
            or $state[$p:lk] = 1907954                      (: '{' 'TOKEN_MGR_DECLS' '|=' :)
            or $state[$p:lk] = 1910642                      (: '{' 'false' '|=' :)
            or $state[$p:lk] = 1912434                      (: '{' 'null' '|=' :)
            or $state[$p:lk] = 1914098                      (: '{' 'this' '|=' :)
            or $state[$p:lk] = 1914610                      (: '{' 'true' '|=' :)
            or $state[$p:lk] = 1952114) then                (: '{' '(' '~' :)
        let $state := p:memoized($state, 1)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:lookahead1W(135, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                                'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                                'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                                'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                                'void' | '{' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-expansion_unit($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 1                                (: IDENTIFIER :)
      and $state[$p:lk] != 4                                (: INTEGER_LITERAL :)
      and $state[$p:lk] != 5                                (: FLOATING_POINT_LITERAL :)
      and $state[$p:lk] != 6                                (: CHARACTER_LITERAL :)
      and $state[$p:lk] != 7                                (: STRING_LITERAL :)
      and $state[$p:lk] != 18                               (: '(' :)
      and $state[$p:lk] != 35                               (: '<' :)
      and $state[$p:lk] != 47                               (: 'EOF' :)
      and $state[$p:lk] != 48                               (: 'IGNORE_CASE' :)
      and $state[$p:lk] != 49                               (: 'JAVACODE' :)
      and $state[$p:lk] != 50                               (: 'LOOKAHEAD' :)
      and $state[$p:lk] != 51                               (: 'MORE' :)
      and $state[$p:lk] != 52                               (: 'PARSER_BEGIN' :)
      and $state[$p:lk] != 53                               (: 'PARSER_END' :)
      and $state[$p:lk] != 54                               (: 'SKIP' :)
      and $state[$p:lk] != 55                               (: 'SPECIAL_TOKEN' :)
      and $state[$p:lk] != 56                               (: 'TOKEN' :)
      and $state[$p:lk] != 57                               (: 'TOKEN_MGR_DECLS' :)
      and $state[$p:lk] != 58                               (: '[' :)
      and $state[$p:lk] != 64                               (: 'boolean' :)
      and $state[$p:lk] != 66                               (: 'byte' :)
      and $state[$p:lk] != 69                               (: 'char' :)
      and $state[$p:lk] != 74                               (: 'double' :)
      and $state[$p:lk] != 78                               (: 'false' :)
      and $state[$p:lk] != 81                               (: 'float' :)
      and $state[$p:lk] != 87                               (: 'int' :)
      and $state[$p:lk] != 89                               (: 'long' :)
      and $state[$p:lk] != 91                               (: 'new' :)
      and $state[$p:lk] != 92                               (: 'null' :)
      and $state[$p:lk] != 99                               (: 'short' :)
      and $state[$p:lk] != 102                              (: 'super' :)
      and $state[$p:lk] != 105                              (: 'this' :)
      and $state[$p:lk] != 109                              (: 'true' :)
      and $state[$p:lk] != 110                              (: 'try' :)
      and $state[$p:lk] != 111                              (: 'void' :)
      and $state[$p:lk] != 4466                             (: '{' ';' :)
      and $state[$p:lk] != 6002                             (: '{' '@' :)
      and $state[$p:lk] != 8050                             (: '{' 'abstract' :)
      and $state[$p:lk] != 8178                             (: '{' 'assert' :)
      and $state[$p:lk] != 8434                             (: '{' 'break' :)
      and $state[$p:lk] != 9074                             (: '{' 'class' :)
      and $state[$p:lk] != 9202                             (: '{' 'continue' :)
      and $state[$p:lk] != 9458                             (: '{' 'do' :)
      and $state[$p:lk] != 10226                            (: '{' 'final' :)
      and $state[$p:lk] != 10610                            (: '{' 'for' :)
      and $state[$p:lk] != 10738                            (: '{' 'if' :)
      and $state[$p:lk] != 11378                            (: '{' 'interface' :)
      and $state[$p:lk] != 11634                            (: '{' 'native' :)
      and $state[$p:lk] != 12274                            (: '{' 'private' :)
      and $state[$p:lk] != 12402                            (: '{' 'protected' :)
      and $state[$p:lk] != 12530                            (: '{' 'public' :)
      and $state[$p:lk] != 12658                            (: '{' 'return' :)
      and $state[$p:lk] != 12914                            (: '{' 'static' :)
      and $state[$p:lk] != 13042                            (: '{' 'strictfp' :)
      and $state[$p:lk] != 13298                            (: '{' 'switch' :)
      and $state[$p:lk] != 13426                            (: '{' 'synchronized' :)
      and $state[$p:lk] != 13682                            (: '{' 'throw' :)
      and $state[$p:lk] != 13938                            (: '{' 'transient' :)
      and $state[$p:lk] != 14194                            (: '{' 'try' :)
      and $state[$p:lk] != 14450                            (: '{' 'volatile' :)
      and $state[$p:lk] != 14578                            (: '{' 'while' :)
      and $state[$p:lk] != 14706                            (: '{' '{' :)
      and $state[$p:lk] != 16626                            (: '{' IDENTIFIER IDENTIFIER :)
      and $state[$p:lk] != 24690                            (: '{' 'boolean' IDENTIFIER :)
      and $state[$p:lk] != 24946                            (: '{' 'byte' IDENTIFIER :)
      and $state[$p:lk] != 25330                            (: '{' 'char' IDENTIFIER :)
      and $state[$p:lk] != 25970                            (: '{' 'double' IDENTIFIER :)
      and $state[$p:lk] != 26866                            (: '{' 'float' IDENTIFIER :)
      and $state[$p:lk] != 27634                            (: '{' 'int' IDENTIFIER :)
      and $state[$p:lk] != 27890                            (: '{' 'long' IDENTIFIER :)
      and $state[$p:lk] != 29170                            (: '{' 'short' IDENTIFIER :)
      and $state[$p:lk] != 31602                            (: '{' '}' IDENTIFIER :)
      and $state[$p:lk] != 80754                            (: '{' '}' INTEGER_LITERAL :)
      and $state[$p:lk] != 97138                            (: '{' '}' FLOATING_POINT_LITERAL :)
      and $state[$p:lk] != 113522                           (: '{' '}' CHARACTER_LITERAL :)
      and $state[$p:lk] != 129906                           (: '{' '}' STRING_LITERAL :)
      and $state[$p:lk] != 310130                           (: '{' '}' '(' :)
      and $state[$p:lk] != 424818                           (: '{' '}' ',' :)
      and $state[$p:lk] != 540914                           (: '{' IDENTIFIER ':' :)
      and $state[$p:lk] != 557298                           (: '{' IDENTIFIER ';' :)
      and $state[$p:lk] != 557682                           (: '{' INTEGER_LITERAL ';' :)
      and $state[$p:lk] != 557810                           (: '{' FLOATING_POINT_LITERAL ';' :)
      and $state[$p:lk] != 557938                           (: '{' CHARACTER_LITERAL ';' :)
      and $state[$p:lk] != 558066                           (: '{' STRING_LITERAL ';' :)
      and $state[$p:lk] != 563186                           (: '{' 'EOF' ';' :)
      and $state[$p:lk] != 563314                           (: '{' 'IGNORE_CASE' ';' :)
      and $state[$p:lk] != 563442                           (: '{' 'JAVACODE' ';' :)
      and $state[$p:lk] != 563570                           (: '{' 'LOOKAHEAD' ';' :)
      and $state[$p:lk] != 563698                           (: '{' 'MORE' ';' :)
      and $state[$p:lk] != 563826                           (: '{' 'PARSER_BEGIN' ';' :)
      and $state[$p:lk] != 563954                           (: '{' 'PARSER_END' ';' :)
      and $state[$p:lk] != 564082                           (: '{' 'SKIP' ';' :)
      and $state[$p:lk] != 564210                           (: '{' 'SPECIAL_TOKEN' ';' :)
      and $state[$p:lk] != 564338                           (: '{' 'TOKEN' ';' :)
      and $state[$p:lk] != 564466                           (: '{' 'TOKEN_MGR_DECLS' ';' :)
      and $state[$p:lk] != 567154                           (: '{' 'false' ';' :)
      and $state[$p:lk] != 568946                           (: '{' 'null' ';' :)
      and $state[$p:lk] != 570610                           (: '{' 'this' ';' :)
      and $state[$p:lk] != 571122                           (: '{' 'true' ';' :)
      and $state[$p:lk] != 588658                           (: '{' '}' '<' :)
      and $state[$p:lk] != 785266                           (: '{' '}' 'EOF' :)
      and $state[$p:lk] != 801650                           (: '{' '}' 'IGNORE_CASE' :)
      and $state[$p:lk] != 818034                           (: '{' '}' 'JAVACODE' :)
      and $state[$p:lk] != 834418                           (: '{' '}' 'LOOKAHEAD' :)
      and $state[$p:lk] != 850802                           (: '{' '}' 'MORE' :)
      and $state[$p:lk] != 867186                           (: '{' '}' 'PARSER_BEGIN' :)
      and $state[$p:lk] != 883570                           (: '{' '}' 'PARSER_END' :)
      and $state[$p:lk] != 899954                           (: '{' '}' 'SKIP' :)
      and $state[$p:lk] != 916338                           (: '{' '}' 'SPECIAL_TOKEN' :)
      and $state[$p:lk] != 932722                           (: '{' '}' 'TOKEN' :)
      and $state[$p:lk] != 949106                           (: '{' '}' 'TOKEN_MGR_DECLS' :)
      and $state[$p:lk] != 965490                           (: '{' '}' '[' :)
      and $state[$p:lk] != 981874                           (: '{' '}' ']' :)
      and $state[$p:lk] != 1063794                          (: '{' '}' 'boolean' :)
      and $state[$p:lk] != 1096562                          (: '{' '}' 'byte' :)
      and $state[$p:lk] != 1145714                          (: '{' '}' 'char' :)
      and $state[$p:lk] != 1227634                          (: '{' '}' 'double' :)
      and $state[$p:lk] != 1293170                          (: '{' '}' 'false' :)
      and $state[$p:lk] != 1342322                          (: '{' '}' 'float' :)
      and $state[$p:lk] != 1440626                          (: '{' '}' 'int' :)
      and $state[$p:lk] != 1473394                          (: '{' '}' 'long' :)
      and $state[$p:lk] != 1506162                          (: '{' '}' 'new' :)
      and $state[$p:lk] != 1522546                          (: '{' '}' 'null' :)
      and $state[$p:lk] != 1637234                          (: '{' '}' 'short' :)
      and $state[$p:lk] != 1686386                          (: '{' '}' 'super' :)
      and $state[$p:lk] != 1735538                          (: '{' '}' 'this' :)
      and $state[$p:lk] != 1801074                          (: '{' '}' 'true' :)
      and $state[$p:lk] != 1817458                          (: '{' '}' 'try' :)
      and $state[$p:lk] != 1833842                          (: '{' '}' 'void' :)
      and $state[$p:lk] != 1882994                          (: '{' '}' '{' :)
      and $state[$p:lk] != 1899378                          (: '{' '}' '|' :)
      and $state[$p:lk] != 1948530) then                    (: '{' '}' '}' :)
        $state
      else
        p:parse-expansion-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production expansion (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expansion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-expansion_unit($input, $state)
    let $state := p:lookahead1W(156, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                               '}' :)
    let $state :=
      if ($state[$p:l1] eq 114) then                        (: '{' :)
        let $state := p:lookahead2W(171, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' | '~' :)
        let $state :=
          if ($state[$p:lk] eq 242) then                    (: '{' IDENTIFIER :)
            let $state := p:lookahead3W(153, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                                '&=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' |
                                                                '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                                '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' |
                                                                '>>>=' | '?' | '[' | '^' | '^=' | 'instanceof' | '|' |
                                                                '|=' | '||' | '}' :)
            return $state
          else if ($state[$p:lk] eq 2418) then              (: '{' '(' :)
            let $state := p:lookahead3W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'void' | '~' :)
            return $state
          else if ($state[$p:lk] eq 11762) then             (: '{' 'new' :)
            let $state := p:lookahead3W(91, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
            return $state
          else if ($state[$p:lk] eq 15218) then             (: '{' '}' :)
            let $state := p:lookahead3W(156, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                                'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                                'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                                'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                                ']' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'try' | 'void' | '{' | '|' |
                                                                '}' :)
            return $state
          else if ($state[$p:lk] = (3058,                   (: '{' '++' :)
                                    3570)) then             (: '{' '--' :)
            let $state := p:lookahead3W(129, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                                'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                                'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
            return $state
          else if ($state[$p:lk] = (13170,                  (: '{' 'super' :)
                                    14322)) then            (: '{' 'void' :)
            let $state := p:lookahead3W(6, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
            return $state
          else if ($state[$p:lk] = (8306,                   (: '{' 'boolean' :)
                                    8562,                   (: '{' 'byte' :)
                                    8946,                   (: '{' 'char' :)
                                    9586,                   (: '{' 'double' :)
                                    10482,                  (: '{' 'float' :)
                                    11250,                  (: '{' 'int' :)
                                    11506,                  (: '{' 'long' :)
                                    12786)) then            (: '{' 'short' :)
            let $state := p:lookahead3W(55, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
            return $state
          else if ($state[$p:lk] = (626,                    (: '{' INTEGER_LITERAL :)
                                    754,                    (: '{' FLOATING_POINT_LITERAL :)
                                    882,                    (: '{' CHARACTER_LITERAL :)
                                    1010,                   (: '{' STRING_LITERAL :)
                                    6130,                   (: '{' 'EOF' :)
                                    6258,                   (: '{' 'IGNORE_CASE' :)
                                    6386,                   (: '{' 'JAVACODE' :)
                                    6514,                   (: '{' 'LOOKAHEAD' :)
                                    6642,                   (: '{' 'MORE' :)
                                    6770,                   (: '{' 'PARSER_BEGIN' :)
                                    6898,                   (: '{' 'PARSER_END' :)
                                    7026,                   (: '{' 'SKIP' :)
                                    7154,                   (: '{' 'SPECIAL_TOKEN' :)
                                    7282,                   (: '{' 'TOKEN' :)
                                    7410,                   (: '{' 'TOKEN_MGR_DECLS' :)
                                    10098,                  (: '{' 'false' :)
                                    11890,                  (: '{' 'null' :)
                                    13554,                  (: '{' 'this' :)
                                    14066)) then            (: '{' 'true' :)
            let $state := p:lookahead3W(141, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                                '%' | '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' |
                                                                '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                                '/=' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' |
                                                                '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                                'instanceof' | '|' | '|=' | '||' | '}' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 18802                        (: '{' '(' IDENTIFIER :)
            or $state[$p:lk] = 19442                        (: '{' '++' IDENTIFIER :)
            or $state[$p:lk] = 19954                        (: '{' '--' IDENTIFIER :)
            or $state[$p:lk] = 28146                        (: '{' 'new' IDENTIFIER :)
            or $state[$p:lk] = 67954                        (: '{' '(' INTEGER_LITERAL :)
            or $state[$p:lk] = 68594                        (: '{' '++' INTEGER_LITERAL :)
            or $state[$p:lk] = 69106                        (: '{' '--' INTEGER_LITERAL :)
            or $state[$p:lk] = 84338                        (: '{' '(' FLOATING_POINT_LITERAL :)
            or $state[$p:lk] = 84978                        (: '{' '++' FLOATING_POINT_LITERAL :)
            or $state[$p:lk] = 85490                        (: '{' '--' FLOATING_POINT_LITERAL :)
            or $state[$p:lk] = 100722                       (: '{' '(' CHARACTER_LITERAL :)
            or $state[$p:lk] = 101362                       (: '{' '++' CHARACTER_LITERAL :)
            or $state[$p:lk] = 101874                       (: '{' '--' CHARACTER_LITERAL :)
            or $state[$p:lk] = 117106                       (: '{' '(' STRING_LITERAL :)
            or $state[$p:lk] = 117746                       (: '{' '++' STRING_LITERAL :)
            or $state[$p:lk] = 118258                       (: '{' '--' STRING_LITERAL :)
            or $state[$p:lk] = 166258                       (: '{' '(' '!' :)
            or $state[$p:lk] = 229618                       (: '{' IDENTIFIER '%=' :)
            or $state[$p:lk] = 230002                       (: '{' INTEGER_LITERAL '%=' :)
            or $state[$p:lk] = 230130                       (: '{' FLOATING_POINT_LITERAL '%=' :)
            or $state[$p:lk] = 230258                       (: '{' CHARACTER_LITERAL '%=' :)
            or $state[$p:lk] = 230386                       (: '{' STRING_LITERAL '%=' :)
            or $state[$p:lk] = 235506                       (: '{' 'EOF' '%=' :)
            or $state[$p:lk] = 235634                       (: '{' 'IGNORE_CASE' '%=' :)
            or $state[$p:lk] = 235762                       (: '{' 'JAVACODE' '%=' :)
            or $state[$p:lk] = 235890                       (: '{' 'LOOKAHEAD' '%=' :)
            or $state[$p:lk] = 236018                       (: '{' 'MORE' '%=' :)
            or $state[$p:lk] = 236146                       (: '{' 'PARSER_BEGIN' '%=' :)
            or $state[$p:lk] = 236274                       (: '{' 'PARSER_END' '%=' :)
            or $state[$p:lk] = 236402                       (: '{' 'SKIP' '%=' :)
            or $state[$p:lk] = 236530                       (: '{' 'SPECIAL_TOKEN' '%=' :)
            or $state[$p:lk] = 236658                       (: '{' 'TOKEN' '%=' :)
            or $state[$p:lk] = 236786                       (: '{' 'TOKEN_MGR_DECLS' '%=' :)
            or $state[$p:lk] = 239474                       (: '{' 'false' '%=' :)
            or $state[$p:lk] = 241266                       (: '{' 'null' '%=' :)
            or $state[$p:lk] = 242930                       (: '{' 'this' '%=' :)
            or $state[$p:lk] = 243442                       (: '{' 'true' '%=' :)
            or $state[$p:lk] = 278770                       (: '{' IDENTIFIER '&=' :)
            or $state[$p:lk] = 279154                       (: '{' INTEGER_LITERAL '&=' :)
            or $state[$p:lk] = 279282                       (: '{' FLOATING_POINT_LITERAL '&=' :)
            or $state[$p:lk] = 279410                       (: '{' CHARACTER_LITERAL '&=' :)
            or $state[$p:lk] = 279538                       (: '{' STRING_LITERAL '&=' :)
            or $state[$p:lk] = 284658                       (: '{' 'EOF' '&=' :)
            or $state[$p:lk] = 284786                       (: '{' 'IGNORE_CASE' '&=' :)
            or $state[$p:lk] = 284914                       (: '{' 'JAVACODE' '&=' :)
            or $state[$p:lk] = 285042                       (: '{' 'LOOKAHEAD' '&=' :)
            or $state[$p:lk] = 285170                       (: '{' 'MORE' '&=' :)
            or $state[$p:lk] = 285298                       (: '{' 'PARSER_BEGIN' '&=' :)
            or $state[$p:lk] = 285426                       (: '{' 'PARSER_END' '&=' :)
            or $state[$p:lk] = 285554                       (: '{' 'SKIP' '&=' :)
            or $state[$p:lk] = 285682                       (: '{' 'SPECIAL_TOKEN' '&=' :)
            or $state[$p:lk] = 285810                       (: '{' 'TOKEN' '&=' :)
            or $state[$p:lk] = 285938                       (: '{' 'TOKEN_MGR_DECLS' '&=' :)
            or $state[$p:lk] = 288626                       (: '{' 'false' '&=' :)
            or $state[$p:lk] = 290418                       (: '{' 'null' '&=' :)
            or $state[$p:lk] = 292082                       (: '{' 'this' '&=' :)
            or $state[$p:lk] = 292594                       (: '{' 'true' '&=' :)
            or $state[$p:lk] = 295154                       (: '{' IDENTIFIER '(' :)
            or $state[$p:lk] = 295538                       (: '{' INTEGER_LITERAL '(' :)
            or $state[$p:lk] = 295666                       (: '{' FLOATING_POINT_LITERAL '(' :)
            or $state[$p:lk] = 295794                       (: '{' CHARACTER_LITERAL '(' :)
            or $state[$p:lk] = 295922                       (: '{' STRING_LITERAL '(' :)
            or $state[$p:lk] = 297330                       (: '{' '(' '(' :)
            or $state[$p:lk] = 297970                       (: '{' '++' '(' :)
            or $state[$p:lk] = 298482                       (: '{' '--' '(' :)
            or $state[$p:lk] = 301042                       (: '{' 'EOF' '(' :)
            or $state[$p:lk] = 301170                       (: '{' 'IGNORE_CASE' '(' :)
            or $state[$p:lk] = 301298                       (: '{' 'JAVACODE' '(' :)
            or $state[$p:lk] = 301426                       (: '{' 'LOOKAHEAD' '(' :)
            or $state[$p:lk] = 301554                       (: '{' 'MORE' '(' :)
            or $state[$p:lk] = 301682                       (: '{' 'PARSER_BEGIN' '(' :)
            or $state[$p:lk] = 301810                       (: '{' 'PARSER_END' '(' :)
            or $state[$p:lk] = 301938                       (: '{' 'SKIP' '(' :)
            or $state[$p:lk] = 302066                       (: '{' 'SPECIAL_TOKEN' '(' :)
            or $state[$p:lk] = 302194                       (: '{' 'TOKEN' '(' :)
            or $state[$p:lk] = 302322                       (: '{' 'TOKEN_MGR_DECLS' '(' :)
            or $state[$p:lk] = 305010                       (: '{' 'false' '(' :)
            or $state[$p:lk] = 306802                       (: '{' 'null' '(' :)
            or $state[$p:lk] = 308466                       (: '{' 'this' '(' :)
            or $state[$p:lk] = 308978                       (: '{' 'true' '(' :)
            or $state[$p:lk] = 326514                       (: '{' '}' ')' :)
            or $state[$p:lk] = 344306                       (: '{' IDENTIFIER '*=' :)
            or $state[$p:lk] = 344690                       (: '{' INTEGER_LITERAL '*=' :)
            or $state[$p:lk] = 344818                       (: '{' FLOATING_POINT_LITERAL '*=' :)
            or $state[$p:lk] = 344946                       (: '{' CHARACTER_LITERAL '*=' :)
            or $state[$p:lk] = 345074                       (: '{' STRING_LITERAL '*=' :)
            or $state[$p:lk] = 350194                       (: '{' 'EOF' '*=' :)
            or $state[$p:lk] = 350322                       (: '{' 'IGNORE_CASE' '*=' :)
            or $state[$p:lk] = 350450                       (: '{' 'JAVACODE' '*=' :)
            or $state[$p:lk] = 350578                       (: '{' 'LOOKAHEAD' '*=' :)
            or $state[$p:lk] = 350706                       (: '{' 'MORE' '*=' :)
            or $state[$p:lk] = 350834                       (: '{' 'PARSER_BEGIN' '*=' :)
            or $state[$p:lk] = 350962                       (: '{' 'PARSER_END' '*=' :)
            or $state[$p:lk] = 351090                       (: '{' 'SKIP' '*=' :)
            or $state[$p:lk] = 351218                       (: '{' 'SPECIAL_TOKEN' '*=' :)
            or $state[$p:lk] = 351346                       (: '{' 'TOKEN' '*=' :)
            or $state[$p:lk] = 351474                       (: '{' 'TOKEN_MGR_DECLS' '*=' :)
            or $state[$p:lk] = 354162                       (: '{' 'false' '*=' :)
            or $state[$p:lk] = 355954                       (: '{' 'null' '*=' :)
            or $state[$p:lk] = 357618                       (: '{' 'this' '*=' :)
            or $state[$p:lk] = 358130                       (: '{' 'true' '*=' :)
            or $state[$p:lk] = 362866                       (: '{' '(' '+' :)
            or $state[$p:lk] = 377074                       (: '{' IDENTIFIER '++' :)
            or $state[$p:lk] = 377458                       (: '{' INTEGER_LITERAL '++' :)
            or $state[$p:lk] = 377586                       (: '{' FLOATING_POINT_LITERAL '++' :)
            or $state[$p:lk] = 377714                       (: '{' CHARACTER_LITERAL '++' :)
            or $state[$p:lk] = 377842                       (: '{' STRING_LITERAL '++' :)
            or $state[$p:lk] = 379250                       (: '{' '(' '++' :)
            or $state[$p:lk] = 382962                       (: '{' 'EOF' '++' :)
            or $state[$p:lk] = 383090                       (: '{' 'IGNORE_CASE' '++' :)
            or $state[$p:lk] = 383218                       (: '{' 'JAVACODE' '++' :)
            or $state[$p:lk] = 383346                       (: '{' 'LOOKAHEAD' '++' :)
            or $state[$p:lk] = 383474                       (: '{' 'MORE' '++' :)
            or $state[$p:lk] = 383602                       (: '{' 'PARSER_BEGIN' '++' :)
            or $state[$p:lk] = 383730                       (: '{' 'PARSER_END' '++' :)
            or $state[$p:lk] = 383858                       (: '{' 'SKIP' '++' :)
            or $state[$p:lk] = 383986                       (: '{' 'SPECIAL_TOKEN' '++' :)
            or $state[$p:lk] = 384114                       (: '{' 'TOKEN' '++' :)
            or $state[$p:lk] = 384242                       (: '{' 'TOKEN_MGR_DECLS' '++' :)
            or $state[$p:lk] = 386930                       (: '{' 'false' '++' :)
            or $state[$p:lk] = 388722                       (: '{' 'null' '++' :)
            or $state[$p:lk] = 390386                       (: '{' 'this' '++' :)
            or $state[$p:lk] = 390898                       (: '{' 'true' '++' :)
            or $state[$p:lk] = 393458                       (: '{' IDENTIFIER '+=' :)
            or $state[$p:lk] = 393842                       (: '{' INTEGER_LITERAL '+=' :)
            or $state[$p:lk] = 393970                       (: '{' FLOATING_POINT_LITERAL '+=' :)
            or $state[$p:lk] = 394098                       (: '{' CHARACTER_LITERAL '+=' :)
            or $state[$p:lk] = 394226                       (: '{' STRING_LITERAL '+=' :)
            or $state[$p:lk] = 399346                       (: '{' 'EOF' '+=' :)
            or $state[$p:lk] = 399474                       (: '{' 'IGNORE_CASE' '+=' :)
            or $state[$p:lk] = 399602                       (: '{' 'JAVACODE' '+=' :)
            or $state[$p:lk] = 399730                       (: '{' 'LOOKAHEAD' '+=' :)
            or $state[$p:lk] = 399858                       (: '{' 'MORE' '+=' :)
            or $state[$p:lk] = 399986                       (: '{' 'PARSER_BEGIN' '+=' :)
            or $state[$p:lk] = 400114                       (: '{' 'PARSER_END' '+=' :)
            or $state[$p:lk] = 400242                       (: '{' 'SKIP' '+=' :)
            or $state[$p:lk] = 400370                       (: '{' 'SPECIAL_TOKEN' '+=' :)
            or $state[$p:lk] = 400498                       (: '{' 'TOKEN' '+=' :)
            or $state[$p:lk] = 400626                       (: '{' 'TOKEN_MGR_DECLS' '+=' :)
            or $state[$p:lk] = 403314                       (: '{' 'false' '+=' :)
            or $state[$p:lk] = 405106                       (: '{' 'null' '+=' :)
            or $state[$p:lk] = 406770                       (: '{' 'this' '+=' :)
            or $state[$p:lk] = 407282                       (: '{' 'true' '+=' :)
            or $state[$p:lk] = 428402                       (: '{' '(' '-' :)
            or $state[$p:lk] = 442610                       (: '{' IDENTIFIER '--' :)
            or $state[$p:lk] = 442994                       (: '{' INTEGER_LITERAL '--' :)
            or $state[$p:lk] = 443122                       (: '{' FLOATING_POINT_LITERAL '--' :)
            or $state[$p:lk] = 443250                       (: '{' CHARACTER_LITERAL '--' :)
            or $state[$p:lk] = 443378                       (: '{' STRING_LITERAL '--' :)
            or $state[$p:lk] = 444786                       (: '{' '(' '--' :)
            or $state[$p:lk] = 448498                       (: '{' 'EOF' '--' :)
            or $state[$p:lk] = 448626                       (: '{' 'IGNORE_CASE' '--' :)
            or $state[$p:lk] = 448754                       (: '{' 'JAVACODE' '--' :)
            or $state[$p:lk] = 448882                       (: '{' 'LOOKAHEAD' '--' :)
            or $state[$p:lk] = 449010                       (: '{' 'MORE' '--' :)
            or $state[$p:lk] = 449138                       (: '{' 'PARSER_BEGIN' '--' :)
            or $state[$p:lk] = 449266                       (: '{' 'PARSER_END' '--' :)
            or $state[$p:lk] = 449394                       (: '{' 'SKIP' '--' :)
            or $state[$p:lk] = 449522                       (: '{' 'SPECIAL_TOKEN' '--' :)
            or $state[$p:lk] = 449650                       (: '{' 'TOKEN' '--' :)
            or $state[$p:lk] = 449778                       (: '{' 'TOKEN_MGR_DECLS' '--' :)
            or $state[$p:lk] = 452466                       (: '{' 'false' '--' :)
            or $state[$p:lk] = 454258                       (: '{' 'null' '--' :)
            or $state[$p:lk] = 455922                       (: '{' 'this' '--' :)
            or $state[$p:lk] = 456434                       (: '{' 'true' '--' :)
            or $state[$p:lk] = 458994                       (: '{' IDENTIFIER '-=' :)
            or $state[$p:lk] = 459378                       (: '{' INTEGER_LITERAL '-=' :)
            or $state[$p:lk] = 459506                       (: '{' FLOATING_POINT_LITERAL '-=' :)
            or $state[$p:lk] = 459634                       (: '{' CHARACTER_LITERAL '-=' :)
            or $state[$p:lk] = 459762                       (: '{' STRING_LITERAL '-=' :)
            or $state[$p:lk] = 464882                       (: '{' 'EOF' '-=' :)
            or $state[$p:lk] = 465010                       (: '{' 'IGNORE_CASE' '-=' :)
            or $state[$p:lk] = 465138                       (: '{' 'JAVACODE' '-=' :)
            or $state[$p:lk] = 465266                       (: '{' 'LOOKAHEAD' '-=' :)
            or $state[$p:lk] = 465394                       (: '{' 'MORE' '-=' :)
            or $state[$p:lk] = 465522                       (: '{' 'PARSER_BEGIN' '-=' :)
            or $state[$p:lk] = 465650                       (: '{' 'PARSER_END' '-=' :)
            or $state[$p:lk] = 465778                       (: '{' 'SKIP' '-=' :)
            or $state[$p:lk] = 465906                       (: '{' 'SPECIAL_TOKEN' '-=' :)
            or $state[$p:lk] = 466034                       (: '{' 'TOKEN' '-=' :)
            or $state[$p:lk] = 466162                       (: '{' 'TOKEN_MGR_DECLS' '-=' :)
            or $state[$p:lk] = 468850                       (: '{' 'false' '-=' :)
            or $state[$p:lk] = 470642                       (: '{' 'null' '-=' :)
            or $state[$p:lk] = 472306                       (: '{' 'this' '-=' :)
            or $state[$p:lk] = 472818                       (: '{' 'true' '-=' :)
            or $state[$p:lk] = 475378                       (: '{' IDENTIFIER '.' :)
            or $state[$p:lk] = 475762                       (: '{' INTEGER_LITERAL '.' :)
            or $state[$p:lk] = 475890                       (: '{' FLOATING_POINT_LITERAL '.' :)
            or $state[$p:lk] = 476018                       (: '{' CHARACTER_LITERAL '.' :)
            or $state[$p:lk] = 476146                       (: '{' STRING_LITERAL '.' :)
            or $state[$p:lk] = 481266                       (: '{' 'EOF' '.' :)
            or $state[$p:lk] = 481394                       (: '{' 'IGNORE_CASE' '.' :)
            or $state[$p:lk] = 481522                       (: '{' 'JAVACODE' '.' :)
            or $state[$p:lk] = 481650                       (: '{' 'LOOKAHEAD' '.' :)
            or $state[$p:lk] = 481778                       (: '{' 'MORE' '.' :)
            or $state[$p:lk] = 481906                       (: '{' 'PARSER_BEGIN' '.' :)
            or $state[$p:lk] = 482034                       (: '{' 'PARSER_END' '.' :)
            or $state[$p:lk] = 482162                       (: '{' 'SKIP' '.' :)
            or $state[$p:lk] = 482290                       (: '{' 'SPECIAL_TOKEN' '.' :)
            or $state[$p:lk] = 482418                       (: '{' 'TOKEN' '.' :)
            or $state[$p:lk] = 482546                       (: '{' 'TOKEN_MGR_DECLS' '.' :)
            or $state[$p:lk] = 483442                       (: '{' 'boolean' '.' :)
            or $state[$p:lk] = 483698                       (: '{' 'byte' '.' :)
            or $state[$p:lk] = 484082                       (: '{' 'char' '.' :)
            or $state[$p:lk] = 484722                       (: '{' 'double' '.' :)
            or $state[$p:lk] = 485234                       (: '{' 'false' '.' :)
            or $state[$p:lk] = 485618                       (: '{' 'float' '.' :)
            or $state[$p:lk] = 486386                       (: '{' 'int' '.' :)
            or $state[$p:lk] = 486642                       (: '{' 'long' '.' :)
            or $state[$p:lk] = 487026                       (: '{' 'null' '.' :)
            or $state[$p:lk] = 487922                       (: '{' 'short' '.' :)
            or $state[$p:lk] = 488306                       (: '{' 'super' '.' :)
            or $state[$p:lk] = 488690                       (: '{' 'this' '.' :)
            or $state[$p:lk] = 489202                       (: '{' 'true' '.' :)
            or $state[$p:lk] = 489458                       (: '{' 'void' '.' :)
            or $state[$p:lk] = 524530                       (: '{' IDENTIFIER '/=' :)
            or $state[$p:lk] = 524914                       (: '{' INTEGER_LITERAL '/=' :)
            or $state[$p:lk] = 525042                       (: '{' FLOATING_POINT_LITERAL '/=' :)
            or $state[$p:lk] = 525170                       (: '{' CHARACTER_LITERAL '/=' :)
            or $state[$p:lk] = 525298                       (: '{' STRING_LITERAL '/=' :)
            or $state[$p:lk] = 530418                       (: '{' 'EOF' '/=' :)
            or $state[$p:lk] = 530546                       (: '{' 'IGNORE_CASE' '/=' :)
            or $state[$p:lk] = 530674                       (: '{' 'JAVACODE' '/=' :)
            or $state[$p:lk] = 530802                       (: '{' 'LOOKAHEAD' '/=' :)
            or $state[$p:lk] = 530930                       (: '{' 'MORE' '/=' :)
            or $state[$p:lk] = 531058                       (: '{' 'PARSER_BEGIN' '/=' :)
            or $state[$p:lk] = 531186                       (: '{' 'PARSER_END' '/=' :)
            or $state[$p:lk] = 531314                       (: '{' 'SKIP' '/=' :)
            or $state[$p:lk] = 531442                       (: '{' 'SPECIAL_TOKEN' '/=' :)
            or $state[$p:lk] = 531570                       (: '{' 'TOKEN' '/=' :)
            or $state[$p:lk] = 531698                       (: '{' 'TOKEN_MGR_DECLS' '/=' :)
            or $state[$p:lk] = 534386                       (: '{' 'false' '/=' :)
            or $state[$p:lk] = 536178                       (: '{' 'null' '/=' :)
            or $state[$p:lk] = 537842                       (: '{' 'this' '/=' :)
            or $state[$p:lk] = 538354                       (: '{' 'true' '/=' :)
            or $state[$p:lk] = 573682                       (: '{' IDENTIFIER '<' :)
            or $state[$p:lk] = 606450                       (: '{' IDENTIFIER '<<=' :)
            or $state[$p:lk] = 606834                       (: '{' INTEGER_LITERAL '<<=' :)
            or $state[$p:lk] = 606962                       (: '{' FLOATING_POINT_LITERAL '<<=' :)
            or $state[$p:lk] = 607090                       (: '{' CHARACTER_LITERAL '<<=' :)
            or $state[$p:lk] = 607218                       (: '{' STRING_LITERAL '<<=' :)
            or $state[$p:lk] = 612338                       (: '{' 'EOF' '<<=' :)
            or $state[$p:lk] = 612466                       (: '{' 'IGNORE_CASE' '<<=' :)
            or $state[$p:lk] = 612594                       (: '{' 'JAVACODE' '<<=' :)
            or $state[$p:lk] = 612722                       (: '{' 'LOOKAHEAD' '<<=' :)
            or $state[$p:lk] = 612850                       (: '{' 'MORE' '<<=' :)
            or $state[$p:lk] = 612978                       (: '{' 'PARSER_BEGIN' '<<=' :)
            or $state[$p:lk] = 613106                       (: '{' 'PARSER_END' '<<=' :)
            or $state[$p:lk] = 613234                       (: '{' 'SKIP' '<<=' :)
            or $state[$p:lk] = 613362                       (: '{' 'SPECIAL_TOKEN' '<<=' :)
            or $state[$p:lk] = 613490                       (: '{' 'TOKEN' '<<=' :)
            or $state[$p:lk] = 613618                       (: '{' 'TOKEN_MGR_DECLS' '<<=' :)
            or $state[$p:lk] = 616306                       (: '{' 'false' '<<=' :)
            or $state[$p:lk] = 618098                       (: '{' 'null' '<<=' :)
            or $state[$p:lk] = 619762                       (: '{' 'this' '<<=' :)
            or $state[$p:lk] = 620274                       (: '{' 'true' '<<=' :)
            or $state[$p:lk] = 639218                       (: '{' IDENTIFIER '=' :)
            or $state[$p:lk] = 639602                       (: '{' INTEGER_LITERAL '=' :)
            or $state[$p:lk] = 639730                       (: '{' FLOATING_POINT_LITERAL '=' :)
            or $state[$p:lk] = 639858                       (: '{' CHARACTER_LITERAL '=' :)
            or $state[$p:lk] = 639986                       (: '{' STRING_LITERAL '=' :)
            or $state[$p:lk] = 645106                       (: '{' 'EOF' '=' :)
            or $state[$p:lk] = 645234                       (: '{' 'IGNORE_CASE' '=' :)
            or $state[$p:lk] = 645362                       (: '{' 'JAVACODE' '=' :)
            or $state[$p:lk] = 645490                       (: '{' 'LOOKAHEAD' '=' :)
            or $state[$p:lk] = 645618                       (: '{' 'MORE' '=' :)
            or $state[$p:lk] = 645746                       (: '{' 'PARSER_BEGIN' '=' :)
            or $state[$p:lk] = 645874                       (: '{' 'PARSER_END' '=' :)
            or $state[$p:lk] = 646002                       (: '{' 'SKIP' '=' :)
            or $state[$p:lk] = 646130                       (: '{' 'SPECIAL_TOKEN' '=' :)
            or $state[$p:lk] = 646258                       (: '{' 'TOKEN' '=' :)
            or $state[$p:lk] = 646386                       (: '{' 'TOKEN_MGR_DECLS' '=' :)
            or $state[$p:lk] = 649074                       (: '{' 'false' '=' :)
            or $state[$p:lk] = 650866                       (: '{' 'null' '=' :)
            or $state[$p:lk] = 652530                       (: '{' 'this' '=' :)
            or $state[$p:lk] = 653042                       (: '{' 'true' '=' :)
            or $state[$p:lk] = 704754                       (: '{' IDENTIFIER '>>=' :)
            or $state[$p:lk] = 705138                       (: '{' INTEGER_LITERAL '>>=' :)
            or $state[$p:lk] = 705266                       (: '{' FLOATING_POINT_LITERAL '>>=' :)
            or $state[$p:lk] = 705394                       (: '{' CHARACTER_LITERAL '>>=' :)
            or $state[$p:lk] = 705522                       (: '{' STRING_LITERAL '>>=' :)
            or $state[$p:lk] = 710642                       (: '{' 'EOF' '>>=' :)
            or $state[$p:lk] = 710770                       (: '{' 'IGNORE_CASE' '>>=' :)
            or $state[$p:lk] = 710898                       (: '{' 'JAVACODE' '>>=' :)
            or $state[$p:lk] = 711026                       (: '{' 'LOOKAHEAD' '>>=' :)
            or $state[$p:lk] = 711154                       (: '{' 'MORE' '>>=' :)
            or $state[$p:lk] = 711282                       (: '{' 'PARSER_BEGIN' '>>=' :)
            or $state[$p:lk] = 711410                       (: '{' 'PARSER_END' '>>=' :)
            or $state[$p:lk] = 711538                       (: '{' 'SKIP' '>>=' :)
            or $state[$p:lk] = 711666                       (: '{' 'SPECIAL_TOKEN' '>>=' :)
            or $state[$p:lk] = 711794                       (: '{' 'TOKEN' '>>=' :)
            or $state[$p:lk] = 711922                       (: '{' 'TOKEN_MGR_DECLS' '>>=' :)
            or $state[$p:lk] = 714610                       (: '{' 'false' '>>=' :)
            or $state[$p:lk] = 716402                       (: '{' 'null' '>>=' :)
            or $state[$p:lk] = 718066                       (: '{' 'this' '>>=' :)
            or $state[$p:lk] = 718578                       (: '{' 'true' '>>=' :)
            or $state[$p:lk] = 721138                       (: '{' IDENTIFIER '>>>=' :)
            or $state[$p:lk] = 721522                       (: '{' INTEGER_LITERAL '>>>=' :)
            or $state[$p:lk] = 721650                       (: '{' FLOATING_POINT_LITERAL '>>>=' :)
            or $state[$p:lk] = 721778                       (: '{' CHARACTER_LITERAL '>>>=' :)
            or $state[$p:lk] = 721906                       (: '{' STRING_LITERAL '>>>=' :)
            or $state[$p:lk] = 727026                       (: '{' 'EOF' '>>>=' :)
            or $state[$p:lk] = 727154                       (: '{' 'IGNORE_CASE' '>>>=' :)
            or $state[$p:lk] = 727282                       (: '{' 'JAVACODE' '>>>=' :)
            or $state[$p:lk] = 727410                       (: '{' 'LOOKAHEAD' '>>>=' :)
            or $state[$p:lk] = 727538                       (: '{' 'MORE' '>>>=' :)
            or $state[$p:lk] = 727666                       (: '{' 'PARSER_BEGIN' '>>>=' :)
            or $state[$p:lk] = 727794                       (: '{' 'PARSER_END' '>>>=' :)
            or $state[$p:lk] = 727922                       (: '{' 'SKIP' '>>>=' :)
            or $state[$p:lk] = 728050                       (: '{' 'SPECIAL_TOKEN' '>>>=' :)
            or $state[$p:lk] = 728178                       (: '{' 'TOKEN' '>>>=' :)
            or $state[$p:lk] = 728306                       (: '{' 'TOKEN_MGR_DECLS' '>>>=' :)
            or $state[$p:lk] = 730994                       (: '{' 'false' '>>>=' :)
            or $state[$p:lk] = 732786                       (: '{' 'null' '>>>=' :)
            or $state[$p:lk] = 734450                       (: '{' 'this' '>>>=' :)
            or $state[$p:lk] = 734962                       (: '{' 'true' '>>>=' :)
            or $state[$p:lk] = 772466                       (: '{' '(' 'EOF' :)
            or $state[$p:lk] = 773106                       (: '{' '++' 'EOF' :)
            or $state[$p:lk] = 773618                       (: '{' '--' 'EOF' :)
            or $state[$p:lk] = 788850                       (: '{' '(' 'IGNORE_CASE' :)
            or $state[$p:lk] = 789490                       (: '{' '++' 'IGNORE_CASE' :)
            or $state[$p:lk] = 790002                       (: '{' '--' 'IGNORE_CASE' :)
            or $state[$p:lk] = 805234                       (: '{' '(' 'JAVACODE' :)
            or $state[$p:lk] = 805874                       (: '{' '++' 'JAVACODE' :)
            or $state[$p:lk] = 806386                       (: '{' '--' 'JAVACODE' :)
            or $state[$p:lk] = 821618                       (: '{' '(' 'LOOKAHEAD' :)
            or $state[$p:lk] = 822258                       (: '{' '++' 'LOOKAHEAD' :)
            or $state[$p:lk] = 822770                       (: '{' '--' 'LOOKAHEAD' :)
            or $state[$p:lk] = 838002                       (: '{' '(' 'MORE' :)
            or $state[$p:lk] = 838642                       (: '{' '++' 'MORE' :)
            or $state[$p:lk] = 839154                       (: '{' '--' 'MORE' :)
            or $state[$p:lk] = 854386                       (: '{' '(' 'PARSER_BEGIN' :)
            or $state[$p:lk] = 855026                       (: '{' '++' 'PARSER_BEGIN' :)
            or $state[$p:lk] = 855538                       (: '{' '--' 'PARSER_BEGIN' :)
            or $state[$p:lk] = 870770                       (: '{' '(' 'PARSER_END' :)
            or $state[$p:lk] = 871410                       (: '{' '++' 'PARSER_END' :)
            or $state[$p:lk] = 871922                       (: '{' '--' 'PARSER_END' :)
            or $state[$p:lk] = 887154                       (: '{' '(' 'SKIP' :)
            or $state[$p:lk] = 887794                       (: '{' '++' 'SKIP' :)
            or $state[$p:lk] = 888306                       (: '{' '--' 'SKIP' :)
            or $state[$p:lk] = 903538                       (: '{' '(' 'SPECIAL_TOKEN' :)
            or $state[$p:lk] = 904178                       (: '{' '++' 'SPECIAL_TOKEN' :)
            or $state[$p:lk] = 904690                       (: '{' '--' 'SPECIAL_TOKEN' :)
            or $state[$p:lk] = 919922                       (: '{' '(' 'TOKEN' :)
            or $state[$p:lk] = 920562                       (: '{' '++' 'TOKEN' :)
            or $state[$p:lk] = 921074                       (: '{' '--' 'TOKEN' :)
            or $state[$p:lk] = 936306                       (: '{' '(' 'TOKEN_MGR_DECLS' :)
            or $state[$p:lk] = 936946                       (: '{' '++' 'TOKEN_MGR_DECLS' :)
            or $state[$p:lk] = 937458                       (: '{' '--' 'TOKEN_MGR_DECLS' :)
            or $state[$p:lk] = 950514                       (: '{' IDENTIFIER '[' :)
            or $state[$p:lk] = 950898                       (: '{' INTEGER_LITERAL '[' :)
            or $state[$p:lk] = 951026                       (: '{' FLOATING_POINT_LITERAL '[' :)
            or $state[$p:lk] = 951154                       (: '{' CHARACTER_LITERAL '[' :)
            or $state[$p:lk] = 951282                       (: '{' STRING_LITERAL '[' :)
            or $state[$p:lk] = 956402                       (: '{' 'EOF' '[' :)
            or $state[$p:lk] = 956530                       (: '{' 'IGNORE_CASE' '[' :)
            or $state[$p:lk] = 956658                       (: '{' 'JAVACODE' '[' :)
            or $state[$p:lk] = 956786                       (: '{' 'LOOKAHEAD' '[' :)
            or $state[$p:lk] = 956914                       (: '{' 'MORE' '[' :)
            or $state[$p:lk] = 957042                       (: '{' 'PARSER_BEGIN' '[' :)
            or $state[$p:lk] = 957170                       (: '{' 'PARSER_END' '[' :)
            or $state[$p:lk] = 957298                       (: '{' 'SKIP' '[' :)
            or $state[$p:lk] = 957426                       (: '{' 'SPECIAL_TOKEN' '[' :)
            or $state[$p:lk] = 957554                       (: '{' 'TOKEN' '[' :)
            or $state[$p:lk] = 957682                       (: '{' 'TOKEN_MGR_DECLS' '[' :)
            or $state[$p:lk] = 958578                       (: '{' 'boolean' '[' :)
            or $state[$p:lk] = 958834                       (: '{' 'byte' '[' :)
            or $state[$p:lk] = 959218                       (: '{' 'char' '[' :)
            or $state[$p:lk] = 959858                       (: '{' 'double' '[' :)
            or $state[$p:lk] = 960370                       (: '{' 'false' '[' :)
            or $state[$p:lk] = 960754                       (: '{' 'float' '[' :)
            or $state[$p:lk] = 961522                       (: '{' 'int' '[' :)
            or $state[$p:lk] = 961778                       (: '{' 'long' '[' :)
            or $state[$p:lk] = 962162                       (: '{' 'null' '[' :)
            or $state[$p:lk] = 963058                       (: '{' 'short' '[' :)
            or $state[$p:lk] = 963826                       (: '{' 'this' '[' :)
            or $state[$p:lk] = 964338                       (: '{' 'true' '[' :)
            or $state[$p:lk] = 999666                       (: '{' IDENTIFIER '^=' :)
            or $state[$p:lk] = 1000050                      (: '{' INTEGER_LITERAL '^=' :)
            or $state[$p:lk] = 1000178                      (: '{' FLOATING_POINT_LITERAL '^=' :)
            or $state[$p:lk] = 1000306                      (: '{' CHARACTER_LITERAL '^=' :)
            or $state[$p:lk] = 1000434                      (: '{' STRING_LITERAL '^=' :)
            or $state[$p:lk] = 1005554                      (: '{' 'EOF' '^=' :)
            or $state[$p:lk] = 1005682                      (: '{' 'IGNORE_CASE' '^=' :)
            or $state[$p:lk] = 1005810                      (: '{' 'JAVACODE' '^=' :)
            or $state[$p:lk] = 1005938                      (: '{' 'LOOKAHEAD' '^=' :)
            or $state[$p:lk] = 1006066                      (: '{' 'MORE' '^=' :)
            or $state[$p:lk] = 1006194                      (: '{' 'PARSER_BEGIN' '^=' :)
            or $state[$p:lk] = 1006322                      (: '{' 'PARSER_END' '^=' :)
            or $state[$p:lk] = 1006450                      (: '{' 'SKIP' '^=' :)
            or $state[$p:lk] = 1006578                      (: '{' 'SPECIAL_TOKEN' '^=' :)
            or $state[$p:lk] = 1006706                      (: '{' 'TOKEN' '^=' :)
            or $state[$p:lk] = 1006834                      (: '{' 'TOKEN_MGR_DECLS' '^=' :)
            or $state[$p:lk] = 1009522                      (: '{' 'false' '^=' :)
            or $state[$p:lk] = 1011314                      (: '{' 'null' '^=' :)
            or $state[$p:lk] = 1012978                      (: '{' 'this' '^=' :)
            or $state[$p:lk] = 1013490                      (: '{' 'true' '^=' :)
            or $state[$p:lk] = 1050994                      (: '{' '(' 'boolean' :)
            or $state[$p:lk] = 1051634                      (: '{' '++' 'boolean' :)
            or $state[$p:lk] = 1052146                      (: '{' '--' 'boolean' :)
            or $state[$p:lk] = 1060338                      (: '{' 'new' 'boolean' :)
            or $state[$p:lk] = 1083762                      (: '{' '(' 'byte' :)
            or $state[$p:lk] = 1084402                      (: '{' '++' 'byte' :)
            or $state[$p:lk] = 1084914                      (: '{' '--' 'byte' :)
            or $state[$p:lk] = 1093106                      (: '{' 'new' 'byte' :)
            or $state[$p:lk] = 1132914                      (: '{' '(' 'char' :)
            or $state[$p:lk] = 1133554                      (: '{' '++' 'char' :)
            or $state[$p:lk] = 1134066                      (: '{' '--' 'char' :)
            or $state[$p:lk] = 1142258                      (: '{' 'new' 'char' :)
            or $state[$p:lk] = 1214834                      (: '{' '(' 'double' :)
            or $state[$p:lk] = 1215474                      (: '{' '++' 'double' :)
            or $state[$p:lk] = 1215986                      (: '{' '--' 'double' :)
            or $state[$p:lk] = 1224178                      (: '{' 'new' 'double' :)
            or $state[$p:lk] = 1280370                      (: '{' '(' 'false' :)
            or $state[$p:lk] = 1281010                      (: '{' '++' 'false' :)
            or $state[$p:lk] = 1281522                      (: '{' '--' 'false' :)
            or $state[$p:lk] = 1329522                      (: '{' '(' 'float' :)
            or $state[$p:lk] = 1330162                      (: '{' '++' 'float' :)
            or $state[$p:lk] = 1330674                      (: '{' '--' 'float' :)
            or $state[$p:lk] = 1338866                      (: '{' 'new' 'float' :)
            or $state[$p:lk] = 1427826                      (: '{' '(' 'int' :)
            or $state[$p:lk] = 1428466                      (: '{' '++' 'int' :)
            or $state[$p:lk] = 1428978                      (: '{' '--' 'int' :)
            or $state[$p:lk] = 1437170                      (: '{' 'new' 'int' :)
            or $state[$p:lk] = 1460594                      (: '{' '(' 'long' :)
            or $state[$p:lk] = 1461234                      (: '{' '++' 'long' :)
            or $state[$p:lk] = 1461746                      (: '{' '--' 'long' :)
            or $state[$p:lk] = 1469938                      (: '{' 'new' 'long' :)
            or $state[$p:lk] = 1493362                      (: '{' '(' 'new' :)
            or $state[$p:lk] = 1494002                      (: '{' '++' 'new' :)
            or $state[$p:lk] = 1494514                      (: '{' '--' 'new' :)
            or $state[$p:lk] = 1509746                      (: '{' '(' 'null' :)
            or $state[$p:lk] = 1510386                      (: '{' '++' 'null' :)
            or $state[$p:lk] = 1510898                      (: '{' '--' 'null' :)
            or $state[$p:lk] = 1624434                      (: '{' '(' 'short' :)
            or $state[$p:lk] = 1625074                      (: '{' '++' 'short' :)
            or $state[$p:lk] = 1625586                      (: '{' '--' 'short' :)
            or $state[$p:lk] = 1633778                      (: '{' 'new' 'short' :)
            or $state[$p:lk] = 1673586                      (: '{' '(' 'super' :)
            or $state[$p:lk] = 1674226                      (: '{' '++' 'super' :)
            or $state[$p:lk] = 1674738                      (: '{' '--' 'super' :)
            or $state[$p:lk] = 1722738                      (: '{' '(' 'this' :)
            or $state[$p:lk] = 1723378                      (: '{' '++' 'this' :)
            or $state[$p:lk] = 1723890                      (: '{' '--' 'this' :)
            or $state[$p:lk] = 1788274                      (: '{' '(' 'true' :)
            or $state[$p:lk] = 1788914                      (: '{' '++' 'true' :)
            or $state[$p:lk] = 1789426                      (: '{' '--' 'true' :)
            or $state[$p:lk] = 1821042                      (: '{' '(' 'void' :)
            or $state[$p:lk] = 1821682                      (: '{' '++' 'void' :)
            or $state[$p:lk] = 1822194                      (: '{' '--' 'void' :)
            or $state[$p:lk] = 1900786                      (: '{' IDENTIFIER '|=' :)
            or $state[$p:lk] = 1901170                      (: '{' INTEGER_LITERAL '|=' :)
            or $state[$p:lk] = 1901298                      (: '{' FLOATING_POINT_LITERAL '|=' :)
            or $state[$p:lk] = 1901426                      (: '{' CHARACTER_LITERAL '|=' :)
            or $state[$p:lk] = 1901554                      (: '{' STRING_LITERAL '|=' :)
            or $state[$p:lk] = 1906674                      (: '{' 'EOF' '|=' :)
            or $state[$p:lk] = 1906802                      (: '{' 'IGNORE_CASE' '|=' :)
            or $state[$p:lk] = 1906930                      (: '{' 'JAVACODE' '|=' :)
            or $state[$p:lk] = 1907058                      (: '{' 'LOOKAHEAD' '|=' :)
            or $state[$p:lk] = 1907186                      (: '{' 'MORE' '|=' :)
            or $state[$p:lk] = 1907314                      (: '{' 'PARSER_BEGIN' '|=' :)
            or $state[$p:lk] = 1907442                      (: '{' 'PARSER_END' '|=' :)
            or $state[$p:lk] = 1907570                      (: '{' 'SKIP' '|=' :)
            or $state[$p:lk] = 1907698                      (: '{' 'SPECIAL_TOKEN' '|=' :)
            or $state[$p:lk] = 1907826                      (: '{' 'TOKEN' '|=' :)
            or $state[$p:lk] = 1907954                      (: '{' 'TOKEN_MGR_DECLS' '|=' :)
            or $state[$p:lk] = 1910642                      (: '{' 'false' '|=' :)
            or $state[$p:lk] = 1912434                      (: '{' 'null' '|=' :)
            or $state[$p:lk] = 1914098                      (: '{' 'this' '|=' :)
            or $state[$p:lk] = 1914610                      (: '{' 'true' '|=' :)
            or $state[$p:lk] = 1952114) then                (: '{' '(' '~' :)
        let $state := p:memoized($state, 1)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:lookahead1W(135, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                                'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                                'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                                'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                                'void' | '{' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-expansion_unit($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 1, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-expansion-1($input, $state)
      else if ($state[$p:lk] != -1
           and $state[$p:lk] != 1                           (: IDENTIFIER :)
           and $state[$p:lk] != 4                           (: INTEGER_LITERAL :)
           and $state[$p:lk] != 5                           (: FLOATING_POINT_LITERAL :)
           and $state[$p:lk] != 6                           (: CHARACTER_LITERAL :)
           and $state[$p:lk] != 7                           (: STRING_LITERAL :)
           and $state[$p:lk] != 18                          (: '(' :)
           and $state[$p:lk] != 35                          (: '<' :)
           and $state[$p:lk] != 47                          (: 'EOF' :)
           and $state[$p:lk] != 48                          (: 'IGNORE_CASE' :)
           and $state[$p:lk] != 49                          (: 'JAVACODE' :)
           and $state[$p:lk] != 50                          (: 'LOOKAHEAD' :)
           and $state[$p:lk] != 51                          (: 'MORE' :)
           and $state[$p:lk] != 52                          (: 'PARSER_BEGIN' :)
           and $state[$p:lk] != 53                          (: 'PARSER_END' :)
           and $state[$p:lk] != 54                          (: 'SKIP' :)
           and $state[$p:lk] != 55                          (: 'SPECIAL_TOKEN' :)
           and $state[$p:lk] != 56                          (: 'TOKEN' :)
           and $state[$p:lk] != 57                          (: 'TOKEN_MGR_DECLS' :)
           and $state[$p:lk] != 58                          (: '[' :)
           and $state[$p:lk] != 64                          (: 'boolean' :)
           and $state[$p:lk] != 66                          (: 'byte' :)
           and $state[$p:lk] != 69                          (: 'char' :)
           and $state[$p:lk] != 74                          (: 'double' :)
           and $state[$p:lk] != 78                          (: 'false' :)
           and $state[$p:lk] != 81                          (: 'float' :)
           and $state[$p:lk] != 87                          (: 'int' :)
           and $state[$p:lk] != 89                          (: 'long' :)
           and $state[$p:lk] != 91                          (: 'new' :)
           and $state[$p:lk] != 92                          (: 'null' :)
           and $state[$p:lk] != 99                          (: 'short' :)
           and $state[$p:lk] != 102                         (: 'super' :)
           and $state[$p:lk] != 105                         (: 'this' :)
           and $state[$p:lk] != 109                         (: 'true' :)
           and $state[$p:lk] != 110                         (: 'try' :)
           and $state[$p:lk] != 111                         (: 'void' :)
           and $state[$p:lk] != 4466                        (: '{' ';' :)
           and $state[$p:lk] != 6002                        (: '{' '@' :)
           and $state[$p:lk] != 8050                        (: '{' 'abstract' :)
           and $state[$p:lk] != 8178                        (: '{' 'assert' :)
           and $state[$p:lk] != 8434                        (: '{' 'break' :)
           and $state[$p:lk] != 9074                        (: '{' 'class' :)
           and $state[$p:lk] != 9202                        (: '{' 'continue' :)
           and $state[$p:lk] != 9458                        (: '{' 'do' :)
           and $state[$p:lk] != 10226                       (: '{' 'final' :)
           and $state[$p:lk] != 10610                       (: '{' 'for' :)
           and $state[$p:lk] != 10738                       (: '{' 'if' :)
           and $state[$p:lk] != 11378                       (: '{' 'interface' :)
           and $state[$p:lk] != 11634                       (: '{' 'native' :)
           and $state[$p:lk] != 12274                       (: '{' 'private' :)
           and $state[$p:lk] != 12402                       (: '{' 'protected' :)
           and $state[$p:lk] != 12530                       (: '{' 'public' :)
           and $state[$p:lk] != 12658                       (: '{' 'return' :)
           and $state[$p:lk] != 12914                       (: '{' 'static' :)
           and $state[$p:lk] != 13042                       (: '{' 'strictfp' :)
           and $state[$p:lk] != 13298                       (: '{' 'switch' :)
           and $state[$p:lk] != 13426                       (: '{' 'synchronized' :)
           and $state[$p:lk] != 13682                       (: '{' 'throw' :)
           and $state[$p:lk] != 13938                       (: '{' 'transient' :)
           and $state[$p:lk] != 14194                       (: '{' 'try' :)
           and $state[$p:lk] != 14450                       (: '{' 'volatile' :)
           and $state[$p:lk] != 14578                       (: '{' 'while' :)
           and $state[$p:lk] != 14706                       (: '{' '{' :)
           and $state[$p:lk] != 16626                       (: '{' IDENTIFIER IDENTIFIER :)
           and $state[$p:lk] != 24690                       (: '{' 'boolean' IDENTIFIER :)
           and $state[$p:lk] != 24946                       (: '{' 'byte' IDENTIFIER :)
           and $state[$p:lk] != 25330                       (: '{' 'char' IDENTIFIER :)
           and $state[$p:lk] != 25970                       (: '{' 'double' IDENTIFIER :)
           and $state[$p:lk] != 26866                       (: '{' 'float' IDENTIFIER :)
           and $state[$p:lk] != 27634                       (: '{' 'int' IDENTIFIER :)
           and $state[$p:lk] != 27890                       (: '{' 'long' IDENTIFIER :)
           and $state[$p:lk] != 29170                       (: '{' 'short' IDENTIFIER :)
           and $state[$p:lk] != 31602                       (: '{' '}' IDENTIFIER :)
           and $state[$p:lk] != 80754                       (: '{' '}' INTEGER_LITERAL :)
           and $state[$p:lk] != 97138                       (: '{' '}' FLOATING_POINT_LITERAL :)
           and $state[$p:lk] != 113522                      (: '{' '}' CHARACTER_LITERAL :)
           and $state[$p:lk] != 129906                      (: '{' '}' STRING_LITERAL :)
           and $state[$p:lk] != 310130                      (: '{' '}' '(' :)
           and $state[$p:lk] != 424818                      (: '{' '}' ',' :)
           and $state[$p:lk] != 540914                      (: '{' IDENTIFIER ':' :)
           and $state[$p:lk] != 557298                      (: '{' IDENTIFIER ';' :)
           and $state[$p:lk] != 557682                      (: '{' INTEGER_LITERAL ';' :)
           and $state[$p:lk] != 557810                      (: '{' FLOATING_POINT_LITERAL ';' :)
           and $state[$p:lk] != 557938                      (: '{' CHARACTER_LITERAL ';' :)
           and $state[$p:lk] != 558066                      (: '{' STRING_LITERAL ';' :)
           and $state[$p:lk] != 563186                      (: '{' 'EOF' ';' :)
           and $state[$p:lk] != 563314                      (: '{' 'IGNORE_CASE' ';' :)
           and $state[$p:lk] != 563442                      (: '{' 'JAVACODE' ';' :)
           and $state[$p:lk] != 563570                      (: '{' 'LOOKAHEAD' ';' :)
           and $state[$p:lk] != 563698                      (: '{' 'MORE' ';' :)
           and $state[$p:lk] != 563826                      (: '{' 'PARSER_BEGIN' ';' :)
           and $state[$p:lk] != 563954                      (: '{' 'PARSER_END' ';' :)
           and $state[$p:lk] != 564082                      (: '{' 'SKIP' ';' :)
           and $state[$p:lk] != 564210                      (: '{' 'SPECIAL_TOKEN' ';' :)
           and $state[$p:lk] != 564338                      (: '{' 'TOKEN' ';' :)
           and $state[$p:lk] != 564466                      (: '{' 'TOKEN_MGR_DECLS' ';' :)
           and $state[$p:lk] != 567154                      (: '{' 'false' ';' :)
           and $state[$p:lk] != 568946                      (: '{' 'null' ';' :)
           and $state[$p:lk] != 570610                      (: '{' 'this' ';' :)
           and $state[$p:lk] != 571122                      (: '{' 'true' ';' :)
           and $state[$p:lk] != 588658                      (: '{' '}' '<' :)
           and $state[$p:lk] != 785266                      (: '{' '}' 'EOF' :)
           and $state[$p:lk] != 801650                      (: '{' '}' 'IGNORE_CASE' :)
           and $state[$p:lk] != 818034                      (: '{' '}' 'JAVACODE' :)
           and $state[$p:lk] != 834418                      (: '{' '}' 'LOOKAHEAD' :)
           and $state[$p:lk] != 850802                      (: '{' '}' 'MORE' :)
           and $state[$p:lk] != 867186                      (: '{' '}' 'PARSER_BEGIN' :)
           and $state[$p:lk] != 883570                      (: '{' '}' 'PARSER_END' :)
           and $state[$p:lk] != 899954                      (: '{' '}' 'SKIP' :)
           and $state[$p:lk] != 916338                      (: '{' '}' 'SPECIAL_TOKEN' :)
           and $state[$p:lk] != 932722                      (: '{' '}' 'TOKEN' :)
           and $state[$p:lk] != 949106                      (: '{' '}' 'TOKEN_MGR_DECLS' :)
           and $state[$p:lk] != 965490                      (: '{' '}' '[' :)
           and $state[$p:lk] != 981874                      (: '{' '}' ']' :)
           and $state[$p:lk] != 1063794                     (: '{' '}' 'boolean' :)
           and $state[$p:lk] != 1096562                     (: '{' '}' 'byte' :)
           and $state[$p:lk] != 1145714                     (: '{' '}' 'char' :)
           and $state[$p:lk] != 1227634                     (: '{' '}' 'double' :)
           and $state[$p:lk] != 1293170                     (: '{' '}' 'false' :)
           and $state[$p:lk] != 1342322                     (: '{' '}' 'float' :)
           and $state[$p:lk] != 1440626                     (: '{' '}' 'int' :)
           and $state[$p:lk] != 1473394                     (: '{' '}' 'long' :)
           and $state[$p:lk] != 1506162                     (: '{' '}' 'new' :)
           and $state[$p:lk] != 1522546                     (: '{' '}' 'null' :)
           and $state[$p:lk] != 1637234                     (: '{' '}' 'short' :)
           and $state[$p:lk] != 1686386                     (: '{' '}' 'super' :)
           and $state[$p:lk] != 1735538                     (: '{' '}' 'this' :)
           and $state[$p:lk] != 1801074                     (: '{' '}' 'true' :)
           and $state[$p:lk] != 1817458                     (: '{' '}' 'try' :)
           and $state[$p:lk] != 1833842                     (: '{' '}' 'void' :)
           and $state[$p:lk] != 1882994                     (: '{' '}' '{' :)
           and $state[$p:lk] != 1899378                     (: '{' '}' '|' :)
           and $state[$p:lk] != 1948530) then               (: '{' '}' '}' :)
        $state
      else
        p:try-expansion-1($input, $state)
};

(:~
 : Parse expansion.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expansion($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 50) then                           (: 'LOOKAHEAD' :)
      let $state := p:lookahead2W(69, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '=' | '[' :)
      let $state :=
        if ($state[$p:lk] eq 2354) then                     (: 'LOOKAHEAD' '(' :)
          let $state := p:lookahead3W(164, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | ',' |
                                                               '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18738                          (: 'LOOKAHEAD' '(' IDENTIFIER :)
          or $state[$p:lk] = 67890                          (: 'LOOKAHEAD' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 84274                          (: 'LOOKAHEAD' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100658                         (: 'LOOKAHEAD' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117042                         (: 'LOOKAHEAD' '(' STRING_LITERAL :)
          or $state[$p:lk] = 297266                         (: 'LOOKAHEAD' '(' '(' :)
          or $state[$p:lk] = 313650                         (: 'LOOKAHEAD' '(' ')' :)
          or $state[$p:lk] = 411954                         (: 'LOOKAHEAD' '(' ',' :)
          or $state[$p:lk] = 575794                         (: 'LOOKAHEAD' '(' '<' :)
          or $state[$p:lk] = 772402                         (: 'LOOKAHEAD' '(' 'EOF' :)
          or $state[$p:lk] = 788786                         (: 'LOOKAHEAD' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805170                         (: 'LOOKAHEAD' '(' 'JAVACODE' :)
          or $state[$p:lk] = 821554                         (: 'LOOKAHEAD' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 837938                         (: 'LOOKAHEAD' '(' 'MORE' :)
          or $state[$p:lk] = 854322                         (: 'LOOKAHEAD' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870706                         (: 'LOOKAHEAD' '(' 'PARSER_END' :)
          or $state[$p:lk] = 887090                         (: 'LOOKAHEAD' '(' 'SKIP' :)
          or $state[$p:lk] = 903474                         (: 'LOOKAHEAD' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919858                         (: 'LOOKAHEAD' '(' 'TOKEN' :)
          or $state[$p:lk] = 936242                         (: 'LOOKAHEAD' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 952626                         (: 'LOOKAHEAD' '(' '[' :)
          or $state[$p:lk] = 1050930                        (: 'LOOKAHEAD' '(' 'boolean' :)
          or $state[$p:lk] = 1083698                        (: 'LOOKAHEAD' '(' 'byte' :)
          or $state[$p:lk] = 1132850                        (: 'LOOKAHEAD' '(' 'char' :)
          or $state[$p:lk] = 1214770                        (: 'LOOKAHEAD' '(' 'double' :)
          or $state[$p:lk] = 1280306                        (: 'LOOKAHEAD' '(' 'false' :)
          or $state[$p:lk] = 1329458                        (: 'LOOKAHEAD' '(' 'float' :)
          or $state[$p:lk] = 1427762                        (: 'LOOKAHEAD' '(' 'int' :)
          or $state[$p:lk] = 1460530                        (: 'LOOKAHEAD' '(' 'long' :)
          or $state[$p:lk] = 1493298                        (: 'LOOKAHEAD' '(' 'new' :)
          or $state[$p:lk] = 1509682                        (: 'LOOKAHEAD' '(' 'null' :)
          or $state[$p:lk] = 1624370                        (: 'LOOKAHEAD' '(' 'short' :)
          or $state[$p:lk] = 1673522                        (: 'LOOKAHEAD' '(' 'super' :)
          or $state[$p:lk] = 1722674                        (: 'LOOKAHEAD' '(' 'this' :)
          or $state[$p:lk] = 1788210                        (: 'LOOKAHEAD' '(' 'true' :)
          or $state[$p:lk] = 1804594                        (: 'LOOKAHEAD' '(' 'try' :)
          or $state[$p:lk] = 1820978                        (: 'LOOKAHEAD' '(' 'void' :)
          or $state[$p:lk] = 1870130) then                  (: 'LOOKAHEAD' '(' '{' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(50, $input, $state)      (: 'LOOKAHEAD' :)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state := p:consumeT(18, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(140, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-local_lookahead($input, $state)
          let $state := p:lookahead1W(4, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
          let $state := p:consumeT(19, $input, $state)      (: ')' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(50, $input, $state)           (: 'LOOKAHEAD' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state := p:consume(18, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(140, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-local_lookahead($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consume(19, $input, $state)           (: ')' :)
      return $state
    else
      $state
  let $state := p:parse-expansion-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "expansion", $count, $begin, $end)
};

(:~
 : Try parsing expansion.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expansion($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 50) then                           (: 'LOOKAHEAD' :)
      let $state := p:lookahead2W(69, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '=' | '[' :)
      let $state :=
        if ($state[$p:lk] eq 2354) then                     (: 'LOOKAHEAD' '(' :)
          let $state := p:lookahead3W(164, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | ',' |
                                                               '-' | '--' | '<' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               '[' | 'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18738                          (: 'LOOKAHEAD' '(' IDENTIFIER :)
          or $state[$p:lk] = 67890                          (: 'LOOKAHEAD' '(' INTEGER_LITERAL :)
          or $state[$p:lk] = 84274                          (: 'LOOKAHEAD' '(' FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 100658                         (: 'LOOKAHEAD' '(' CHARACTER_LITERAL :)
          or $state[$p:lk] = 117042                         (: 'LOOKAHEAD' '(' STRING_LITERAL :)
          or $state[$p:lk] = 297266                         (: 'LOOKAHEAD' '(' '(' :)
          or $state[$p:lk] = 313650                         (: 'LOOKAHEAD' '(' ')' :)
          or $state[$p:lk] = 411954                         (: 'LOOKAHEAD' '(' ',' :)
          or $state[$p:lk] = 575794                         (: 'LOOKAHEAD' '(' '<' :)
          or $state[$p:lk] = 772402                         (: 'LOOKAHEAD' '(' 'EOF' :)
          or $state[$p:lk] = 788786                         (: 'LOOKAHEAD' '(' 'IGNORE_CASE' :)
          or $state[$p:lk] = 805170                         (: 'LOOKAHEAD' '(' 'JAVACODE' :)
          or $state[$p:lk] = 821554                         (: 'LOOKAHEAD' '(' 'LOOKAHEAD' :)
          or $state[$p:lk] = 837938                         (: 'LOOKAHEAD' '(' 'MORE' :)
          or $state[$p:lk] = 854322                         (: 'LOOKAHEAD' '(' 'PARSER_BEGIN' :)
          or $state[$p:lk] = 870706                         (: 'LOOKAHEAD' '(' 'PARSER_END' :)
          or $state[$p:lk] = 887090                         (: 'LOOKAHEAD' '(' 'SKIP' :)
          or $state[$p:lk] = 903474                         (: 'LOOKAHEAD' '(' 'SPECIAL_TOKEN' :)
          or $state[$p:lk] = 919858                         (: 'LOOKAHEAD' '(' 'TOKEN' :)
          or $state[$p:lk] = 936242                         (: 'LOOKAHEAD' '(' 'TOKEN_MGR_DECLS' :)
          or $state[$p:lk] = 952626                         (: 'LOOKAHEAD' '(' '[' :)
          or $state[$p:lk] = 1050930                        (: 'LOOKAHEAD' '(' 'boolean' :)
          or $state[$p:lk] = 1083698                        (: 'LOOKAHEAD' '(' 'byte' :)
          or $state[$p:lk] = 1132850                        (: 'LOOKAHEAD' '(' 'char' :)
          or $state[$p:lk] = 1214770                        (: 'LOOKAHEAD' '(' 'double' :)
          or $state[$p:lk] = 1280306                        (: 'LOOKAHEAD' '(' 'false' :)
          or $state[$p:lk] = 1329458                        (: 'LOOKAHEAD' '(' 'float' :)
          or $state[$p:lk] = 1427762                        (: 'LOOKAHEAD' '(' 'int' :)
          or $state[$p:lk] = 1460530                        (: 'LOOKAHEAD' '(' 'long' :)
          or $state[$p:lk] = 1493298                        (: 'LOOKAHEAD' '(' 'new' :)
          or $state[$p:lk] = 1509682                        (: 'LOOKAHEAD' '(' 'null' :)
          or $state[$p:lk] = 1624370                        (: 'LOOKAHEAD' '(' 'short' :)
          or $state[$p:lk] = 1673522                        (: 'LOOKAHEAD' '(' 'super' :)
          or $state[$p:lk] = 1722674                        (: 'LOOKAHEAD' '(' 'this' :)
          or $state[$p:lk] = 1788210                        (: 'LOOKAHEAD' '(' 'true' :)
          or $state[$p:lk] = 1804594                        (: 'LOOKAHEAD' '(' 'try' :)
          or $state[$p:lk] = 1820978                        (: 'LOOKAHEAD' '(' 'void' :)
          or $state[$p:lk] = 1870130) then                  (: 'LOOKAHEAD' '(' '{' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(50, $input, $state)      (: 'LOOKAHEAD' :)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state := p:consumeT(18, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(140, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-local_lookahead($input, $state)
          let $state := p:lookahead1W(4, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
          let $state := p:consumeT(19, $input, $state)      (: ')' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consumeT(50, $input, $state)          (: 'LOOKAHEAD' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state := p:consumeT(18, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(140, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '<' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | '[' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'try' | 'void' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-local_lookahead($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consumeT(19, $input, $state)          (: ')' :)
      return $state
    else
      $state
  let $state := p:try-expansion-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production expansion_choices (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expansion_choices-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 115) then                          (: '|' :)
      $state
    else
      let $state := p:consume(115, $input, $state)          (: '|' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-expansion($input, $state)
      return p:parse-expansion_choices-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production expansion_choices (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expansion_choices-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 115) then                          (: '|' :)
      $state
    else
      let $state := p:consumeT(115, $input, $state)         (: '|' :)
      let $state := p:lookahead1W(135, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-expansion($input, $state)
      return p:try-expansion_choices-1($input, $state)
};

(:~
 : Parse expansion_choices.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-expansion_choices($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expansion($input, $state)
  let $state := p:parse-expansion_choices-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "expansion_choices", $count, $begin, $end)
};

(:~
 : Try parsing expansion_choices.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-expansion_choices($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-expansion($input, $state)
  let $state := p:try-expansion_choices-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production bnf_production (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-bnf_production-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      return p:parse-bnf_production-1($input, $state)
};

(:~
 : Parse bnf_production.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-bnf_production($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AccessModifier($input, $state)
  let $state := p:lookahead1W(93, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' | 'void' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ResultType($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-identifier($input, $state)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FormalParameters($input, $state)
  let $state := p:lookahead1W(46, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' |
                                                               'throws' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'throws' :)
      let $state := p:consume(107, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      let $state := p:parse-bnf_production-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(33, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Block($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(135, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | '[' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'try' |
                                                               'void' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-expansion_choices($input, $state)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "bnf_production", $count, $begin, $end)
};

(:~
 : Parse token_manager_decls.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-token_manager_decls($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(57, $input, $state)               (: 'TOKEN_MGR_DECLS' :)
  let $state := p:lookahead1W(7, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
  let $state := p:consume(33, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ClassOrInterfaceBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "token_manager_decls", $count, $begin, $end)
};

(:~
 : Parse character_descriptor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-character_descriptor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StringLiteral($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '-' | ']' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26) then                       (: '-' :)
      let $state := p:consume(26, $input, $state)           (: '-' :)
      let $state := p:lookahead1W(2, $input, $state)        (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StringLiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "character_descriptor", $count, $begin, $end)
};

(:~
 : Try parsing character_descriptor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-character_descriptor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StringLiteral($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '-' | ']' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26) then                       (: '-' :)
      let $state := p:consumeT(26, $input, $state)          (: '-' :)
      let $state := p:lookahead1W(2, $input, $state)        (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-StringLiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production character_list (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-character_list-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(41, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ']' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(2, $input, $state)      (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-character_descriptor($input, $state)
        return p:parse-character_list-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production character_list (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-character_list-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(41, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ']' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(2, $input, $state)      (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-character_descriptor($input, $state)
        return p:try-character_list-1($input, $state)
};

(:~
 : Parse character_list.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-character_list($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: '~' :)
      let $state := p:consume(119, $input, $state)          (: '~' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
  let $state := p:consume(58, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(33, $input, $state)           (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ']' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: STRING_LITERAL :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-character_descriptor($input, $state)
      let $state := p:parse-character_list-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(59, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "character_list", $count, $begin, $end)
};

(:~
 : Try parsing character_list.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-character_list($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: '~' :)
      let $state := p:consumeT(119, $input, $state)         (: '~' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
  let $state := p:consumeT(58, $input, $state)              (: '[' :)
  let $state := p:lookahead1W(33, $input, $state)           (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ']' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: STRING_LITERAL :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-character_descriptor($input, $state)
      let $state := p:try-character_list-1($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(59, $input, $state)              (: ']' :)
  return $state
};

(:~
 : Parse complex_regular_expression_unit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-complex_regular_expression_unit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: STRING_LITERAL :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StringLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state := p:consume(35, $input, $state)           (: '<' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-identifier($input, $state)
      let $state := p:lookahead1W(11, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
      let $state := p:consume(41, $input, $state)           (: '>' :)
      return $state
    else if ($state[$p:l1] = 18) then                       (: '(' :)
      let $state := p:consume(18, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(80, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | '[' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-complex_regular_expression_choices($input, $state)
      let $state := p:consume(19, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(95, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '*' | '+' | '<' | '>' |
                                                               '?' | '[' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 20                         (: '*' :)
              or $state[$p:l1] = 22                         (: '+' :)
              or $state[$p:l1] = 45                         (: '?' :)
              or $state[$p:l1] = 114) then                  (: '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 22) then               (: '+' :)
              let $state := p:consume(22, $input, $state)   (: '+' :)
              return $state
            else if ($state[$p:l1] = 20) then               (: '*' :)
              let $state := p:consume(20, $input, $state)   (: '*' :)
              return $state
            else if ($state[$p:l1] = 45) then               (: '?' :)
              let $state := p:consume(45, $input, $state)   (: '?' :)
              return $state
            else
              let $state := p:consume(114, $input, $state)  (: '{' :)
              let $state := p:lookahead1W(1, $input, $state) (: SKIP | INTEGER_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-IntegerLiteral($input, $state)
              let $state := p:lookahead1W(42, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                                 '}' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 25) then           (: ',' :)
                  let $state := p:consume(25, $input, $state) (: ',' :)
                  let $state := p:lookahead1W(31, $input, $state) (: SKIP | INTEGER_LITERAL | SINGLE_LINE_COMMENT |
                                                                     MULTI_LINE_COMMENT | '}' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else if ($state[$p:l1] = 4) then        (: INTEGER_LITERAL :)
                      let $state := p:whitespace($input, $state)
                      let $state :=
                        if ($state[$p:error]) then
                          $state
                        else
                          p:parse-IntegerLiteral($input, $state)
                      return $state
                    else
                      $state
                  return $state
                else
                  $state
              let $state := p:lookahead1W(24, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '}' :)
              let $state := p:consume(118, $input, $state)  (: '}' :)
              return $state
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-character_list($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "complex_regular_expression_unit", $count, $begin, $end)
};

(:~
 : Try parsing complex_regular_expression_unit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-complex_regular_expression_unit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: STRING_LITERAL :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-StringLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state := p:consumeT(35, $input, $state)          (: '<' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-identifier($input, $state)
      let $state := p:lookahead1W(11, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
      let $state := p:consumeT(41, $input, $state)          (: '>' :)
      return $state
    else if ($state[$p:l1] = 18) then                       (: '(' :)
      let $state := p:consumeT(18, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(80, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | '[' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-complex_regular_expression_choices($input, $state)
      let $state := p:consumeT(19, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(95, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '*' | '+' | '<' | '>' |
                                                               '?' | '[' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 20                         (: '*' :)
              or $state[$p:l1] = 22                         (: '+' :)
              or $state[$p:l1] = 45                         (: '?' :)
              or $state[$p:l1] = 114) then                  (: '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 22) then               (: '+' :)
              let $state := p:consumeT(22, $input, $state)  (: '+' :)
              return $state
            else if ($state[$p:l1] = 20) then               (: '*' :)
              let $state := p:consumeT(20, $input, $state)  (: '*' :)
              return $state
            else if ($state[$p:l1] = 45) then               (: '?' :)
              let $state := p:consumeT(45, $input, $state)  (: '?' :)
              return $state
            else
              let $state := p:consumeT(114, $input, $state) (: '{' :)
              let $state := p:lookahead1W(1, $input, $state) (: SKIP | INTEGER_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-IntegerLiteral($input, $state)
              let $state := p:lookahead1W(42, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                                 '}' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 25) then           (: ',' :)
                  let $state := p:consumeT(25, $input, $state) (: ',' :)
                  let $state := p:lookahead1W(31, $input, $state) (: SKIP | INTEGER_LITERAL | SINGLE_LINE_COMMENT |
                                                                     MULTI_LINE_COMMENT | '}' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else if ($state[$p:l1] = 4) then        (: INTEGER_LITERAL :)
                      let $state :=
                        if ($state[$p:error]) then
                          $state
                        else
                          p:try-IntegerLiteral($input, $state)
                      return $state
                    else
                      $state
                  return $state
                else
                  $state
              let $state := p:lookahead1W(24, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '}' :)
              let $state := p:consumeT(118, $input, $state) (: '}' :)
              return $state
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-character_list($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production complex_regular_expression (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-complex_regular_expression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-complex_regular_expression_unit($input, $state)
    let $state := p:lookahead1W(89, $input, $state)         (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '<' | '>' | '[' | '|' |
                                                               '~' :)
    return
      if ($state[$p:l1] = 19                                (: ')' :)
       or $state[$p:l1] = 41                                (: '>' :)
       or $state[$p:l1] = 115) then                         (: '|' :)
        $state
      else
        p:parse-complex_regular_expression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production complex_regular_expression (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-complex_regular_expression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-complex_regular_expression_unit($input, $state)
    let $state := p:lookahead1W(89, $input, $state)         (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '<' | '>' | '[' | '|' |
                                                               '~' :)
    return
      if ($state[$p:l1] = 19                                (: ')' :)
       or $state[$p:l1] = 41                                (: '>' :)
       or $state[$p:l1] = 115) then                         (: '|' :)
        $state
      else
        p:try-complex_regular_expression-1($input, $state)
};

(:~
 : Parse complex_regular_expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-complex_regular_expression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-complex_regular_expression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "complex_regular_expression", $count, $begin, $end)
};

(:~
 : Try parsing complex_regular_expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-complex_regular_expression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-complex_regular_expression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production complex_regular_expression_choices (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-complex_regular_expression_choices-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 115) then                          (: '|' :)
      $state
    else
      let $state := p:consume(115, $input, $state)          (: '|' :)
      let $state := p:lookahead1W(80, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | '[' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-complex_regular_expression($input, $state)
      return p:parse-complex_regular_expression_choices-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production complex_regular_expression_choices (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-complex_regular_expression_choices-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 115) then                          (: '|' :)
      $state
    else
      let $state := p:consumeT(115, $input, $state)         (: '|' :)
      let $state := p:lookahead1W(80, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | '[' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-complex_regular_expression($input, $state)
      return p:try-complex_regular_expression_choices-1($input, $state)
};

(:~
 : Parse complex_regular_expression_choices.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-complex_regular_expression_choices($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-complex_regular_expression($input, $state)
  let $state := p:parse-complex_regular_expression_choices-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "complex_regular_expression_choices", $count, $begin, $end)
};

(:~
 : Try parsing complex_regular_expression_choices.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-complex_regular_expression_choices($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-complex_regular_expression($input, $state)
  let $state := p:try-complex_regular_expression_choices-1($input, $state)
  return $state
};

(:~
 : Parse regular_expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-regular_expression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 35) then                           (: '<' :)
      let $state := p:lookahead2W(88, $input, $state)       (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                               SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '#' | '(' |
                                                               '<' | 'EOF' | '[' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 163) then                      (: '<' IDENTIFIER :)
          let $state := p:lookahead3W(44, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' |
                                                               '>' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7) then                        (: STRING_LITERAL :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StringLiteral($input, $state)
      return $state
    else if ($state[$p:lk] = 671907) then                   (: '<' IDENTIFIER '>' :)
      let $state := p:consume(35, $input, $state)           (: '<' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-identifier($input, $state)
      let $state := p:lookahead1W(11, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
      let $state := p:consume(41, $input, $state)           (: '>' :)
      return $state
    else if ($state[$p:lk] = 6051) then                     (: '<' 'EOF' :)
      let $state := p:consume(35, $input, $state)           (: '<' :)
      let $state := p:lookahead1W(12, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'EOF' :)
      let $state := p:consume(47, $input, $state)           (: 'EOF' :)
      let $state := p:lookahead1W(11, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
      let $state := p:consume(41, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(35, $input, $state)           (: '<' :)
      let $state := p:lookahead1W(87, $input, $state)       (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                               SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '#' | '(' |
                                                               '<' | '[' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 1                          (: IDENTIFIER :)
              or $state[$p:l1] = 12) then                   (: '#' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 12) then               (: '#' :)
              let $state := p:consume(12, $input, $state)   (: '#' :)
              return $state
            else
              $state
          let $state := p:lookahead1W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-identifier($input, $state)
          let $state := p:lookahead1W(7, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
          let $state := p:consume(33, $input, $state)       (: ':' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(80, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | '[' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-complex_regular_expression_choices($input, $state)
      let $state := p:consume(41, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "regular_expression", $count, $begin, $end)
};

(:~
 : Try parsing regular_expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-regular_expression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 35) then                           (: '<' :)
      let $state := p:lookahead2W(88, $input, $state)       (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                               SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '#' | '(' |
                                                               '<' | 'EOF' | '[' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 163) then                      (: '<' IDENTIFIER :)
          let $state := p:lookahead3W(44, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' |
                                                               '>' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7) then                        (: STRING_LITERAL :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-StringLiteral($input, $state)
      return $state
    else if ($state[$p:lk] = 671907) then                   (: '<' IDENTIFIER '>' :)
      let $state := p:consumeT(35, $input, $state)          (: '<' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-identifier($input, $state)
      let $state := p:lookahead1W(11, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
      let $state := p:consumeT(41, $input, $state)          (: '>' :)
      return $state
    else if ($state[$p:lk] = 6051) then                     (: '<' 'EOF' :)
      let $state := p:consumeT(35, $input, $state)          (: '<' :)
      let $state := p:lookahead1W(12, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'EOF' :)
      let $state := p:consumeT(47, $input, $state)          (: 'EOF' :)
      let $state := p:lookahead1W(11, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
      let $state := p:consumeT(41, $input, $state)          (: '>' :)
      return $state
    else
      let $state := p:consumeT(35, $input, $state)          (: '<' :)
      let $state := p:lookahead1W(87, $input, $state)       (: IDENTIFIER | SKIP | STRING_LITERAL |
                                                               SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '#' | '(' |
                                                               '<' | '[' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 1                          (: IDENTIFIER :)
              or $state[$p:l1] = 12) then                   (: '#' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 12) then               (: '#' :)
              let $state := p:consumeT(12, $input, $state)  (: '#' :)
              return $state
            else
              $state
          let $state := p:lookahead1W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-identifier($input, $state)
          let $state := p:lookahead1W(7, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
          let $state := p:consumeT(33, $input, $state)      (: ':' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(80, $input, $state)       (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '<' | '[' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-complex_regular_expression_choices($input, $state)
      let $state := p:consumeT(41, $input, $state)          (: '>' :)
      return $state
  return $state
};

(:~
 : Parse regexpr_spec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-regexpr_spec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-regular_expression($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' |
                                                               '{' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Block($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(62, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' |
                                                               '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 33) then                       (: ':' :)
      let $state := p:consume(33, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "regexpr_spec", $count, $begin, $end)
};

(:~
 : Parse regexpr_kind.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-regexpr_kind($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 56) then                       (: 'TOKEN' :)
      let $state := p:consume(56, $input, $state)           (: 'TOKEN' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'SPECIAL_TOKEN' :)
      let $state := p:consume(55, $input, $state)           (: 'SPECIAL_TOKEN' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'SKIP' :)
      let $state := p:consume(54, $input, $state)           (: 'SKIP' :)
      return $state
    else
      let $state := p:consume(51, $input, $state)           (: 'MORE' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "regexpr_kind", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production regular_expr_production (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-regular_expr_production-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(40, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '>' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state := p:consume(1, $input, $state)          (: IDENTIFIER :)
        return p:parse-regular_expr_production-1($input, $state)
};

(:~
 : Parse the 2nd loop of production regular_expr_production (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-regular_expr_production-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(53, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '|' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 115) then                        (: '|' :)
        $state
      else
        let $state := p:consume(115, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(32, $input, $state)     (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-regexpr_spec($input, $state)
        return p:parse-regular_expr_production-2($input, $state)
};

(:~
 : Parse regular_expr_production.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-regular_expr_production($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state :=
        if ($state[$p:l1] eq 35) then                       (: '<' :)
          let $state := p:lookahead2W(26, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '*' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 2595) then                 (: '<' '*' :)
          let $state := p:consume(35, $input, $state)       (: '<' :)
          let $state := p:lookahead1W(5, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '*' :)
          let $state := p:consume(20, $input, $state)       (: '*' :)
          let $state := p:lookahead1W(11, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
          let $state := p:consume(41, $input, $state)       (: '>' :)
          return $state
        else
          let $state := p:consume(35, $input, $state)       (: '<' :)
          let $state := p:lookahead1W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state := p:consume(1, $input, $state)        (: IDENTIFIER :)
          let $state := p:parse-regular_expr_production-1($input, $state)
          let $state := p:consume(41, $input, $state)       (: '>' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(76, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'MORE' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-regexpr_kind($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' |
                                                               '[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 58) then                       (: '[' :)
      let $state := p:consume(58, $input, $state)           (: '[' :)
      let $state := p:lookahead1W(13, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'IGNORE_CASE' :)
      let $state := p:consume(48, $input, $state)           (: 'IGNORE_CASE' :)
      let $state := p:lookahead1W(16, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
      let $state := p:consume(59, $input, $state)           (: ']' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(7, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
  let $state := p:consume(33, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(32, $input, $state)           (: SKIP | STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-regexpr_spec($input, $state)
  let $state := p:parse-regular_expr_production-2($input, $state)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "regular_expr_production", $count, $begin, $end)
};

(:~
 : Parse AccessModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AccessModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95                             (: 'private' :)
          or $state[$p:l1] = 96                             (: 'protected' :)
          or $state[$p:l1] = 97) then                       (: 'public' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 97) then                   (: 'public' :)
          let $state := p:consume(97, $input, $state)       (: 'public' :)
          return $state
        else if ($state[$p:l1] = 96) then                   (: 'protected' :)
          let $state := p:consume(96, $input, $state)       (: 'protected' :)
          return $state
        else
          let $state := p:consume(95, $input, $state)       (: 'private' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AccessModifier", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production javacode_production (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-javacode_production-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      return p:parse-javacode_production-1($input, $state)
};

(:~
 : Parse javacode_production.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-javacode_production($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(49, $input, $state)               (: 'JAVACODE' :)
  let $state := p:lookahead1W(100, $input, $state)          (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'private' |
                                                               'protected' | 'public' | 'short' | 'void' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AccessModifier($input, $state)
  let $state := p:lookahead1W(93, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' | 'void' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ResultType($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-identifier($input, $state)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FormalParameters($input, $state)
  let $state := p:lookahead1W(52, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'throws' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'throws' :)
      let $state := p:consume(107, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      let $state := p:parse-javacode_production-1($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "javacode_production", $count, $begin, $end)
};

(:~
 : Parse production.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-production($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: 'JAVACODE' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-javacode_production($input, $state)
      return $state
    else if ($state[$p:l1] = 35                             (: '<' :)
          or $state[$p:l1] = 51                             (: 'MORE' :)
          or $state[$p:l1] = 54                             (: 'SKIP' :)
          or $state[$p:l1] = 55                             (: 'SPECIAL_TOKEN' :)
          or $state[$p:l1] = 56) then                       (: 'TOKEN' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-regular_expr_production($input, $state)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-token_manager_decls($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-bnf_production($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "production", $count, $begin, $end)
};

(:~
 : Parse DefaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(72, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MemberValue($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultValue", $count, $begin, $end)
};

(:~
 : Try parsing DefaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(72, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MemberValue($input, $state)
  return $state
};

(:~
 : Parse AnnotationTypeMemberDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotationTypeMemberDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: ';' :)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Modifiers($input, $state)
      let $state :=
        if ($state[$p:l1] eq 1) then                        (: IDENTIFIER :)
          let $state := p:lookahead2W(65, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '<' | '[' :)
          let $state :=
            if ($state[$p:lk] eq 129) then                  (: IDENTIFIER IDENTIFIER :)
              let $state := p:lookahead3W(81, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                                 ',' | ';' | '=' | '[' :)
              return $state
            else if ($state[$p:lk] eq 3713) then            (: IDENTIFIER '.' :)
              let $state := p:lookahead3W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              return $state
            else if ($state[$p:lk] eq 4481) then            (: IDENTIFIER '<' :)
              let $state := p:lookahead3W(92, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                 MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' |
                                                                 'char' | 'double' | 'float' | 'int' | 'long' | 'short' :)
              return $state
            else if ($state[$p:lk] eq 7425) then            (: IDENTIFIER '[' :)
              let $state := p:lookahead3W(16, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] = (64,                       (: 'boolean' :)
                                  66,                       (: 'byte' :)
                                  69,                       (: 'char' :)
                                  74,                       (: 'double' :)
                                  81,                       (: 'float' :)
                                  87,                       (: 'int' :)
                                  89,                       (: 'long' :)
                                  99)) then                 (: 'short' :)
          let $state := p:lookahead2W(29, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '[' :)
          let $state :=
            if ($state[$p:lk] = (192,                       (: 'boolean' IDENTIFIER :)
                                 194,                       (: 'byte' IDENTIFIER :)
                                 197,                       (: 'char' IDENTIFIER :)
                                 202,                       (: 'double' IDENTIFIER :)
                                 209,                       (: 'float' IDENTIFIER :)
                                 215,                       (: 'int' IDENTIFIER :)
                                 217,                       (: 'long' IDENTIFIER :)
                                 227)) then                 (: 'short' IDENTIFIER :)
              let $state := p:lookahead3W(81, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                                 ',' | ';' | '=' | '[' :)
              return $state
            else if ($state[$p:lk] = (7488,                 (: 'boolean' '[' :)
                                      7490,                 (: 'byte' '[' :)
                                      7493,                 (: 'char' '[' :)
                                      7498,                 (: 'double' '[' :)
                                      7505,                 (: 'float' '[' :)
                                      7511,                 (: 'int' '[' :)
                                      7513,                 (: 'long' '[' :)
                                      7523)) then           (: 'short' '[' :)
              let $state := p:lookahead3W(16, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 20097                      (: IDENTIFIER '.' IDENTIFIER :)
              or $state[$p:lk] = 20865                      (: IDENTIFIER '<' IDENTIFIER :)
              or $state[$p:lk] = 741761                     (: IDENTIFIER '<' '?' :)
              or $state[$p:lk] = 974081                     (: IDENTIFIER '[' ']' :)
              or $state[$p:lk] = 974144                     (: 'boolean' '[' ']' :)
              or $state[$p:lk] = 974146                     (: 'byte' '[' ']' :)
              or $state[$p:lk] = 974149                     (: 'char' '[' ']' :)
              or $state[$p:lk] = 974154                     (: 'double' '[' ']' :)
              or $state[$p:lk] = 974161                     (: 'float' '[' ']' :)
              or $state[$p:lk] = 974167                     (: 'int' '[' ']' :)
              or $state[$p:lk] = 974169                     (: 'long' '[' ']' :)
              or $state[$p:lk] = 974179                     (: 'short' '[' ']' :)
              or $state[$p:lk] = 1053057                    (: IDENTIFIER '<' 'boolean' :)
              or $state[$p:lk] = 1085825                    (: IDENTIFIER '<' 'byte' :)
              or $state[$p:lk] = 1134977                    (: IDENTIFIER '<' 'char' :)
              or $state[$p:lk] = 1216897                    (: IDENTIFIER '<' 'double' :)
              or $state[$p:lk] = 1331585                    (: IDENTIFIER '<' 'float' :)
              or $state[$p:lk] = 1429889                    (: IDENTIFIER '<' 'int' :)
              or $state[$p:lk] = 1462657                    (: IDENTIFIER '<' 'long' :)
              or $state[$p:lk] = 1626497) then              (: IDENTIFIER '<' 'short' :)
          let $state := p:memoized($state, 24)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-Type($input, $state)
              let $state := p:lookahead1W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              let $state := p:consumeT(1, $input, $state)   (: IDENTIFIER :)
              let $state := p:lookahead1W(3, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
              let $state := p:consumeT(18, $input, $state)  (: '(' :)
              let $state := p:lookahead1W(4, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
              let $state := p:consumeT(19, $input, $state)  (: ')' :)
              let $state := p:lookahead1W(47, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                                 'default' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 72) then           (: 'default' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-DefaultValue($input, $state)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(8, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
              let $state := p:consumeT(34, $input, $state)  (: ';' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -5, -5)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
         or $state[$p:lk] = 295041                          (: IDENTIFIER IDENTIFIER '(' :)
         or $state[$p:lk] = 295104                          (: 'boolean' IDENTIFIER '(' :)
         or $state[$p:lk] = 295106                          (: 'byte' IDENTIFIER '(' :)
         or $state[$p:lk] = 295109                          (: 'char' IDENTIFIER '(' :)
         or $state[$p:lk] = 295114                          (: 'double' IDENTIFIER '(' :)
         or $state[$p:lk] = 295121                          (: 'float' IDENTIFIER '(' :)
         or $state[$p:lk] = 295127                          (: 'int' IDENTIFIER '(' :)
         or $state[$p:lk] = 295129                          (: 'long' IDENTIFIER '(' :)
         or $state[$p:lk] = 295139) then                    (: 'short' IDENTIFIER '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Type($input, $state)
          let $state := p:lookahead1W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state := p:consume(1, $input, $state)        (: IDENTIFIER :)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state := p:consume(18, $input, $state)       (: '(' :)
          let $state := p:lookahead1W(4, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
          let $state := p:consume(19, $input, $state)       (: ')' :)
          let $state := p:lookahead1W(47, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               'default' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 72) then               (: 'default' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-DefaultValue($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(8, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
          let $state := p:consume(34, $input, $state)       (: ';' :)
          return $state
        else if ($state[$p:lk] = 70                         (: 'class' :)
              or $state[$p:lk] = 88) then                   (: 'interface' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ClassOrInterfaceDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = 76) then                   (: 'enum' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-EnumDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = 46) then                   (: '@' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnnotationTypeDeclaration($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FieldDeclaration($input, $state)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AnnotationTypeMemberDeclaration", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AnnotationTypeBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotationTypeBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(122, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'class' | 'double' | 'enum' | 'final' |
                                                               'float' | 'int' | 'interface' | 'long' | 'native' |
                                                               'private' | 'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' |
                                                               '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-AnnotationTypeMemberDeclaration($input, $state)
        return p:parse-AnnotationTypeBody-1($input, $state)
};

(:~
 : Parse AnnotationTypeBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotationTypeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:parse-AnnotationTypeBody-1($input, $state)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnnotationTypeBody", $count, $begin, $end)
};

(:~
 : Parse AnnotationTypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotationTypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(46, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(18, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'interface' :)
  let $state := p:consume(88, $input, $state)               (: 'interface' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AnnotationTypeBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnnotationTypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: ';' :)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Modifiers($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 76) then                   (: 'enum' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-EnumDeclaration($input, $state)
          return $state
        else if ($state[$p:l1] = 46) then                   (: '@' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnnotationTypeDeclaration($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ClassOrInterfaceDeclaration($input, $state)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse ImportDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ImportDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(85, $input, $state)               (: 'import' :)
  let $state := p:lookahead1W(99, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'static' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 100) then                      (: 'static' :)
      let $state := p:consume(100, $input, $state)          (: 'static' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29) then                       (: '.' :)
      let $state := p:consume(29, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(5, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '*' :)
      let $state := p:consume(20, $input, $state)           (: '*' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ImportDeclaration", $count, $begin, $end)
};

(:~
 : Parse MarkerAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MarkerAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(46, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MarkerAnnotation", $count, $begin, $end)
};

(:~
 : Try parsing MarkerAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MarkerAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(46, $input, $state)              (: '@' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Name($input, $state)
  return $state
};

(:~
 : Parse SingleMemberAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleMemberAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(46, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MemberValue($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleMemberAnnotation", $count, $begin, $end)
};

(:~
 : Try parsing SingleMemberAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SingleMemberAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(46, $input, $state)              (: '@' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Name($input, $state)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MemberValue($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse RUNSIGNEDSHIFT.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RUNSIGNEDSHIFT($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(41, $input, $state)               (: '>' :)
  let $state := p:lookahead1W(11, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
  let $state := p:consume(41, $input, $state)               (: '>' :)
  let $state := p:lookahead1W(11, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
  let $state := p:consume(41, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "RUNSIGNEDSHIFT", $count, $begin, $end)
};

(:~
 : Try parsing RUNSIGNEDSHIFT.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RUNSIGNEDSHIFT($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(41, $input, $state)              (: '>' :)
  let $state := p:lookahead1W(11, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
  let $state := p:consumeT(41, $input, $state)              (: '>' :)
  let $state := p:lookahead1W(11, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
  let $state := p:consumeT(41, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse RSIGNEDSHIFT.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RSIGNEDSHIFT($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(41, $input, $state)               (: '>' :)
  let $state := p:lookahead1W(11, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
  let $state := p:consume(41, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "RSIGNEDSHIFT", $count, $begin, $end)
};

(:~
 : Try parsing RSIGNEDSHIFT.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RSIGNEDSHIFT($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(41, $input, $state)              (: '>' :)
  let $state := p:lookahead1W(11, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
  let $state := p:consumeT(41, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse PostfixExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PostfixExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23                             (: '++' :)
          or $state[$p:l1] = 27) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: '++' :)
          let $state := p:consume(23, $input, $state)       (: '++' :)
          return $state
        else
          let $state := p:consume(27, $input, $state)       (: '--' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpression", $count, $begin, $end)
};

(:~
 : Try parsing PostfixExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PostfixExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23                             (: '++' :)
          or $state[$p:l1] = 27) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: '++' :)
          let $state := p:consumeT(23, $input, $state)      (: '++' :)
          return $state
        else
          let $state := p:consumeT(27, $input, $state)      (: '--' :)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 18) then                           (: '(' :)
      let $state := p:lookahead2W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:lk] eq 146) then                      (: '(' IDENTIFIER :)
          let $state := p:lookahead3W(70, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '.' | '<' | '[' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(37, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '[' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 16)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state := p:consumeT(18, $input, $state)        (: '(' :)
        let $state := p:lookahead1W(91, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Type($input, $state)
        let $state := p:lookahead1W(4, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
        let $state := p:consumeT(19, $input, $state)        (: ')' :)
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-UnaryExpression($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(18, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Type($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consume(19, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnaryExpression($input, $state)
      return $state
    else
      let $state := p:consume(18, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Type($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consume(19, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(131, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnaryExpressionNotPlusMinus($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpression", $count, $begin, $end)
};

(:~
 : Try parsing CastExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CastExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 18) then                           (: '(' :)
      let $state := p:lookahead2W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:lk] eq 146) then                      (: '(' IDENTIFIER :)
          let $state := p:lookahead3W(70, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '.' | '<' | '[' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(37, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '[' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 16)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state := p:consumeT(18, $input, $state)        (: '(' :)
        let $state := p:lookahead1W(91, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Type($input, $state)
        let $state := p:lookahead1W(4, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
        let $state := p:consumeT(19, $input, $state)        (: ')' :)
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-UnaryExpression($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consumeT(18, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Type($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consumeT(19, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnaryExpression($input, $state)
      return $state
    else
      let $state := p:consumeT(18, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Type($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
      let $state := p:consumeT(19, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(131, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnaryExpressionNotPlusMinus($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnaryExpressionNotPlusMinus.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpressionNotPlusMinus($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 18) then                           (: '(' :)
      let $state := p:lookahead2W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 146) then                      (: '(' IDENTIFIER :)
          let $state := p:lookahead3W(136, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(58, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '.' | '[' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 311442                         (: '(' IDENTIFIER ')' :)
          or $state[$p:lk] = 475282                         (: '(' IDENTIFIER '.' :)
          or $state[$p:lk] = 573586                         (: '(' IDENTIFIER '<' :)
          or $state[$p:lk] = 950418                         (: '(' IDENTIFIER '[' :)
          or $state[$p:lk] = 958482                         (: '(' 'boolean' '[' :)
          or $state[$p:lk] = 958738                         (: '(' 'byte' '[' :)
          or $state[$p:lk] = 959122                         (: '(' 'char' '[' :)
          or $state[$p:lk] = 959762                         (: '(' 'double' '[' :)
          or $state[$p:lk] = 960658                         (: '(' 'float' '[' :)
          or $state[$p:lk] = 961426                         (: '(' 'int' '[' :)
          or $state[$p:lk] = 961682                         (: '(' 'long' '[' :)
          or $state[$p:lk] = 962962) then                   (: '(' 'short' '[' :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-CastExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
            else
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -3, -3)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 10                             (: '!' :)
          or $state[$p:lk] = 119) then                      (: '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 119) then                  (: '~' :)
          let $state := p:consume(119, $input, $state)      (: '~' :)
          return $state
        else
          let $state := p:consume(10, $input, $state)       (: '!' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:lk] = -2
     or $state[$p:lk] = 319506                              (: '(' 'boolean' ')' :)
     or $state[$p:lk] = 319762                              (: '(' 'byte' ')' :)
     or $state[$p:lk] = 320146                              (: '(' 'char' ')' :)
     or $state[$p:lk] = 320786                              (: '(' 'double' ')' :)
     or $state[$p:lk] = 321682                              (: '(' 'float' ')' :)
     or $state[$p:lk] = 322450                              (: '(' 'int' ')' :)
     or $state[$p:lk] = 322706                              (: '(' 'long' ')' :)
     or $state[$p:lk] = 323986) then                        (: '(' 'short' ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CastExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PostfixExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpressionNotPlusMinus", $count, $begin, $end)
};

(:~
 : Try parsing UnaryExpressionNotPlusMinus.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryExpressionNotPlusMinus($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 18) then                           (: '(' :)
      let $state := p:lookahead2W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 146) then                      (: '(' IDENTIFIER :)
          let $state := p:lookahead3W(136, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(58, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               '.' | '[' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 311442                         (: '(' IDENTIFIER ')' :)
          or $state[$p:lk] = 475282                         (: '(' IDENTIFIER '.' :)
          or $state[$p:lk] = 573586                         (: '(' IDENTIFIER '<' :)
          or $state[$p:lk] = 950418                         (: '(' IDENTIFIER '[' :)
          or $state[$p:lk] = 958482                         (: '(' 'boolean' '[' :)
          or $state[$p:lk] = 958738                         (: '(' 'byte' '[' :)
          or $state[$p:lk] = 959122                         (: '(' 'char' '[' :)
          or $state[$p:lk] = 959762                         (: '(' 'double' '[' :)
          or $state[$p:lk] = 960658                         (: '(' 'float' '[' :)
          or $state[$p:lk] = 961426                         (: '(' 'int' '[' :)
          or $state[$p:lk] = 961682                         (: '(' 'long' '[' :)
          or $state[$p:lk] = 962962) then                   (: '(' 'short' '[' :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-CastExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
            else
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -3, -3)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 10                             (: '!' :)
          or $state[$p:lk] = 119) then                      (: '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 119) then                  (: '~' :)
          let $state := p:consumeT(119, $input, $state)     (: '~' :)
          return $state
        else
          let $state := p:consumeT(10, $input, $state)      (: '!' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:lk] = -2
     or $state[$p:lk] = 319506                              (: '(' 'boolean' ')' :)
     or $state[$p:lk] = 319762                              (: '(' 'byte' ')' :)
     or $state[$p:lk] = 320146                              (: '(' 'char' ')' :)
     or $state[$p:lk] = 320786                              (: '(' 'double' ')' :)
     or $state[$p:lk] = 321682                              (: '(' 'float' ')' :)
     or $state[$p:lk] = 322450                              (: '(' 'int' ')' :)
     or $state[$p:lk] = 322706                              (: '(' 'long' ')' :)
     or $state[$p:lk] = 323986) then                        (: '(' 'short' ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CastExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PostfixExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse MemberSelector.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MemberSelector($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(29, $input, $state)               (: '.' :)
  let $state := p:lookahead1W(9, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TypeArguments($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $end := $state[$p:e0]
  return p:reduce($state, "MemberSelector", $count, $begin, $end)
};

(:~
 : Try parsing MemberSelector.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MemberSelector($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(29, $input, $state)              (: '.' :)
  let $state := p:lookahead1W(9, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TypeArguments($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  return $state
};

(:~
 : Parse PrimarySuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimarySuffix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 29) then                           (: '.' :)
      let $state := p:lookahead2W(66, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'new' | 'this' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 13469) then                    (: '.' 'this' :)
      let $state := p:consume(29, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(21, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'this' :)
      let $state := p:consume(105, $input, $state)          (: 'this' :)
      return $state
    else if ($state[$p:lk] = 11677) then                    (: '.' 'new' :)
      let $state := p:consume(29, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(19, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'new' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AllocationExpression($input, $state)
      return $state
    else if ($state[$p:lk] = 4509) then                     (: '.' '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MemberSelector($input, $state)
      return $state
    else if ($state[$p:lk] = 58) then                       (: '[' :)
      let $state := p:consume(58, $input, $state)           (: '[' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      let $state := p:consume(59, $input, $state)           (: ']' :)
      return $state
    else if ($state[$p:lk] = 157) then                      (: '.' IDENTIFIER :)
      let $state := p:consume(29, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Arguments($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimarySuffix", $count, $begin, $end)
};

(:~
 : Try parsing PrimarySuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrimarySuffix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 29) then                           (: '.' :)
      let $state := p:lookahead2W(66, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'new' | 'this' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 13469) then                    (: '.' 'this' :)
      let $state := p:consumeT(29, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(21, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'this' :)
      let $state := p:consumeT(105, $input, $state)         (: 'this' :)
      return $state
    else if ($state[$p:lk] = 11677) then                    (: '.' 'new' :)
      let $state := p:consumeT(29, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(19, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'new' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AllocationExpression($input, $state)
      return $state
    else if ($state[$p:lk] = 4509) then                     (: '.' '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MemberSelector($input, $state)
      return $state
    else if ($state[$p:lk] = 58) then                       (: '[' :)
      let $state := p:consumeT(58, $input, $state)          (: '[' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      let $state := p:consumeT(59, $input, $state)          (: ']' :)
      return $state
    else if ($state[$p:lk] = 157) then                      (: '.' IDENTIFIER :)
      let $state := p:consumeT(29, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:consumeT(1, $input, $state)           (: IDENTIFIER :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Arguments($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production MethodDeclarator (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MethodDeclarator-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               '[' | 'throws' | '{' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        let $state := p:consume(58, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consume(59, $input, $state)         (: ']' :)
        return p:parse-MethodDeclarator-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MethodDeclarator (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MethodDeclarator-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               '[' | 'throws' | '{' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(58, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consumeT(59, $input, $state)        (: ']' :)
        return p:try-MethodDeclarator-1($input, $state)
};

(:~
 : Parse MethodDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MethodDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FormalParameters($input, $state)
  let $state := p:parse-MethodDeclarator-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MethodDeclarator", $count, $begin, $end)
};

(:~
 : Try parsing MethodDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MethodDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FormalParameters($input, $state)
  let $state := p:try-MethodDeclarator-1($input, $state)
  return $state
};

(:~
 : Parse ResultType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ResultType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 111) then                      (: 'void' :)
      let $state := p:consume(111, $input, $state)          (: 'void' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Type($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ResultType", $count, $begin, $end)
};

(:~
 : Try parsing ResultType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ResultType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 111) then                      (: 'void' :)
      let $state := p:consumeT(111, $input, $state)         (: 'void' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Type($input, $state)
      return $state
  return $state
};

(:~
 : Parse MethodDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MethodDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(93, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' | 'void' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ResultType($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MethodDeclarator($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'throws' :)
      let $state := p:consume(107, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Block($input, $state)
      return $state
    else
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "MethodDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing MethodDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MethodDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(93, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' | 'void' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ResultType($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MethodDeclarator($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'throws' :)
      let $state := p:consumeT(107, $input, $state)         (: 'throws' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NameList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Block($input, $state)
      return $state
    else
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FieldDeclaration (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FieldDeclaration-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VariableDeclarator($input, $state)
        return p:parse-FieldDeclaration-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FieldDeclaration (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FieldDeclaration-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-VariableDeclarator($input, $state)
        return p:try-FieldDeclaration-1($input, $state)
};

(:~
 : Parse FieldDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FieldDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Type($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VariableDeclarator($input, $state)
  let $state := p:parse-FieldDeclaration-1($input, $state)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FieldDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing FieldDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FieldDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Type($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VariableDeclarator($input, $state)
  let $state := p:try-FieldDeclaration-1($input, $state)
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse ExplicitConstructorInvocation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExplicitConstructorInvocation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 105) then                          (: 'this' :)
      let $state := p:lookahead2W(56, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '[' :)
      let $state :=
        if ($state[$p:lk] eq 2409) then                     (: 'this' '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 1                             (: IDENTIFIER :)
         and $state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 64                            (: 'boolean' :)
         and $state[$p:lk] != 66                            (: 'byte' :)
         and $state[$p:lk] != 69                            (: 'char' :)
         and $state[$p:lk] != 74                            (: 'double' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 81                            (: 'float' :)
         and $state[$p:lk] != 87                            (: 'int' :)
         and $state[$p:lk] != 89                            (: 'long' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 99                            (: 'short' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 3817                          (: 'this' '.' :)
         and $state[$p:lk] != 7529) then                    (: 'this' '[' :)
      let $state := p:memoized($state, 10)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(105, $input, $state)     (: 'this' :)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Arguments($input, $state)
          let $state := p:lookahead1W(8, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
          let $state := p:consumeT(34, $input, $state)      (: ';' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(105, $input, $state)          (: 'this' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Arguments($input, $state)
      let $state := p:lookahead1W(8, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:l1] eq 102) then                      (: 'super' :)
          let $state := p:lookahead2W(34, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] != 2406) then                (: 'super' '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-PrimaryExpression($input, $state)
          let $state := p:consume(29, $input, $state)       (: '.' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(20, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'super' :)
      let $state := p:consume(102, $input, $state)          (: 'super' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Arguments($input, $state)
      let $state := p:lookahead1W(8, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExplicitConstructorInvocation", $count, $begin, $end)
};

(:~
 : Try parsing ExplicitConstructorInvocation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExplicitConstructorInvocation($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 105) then                          (: 'this' :)
      let $state := p:lookahead2W(56, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '[' :)
      let $state :=
        if ($state[$p:lk] eq 2409) then                     (: 'this' '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 1                             (: IDENTIFIER :)
         and $state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 64                            (: 'boolean' :)
         and $state[$p:lk] != 66                            (: 'byte' :)
         and $state[$p:lk] != 69                            (: 'char' :)
         and $state[$p:lk] != 74                            (: 'double' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 81                            (: 'float' :)
         and $state[$p:lk] != 87                            (: 'int' :)
         and $state[$p:lk] != 89                            (: 'long' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 99                            (: 'short' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 3817                          (: 'this' '.' :)
         and $state[$p:lk] != 7529) then                    (: 'this' '[' :)
      let $state := p:memoized($state, 10)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(105, $input, $state)     (: 'this' :)
          let $state := p:lookahead1W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Arguments($input, $state)
          let $state := p:lookahead1W(8, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
          let $state := p:consumeT(34, $input, $state)      (: ';' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consumeT(105, $input, $state)         (: 'this' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Arguments($input, $state)
      let $state := p:lookahead1W(8, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:l1] eq 102) then                      (: 'super' :)
          let $state := p:lookahead2W(34, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] != 2406) then                (: 'super' '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-PrimaryExpression($input, $state)
          let $state := p:consumeT(29, $input, $state)      (: '.' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(20, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'super' :)
      let $state := p:consumeT(102, $input, $state)         (: 'super' :)
      let $state := p:lookahead1W(3, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Arguments($input, $state)
      let $state := p:lookahead1W(8, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production NameList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      return p:parse-NameList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production NameList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NameList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Name($input, $state)
      return p:try-NameList-1($input, $state)
};

(:~
 : Parse NameList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:parse-NameList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NameList", $count, $begin, $end)
};

(:~
 : Try parsing NameList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NameList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Name($input, $state)
  let $state := p:try-NameList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FormalParameters (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FormalParameters-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(118, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FormalParameter($input, $state)
      return p:parse-FormalParameters-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FormalParameters (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FormalParameters-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(118, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FormalParameter($input, $state)
      return p:try-FormalParameters-1($input, $state)
};

(:~
 : Parse FormalParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FormalParameters($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(120, $input, $state)          (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ')' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 19) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FormalParameter($input, $state)
      let $state := p:parse-FormalParameters-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FormalParameters", $count, $begin, $end)
};

(:~
 : Try parsing FormalParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FormalParameters($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(120, $input, $state)          (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ')' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 19) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FormalParameter($input, $state)
      let $state := p:try-FormalParameters-1($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse the 1st loop of production ConstructorDeclaration (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructorDeclaration-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(168, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-BlockStatement($input, $state)
        return p:parse-ConstructorDeclaration-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ConstructorDeclaration (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ConstructorDeclaration-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(168, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-BlockStatement($input, $state)
        return p:try-ConstructorDeclaration-1($input, $state)
};

(:~
 : Parse ConstructorDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructorDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FormalParameters($input, $state)
  let $state := p:lookahead1W(52, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'throws' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'throws' :)
      let $state := p:consume(107, $input, $state)          (: 'throws' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(117, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | '--' | '-=' | '.' | '/=' | ':' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 2305) then                     (: IDENTIFIER '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 3713) then                (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(107, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 18) then                      (: '(' :)
      let $state := p:lookahead2W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 11666) then                    (: '(' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] = (2962,                     (: '(' '++' :)
                                  3474)) then               (: '(' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (13074,                    (: '(' 'super' :)
                                  14226)) then              (: '(' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (1298,                     (: '(' '!' :)
                                  2322,                     (: '(' '(' :)
                                  2834,                     (: '(' '+' :)
                                  3346,                     (: '(' '-' :)
                                  15250)) then              (: '(' '~' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (146,                      (: '(' IDENTIFIER :)
                                  530,                      (: '(' INTEGER_LITERAL :)
                                  658,                      (: '(' FLOATING_POINT_LITERAL :)
                                  786,                      (: '(' CHARACTER_LITERAL :)
                                  914,                      (: '(' STRING_LITERAL :)
                                  6034,                     (: '(' 'EOF' :)
                                  6162,                     (: '(' 'IGNORE_CASE' :)
                                  6290,                     (: '(' 'JAVACODE' :)
                                  6418,                     (: '(' 'LOOKAHEAD' :)
                                  6546,                     (: '(' 'MORE' :)
                                  6674,                     (: '(' 'PARSER_BEGIN' :)
                                  6802,                     (: '(' 'PARSER_END' :)
                                  6930,                     (: '(' 'SKIP' :)
                                  7058,                     (: '(' 'SPECIAL_TOKEN' :)
                                  7186,                     (: '(' 'TOKEN' :)
                                  7314,                     (: '(' 'TOKEN_MGR_DECLS' :)
                                  10002,                    (: '(' 'false' :)
                                  11794,                    (: '(' 'null' :)
                                  13458,                    (: '(' 'this' :)
                                  13970)) then              (: '(' 'true' :)
          let $state := p:lookahead3W(136, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 91) then                      (: 'new' :)
      let $state := p:lookahead2W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:lk] eq 219) then                      (: 'new' IDENTIFIER :)
          let $state := p:lookahead3W(68, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '<' | '[' :)
          return $state
        else if ($state[$p:lk] = (8283,                     (: 'new' 'boolean' :)
                                  8539,                     (: 'new' 'byte' :)
                                  8923,                     (: 'new' 'char' :)
                                  9563,                     (: 'new' 'double' :)
                                  10459,                    (: 'new' 'float' :)
                                  11227,                    (: 'new' 'int' :)
                                  11483,                    (: 'new' 'long' :)
                                  12763)) then              (: 'new' 'short' :)
          let $state := p:lookahead3W(15, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 102) then                     (: 'super' :)
      let $state := p:lookahead2W(34, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' :)
      let $state :=
        if ($state[$p:lk] eq 3814) then                     (: 'super' '.' :)
          let $state := p:lookahead3W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 111) then                     (: 'void' :)
      let $state := p:lookahead2W(6, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
      let $state :=
        if ($state[$p:lk] eq 3823) then                     (: 'void' '.' :)
          let $state := p:lookahead3W(17, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (4,                            (: INTEGER_LITERAL :)
                              5,                            (: FLOATING_POINT_LITERAL :)
                              6,                            (: CHARACTER_LITERAL :)
                              7,                            (: STRING_LITERAL :)
                              78,                           (: 'false' :)
                              92,                           (: 'null' :)
                              105,                          (: 'this' :)
                              109)) then                    (: 'true' :)
      let $state := p:lookahead2W(109, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ';' | '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' |
                                                               '|=' :)
      let $state :=
        if ($state[$p:lk] = (2308,                          (: INTEGER_LITERAL '(' :)
                             2309,                          (: FLOATING_POINT_LITERAL '(' :)
                             2310,                          (: CHARACTER_LITERAL '(' :)
                             2311,                          (: STRING_LITERAL '(' :)
                             2382,                          (: 'false' '(' :)
                             2396,                          (: 'null' '(' :)
                             2409,                          (: 'this' '(' :)
                             2413)) then                    (: 'true' '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (3716,                     (: INTEGER_LITERAL '.' :)
                                  3717,                     (: FLOATING_POINT_LITERAL '.' :)
                                  3718,                     (: CHARACTER_LITERAL '.' :)
                                  3719,                     (: STRING_LITERAL '.' :)
                                  3790,                     (: 'false' '.' :)
                                  3804,                     (: 'null' '.' :)
                                  3817,                     (: 'this' '.' :)
                                  3821)) then               (: 'true' '.' :)
          let $state := p:lookahead3W(78, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] = (7428,                     (: INTEGER_LITERAL '[' :)
                                  7429,                     (: FLOATING_POINT_LITERAL '[' :)
                                  7430,                     (: CHARACTER_LITERAL '[' :)
                                  7431,                     (: STRING_LITERAL '[' :)
                                  7502,                     (: 'false' '[' :)
                                  7516,                     (: 'null' '[' :)
                                  7529,                     (: 'this' '[' :)
                                  7533)) then               (: 'true' '[' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (3776,                          (: 'boolean' '.' :)
                             3778,                          (: 'byte' '.' :)
                             3781,                          (: 'char' '.' :)
                             3786,                          (: 'double' '.' :)
                             3793,                          (: 'float' '.' :)
                             3799,                          (: 'int' '.' :)
                             3801,                          (: 'long' '.' :)
                             3811)) then                    (: 'short' '.' :)
          let $state := p:lookahead3W(17, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
          return $state
        else if ($state[$p:lk] = (7488,                     (: 'boolean' '[' :)
                                  7490,                     (: 'byte' '[' :)
                                  7493,                     (: 'char' '[' :)
                                  7498,                     (: 'double' '[' :)
                                  7505,                     (: 'float' '[' :)
                                  7511,                     (: 'int' '[' :)
                                  7513,                     (: 'long' '[' :)
                                  7523)) then               (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (47,                           (: 'EOF' :)
                              48,                           (: 'IGNORE_CASE' :)
                              49,                           (: 'JAVACODE' :)
                              50,                           (: 'LOOKAHEAD' :)
                              51,                           (: 'MORE' :)
                              52,                           (: 'PARSER_BEGIN' :)
                              53,                           (: 'PARSER_END' :)
                              54,                           (: 'SKIP' :)
                              55,                           (: 'SPECIAL_TOKEN' :)
                              56,                           (: 'TOKEN' :)
                              57)) then                     (: 'TOKEN_MGR_DECLS' :)
      let $state := p:lookahead2W(109, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ';' | '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' |
                                                               '|=' :)
      let $state :=
        if ($state[$p:lk] = (2351,                          (: 'EOF' '(' :)
                             2352,                          (: 'IGNORE_CASE' '(' :)
                             2353,                          (: 'JAVACODE' '(' :)
                             2354,                          (: 'LOOKAHEAD' '(' :)
                             2355,                          (: 'MORE' '(' :)
                             2356,                          (: 'PARSER_BEGIN' '(' :)
                             2357,                          (: 'PARSER_END' '(' :)
                             2358,                          (: 'SKIP' '(' :)
                             2359,                          (: 'SPECIAL_TOKEN' '(' :)
                             2360,                          (: 'TOKEN' '(' :)
                             2361)) then                    (: 'TOKEN_MGR_DECLS' '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (3759,                     (: 'EOF' '.' :)
                                  3760,                     (: 'IGNORE_CASE' '.' :)
                                  3761,                     (: 'JAVACODE' '.' :)
                                  3762,                     (: 'LOOKAHEAD' '.' :)
                                  3763,                     (: 'MORE' '.' :)
                                  3764,                     (: 'PARSER_BEGIN' '.' :)
                                  3765,                     (: 'PARSER_END' '.' :)
                                  3766,                     (: 'SKIP' '.' :)
                                  3767,                     (: 'SPECIAL_TOKEN' '.' :)
                                  3768,                     (: 'TOKEN' '.' :)
                                  3769)) then               (: 'TOKEN_MGR_DECLS' '.' :)
          let $state := p:lookahead3W(104, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] = (7471,                     (: 'EOF' '[' :)
                                  7472,                     (: 'IGNORE_CASE' '[' :)
                                  7473,                     (: 'JAVACODE' '[' :)
                                  7474,                     (: 'LOOKAHEAD' '[' :)
                                  7475,                     (: 'MORE' '[' :)
                                  7476,                     (: 'PARSER_BEGIN' '[' :)
                                  7477,                     (: 'PARSER_END' '[' :)
                                  7478,                     (: 'SKIP' '[' :)
                                  7479,                     (: 'SPECIAL_TOKEN' '[' :)
                                  7480,                     (: 'TOKEN' '[' :)
                                  7481)) then               (: 'TOKEN_MGR_DECLS' '[' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 23                            (: '++' :)
         and $state[$p:lk] != 27                            (: '--' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 46                            (: '@' :)
         and $state[$p:lk] != 62                            (: 'abstract' :)
         and $state[$p:lk] != 63                            (: 'assert' :)
         and $state[$p:lk] != 65                            (: 'break' :)
         and $state[$p:lk] != 70                            (: 'class' :)
         and $state[$p:lk] != 71                            (: 'continue' :)
         and $state[$p:lk] != 73                            (: 'do' :)
         and $state[$p:lk] != 79                            (: 'final' :)
         and $state[$p:lk] != 82                            (: 'for' :)
         and $state[$p:lk] != 83                            (: 'if' :)
         and $state[$p:lk] != 88                            (: 'interface' :)
         and $state[$p:lk] != 90                            (: 'native' :)
         and $state[$p:lk] != 95                            (: 'private' :)
         and $state[$p:lk] != 96                            (: 'protected' :)
         and $state[$p:lk] != 97                            (: 'public' :)
         and $state[$p:lk] != 98                            (: 'return' :)
         and $state[$p:lk] != 100                           (: 'static' :)
         and $state[$p:lk] != 101                           (: 'strictfp' :)
         and $state[$p:lk] != 103                           (: 'switch' :)
         and $state[$p:lk] != 104                           (: 'synchronized' :)
         and $state[$p:lk] != 106                           (: 'throw' :)
         and $state[$p:lk] != 108                           (: 'transient' :)
         and $state[$p:lk] != 110                           (: 'try' :)
         and $state[$p:lk] != 112                           (: 'volatile' :)
         and $state[$p:lk] != 113                           (: 'while' :)
         and $state[$p:lk] != 114                           (: '{' :)
         and $state[$p:lk] != 118                           (: '}' :)
         and $state[$p:lk] != 129                           (: IDENTIFIER IDENTIFIER :)
         and $state[$p:lk] != 192                           (: 'boolean' IDENTIFIER :)
         and $state[$p:lk] != 194                           (: 'byte' IDENTIFIER :)
         and $state[$p:lk] != 197                           (: 'char' IDENTIFIER :)
         and $state[$p:lk] != 202                           (: 'double' IDENTIFIER :)
         and $state[$p:lk] != 209                           (: 'float' IDENTIFIER :)
         and $state[$p:lk] != 215                           (: 'int' IDENTIFIER :)
         and $state[$p:lk] != 217                           (: 'long' IDENTIFIER :)
         and $state[$p:lk] != 227                           (: 'short' IDENTIFIER :)
         and $state[$p:lk] != 1793                          (: IDENTIFIER '%=' :)
         and $state[$p:lk] != 1796                          (: INTEGER_LITERAL '%=' :)
         and $state[$p:lk] != 1797                          (: FLOATING_POINT_LITERAL '%=' :)
         and $state[$p:lk] != 1798                          (: CHARACTER_LITERAL '%=' :)
         and $state[$p:lk] != 1799                          (: STRING_LITERAL '%=' :)
         and $state[$p:lk] != 1839                          (: 'EOF' '%=' :)
         and $state[$p:lk] != 1840                          (: 'IGNORE_CASE' '%=' :)
         and $state[$p:lk] != 1841                          (: 'JAVACODE' '%=' :)
         and $state[$p:lk] != 1842                          (: 'LOOKAHEAD' '%=' :)
         and $state[$p:lk] != 1843                          (: 'MORE' '%=' :)
         and $state[$p:lk] != 1844                          (: 'PARSER_BEGIN' '%=' :)
         and $state[$p:lk] != 1845                          (: 'PARSER_END' '%=' :)
         and $state[$p:lk] != 1846                          (: 'SKIP' '%=' :)
         and $state[$p:lk] != 1847                          (: 'SPECIAL_TOKEN' '%=' :)
         and $state[$p:lk] != 1848                          (: 'TOKEN' '%=' :)
         and $state[$p:lk] != 1849                          (: 'TOKEN_MGR_DECLS' '%=' :)
         and $state[$p:lk] != 1870                          (: 'false' '%=' :)
         and $state[$p:lk] != 1884                          (: 'null' '%=' :)
         and $state[$p:lk] != 1897                          (: 'this' '%=' :)
         and $state[$p:lk] != 1901                          (: 'true' '%=' :)
         and $state[$p:lk] != 2177                          (: IDENTIFIER '&=' :)
         and $state[$p:lk] != 2180                          (: INTEGER_LITERAL '&=' :)
         and $state[$p:lk] != 2181                          (: FLOATING_POINT_LITERAL '&=' :)
         and $state[$p:lk] != 2182                          (: CHARACTER_LITERAL '&=' :)
         and $state[$p:lk] != 2183                          (: STRING_LITERAL '&=' :)
         and $state[$p:lk] != 2223                          (: 'EOF' '&=' :)
         and $state[$p:lk] != 2224                          (: 'IGNORE_CASE' '&=' :)
         and $state[$p:lk] != 2225                          (: 'JAVACODE' '&=' :)
         and $state[$p:lk] != 2226                          (: 'LOOKAHEAD' '&=' :)
         and $state[$p:lk] != 2227                          (: 'MORE' '&=' :)
         and $state[$p:lk] != 2228                          (: 'PARSER_BEGIN' '&=' :)
         and $state[$p:lk] != 2229                          (: 'PARSER_END' '&=' :)
         and $state[$p:lk] != 2230                          (: 'SKIP' '&=' :)
         and $state[$p:lk] != 2231                          (: 'SPECIAL_TOKEN' '&=' :)
         and $state[$p:lk] != 2232                          (: 'TOKEN' '&=' :)
         and $state[$p:lk] != 2233                          (: 'TOKEN_MGR_DECLS' '&=' :)
         and $state[$p:lk] != 2254                          (: 'false' '&=' :)
         and $state[$p:lk] != 2268                          (: 'null' '&=' :)
         and $state[$p:lk] != 2281                          (: 'this' '&=' :)
         and $state[$p:lk] != 2285                          (: 'true' '&=' :)
         and $state[$p:lk] != 2406                          (: 'super' '(' :)
         and $state[$p:lk] != 2689                          (: IDENTIFIER '*=' :)
         and $state[$p:lk] != 2692                          (: INTEGER_LITERAL '*=' :)
         and $state[$p:lk] != 2693                          (: FLOATING_POINT_LITERAL '*=' :)
         and $state[$p:lk] != 2694                          (: CHARACTER_LITERAL '*=' :)
         and $state[$p:lk] != 2695                          (: STRING_LITERAL '*=' :)
         and $state[$p:lk] != 2735                          (: 'EOF' '*=' :)
         and $state[$p:lk] != 2736                          (: 'IGNORE_CASE' '*=' :)
         and $state[$p:lk] != 2737                          (: 'JAVACODE' '*=' :)
         and $state[$p:lk] != 2738                          (: 'LOOKAHEAD' '*=' :)
         and $state[$p:lk] != 2739                          (: 'MORE' '*=' :)
         and $state[$p:lk] != 2740                          (: 'PARSER_BEGIN' '*=' :)
         and $state[$p:lk] != 2741                          (: 'PARSER_END' '*=' :)
         and $state[$p:lk] != 2742                          (: 'SKIP' '*=' :)
         and $state[$p:lk] != 2743                          (: 'SPECIAL_TOKEN' '*=' :)
         and $state[$p:lk] != 2744                          (: 'TOKEN' '*=' :)
         and $state[$p:lk] != 2745                          (: 'TOKEN_MGR_DECLS' '*=' :)
         and $state[$p:lk] != 2766                          (: 'false' '*=' :)
         and $state[$p:lk] != 2780                          (: 'null' '*=' :)
         and $state[$p:lk] != 2793                          (: 'this' '*=' :)
         and $state[$p:lk] != 2797                          (: 'true' '*=' :)
         and $state[$p:lk] != 2945                          (: IDENTIFIER '++' :)
         and $state[$p:lk] != 2948                          (: INTEGER_LITERAL '++' :)
         and $state[$p:lk] != 2949                          (: FLOATING_POINT_LITERAL '++' :)
         and $state[$p:lk] != 2950                          (: CHARACTER_LITERAL '++' :)
         and $state[$p:lk] != 2951                          (: STRING_LITERAL '++' :)
         and $state[$p:lk] != 2991                          (: 'EOF' '++' :)
         and $state[$p:lk] != 2992                          (: 'IGNORE_CASE' '++' :)
         and $state[$p:lk] != 2993                          (: 'JAVACODE' '++' :)
         and $state[$p:lk] != 2994                          (: 'LOOKAHEAD' '++' :)
         and $state[$p:lk] != 2995                          (: 'MORE' '++' :)
         and $state[$p:lk] != 2996                          (: 'PARSER_BEGIN' '++' :)
         and $state[$p:lk] != 2997                          (: 'PARSER_END' '++' :)
         and $state[$p:lk] != 2998                          (: 'SKIP' '++' :)
         and $state[$p:lk] != 2999                          (: 'SPECIAL_TOKEN' '++' :)
         and $state[$p:lk] != 3000                          (: 'TOKEN' '++' :)
         and $state[$p:lk] != 3001                          (: 'TOKEN_MGR_DECLS' '++' :)
         and $state[$p:lk] != 3022                          (: 'false' '++' :)
         and $state[$p:lk] != 3036                          (: 'null' '++' :)
         and $state[$p:lk] != 3049                          (: 'this' '++' :)
         and $state[$p:lk] != 3053                          (: 'true' '++' :)
         and $state[$p:lk] != 3073                          (: IDENTIFIER '+=' :)
         and $state[$p:lk] != 3076                          (: INTEGER_LITERAL '+=' :)
         and $state[$p:lk] != 3077                          (: FLOATING_POINT_LITERAL '+=' :)
         and $state[$p:lk] != 3078                          (: CHARACTER_LITERAL '+=' :)
         and $state[$p:lk] != 3079                          (: STRING_LITERAL '+=' :)
         and $state[$p:lk] != 3119                          (: 'EOF' '+=' :)
         and $state[$p:lk] != 3120                          (: 'IGNORE_CASE' '+=' :)
         and $state[$p:lk] != 3121                          (: 'JAVACODE' '+=' :)
         and $state[$p:lk] != 3122                          (: 'LOOKAHEAD' '+=' :)
         and $state[$p:lk] != 3123                          (: 'MORE' '+=' :)
         and $state[$p:lk] != 3124                          (: 'PARSER_BEGIN' '+=' :)
         and $state[$p:lk] != 3125                          (: 'PARSER_END' '+=' :)
         and $state[$p:lk] != 3126                          (: 'SKIP' '+=' :)
         and $state[$p:lk] != 3127                          (: 'SPECIAL_TOKEN' '+=' :)
         and $state[$p:lk] != 3128                          (: 'TOKEN' '+=' :)
         and $state[$p:lk] != 3129                          (: 'TOKEN_MGR_DECLS' '+=' :)
         and $state[$p:lk] != 3150                          (: 'false' '+=' :)
         and $state[$p:lk] != 3164                          (: 'null' '+=' :)
         and $state[$p:lk] != 3177                          (: 'this' '+=' :)
         and $state[$p:lk] != 3181                          (: 'true' '+=' :)
         and $state[$p:lk] != 3457                          (: IDENTIFIER '--' :)
         and $state[$p:lk] != 3460                          (: INTEGER_LITERAL '--' :)
         and $state[$p:lk] != 3461                          (: FLOATING_POINT_LITERAL '--' :)
         and $state[$p:lk] != 3462                          (: CHARACTER_LITERAL '--' :)
         and $state[$p:lk] != 3463                          (: STRING_LITERAL '--' :)
         and $state[$p:lk] != 3503                          (: 'EOF' '--' :)
         and $state[$p:lk] != 3504                          (: 'IGNORE_CASE' '--' :)
         and $state[$p:lk] != 3505                          (: 'JAVACODE' '--' :)
         and $state[$p:lk] != 3506                          (: 'LOOKAHEAD' '--' :)
         and $state[$p:lk] != 3507                          (: 'MORE' '--' :)
         and $state[$p:lk] != 3508                          (: 'PARSER_BEGIN' '--' :)
         and $state[$p:lk] != 3509                          (: 'PARSER_END' '--' :)
         and $state[$p:lk] != 3510                          (: 'SKIP' '--' :)
         and $state[$p:lk] != 3511                          (: 'SPECIAL_TOKEN' '--' :)
         and $state[$p:lk] != 3512                          (: 'TOKEN' '--' :)
         and $state[$p:lk] != 3513                          (: 'TOKEN_MGR_DECLS' '--' :)
         and $state[$p:lk] != 3534                          (: 'false' '--' :)
         and $state[$p:lk] != 3548                          (: 'null' '--' :)
         and $state[$p:lk] != 3561                          (: 'this' '--' :)
         and $state[$p:lk] != 3565                          (: 'true' '--' :)
         and $state[$p:lk] != 3585                          (: IDENTIFIER '-=' :)
         and $state[$p:lk] != 3588                          (: INTEGER_LITERAL '-=' :)
         and $state[$p:lk] != 3589                          (: FLOATING_POINT_LITERAL '-=' :)
         and $state[$p:lk] != 3590                          (: CHARACTER_LITERAL '-=' :)
         and $state[$p:lk] != 3591                          (: STRING_LITERAL '-=' :)
         and $state[$p:lk] != 3631                          (: 'EOF' '-=' :)
         and $state[$p:lk] != 3632                          (: 'IGNORE_CASE' '-=' :)
         and $state[$p:lk] != 3633                          (: 'JAVACODE' '-=' :)
         and $state[$p:lk] != 3634                          (: 'LOOKAHEAD' '-=' :)
         and $state[$p:lk] != 3635                          (: 'MORE' '-=' :)
         and $state[$p:lk] != 3636                          (: 'PARSER_BEGIN' '-=' :)
         and $state[$p:lk] != 3637                          (: 'PARSER_END' '-=' :)
         and $state[$p:lk] != 3638                          (: 'SKIP' '-=' :)
         and $state[$p:lk] != 3639                          (: 'SPECIAL_TOKEN' '-=' :)
         and $state[$p:lk] != 3640                          (: 'TOKEN' '-=' :)
         and $state[$p:lk] != 3641                          (: 'TOKEN_MGR_DECLS' '-=' :)
         and $state[$p:lk] != 3662                          (: 'false' '-=' :)
         and $state[$p:lk] != 3676                          (: 'null' '-=' :)
         and $state[$p:lk] != 3689                          (: 'this' '-=' :)
         and $state[$p:lk] != 3693                          (: 'true' '-=' :)
         and $state[$p:lk] != 4097                          (: IDENTIFIER '/=' :)
         and $state[$p:lk] != 4100                          (: INTEGER_LITERAL '/=' :)
         and $state[$p:lk] != 4101                          (: FLOATING_POINT_LITERAL '/=' :)
         and $state[$p:lk] != 4102                          (: CHARACTER_LITERAL '/=' :)
         and $state[$p:lk] != 4103                          (: STRING_LITERAL '/=' :)
         and $state[$p:lk] != 4143                          (: 'EOF' '/=' :)
         and $state[$p:lk] != 4144                          (: 'IGNORE_CASE' '/=' :)
         and $state[$p:lk] != 4145                          (: 'JAVACODE' '/=' :)
         and $state[$p:lk] != 4146                          (: 'LOOKAHEAD' '/=' :)
         and $state[$p:lk] != 4147                          (: 'MORE' '/=' :)
         and $state[$p:lk] != 4148                          (: 'PARSER_BEGIN' '/=' :)
         and $state[$p:lk] != 4149                          (: 'PARSER_END' '/=' :)
         and $state[$p:lk] != 4150                          (: 'SKIP' '/=' :)
         and $state[$p:lk] != 4151                          (: 'SPECIAL_TOKEN' '/=' :)
         and $state[$p:lk] != 4152                          (: 'TOKEN' '/=' :)
         and $state[$p:lk] != 4153                          (: 'TOKEN_MGR_DECLS' '/=' :)
         and $state[$p:lk] != 4174                          (: 'false' '/=' :)
         and $state[$p:lk] != 4188                          (: 'null' '/=' :)
         and $state[$p:lk] != 4201                          (: 'this' '/=' :)
         and $state[$p:lk] != 4205                          (: 'true' '/=' :)
         and $state[$p:lk] != 4225                          (: IDENTIFIER ':' :)
         and $state[$p:lk] != 4353                          (: IDENTIFIER ';' :)
         and $state[$p:lk] != 4356                          (: INTEGER_LITERAL ';' :)
         and $state[$p:lk] != 4357                          (: FLOATING_POINT_LITERAL ';' :)
         and $state[$p:lk] != 4358                          (: CHARACTER_LITERAL ';' :)
         and $state[$p:lk] != 4359                          (: STRING_LITERAL ';' :)
         and $state[$p:lk] != 4399                          (: 'EOF' ';' :)
         and $state[$p:lk] != 4400                          (: 'IGNORE_CASE' ';' :)
         and $state[$p:lk] != 4401                          (: 'JAVACODE' ';' :)
         and $state[$p:lk] != 4402                          (: 'LOOKAHEAD' ';' :)
         and $state[$p:lk] != 4403                          (: 'MORE' ';' :)
         and $state[$p:lk] != 4404                          (: 'PARSER_BEGIN' ';' :)
         and $state[$p:lk] != 4405                          (: 'PARSER_END' ';' :)
         and $state[$p:lk] != 4406                          (: 'SKIP' ';' :)
         and $state[$p:lk] != 4407                          (: 'SPECIAL_TOKEN' ';' :)
         and $state[$p:lk] != 4408                          (: 'TOKEN' ';' :)
         and $state[$p:lk] != 4409                          (: 'TOKEN_MGR_DECLS' ';' :)
         and $state[$p:lk] != 4430                          (: 'false' ';' :)
         and $state[$p:lk] != 4444                          (: 'null' ';' :)
         and $state[$p:lk] != 4457                          (: 'this' ';' :)
         and $state[$p:lk] != 4461                          (: 'true' ';' :)
         and $state[$p:lk] != 4737                          (: IDENTIFIER '<<=' :)
         and $state[$p:lk] != 4740                          (: INTEGER_LITERAL '<<=' :)
         and $state[$p:lk] != 4741                          (: FLOATING_POINT_LITERAL '<<=' :)
         and $state[$p:lk] != 4742                          (: CHARACTER_LITERAL '<<=' :)
         and $state[$p:lk] != 4743                          (: STRING_LITERAL '<<=' :)
         and $state[$p:lk] != 4783                          (: 'EOF' '<<=' :)
         and $state[$p:lk] != 4784                          (: 'IGNORE_CASE' '<<=' :)
         and $state[$p:lk] != 4785                          (: 'JAVACODE' '<<=' :)
         and $state[$p:lk] != 4786                          (: 'LOOKAHEAD' '<<=' :)
         and $state[$p:lk] != 4787                          (: 'MORE' '<<=' :)
         and $state[$p:lk] != 4788                          (: 'PARSER_BEGIN' '<<=' :)
         and $state[$p:lk] != 4789                          (: 'PARSER_END' '<<=' :)
         and $state[$p:lk] != 4790                          (: 'SKIP' '<<=' :)
         and $state[$p:lk] != 4791                          (: 'SPECIAL_TOKEN' '<<=' :)
         and $state[$p:lk] != 4792                          (: 'TOKEN' '<<=' :)
         and $state[$p:lk] != 4793                          (: 'TOKEN_MGR_DECLS' '<<=' :)
         and $state[$p:lk] != 4814                          (: 'false' '<<=' :)
         and $state[$p:lk] != 4828                          (: 'null' '<<=' :)
         and $state[$p:lk] != 4841                          (: 'this' '<<=' :)
         and $state[$p:lk] != 4845                          (: 'true' '<<=' :)
         and $state[$p:lk] != 4993                          (: IDENTIFIER '=' :)
         and $state[$p:lk] != 4996                          (: INTEGER_LITERAL '=' :)
         and $state[$p:lk] != 4997                          (: FLOATING_POINT_LITERAL '=' :)
         and $state[$p:lk] != 4998                          (: CHARACTER_LITERAL '=' :)
         and $state[$p:lk] != 4999                          (: STRING_LITERAL '=' :)
         and $state[$p:lk] != 5039                          (: 'EOF' '=' :)
         and $state[$p:lk] != 5040                          (: 'IGNORE_CASE' '=' :)
         and $state[$p:lk] != 5041                          (: 'JAVACODE' '=' :)
         and $state[$p:lk] != 5042                          (: 'LOOKAHEAD' '=' :)
         and $state[$p:lk] != 5043                          (: 'MORE' '=' :)
         and $state[$p:lk] != 5044                          (: 'PARSER_BEGIN' '=' :)
         and $state[$p:lk] != 5045                          (: 'PARSER_END' '=' :)
         and $state[$p:lk] != 5046                          (: 'SKIP' '=' :)
         and $state[$p:lk] != 5047                          (: 'SPECIAL_TOKEN' '=' :)
         and $state[$p:lk] != 5048                          (: 'TOKEN' '=' :)
         and $state[$p:lk] != 5049                          (: 'TOKEN_MGR_DECLS' '=' :)
         and $state[$p:lk] != 5070                          (: 'false' '=' :)
         and $state[$p:lk] != 5084                          (: 'null' '=' :)
         and $state[$p:lk] != 5097                          (: 'this' '=' :)
         and $state[$p:lk] != 5101                          (: 'true' '=' :)
         and $state[$p:lk] != 5505                          (: IDENTIFIER '>>=' :)
         and $state[$p:lk] != 5508                          (: INTEGER_LITERAL '>>=' :)
         and $state[$p:lk] != 5509                          (: FLOATING_POINT_LITERAL '>>=' :)
         and $state[$p:lk] != 5510                          (: CHARACTER_LITERAL '>>=' :)
         and $state[$p:lk] != 5511                          (: STRING_LITERAL '>>=' :)
         and $state[$p:lk] != 5551                          (: 'EOF' '>>=' :)
         and $state[$p:lk] != 5552                          (: 'IGNORE_CASE' '>>=' :)
         and $state[$p:lk] != 5553                          (: 'JAVACODE' '>>=' :)
         and $state[$p:lk] != 5554                          (: 'LOOKAHEAD' '>>=' :)
         and $state[$p:lk] != 5555                          (: 'MORE' '>>=' :)
         and $state[$p:lk] != 5556                          (: 'PARSER_BEGIN' '>>=' :)
         and $state[$p:lk] != 5557                          (: 'PARSER_END' '>>=' :)
         and $state[$p:lk] != 5558                          (: 'SKIP' '>>=' :)
         and $state[$p:lk] != 5559                          (: 'SPECIAL_TOKEN' '>>=' :)
         and $state[$p:lk] != 5560                          (: 'TOKEN' '>>=' :)
         and $state[$p:lk] != 5561                          (: 'TOKEN_MGR_DECLS' '>>=' :)
         and $state[$p:lk] != 5582                          (: 'false' '>>=' :)
         and $state[$p:lk] != 5596                          (: 'null' '>>=' :)
         and $state[$p:lk] != 5609                          (: 'this' '>>=' :)
         and $state[$p:lk] != 5613                          (: 'true' '>>=' :)
         and $state[$p:lk] != 5633                          (: IDENTIFIER '>>>=' :)
         and $state[$p:lk] != 5636                          (: INTEGER_LITERAL '>>>=' :)
         and $state[$p:lk] != 5637                          (: FLOATING_POINT_LITERAL '>>>=' :)
         and $state[$p:lk] != 5638                          (: CHARACTER_LITERAL '>>>=' :)
         and $state[$p:lk] != 5639                          (: STRING_LITERAL '>>>=' :)
         and $state[$p:lk] != 5679                          (: 'EOF' '>>>=' :)
         and $state[$p:lk] != 5680                          (: 'IGNORE_CASE' '>>>=' :)
         and $state[$p:lk] != 5681                          (: 'JAVACODE' '>>>=' :)
         and $state[$p:lk] != 5682                          (: 'LOOKAHEAD' '>>>=' :)
         and $state[$p:lk] != 5683                          (: 'MORE' '>>>=' :)
         and $state[$p:lk] != 5684                          (: 'PARSER_BEGIN' '>>>=' :)
         and $state[$p:lk] != 5685                          (: 'PARSER_END' '>>>=' :)
         and $state[$p:lk] != 5686                          (: 'SKIP' '>>>=' :)
         and $state[$p:lk] != 5687                          (: 'SPECIAL_TOKEN' '>>>=' :)
         and $state[$p:lk] != 5688                          (: 'TOKEN' '>>>=' :)
         and $state[$p:lk] != 5689                          (: 'TOKEN_MGR_DECLS' '>>>=' :)
         and $state[$p:lk] != 5710                          (: 'false' '>>>=' :)
         and $state[$p:lk] != 5724                          (: 'null' '>>>=' :)
         and $state[$p:lk] != 5737                          (: 'this' '>>>=' :)
         and $state[$p:lk] != 5741                          (: 'true' '>>>=' :)
         and $state[$p:lk] != 7809                          (: IDENTIFIER '^=' :)
         and $state[$p:lk] != 7812                          (: INTEGER_LITERAL '^=' :)
         and $state[$p:lk] != 7813                          (: FLOATING_POINT_LITERAL '^=' :)
         and $state[$p:lk] != 7814                          (: CHARACTER_LITERAL '^=' :)
         and $state[$p:lk] != 7815                          (: STRING_LITERAL '^=' :)
         and $state[$p:lk] != 7855                          (: 'EOF' '^=' :)
         and $state[$p:lk] != 7856                          (: 'IGNORE_CASE' '^=' :)
         and $state[$p:lk] != 7857                          (: 'JAVACODE' '^=' :)
         and $state[$p:lk] != 7858                          (: 'LOOKAHEAD' '^=' :)
         and $state[$p:lk] != 7859                          (: 'MORE' '^=' :)
         and $state[$p:lk] != 7860                          (: 'PARSER_BEGIN' '^=' :)
         and $state[$p:lk] != 7861                          (: 'PARSER_END' '^=' :)
         and $state[$p:lk] != 7862                          (: 'SKIP' '^=' :)
         and $state[$p:lk] != 7863                          (: 'SPECIAL_TOKEN' '^=' :)
         and $state[$p:lk] != 7864                          (: 'TOKEN' '^=' :)
         and $state[$p:lk] != 7865                          (: 'TOKEN_MGR_DECLS' '^=' :)
         and $state[$p:lk] != 7886                          (: 'false' '^=' :)
         and $state[$p:lk] != 7900                          (: 'null' '^=' :)
         and $state[$p:lk] != 7913                          (: 'this' '^=' :)
         and $state[$p:lk] != 7917                          (: 'true' '^=' :)
         and $state[$p:lk] != 14849                         (: IDENTIFIER '|=' :)
         and $state[$p:lk] != 14852                         (: INTEGER_LITERAL '|=' :)
         and $state[$p:lk] != 14853                         (: FLOATING_POINT_LITERAL '|=' :)
         and $state[$p:lk] != 14854                         (: CHARACTER_LITERAL '|=' :)
         and $state[$p:lk] != 14855                         (: STRING_LITERAL '|=' :)
         and $state[$p:lk] != 14895                         (: 'EOF' '|=' :)
         and $state[$p:lk] != 14896                         (: 'IGNORE_CASE' '|=' :)
         and $state[$p:lk] != 14897                         (: 'JAVACODE' '|=' :)
         and $state[$p:lk] != 14898                         (: 'LOOKAHEAD' '|=' :)
         and $state[$p:lk] != 14899                         (: 'MORE' '|=' :)
         and $state[$p:lk] != 14900                         (: 'PARSER_BEGIN' '|=' :)
         and $state[$p:lk] != 14901                         (: 'PARSER_END' '|=' :)
         and $state[$p:lk] != 14902                         (: 'SKIP' '|=' :)
         and $state[$p:lk] != 14903                         (: 'SPECIAL_TOKEN' '|=' :)
         and $state[$p:lk] != 14904                         (: 'TOKEN' '|=' :)
         and $state[$p:lk] != 14905                         (: 'TOKEN_MGR_DECLS' '|=' :)
         and $state[$p:lk] != 14926                         (: 'false' '|=' :)
         and $state[$p:lk] != 14940                         (: 'null' '|=' :)
         and $state[$p:lk] != 14953                         (: 'this' '|=' :)
         and $state[$p:lk] != 14957                         (: 'true' '|=' :)
         and $state[$p:lk] != 1674881                       (: IDENTIFIER '.' 'super' :)
         and $state[$p:lk] != 1674884                       (: INTEGER_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674885                       (: FLOATING_POINT_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674886                       (: CHARACTER_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674887                       (: STRING_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674927                       (: 'EOF' '.' 'super' :)
         and $state[$p:lk] != 1674928                       (: 'IGNORE_CASE' '.' 'super' :)
         and $state[$p:lk] != 1674929                       (: 'JAVACODE' '.' 'super' :)
         and $state[$p:lk] != 1674930                       (: 'LOOKAHEAD' '.' 'super' :)
         and $state[$p:lk] != 1674931                       (: 'MORE' '.' 'super' :)
         and $state[$p:lk] != 1674932                       (: 'PARSER_BEGIN' '.' 'super' :)
         and $state[$p:lk] != 1674933                       (: 'PARSER_END' '.' 'super' :)
         and $state[$p:lk] != 1674934                       (: 'SKIP' '.' 'super' :)
         and $state[$p:lk] != 1674935                       (: 'SPECIAL_TOKEN' '.' 'super' :)
         and $state[$p:lk] != 1674936                       (: 'TOKEN' '.' 'super' :)
         and $state[$p:lk] != 1674937                       (: 'TOKEN_MGR_DECLS' '.' 'super' :)
         and $state[$p:lk] != 1674958                       (: 'false' '.' 'super' :)
         and $state[$p:lk] != 1674972                       (: 'null' '.' 'super' :)
         and $state[$p:lk] != 1674985                       (: 'this' '.' 'super' :)
         and $state[$p:lk] != 1674989) then                 (: 'true' '.' 'super' :)
      let $state := p:memoized($state, 9)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ExplicitConstructorInvocation($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 2406                           (: 'super' '(' :)
          or $state[$p:lk] = 1674881                        (: IDENTIFIER '.' 'super' :)
          or $state[$p:lk] = 1674884                        (: INTEGER_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674885                        (: FLOATING_POINT_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674886                        (: CHARACTER_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674887                        (: STRING_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674927                        (: 'EOF' '.' 'super' :)
          or $state[$p:lk] = 1674928                        (: 'IGNORE_CASE' '.' 'super' :)
          or $state[$p:lk] = 1674929                        (: 'JAVACODE' '.' 'super' :)
          or $state[$p:lk] = 1674930                        (: 'LOOKAHEAD' '.' 'super' :)
          or $state[$p:lk] = 1674931                        (: 'MORE' '.' 'super' :)
          or $state[$p:lk] = 1674932                        (: 'PARSER_BEGIN' '.' 'super' :)
          or $state[$p:lk] = 1674933                        (: 'PARSER_END' '.' 'super' :)
          or $state[$p:lk] = 1674934                        (: 'SKIP' '.' 'super' :)
          or $state[$p:lk] = 1674935                        (: 'SPECIAL_TOKEN' '.' 'super' :)
          or $state[$p:lk] = 1674936                        (: 'TOKEN' '.' 'super' :)
          or $state[$p:lk] = 1674937                        (: 'TOKEN_MGR_DECLS' '.' 'super' :)
          or $state[$p:lk] = 1674958                        (: 'false' '.' 'super' :)
          or $state[$p:lk] = 1674972                        (: 'null' '.' 'super' :)
          or $state[$p:lk] = 1674985                        (: 'this' '.' 'super' :)
          or $state[$p:lk] = 1674989) then                  (: 'true' '.' 'super' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExplicitConstructorInvocation($input, $state)
      return $state
    else
      $state
  let $state := p:parse-ConstructorDeclaration-1($input, $state)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructorDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing ConstructorDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ConstructorDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FormalParameters($input, $state)
  let $state := p:lookahead1W(52, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'throws' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'throws' :)
      let $state := p:consumeT(107, $input, $state)         (: 'throws' :)
      let $state := p:lookahead1W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NameList($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(114, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(168, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(117, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | '--' | '-=' | '.' | '/=' | ':' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 2305) then                     (: IDENTIFIER '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 3713) then                (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(107, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 18) then                      (: '(' :)
      let $state := p:lookahead2W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:lk] eq 11666) then                    (: '(' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] = (2962,                     (: '(' '++' :)
                                  3474)) then               (: '(' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (13074,                    (: '(' 'super' :)
                                  14226)) then              (: '(' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (1298,                     (: '(' '!' :)
                                  2322,                     (: '(' '(' :)
                                  2834,                     (: '(' '+' :)
                                  3346,                     (: '(' '-' :)
                                  15250)) then              (: '(' '~' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (8210,                     (: '(' 'boolean' :)
                                  8466,                     (: '(' 'byte' :)
                                  8850,                     (: '(' 'char' :)
                                  9490,                     (: '(' 'double' :)
                                  10386,                    (: '(' 'float' :)
                                  11154,                    (: '(' 'int' :)
                                  11410,                    (: '(' 'long' :)
                                  12690)) then              (: '(' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (146,                      (: '(' IDENTIFIER :)
                                  530,                      (: '(' INTEGER_LITERAL :)
                                  658,                      (: '(' FLOATING_POINT_LITERAL :)
                                  786,                      (: '(' CHARACTER_LITERAL :)
                                  914,                      (: '(' STRING_LITERAL :)
                                  6034,                     (: '(' 'EOF' :)
                                  6162,                     (: '(' 'IGNORE_CASE' :)
                                  6290,                     (: '(' 'JAVACODE' :)
                                  6418,                     (: '(' 'LOOKAHEAD' :)
                                  6546,                     (: '(' 'MORE' :)
                                  6674,                     (: '(' 'PARSER_BEGIN' :)
                                  6802,                     (: '(' 'PARSER_END' :)
                                  6930,                     (: '(' 'SKIP' :)
                                  7058,                     (: '(' 'SPECIAL_TOKEN' :)
                                  7186,                     (: '(' 'TOKEN' :)
                                  7314,                     (: '(' 'TOKEN_MGR_DECLS' :)
                                  10002,                    (: '(' 'false' :)
                                  11794,                    (: '(' 'null' :)
                                  13458,                    (: '(' 'this' :)
                                  13970)) then              (: '(' 'true' :)
          let $state := p:lookahead3W(136, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                               '>=' | '>>=' | '>>>=' | '?' | '[' | '^' | '^=' |
                                                               'instanceof' | '|' | '|=' | '||' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 91) then                      (: 'new' :)
      let $state := p:lookahead2W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:lk] eq 219) then                      (: 'new' IDENTIFIER :)
          let $state := p:lookahead3W(68, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '<' | '[' :)
          return $state
        else if ($state[$p:lk] = (8283,                     (: 'new' 'boolean' :)
                                  8539,                     (: 'new' 'byte' :)
                                  8923,                     (: 'new' 'char' :)
                                  9563,                     (: 'new' 'double' :)
                                  10459,                    (: 'new' 'float' :)
                                  11227,                    (: 'new' 'int' :)
                                  11483,                    (: 'new' 'long' :)
                                  12763)) then              (: 'new' 'short' :)
          let $state := p:lookahead3W(15, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 102) then                     (: 'super' :)
      let $state := p:lookahead2W(34, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' :)
      let $state :=
        if ($state[$p:lk] eq 3814) then                     (: 'super' '.' :)
          let $state := p:lookahead3W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 111) then                     (: 'void' :)
      let $state := p:lookahead2W(6, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
      let $state :=
        if ($state[$p:lk] eq 3823) then                     (: 'void' '.' :)
          let $state := p:lookahead3W(17, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (4,                            (: INTEGER_LITERAL :)
                              5,                            (: FLOATING_POINT_LITERAL :)
                              6,                            (: CHARACTER_LITERAL :)
                              7,                            (: STRING_LITERAL :)
                              78,                           (: 'false' :)
                              92,                           (: 'null' :)
                              105,                          (: 'this' :)
                              109)) then                    (: 'true' :)
      let $state := p:lookahead2W(109, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ';' | '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' |
                                                               '|=' :)
      let $state :=
        if ($state[$p:lk] = (2308,                          (: INTEGER_LITERAL '(' :)
                             2309,                          (: FLOATING_POINT_LITERAL '(' :)
                             2310,                          (: CHARACTER_LITERAL '(' :)
                             2311,                          (: STRING_LITERAL '(' :)
                             2382,                          (: 'false' '(' :)
                             2396,                          (: 'null' '(' :)
                             2409,                          (: 'this' '(' :)
                             2413)) then                    (: 'true' '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (3716,                     (: INTEGER_LITERAL '.' :)
                                  3717,                     (: FLOATING_POINT_LITERAL '.' :)
                                  3718,                     (: CHARACTER_LITERAL '.' :)
                                  3719,                     (: STRING_LITERAL '.' :)
                                  3790,                     (: 'false' '.' :)
                                  3804,                     (: 'null' '.' :)
                                  3817,                     (: 'this' '.' :)
                                  3821)) then               (: 'true' '.' :)
          let $state := p:lookahead3W(78, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] = (7428,                     (: INTEGER_LITERAL '[' :)
                                  7429,                     (: FLOATING_POINT_LITERAL '[' :)
                                  7430,                     (: CHARACTER_LITERAL '[' :)
                                  7431,                     (: STRING_LITERAL '[' :)
                                  7502,                     (: 'false' '[' :)
                                  7516,                     (: 'null' '[' :)
                                  7529,                     (: 'this' '[' :)
                                  7533)) then               (: 'true' '[' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (3776,                          (: 'boolean' '.' :)
                             3778,                          (: 'byte' '.' :)
                             3781,                          (: 'char' '.' :)
                             3786,                          (: 'double' '.' :)
                             3793,                          (: 'float' '.' :)
                             3799,                          (: 'int' '.' :)
                             3801,                          (: 'long' '.' :)
                             3811)) then                    (: 'short' '.' :)
          let $state := p:lookahead3W(17, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
          return $state
        else if ($state[$p:lk] = (7488,                     (: 'boolean' '[' :)
                                  7490,                     (: 'byte' '[' :)
                                  7493,                     (: 'char' '[' :)
                                  7498,                     (: 'double' '[' :)
                                  7505,                     (: 'float' '[' :)
                                  7511,                     (: 'int' '[' :)
                                  7513,                     (: 'long' '[' :)
                                  7523)) then               (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (47,                           (: 'EOF' :)
                              48,                           (: 'IGNORE_CASE' :)
                              49,                           (: 'JAVACODE' :)
                              50,                           (: 'LOOKAHEAD' :)
                              51,                           (: 'MORE' :)
                              52,                           (: 'PARSER_BEGIN' :)
                              53,                           (: 'PARSER_END' :)
                              54,                           (: 'SKIP' :)
                              55,                           (: 'SPECIAL_TOKEN' :)
                              56,                           (: 'TOKEN' :)
                              57)) then                     (: 'TOKEN_MGR_DECLS' :)
      let $state := p:lookahead2W(109, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ';' | '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' |
                                                               '|=' :)
      let $state :=
        if ($state[$p:lk] = (2351,                          (: 'EOF' '(' :)
                             2352,                          (: 'IGNORE_CASE' '(' :)
                             2353,                          (: 'JAVACODE' '(' :)
                             2354,                          (: 'LOOKAHEAD' '(' :)
                             2355,                          (: 'MORE' '(' :)
                             2356,                          (: 'PARSER_BEGIN' '(' :)
                             2357,                          (: 'PARSER_END' '(' :)
                             2358,                          (: 'SKIP' '(' :)
                             2359,                          (: 'SPECIAL_TOKEN' '(' :)
                             2360,                          (: 'TOKEN' '(' :)
                             2361)) then                    (: 'TOKEN_MGR_DECLS' '(' :)
          let $state := p:lookahead3W(142, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (3759,                     (: 'EOF' '.' :)
                                  3760,                     (: 'IGNORE_CASE' '.' :)
                                  3761,                     (: 'JAVACODE' '.' :)
                                  3762,                     (: 'LOOKAHEAD' '.' :)
                                  3763,                     (: 'MORE' '.' :)
                                  3764,                     (: 'PARSER_BEGIN' '.' :)
                                  3765,                     (: 'PARSER_END' '.' :)
                                  3766,                     (: 'SKIP' '.' :)
                                  3767,                     (: 'SPECIAL_TOKEN' '.' :)
                                  3768,                     (: 'TOKEN' '.' :)
                                  3769)) then               (: 'TOKEN_MGR_DECLS' '.' :)
          let $state := p:lookahead3W(104, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] = (7471,                     (: 'EOF' '[' :)
                                  7472,                     (: 'IGNORE_CASE' '[' :)
                                  7473,                     (: 'JAVACODE' '[' :)
                                  7474,                     (: 'LOOKAHEAD' '[' :)
                                  7475,                     (: 'MORE' '[' :)
                                  7476,                     (: 'PARSER_BEGIN' '[' :)
                                  7477,                     (: 'PARSER_END' '[' :)
                                  7478,                     (: 'SKIP' '[' :)
                                  7479,                     (: 'SPECIAL_TOKEN' '[' :)
                                  7480,                     (: 'TOKEN' '[' :)
                                  7481)) then               (: 'TOKEN_MGR_DECLS' '[' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 23                            (: '++' :)
         and $state[$p:lk] != 27                            (: '--' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 46                            (: '@' :)
         and $state[$p:lk] != 62                            (: 'abstract' :)
         and $state[$p:lk] != 63                            (: 'assert' :)
         and $state[$p:lk] != 65                            (: 'break' :)
         and $state[$p:lk] != 70                            (: 'class' :)
         and $state[$p:lk] != 71                            (: 'continue' :)
         and $state[$p:lk] != 73                            (: 'do' :)
         and $state[$p:lk] != 79                            (: 'final' :)
         and $state[$p:lk] != 82                            (: 'for' :)
         and $state[$p:lk] != 83                            (: 'if' :)
         and $state[$p:lk] != 88                            (: 'interface' :)
         and $state[$p:lk] != 90                            (: 'native' :)
         and $state[$p:lk] != 95                            (: 'private' :)
         and $state[$p:lk] != 96                            (: 'protected' :)
         and $state[$p:lk] != 97                            (: 'public' :)
         and $state[$p:lk] != 98                            (: 'return' :)
         and $state[$p:lk] != 100                           (: 'static' :)
         and $state[$p:lk] != 101                           (: 'strictfp' :)
         and $state[$p:lk] != 103                           (: 'switch' :)
         and $state[$p:lk] != 104                           (: 'synchronized' :)
         and $state[$p:lk] != 106                           (: 'throw' :)
         and $state[$p:lk] != 108                           (: 'transient' :)
         and $state[$p:lk] != 110                           (: 'try' :)
         and $state[$p:lk] != 112                           (: 'volatile' :)
         and $state[$p:lk] != 113                           (: 'while' :)
         and $state[$p:lk] != 114                           (: '{' :)
         and $state[$p:lk] != 118                           (: '}' :)
         and $state[$p:lk] != 129                           (: IDENTIFIER IDENTIFIER :)
         and $state[$p:lk] != 192                           (: 'boolean' IDENTIFIER :)
         and $state[$p:lk] != 194                           (: 'byte' IDENTIFIER :)
         and $state[$p:lk] != 197                           (: 'char' IDENTIFIER :)
         and $state[$p:lk] != 202                           (: 'double' IDENTIFIER :)
         and $state[$p:lk] != 209                           (: 'float' IDENTIFIER :)
         and $state[$p:lk] != 215                           (: 'int' IDENTIFIER :)
         and $state[$p:lk] != 217                           (: 'long' IDENTIFIER :)
         and $state[$p:lk] != 227                           (: 'short' IDENTIFIER :)
         and $state[$p:lk] != 1793                          (: IDENTIFIER '%=' :)
         and $state[$p:lk] != 1796                          (: INTEGER_LITERAL '%=' :)
         and $state[$p:lk] != 1797                          (: FLOATING_POINT_LITERAL '%=' :)
         and $state[$p:lk] != 1798                          (: CHARACTER_LITERAL '%=' :)
         and $state[$p:lk] != 1799                          (: STRING_LITERAL '%=' :)
         and $state[$p:lk] != 1839                          (: 'EOF' '%=' :)
         and $state[$p:lk] != 1840                          (: 'IGNORE_CASE' '%=' :)
         and $state[$p:lk] != 1841                          (: 'JAVACODE' '%=' :)
         and $state[$p:lk] != 1842                          (: 'LOOKAHEAD' '%=' :)
         and $state[$p:lk] != 1843                          (: 'MORE' '%=' :)
         and $state[$p:lk] != 1844                          (: 'PARSER_BEGIN' '%=' :)
         and $state[$p:lk] != 1845                          (: 'PARSER_END' '%=' :)
         and $state[$p:lk] != 1846                          (: 'SKIP' '%=' :)
         and $state[$p:lk] != 1847                          (: 'SPECIAL_TOKEN' '%=' :)
         and $state[$p:lk] != 1848                          (: 'TOKEN' '%=' :)
         and $state[$p:lk] != 1849                          (: 'TOKEN_MGR_DECLS' '%=' :)
         and $state[$p:lk] != 1870                          (: 'false' '%=' :)
         and $state[$p:lk] != 1884                          (: 'null' '%=' :)
         and $state[$p:lk] != 1897                          (: 'this' '%=' :)
         and $state[$p:lk] != 1901                          (: 'true' '%=' :)
         and $state[$p:lk] != 2177                          (: IDENTIFIER '&=' :)
         and $state[$p:lk] != 2180                          (: INTEGER_LITERAL '&=' :)
         and $state[$p:lk] != 2181                          (: FLOATING_POINT_LITERAL '&=' :)
         and $state[$p:lk] != 2182                          (: CHARACTER_LITERAL '&=' :)
         and $state[$p:lk] != 2183                          (: STRING_LITERAL '&=' :)
         and $state[$p:lk] != 2223                          (: 'EOF' '&=' :)
         and $state[$p:lk] != 2224                          (: 'IGNORE_CASE' '&=' :)
         and $state[$p:lk] != 2225                          (: 'JAVACODE' '&=' :)
         and $state[$p:lk] != 2226                          (: 'LOOKAHEAD' '&=' :)
         and $state[$p:lk] != 2227                          (: 'MORE' '&=' :)
         and $state[$p:lk] != 2228                          (: 'PARSER_BEGIN' '&=' :)
         and $state[$p:lk] != 2229                          (: 'PARSER_END' '&=' :)
         and $state[$p:lk] != 2230                          (: 'SKIP' '&=' :)
         and $state[$p:lk] != 2231                          (: 'SPECIAL_TOKEN' '&=' :)
         and $state[$p:lk] != 2232                          (: 'TOKEN' '&=' :)
         and $state[$p:lk] != 2233                          (: 'TOKEN_MGR_DECLS' '&=' :)
         and $state[$p:lk] != 2254                          (: 'false' '&=' :)
         and $state[$p:lk] != 2268                          (: 'null' '&=' :)
         and $state[$p:lk] != 2281                          (: 'this' '&=' :)
         and $state[$p:lk] != 2285                          (: 'true' '&=' :)
         and $state[$p:lk] != 2406                          (: 'super' '(' :)
         and $state[$p:lk] != 2689                          (: IDENTIFIER '*=' :)
         and $state[$p:lk] != 2692                          (: INTEGER_LITERAL '*=' :)
         and $state[$p:lk] != 2693                          (: FLOATING_POINT_LITERAL '*=' :)
         and $state[$p:lk] != 2694                          (: CHARACTER_LITERAL '*=' :)
         and $state[$p:lk] != 2695                          (: STRING_LITERAL '*=' :)
         and $state[$p:lk] != 2735                          (: 'EOF' '*=' :)
         and $state[$p:lk] != 2736                          (: 'IGNORE_CASE' '*=' :)
         and $state[$p:lk] != 2737                          (: 'JAVACODE' '*=' :)
         and $state[$p:lk] != 2738                          (: 'LOOKAHEAD' '*=' :)
         and $state[$p:lk] != 2739                          (: 'MORE' '*=' :)
         and $state[$p:lk] != 2740                          (: 'PARSER_BEGIN' '*=' :)
         and $state[$p:lk] != 2741                          (: 'PARSER_END' '*=' :)
         and $state[$p:lk] != 2742                          (: 'SKIP' '*=' :)
         and $state[$p:lk] != 2743                          (: 'SPECIAL_TOKEN' '*=' :)
         and $state[$p:lk] != 2744                          (: 'TOKEN' '*=' :)
         and $state[$p:lk] != 2745                          (: 'TOKEN_MGR_DECLS' '*=' :)
         and $state[$p:lk] != 2766                          (: 'false' '*=' :)
         and $state[$p:lk] != 2780                          (: 'null' '*=' :)
         and $state[$p:lk] != 2793                          (: 'this' '*=' :)
         and $state[$p:lk] != 2797                          (: 'true' '*=' :)
         and $state[$p:lk] != 2945                          (: IDENTIFIER '++' :)
         and $state[$p:lk] != 2948                          (: INTEGER_LITERAL '++' :)
         and $state[$p:lk] != 2949                          (: FLOATING_POINT_LITERAL '++' :)
         and $state[$p:lk] != 2950                          (: CHARACTER_LITERAL '++' :)
         and $state[$p:lk] != 2951                          (: STRING_LITERAL '++' :)
         and $state[$p:lk] != 2991                          (: 'EOF' '++' :)
         and $state[$p:lk] != 2992                          (: 'IGNORE_CASE' '++' :)
         and $state[$p:lk] != 2993                          (: 'JAVACODE' '++' :)
         and $state[$p:lk] != 2994                          (: 'LOOKAHEAD' '++' :)
         and $state[$p:lk] != 2995                          (: 'MORE' '++' :)
         and $state[$p:lk] != 2996                          (: 'PARSER_BEGIN' '++' :)
         and $state[$p:lk] != 2997                          (: 'PARSER_END' '++' :)
         and $state[$p:lk] != 2998                          (: 'SKIP' '++' :)
         and $state[$p:lk] != 2999                          (: 'SPECIAL_TOKEN' '++' :)
         and $state[$p:lk] != 3000                          (: 'TOKEN' '++' :)
         and $state[$p:lk] != 3001                          (: 'TOKEN_MGR_DECLS' '++' :)
         and $state[$p:lk] != 3022                          (: 'false' '++' :)
         and $state[$p:lk] != 3036                          (: 'null' '++' :)
         and $state[$p:lk] != 3049                          (: 'this' '++' :)
         and $state[$p:lk] != 3053                          (: 'true' '++' :)
         and $state[$p:lk] != 3073                          (: IDENTIFIER '+=' :)
         and $state[$p:lk] != 3076                          (: INTEGER_LITERAL '+=' :)
         and $state[$p:lk] != 3077                          (: FLOATING_POINT_LITERAL '+=' :)
         and $state[$p:lk] != 3078                          (: CHARACTER_LITERAL '+=' :)
         and $state[$p:lk] != 3079                          (: STRING_LITERAL '+=' :)
         and $state[$p:lk] != 3119                          (: 'EOF' '+=' :)
         and $state[$p:lk] != 3120                          (: 'IGNORE_CASE' '+=' :)
         and $state[$p:lk] != 3121                          (: 'JAVACODE' '+=' :)
         and $state[$p:lk] != 3122                          (: 'LOOKAHEAD' '+=' :)
         and $state[$p:lk] != 3123                          (: 'MORE' '+=' :)
         and $state[$p:lk] != 3124                          (: 'PARSER_BEGIN' '+=' :)
         and $state[$p:lk] != 3125                          (: 'PARSER_END' '+=' :)
         and $state[$p:lk] != 3126                          (: 'SKIP' '+=' :)
         and $state[$p:lk] != 3127                          (: 'SPECIAL_TOKEN' '+=' :)
         and $state[$p:lk] != 3128                          (: 'TOKEN' '+=' :)
         and $state[$p:lk] != 3129                          (: 'TOKEN_MGR_DECLS' '+=' :)
         and $state[$p:lk] != 3150                          (: 'false' '+=' :)
         and $state[$p:lk] != 3164                          (: 'null' '+=' :)
         and $state[$p:lk] != 3177                          (: 'this' '+=' :)
         and $state[$p:lk] != 3181                          (: 'true' '+=' :)
         and $state[$p:lk] != 3457                          (: IDENTIFIER '--' :)
         and $state[$p:lk] != 3460                          (: INTEGER_LITERAL '--' :)
         and $state[$p:lk] != 3461                          (: FLOATING_POINT_LITERAL '--' :)
         and $state[$p:lk] != 3462                          (: CHARACTER_LITERAL '--' :)
         and $state[$p:lk] != 3463                          (: STRING_LITERAL '--' :)
         and $state[$p:lk] != 3503                          (: 'EOF' '--' :)
         and $state[$p:lk] != 3504                          (: 'IGNORE_CASE' '--' :)
         and $state[$p:lk] != 3505                          (: 'JAVACODE' '--' :)
         and $state[$p:lk] != 3506                          (: 'LOOKAHEAD' '--' :)
         and $state[$p:lk] != 3507                          (: 'MORE' '--' :)
         and $state[$p:lk] != 3508                          (: 'PARSER_BEGIN' '--' :)
         and $state[$p:lk] != 3509                          (: 'PARSER_END' '--' :)
         and $state[$p:lk] != 3510                          (: 'SKIP' '--' :)
         and $state[$p:lk] != 3511                          (: 'SPECIAL_TOKEN' '--' :)
         and $state[$p:lk] != 3512                          (: 'TOKEN' '--' :)
         and $state[$p:lk] != 3513                          (: 'TOKEN_MGR_DECLS' '--' :)
         and $state[$p:lk] != 3534                          (: 'false' '--' :)
         and $state[$p:lk] != 3548                          (: 'null' '--' :)
         and $state[$p:lk] != 3561                          (: 'this' '--' :)
         and $state[$p:lk] != 3565                          (: 'true' '--' :)
         and $state[$p:lk] != 3585                          (: IDENTIFIER '-=' :)
         and $state[$p:lk] != 3588                          (: INTEGER_LITERAL '-=' :)
         and $state[$p:lk] != 3589                          (: FLOATING_POINT_LITERAL '-=' :)
         and $state[$p:lk] != 3590                          (: CHARACTER_LITERAL '-=' :)
         and $state[$p:lk] != 3591                          (: STRING_LITERAL '-=' :)
         and $state[$p:lk] != 3631                          (: 'EOF' '-=' :)
         and $state[$p:lk] != 3632                          (: 'IGNORE_CASE' '-=' :)
         and $state[$p:lk] != 3633                          (: 'JAVACODE' '-=' :)
         and $state[$p:lk] != 3634                          (: 'LOOKAHEAD' '-=' :)
         and $state[$p:lk] != 3635                          (: 'MORE' '-=' :)
         and $state[$p:lk] != 3636                          (: 'PARSER_BEGIN' '-=' :)
         and $state[$p:lk] != 3637                          (: 'PARSER_END' '-=' :)
         and $state[$p:lk] != 3638                          (: 'SKIP' '-=' :)
         and $state[$p:lk] != 3639                          (: 'SPECIAL_TOKEN' '-=' :)
         and $state[$p:lk] != 3640                          (: 'TOKEN' '-=' :)
         and $state[$p:lk] != 3641                          (: 'TOKEN_MGR_DECLS' '-=' :)
         and $state[$p:lk] != 3662                          (: 'false' '-=' :)
         and $state[$p:lk] != 3676                          (: 'null' '-=' :)
         and $state[$p:lk] != 3689                          (: 'this' '-=' :)
         and $state[$p:lk] != 3693                          (: 'true' '-=' :)
         and $state[$p:lk] != 4097                          (: IDENTIFIER '/=' :)
         and $state[$p:lk] != 4100                          (: INTEGER_LITERAL '/=' :)
         and $state[$p:lk] != 4101                          (: FLOATING_POINT_LITERAL '/=' :)
         and $state[$p:lk] != 4102                          (: CHARACTER_LITERAL '/=' :)
         and $state[$p:lk] != 4103                          (: STRING_LITERAL '/=' :)
         and $state[$p:lk] != 4143                          (: 'EOF' '/=' :)
         and $state[$p:lk] != 4144                          (: 'IGNORE_CASE' '/=' :)
         and $state[$p:lk] != 4145                          (: 'JAVACODE' '/=' :)
         and $state[$p:lk] != 4146                          (: 'LOOKAHEAD' '/=' :)
         and $state[$p:lk] != 4147                          (: 'MORE' '/=' :)
         and $state[$p:lk] != 4148                          (: 'PARSER_BEGIN' '/=' :)
         and $state[$p:lk] != 4149                          (: 'PARSER_END' '/=' :)
         and $state[$p:lk] != 4150                          (: 'SKIP' '/=' :)
         and $state[$p:lk] != 4151                          (: 'SPECIAL_TOKEN' '/=' :)
         and $state[$p:lk] != 4152                          (: 'TOKEN' '/=' :)
         and $state[$p:lk] != 4153                          (: 'TOKEN_MGR_DECLS' '/=' :)
         and $state[$p:lk] != 4174                          (: 'false' '/=' :)
         and $state[$p:lk] != 4188                          (: 'null' '/=' :)
         and $state[$p:lk] != 4201                          (: 'this' '/=' :)
         and $state[$p:lk] != 4205                          (: 'true' '/=' :)
         and $state[$p:lk] != 4225                          (: IDENTIFIER ':' :)
         and $state[$p:lk] != 4353                          (: IDENTIFIER ';' :)
         and $state[$p:lk] != 4356                          (: INTEGER_LITERAL ';' :)
         and $state[$p:lk] != 4357                          (: FLOATING_POINT_LITERAL ';' :)
         and $state[$p:lk] != 4358                          (: CHARACTER_LITERAL ';' :)
         and $state[$p:lk] != 4359                          (: STRING_LITERAL ';' :)
         and $state[$p:lk] != 4399                          (: 'EOF' ';' :)
         and $state[$p:lk] != 4400                          (: 'IGNORE_CASE' ';' :)
         and $state[$p:lk] != 4401                          (: 'JAVACODE' ';' :)
         and $state[$p:lk] != 4402                          (: 'LOOKAHEAD' ';' :)
         and $state[$p:lk] != 4403                          (: 'MORE' ';' :)
         and $state[$p:lk] != 4404                          (: 'PARSER_BEGIN' ';' :)
         and $state[$p:lk] != 4405                          (: 'PARSER_END' ';' :)
         and $state[$p:lk] != 4406                          (: 'SKIP' ';' :)
         and $state[$p:lk] != 4407                          (: 'SPECIAL_TOKEN' ';' :)
         and $state[$p:lk] != 4408                          (: 'TOKEN' ';' :)
         and $state[$p:lk] != 4409                          (: 'TOKEN_MGR_DECLS' ';' :)
         and $state[$p:lk] != 4430                          (: 'false' ';' :)
         and $state[$p:lk] != 4444                          (: 'null' ';' :)
         and $state[$p:lk] != 4457                          (: 'this' ';' :)
         and $state[$p:lk] != 4461                          (: 'true' ';' :)
         and $state[$p:lk] != 4737                          (: IDENTIFIER '<<=' :)
         and $state[$p:lk] != 4740                          (: INTEGER_LITERAL '<<=' :)
         and $state[$p:lk] != 4741                          (: FLOATING_POINT_LITERAL '<<=' :)
         and $state[$p:lk] != 4742                          (: CHARACTER_LITERAL '<<=' :)
         and $state[$p:lk] != 4743                          (: STRING_LITERAL '<<=' :)
         and $state[$p:lk] != 4783                          (: 'EOF' '<<=' :)
         and $state[$p:lk] != 4784                          (: 'IGNORE_CASE' '<<=' :)
         and $state[$p:lk] != 4785                          (: 'JAVACODE' '<<=' :)
         and $state[$p:lk] != 4786                          (: 'LOOKAHEAD' '<<=' :)
         and $state[$p:lk] != 4787                          (: 'MORE' '<<=' :)
         and $state[$p:lk] != 4788                          (: 'PARSER_BEGIN' '<<=' :)
         and $state[$p:lk] != 4789                          (: 'PARSER_END' '<<=' :)
         and $state[$p:lk] != 4790                          (: 'SKIP' '<<=' :)
         and $state[$p:lk] != 4791                          (: 'SPECIAL_TOKEN' '<<=' :)
         and $state[$p:lk] != 4792                          (: 'TOKEN' '<<=' :)
         and $state[$p:lk] != 4793                          (: 'TOKEN_MGR_DECLS' '<<=' :)
         and $state[$p:lk] != 4814                          (: 'false' '<<=' :)
         and $state[$p:lk] != 4828                          (: 'null' '<<=' :)
         and $state[$p:lk] != 4841                          (: 'this' '<<=' :)
         and $state[$p:lk] != 4845                          (: 'true' '<<=' :)
         and $state[$p:lk] != 4993                          (: IDENTIFIER '=' :)
         and $state[$p:lk] != 4996                          (: INTEGER_LITERAL '=' :)
         and $state[$p:lk] != 4997                          (: FLOATING_POINT_LITERAL '=' :)
         and $state[$p:lk] != 4998                          (: CHARACTER_LITERAL '=' :)
         and $state[$p:lk] != 4999                          (: STRING_LITERAL '=' :)
         and $state[$p:lk] != 5039                          (: 'EOF' '=' :)
         and $state[$p:lk] != 5040                          (: 'IGNORE_CASE' '=' :)
         and $state[$p:lk] != 5041                          (: 'JAVACODE' '=' :)
         and $state[$p:lk] != 5042                          (: 'LOOKAHEAD' '=' :)
         and $state[$p:lk] != 5043                          (: 'MORE' '=' :)
         and $state[$p:lk] != 5044                          (: 'PARSER_BEGIN' '=' :)
         and $state[$p:lk] != 5045                          (: 'PARSER_END' '=' :)
         and $state[$p:lk] != 5046                          (: 'SKIP' '=' :)
         and $state[$p:lk] != 5047                          (: 'SPECIAL_TOKEN' '=' :)
         and $state[$p:lk] != 5048                          (: 'TOKEN' '=' :)
         and $state[$p:lk] != 5049                          (: 'TOKEN_MGR_DECLS' '=' :)
         and $state[$p:lk] != 5070                          (: 'false' '=' :)
         and $state[$p:lk] != 5084                          (: 'null' '=' :)
         and $state[$p:lk] != 5097                          (: 'this' '=' :)
         and $state[$p:lk] != 5101                          (: 'true' '=' :)
         and $state[$p:lk] != 5505                          (: IDENTIFIER '>>=' :)
         and $state[$p:lk] != 5508                          (: INTEGER_LITERAL '>>=' :)
         and $state[$p:lk] != 5509                          (: FLOATING_POINT_LITERAL '>>=' :)
         and $state[$p:lk] != 5510                          (: CHARACTER_LITERAL '>>=' :)
         and $state[$p:lk] != 5511                          (: STRING_LITERAL '>>=' :)
         and $state[$p:lk] != 5551                          (: 'EOF' '>>=' :)
         and $state[$p:lk] != 5552                          (: 'IGNORE_CASE' '>>=' :)
         and $state[$p:lk] != 5553                          (: 'JAVACODE' '>>=' :)
         and $state[$p:lk] != 5554                          (: 'LOOKAHEAD' '>>=' :)
         and $state[$p:lk] != 5555                          (: 'MORE' '>>=' :)
         and $state[$p:lk] != 5556                          (: 'PARSER_BEGIN' '>>=' :)
         and $state[$p:lk] != 5557                          (: 'PARSER_END' '>>=' :)
         and $state[$p:lk] != 5558                          (: 'SKIP' '>>=' :)
         and $state[$p:lk] != 5559                          (: 'SPECIAL_TOKEN' '>>=' :)
         and $state[$p:lk] != 5560                          (: 'TOKEN' '>>=' :)
         and $state[$p:lk] != 5561                          (: 'TOKEN_MGR_DECLS' '>>=' :)
         and $state[$p:lk] != 5582                          (: 'false' '>>=' :)
         and $state[$p:lk] != 5596                          (: 'null' '>>=' :)
         and $state[$p:lk] != 5609                          (: 'this' '>>=' :)
         and $state[$p:lk] != 5613                          (: 'true' '>>=' :)
         and $state[$p:lk] != 5633                          (: IDENTIFIER '>>>=' :)
         and $state[$p:lk] != 5636                          (: INTEGER_LITERAL '>>>=' :)
         and $state[$p:lk] != 5637                          (: FLOATING_POINT_LITERAL '>>>=' :)
         and $state[$p:lk] != 5638                          (: CHARACTER_LITERAL '>>>=' :)
         and $state[$p:lk] != 5639                          (: STRING_LITERAL '>>>=' :)
         and $state[$p:lk] != 5679                          (: 'EOF' '>>>=' :)
         and $state[$p:lk] != 5680                          (: 'IGNORE_CASE' '>>>=' :)
         and $state[$p:lk] != 5681                          (: 'JAVACODE' '>>>=' :)
         and $state[$p:lk] != 5682                          (: 'LOOKAHEAD' '>>>=' :)
         and $state[$p:lk] != 5683                          (: 'MORE' '>>>=' :)
         and $state[$p:lk] != 5684                          (: 'PARSER_BEGIN' '>>>=' :)
         and $state[$p:lk] != 5685                          (: 'PARSER_END' '>>>=' :)
         and $state[$p:lk] != 5686                          (: 'SKIP' '>>>=' :)
         and $state[$p:lk] != 5687                          (: 'SPECIAL_TOKEN' '>>>=' :)
         and $state[$p:lk] != 5688                          (: 'TOKEN' '>>>=' :)
         and $state[$p:lk] != 5689                          (: 'TOKEN_MGR_DECLS' '>>>=' :)
         and $state[$p:lk] != 5710                          (: 'false' '>>>=' :)
         and $state[$p:lk] != 5724                          (: 'null' '>>>=' :)
         and $state[$p:lk] != 5737                          (: 'this' '>>>=' :)
         and $state[$p:lk] != 5741                          (: 'true' '>>>=' :)
         and $state[$p:lk] != 7809                          (: IDENTIFIER '^=' :)
         and $state[$p:lk] != 7812                          (: INTEGER_LITERAL '^=' :)
         and $state[$p:lk] != 7813                          (: FLOATING_POINT_LITERAL '^=' :)
         and $state[$p:lk] != 7814                          (: CHARACTER_LITERAL '^=' :)
         and $state[$p:lk] != 7815                          (: STRING_LITERAL '^=' :)
         and $state[$p:lk] != 7855                          (: 'EOF' '^=' :)
         and $state[$p:lk] != 7856                          (: 'IGNORE_CASE' '^=' :)
         and $state[$p:lk] != 7857                          (: 'JAVACODE' '^=' :)
         and $state[$p:lk] != 7858                          (: 'LOOKAHEAD' '^=' :)
         and $state[$p:lk] != 7859                          (: 'MORE' '^=' :)
         and $state[$p:lk] != 7860                          (: 'PARSER_BEGIN' '^=' :)
         and $state[$p:lk] != 7861                          (: 'PARSER_END' '^=' :)
         and $state[$p:lk] != 7862                          (: 'SKIP' '^=' :)
         and $state[$p:lk] != 7863                          (: 'SPECIAL_TOKEN' '^=' :)
         and $state[$p:lk] != 7864                          (: 'TOKEN' '^=' :)
         and $state[$p:lk] != 7865                          (: 'TOKEN_MGR_DECLS' '^=' :)
         and $state[$p:lk] != 7886                          (: 'false' '^=' :)
         and $state[$p:lk] != 7900                          (: 'null' '^=' :)
         and $state[$p:lk] != 7913                          (: 'this' '^=' :)
         and $state[$p:lk] != 7917                          (: 'true' '^=' :)
         and $state[$p:lk] != 14849                         (: IDENTIFIER '|=' :)
         and $state[$p:lk] != 14852                         (: INTEGER_LITERAL '|=' :)
         and $state[$p:lk] != 14853                         (: FLOATING_POINT_LITERAL '|=' :)
         and $state[$p:lk] != 14854                         (: CHARACTER_LITERAL '|=' :)
         and $state[$p:lk] != 14855                         (: STRING_LITERAL '|=' :)
         and $state[$p:lk] != 14895                         (: 'EOF' '|=' :)
         and $state[$p:lk] != 14896                         (: 'IGNORE_CASE' '|=' :)
         and $state[$p:lk] != 14897                         (: 'JAVACODE' '|=' :)
         and $state[$p:lk] != 14898                         (: 'LOOKAHEAD' '|=' :)
         and $state[$p:lk] != 14899                         (: 'MORE' '|=' :)
         and $state[$p:lk] != 14900                         (: 'PARSER_BEGIN' '|=' :)
         and $state[$p:lk] != 14901                         (: 'PARSER_END' '|=' :)
         and $state[$p:lk] != 14902                         (: 'SKIP' '|=' :)
         and $state[$p:lk] != 14903                         (: 'SPECIAL_TOKEN' '|=' :)
         and $state[$p:lk] != 14904                         (: 'TOKEN' '|=' :)
         and $state[$p:lk] != 14905                         (: 'TOKEN_MGR_DECLS' '|=' :)
         and $state[$p:lk] != 14926                         (: 'false' '|=' :)
         and $state[$p:lk] != 14940                         (: 'null' '|=' :)
         and $state[$p:lk] != 14953                         (: 'this' '|=' :)
         and $state[$p:lk] != 14957                         (: 'true' '|=' :)
         and $state[$p:lk] != 1674881                       (: IDENTIFIER '.' 'super' :)
         and $state[$p:lk] != 1674884                       (: INTEGER_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674885                       (: FLOATING_POINT_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674886                       (: CHARACTER_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674887                       (: STRING_LITERAL '.' 'super' :)
         and $state[$p:lk] != 1674927                       (: 'EOF' '.' 'super' :)
         and $state[$p:lk] != 1674928                       (: 'IGNORE_CASE' '.' 'super' :)
         and $state[$p:lk] != 1674929                       (: 'JAVACODE' '.' 'super' :)
         and $state[$p:lk] != 1674930                       (: 'LOOKAHEAD' '.' 'super' :)
         and $state[$p:lk] != 1674931                       (: 'MORE' '.' 'super' :)
         and $state[$p:lk] != 1674932                       (: 'PARSER_BEGIN' '.' 'super' :)
         and $state[$p:lk] != 1674933                       (: 'PARSER_END' '.' 'super' :)
         and $state[$p:lk] != 1674934                       (: 'SKIP' '.' 'super' :)
         and $state[$p:lk] != 1674935                       (: 'SPECIAL_TOKEN' '.' 'super' :)
         and $state[$p:lk] != 1674936                       (: 'TOKEN' '.' 'super' :)
         and $state[$p:lk] != 1674937                       (: 'TOKEN_MGR_DECLS' '.' 'super' :)
         and $state[$p:lk] != 1674958                       (: 'false' '.' 'super' :)
         and $state[$p:lk] != 1674972                       (: 'null' '.' 'super' :)
         and $state[$p:lk] != 1674985                       (: 'this' '.' 'super' :)
         and $state[$p:lk] != 1674989) then                 (: 'true' '.' 'super' :)
      let $state := p:memoized($state, 9)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ExplicitConstructorInvocation($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 2406                           (: 'super' '(' :)
          or $state[$p:lk] = 1674881                        (: IDENTIFIER '.' 'super' :)
          or $state[$p:lk] = 1674884                        (: INTEGER_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674885                        (: FLOATING_POINT_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674886                        (: CHARACTER_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674887                        (: STRING_LITERAL '.' 'super' :)
          or $state[$p:lk] = 1674927                        (: 'EOF' '.' 'super' :)
          or $state[$p:lk] = 1674928                        (: 'IGNORE_CASE' '.' 'super' :)
          or $state[$p:lk] = 1674929                        (: 'JAVACODE' '.' 'super' :)
          or $state[$p:lk] = 1674930                        (: 'LOOKAHEAD' '.' 'super' :)
          or $state[$p:lk] = 1674931                        (: 'MORE' '.' 'super' :)
          or $state[$p:lk] = 1674932                        (: 'PARSER_BEGIN' '.' 'super' :)
          or $state[$p:lk] = 1674933                        (: 'PARSER_END' '.' 'super' :)
          or $state[$p:lk] = 1674934                        (: 'SKIP' '.' 'super' :)
          or $state[$p:lk] = 1674935                        (: 'SPECIAL_TOKEN' '.' 'super' :)
          or $state[$p:lk] = 1674936                        (: 'TOKEN' '.' 'super' :)
          or $state[$p:lk] = 1674937                        (: 'TOKEN_MGR_DECLS' '.' 'super' :)
          or $state[$p:lk] = 1674958                        (: 'false' '.' 'super' :)
          or $state[$p:lk] = 1674972                        (: 'null' '.' 'super' :)
          or $state[$p:lk] = 1674985                        (: 'this' '.' 'super' :)
          or $state[$p:lk] = 1674989) then                  (: 'true' '.' 'super' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExplicitConstructorInvocation($input, $state)
      return $state
    else
      $state
  let $state := p:try-ConstructorDeclaration-1($input, $state)
  let $state := p:consumeT(118, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse EnumConstant.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnumConstant($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Modifiers($input, $state)
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(82, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               ',' | ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 18) then                       (: '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Arguments($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(71, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ClassOrInterfaceBody($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EnumConstant", $count, $begin, $end)
};

(:~
 : Try parsing EnumConstant.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnumConstant($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Modifiers($input, $state)
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(82, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               ',' | ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 18) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Arguments($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(71, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ClassOrInterfaceBody($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production EnumBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnumBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(60, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 25) then                         (: ',' :)
        let $state := p:lookahead2W(101, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' | '@' | 'abstract' | 'final' |
                                                               'native' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                               'volatile' | '}' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 34                                (: ';' :)
       or $state[$p:lk] = 118                               (: '}' :)
       or $state[$p:lk] = 4377                              (: ',' ';' :)
       or $state[$p:lk] = 15129) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(97, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'final' |
                                                               'native' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                               'volatile' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-EnumConstant($input, $state)
        return p:parse-EnumBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production EnumBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnumBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(60, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 25) then                         (: ',' :)
        let $state := p:lookahead2W(101, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' | '@' | 'abstract' | 'final' |
                                                               'native' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                               'volatile' | '}' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 34                                (: ';' :)
       or $state[$p:lk] = 118                               (: '}' :)
       or $state[$p:lk] = 4377                              (: ',' ';' :)
       or $state[$p:lk] = 15129) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(97, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'final' |
                                                               'native' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                               'volatile' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-EnumConstant($input, $state)
        return p:try-EnumBody-1($input, $state)
};

(:~
 : Parse the 2nd loop of production EnumBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnumBody-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' | '<' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'class' | 'double' |
                                                               'enum' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'void' | 'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ClassOrInterfaceBodyDeclaration($input, $state)
        return p:parse-EnumBody-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production EnumBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnumBody-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' | '<' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'class' | 'double' |
                                                               'enum' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'void' | 'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ClassOrInterfaceBodyDeclaration($input, $state)
        return p:try-EnumBody-2($input, $state)
};

(:~
 : Parse EnumBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnumBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(102, $input, $state)          (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ',' | ';' | '@' | 'abstract' |
                                                               'final' | 'native' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                               'volatile' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 25                            (: ',' :)
         and $state[$p:l1] != 34                            (: ';' :)
         and $state[$p:l1] != 118) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnumConstant($input, $state)
      let $state := p:parse-EnumBody-1($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consume(25, $input, $state)           (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(48, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: ';' :)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      let $state := p:parse-EnumBody-2($input, $state)
      return $state
    else
      $state
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnumBody", $count, $begin, $end)
};

(:~
 : Try parsing EnumBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnumBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(114, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(102, $input, $state)          (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ',' | ';' | '@' | 'abstract' |
                                                               'final' | 'native' | 'private' | 'protected' | 'public' |
                                                               'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                               'volatile' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 25                            (: ',' :)
         and $state[$p:l1] != 34                            (: ';' :)
         and $state[$p:l1] != 118) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EnumConstant($input, $state)
      let $state := p:try-EnumBody-1($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(48, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: ';' :)
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      let $state := p:try-EnumBody-2($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(118, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse EnumDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnumDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(76, $input, $state)               (: 'enum' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(51, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'implements' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ImplementsList($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnumBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnumDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing EnumDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnumDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(76, $input, $state)              (: 'enum' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(51, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'implements' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ImplementsList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnumBody($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ImplementsList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ImplementsList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ClassOrInterfaceType($input, $state)
      return p:parse-ImplementsList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ImplementsList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ImplementsList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ClassOrInterfaceType($input, $state)
      return p:try-ImplementsList-1($input, $state)
};

(:~
 : Parse ImplementsList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ImplementsList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(84, $input, $state)               (: 'implements' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ClassOrInterfaceType($input, $state)
  let $state := p:parse-ImplementsList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ImplementsList", $count, $begin, $end)
};

(:~
 : Try parsing ImplementsList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ImplementsList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(84, $input, $state)              (: 'implements' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ClassOrInterfaceType($input, $state)
  let $state := p:try-ImplementsList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ExtendsList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtendsList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ClassOrInterfaceType($input, $state)
      return p:parse-ExtendsList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExtendsList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExtendsList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ClassOrInterfaceType($input, $state)
      return p:try-ExtendsList-1($input, $state)
};

(:~
 : Parse ExtendsList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtendsList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(77, $input, $state)               (: 'extends' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ClassOrInterfaceType($input, $state)
  let $state := p:parse-ExtendsList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtendsList", $count, $begin, $end)
};

(:~
 : Try parsing ExtendsList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExtendsList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(77, $input, $state)              (: 'extends' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ClassOrInterfaceType($input, $state)
  let $state := p:try-ExtendsList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeBound (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeBound-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 15) then                           (: '&' :)
      $state
    else
      let $state := p:consume(15, $input, $state)           (: '&' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ClassOrInterfaceType($input, $state)
      return p:parse-TypeBound-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypeBound (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeBound-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 15) then                           (: '&' :)
      $state
    else
      let $state := p:consumeT(15, $input, $state)          (: '&' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ClassOrInterfaceType($input, $state)
      return p:try-TypeBound-1($input, $state)
};

(:~
 : Parse TypeBound.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeBound($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(77, $input, $state)               (: 'extends' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ClassOrInterfaceType($input, $state)
  let $state := p:parse-TypeBound-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeBound", $count, $begin, $end)
};

(:~
 : Try parsing TypeBound.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeBound($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(77, $input, $state)              (: 'extends' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ClassOrInterfaceType($input, $state)
  let $state := p:try-TypeBound-1($input, $state)
  return $state
};

(:~
 : Parse TypeParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeParameter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(61, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '>' | 'extends' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'extends' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeBound($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeParameter", $count, $begin, $end)
};

(:~
 : Try parsing TypeParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeParameter($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(61, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '>' | 'extends' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'extends' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeBound($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production TypeParameters (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeParameters-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeParameter($input, $state)
      return p:parse-TypeParameters-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypeParameters (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeParameters-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeParameter($input, $state)
      return p:try-TypeParameters-1($input, $state)
};

(:~
 : Parse TypeParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeParameters($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(35, $input, $state)               (: '<' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TypeParameter($input, $state)
  let $state := p:parse-TypeParameters-1($input, $state)
  let $state := p:consume(41, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeParameters", $count, $begin, $end)
};

(:~
 : Try parsing TypeParameters.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeParameters($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(35, $input, $state)              (: '<' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TypeParameter($input, $state)
  let $state := p:try-TypeParameters-1($input, $state)
  let $state := p:consumeT(41, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse ClassOrInterfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ClassOrInterfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'class' :)
      let $state := p:consume(70, $input, $state)           (: 'class' :)
      return $state
    else
      let $state := p:consume(88, $input, $state)           (: 'interface' :)
      return $state
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(75, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' |
                                                               'extends' | 'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'extends' | 'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'extends' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtendsList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'implements' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ImplementsList($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ClassOrInterfaceBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ClassOrInterfaceDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing ClassOrInterfaceDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ClassOrInterfaceDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'class' :)
      let $state := p:consumeT(70, $input, $state)          (: 'class' :)
      return $state
    else
      let $state := p:consumeT(88, $input, $state)          (: 'interface' :)
      return $state
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(75, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '<' |
                                                               'extends' | 'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeParameters($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'extends' | 'implements' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'extends' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExtendsList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'implements' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ImplementsList($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ClassOrInterfaceBody($input, $state)
  return $state
};

(:~
 : Parse FormalParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FormalParameter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Modifiers($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Type($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '...' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '...' :)
      let $state := p:consume(30, $input, $state)           (: '...' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VariableDeclaratorId($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FormalParameter", $count, $begin, $end)
};

(:~
 : Try parsing FormalParameter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FormalParameter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Modifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Type($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '...' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '...' :)
      let $state := p:consumeT(30, $input, $state)          (: '...' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VariableDeclaratorId($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TryStatement (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryStatement-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(172, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'catch' | 'char' | 'class' | 'continue' |
                                                               'default' | 'do' | 'double' | 'else' | 'false' |
                                                               'final' | 'finally' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: 'catch' :)
        $state
      else
        let $state := p:consume(68, $input, $state)         (: 'catch' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
        let $state := p:consume(18, $input, $state)         (: '(' :)
        let $state := p:lookahead1W(118, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FormalParameter($input, $state)
        let $state := p:consume(19, $input, $state)         (: ')' :)
        let $state := p:lookahead1W(23, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Block($input, $state)
        return p:parse-TryStatement-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TryStatement (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryStatement-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(172, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'catch' | 'char' | 'class' | 'continue' |
                                                               'default' | 'do' | 'double' | 'else' | 'false' |
                                                               'final' | 'finally' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: 'catch' :)
        $state
      else
        let $state := p:consumeT(68, $input, $state)        (: 'catch' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
        let $state := p:consumeT(18, $input, $state)        (: '(' :)
        let $state := p:lookahead1W(118, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FormalParameter($input, $state)
        let $state := p:consumeT(19, $input, $state)        (: ')' :)
        let $state := p:lookahead1W(23, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Block($input, $state)
        return p:try-TryStatement-1($input, $state)
};

(:~
 : Parse TryStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(110, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Block($input, $state)
  let $state := p:parse-TryStatement-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'finally' :)
      let $state := p:consume(80, $input, $state)           (: 'finally' :)
      let $state := p:lookahead1W(23, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Block($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TryStatement", $count, $begin, $end)
};

(:~
 : Try parsing TryStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(110, $input, $state)             (: 'try' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Block($input, $state)
  let $state := p:try-TryStatement-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'finally' :)
      let $state := p:consumeT(80, $input, $state)          (: 'finally' :)
      let $state := p:lookahead1W(23, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Block($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SynchronizedStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SynchronizedStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(104, $input, $state)              (: 'synchronized' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SynchronizedStatement", $count, $begin, $end)
};

(:~
 : Try parsing SynchronizedStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SynchronizedStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(104, $input, $state)             (: 'synchronized' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Block($input, $state)
  return $state
};

(:~
 : Parse ThrowStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ThrowStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(106, $input, $state)              (: 'throw' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ThrowStatement", $count, $begin, $end)
};

(:~
 : Try parsing ThrowStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ThrowStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(106, $input, $state)             (: 'throw' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse ReturnStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReturnStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(98, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(143, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ';' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnStatement", $count, $begin, $end)
};

(:~
 : Try parsing ReturnStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReturnStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(98, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(143, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 34) then                      (: ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse ContinueStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContinueStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(71, $input, $state)               (: 'continue' :)
  let $state := p:lookahead1W(28, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContinueStatement", $count, $begin, $end)
};

(:~
 : Try parsing ContinueStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ContinueStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(71, $input, $state)              (: 'continue' :)
  let $state := p:lookahead1W(28, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:consumeT(1, $input, $state)           (: IDENTIFIER :)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse BreakStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BreakStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(65, $input, $state)               (: 'break' :)
  let $state := p:lookahead1W(28, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "BreakStatement", $count, $begin, $end)
};

(:~
 : Try parsing BreakStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BreakStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(65, $input, $state)              (: 'break' :)
  let $state := p:lookahead1W(28, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:consumeT(1, $input, $state)           (: IDENTIFIER :)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse ForUpdate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForUpdate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StatementExpressionList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForUpdate", $count, $begin, $end)
};

(:~
 : Try parsing ForUpdate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForUpdate($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StatementExpressionList($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production StatementExpressionList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StatementExpressionList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(57, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               ',' | ';' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(132, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-StatementExpression($input, $state)
        return p:parse-StatementExpressionList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production StatementExpressionList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StatementExpressionList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(57, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               ',' | ';' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(132, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-StatementExpression($input, $state)
        return p:try-StatementExpressionList-1($input, $state)
};

(:~
 : Parse StatementExpressionList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StatementExpressionList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StatementExpression($input, $state)
  let $state := p:parse-StatementExpressionList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "StatementExpressionList", $count, $begin, $end)
};

(:~
 : Try parsing StatementExpressionList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StatementExpressionList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StatementExpression($input, $state)
  let $state := p:try-StatementExpressionList-1($input, $state)
  return $state
};

(:~
 : Parse ForInit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForInit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(116, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | ',' | '--' | '-=' | '.' | '/=' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 3713) then                     (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(103, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (7488,                          (: 'boolean' '[' :)
                             7490,                          (: 'byte' '[' :)
                             7493,                          (: 'char' '[' :)
                             7498,                          (: 'double' '[' :)
                             7505,                          (: 'float' '[' :)
                             7511,                          (: 'int' '[' :)
                             7513,                          (: 'long' '[' :)
                             7523)) then                    (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20097                          (: IDENTIFIER '.' IDENTIFIER :)
          or $state[$p:lk] = 20865                          (: IDENTIFIER '<' IDENTIFIER :)
          or $state[$p:lk] = 741761                         (: IDENTIFIER '<' '?' :)
          or $state[$p:lk] = 974081                         (: IDENTIFIER '[' ']' :)
          or $state[$p:lk] = 974144                         (: 'boolean' '[' ']' :)
          or $state[$p:lk] = 974146                         (: 'byte' '[' ']' :)
          or $state[$p:lk] = 974149                         (: 'char' '[' ']' :)
          or $state[$p:lk] = 974154                         (: 'double' '[' ']' :)
          or $state[$p:lk] = 974161                         (: 'float' '[' ']' :)
          or $state[$p:lk] = 974167                         (: 'int' '[' ']' :)
          or $state[$p:lk] = 974169                         (: 'long' '[' ']' :)
          or $state[$p:lk] = 974179                         (: 'short' '[' ']' :)
          or $state[$p:lk] = 1053057                        (: IDENTIFIER '<' 'boolean' :)
          or $state[$p:lk] = 1085825                        (: IDENTIFIER '<' 'byte' :)
          or $state[$p:lk] = 1134977                        (: IDENTIFIER '<' 'char' :)
          or $state[$p:lk] = 1216897                        (: IDENTIFIER '<' 'double' :)
          or $state[$p:lk] = 1331585                        (: IDENTIFIER '<' 'float' :)
          or $state[$p:lk] = 1429889                        (: IDENTIFIER '<' 'int' :)
          or $state[$p:lk] = 1462657                        (: IDENTIFIER '<' 'long' :)
          or $state[$p:lk] = 1626497) then                  (: IDENTIFIER '<' 'short' :)
      let $state := p:memoized($state, 22)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-LocalVariableDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 46                                  (: '@' :)
     or $state[$p:lk] = 62                                  (: 'abstract' :)
     or $state[$p:lk] = 79                                  (: 'final' :)
     or $state[$p:lk] = 90                                  (: 'native' :)
     or $state[$p:lk] = 95                                  (: 'private' :)
     or $state[$p:lk] = 96                                  (: 'protected' :)
     or $state[$p:lk] = 97                                  (: 'public' :)
     or $state[$p:lk] = 100                                 (: 'static' :)
     or $state[$p:lk] = 101                                 (: 'strictfp' :)
     or $state[$p:lk] = 104                                 (: 'synchronized' :)
     or $state[$p:lk] = 108                                 (: 'transient' :)
     or $state[$p:lk] = 112                                 (: 'volatile' :)
     or $state[$p:lk] = 129                                 (: IDENTIFIER IDENTIFIER :)
     or $state[$p:lk] = 192                                 (: 'boolean' IDENTIFIER :)
     or $state[$p:lk] = 194                                 (: 'byte' IDENTIFIER :)
     or $state[$p:lk] = 197                                 (: 'char' IDENTIFIER :)
     or $state[$p:lk] = 202                                 (: 'double' IDENTIFIER :)
     or $state[$p:lk] = 209                                 (: 'float' IDENTIFIER :)
     or $state[$p:lk] = 215                                 (: 'int' IDENTIFIER :)
     or $state[$p:lk] = 217                                 (: 'long' IDENTIFIER :)
     or $state[$p:lk] = 227) then                           (: 'short' IDENTIFIER :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LocalVariableDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StatementExpressionList($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForInit", $count, $begin, $end)
};

(:~
 : Try parsing ForInit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForInit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(116, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | ',' | '--' | '-=' | '.' | '/=' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 3713) then                     (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(103, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (7488,                          (: 'boolean' '[' :)
                             7490,                          (: 'byte' '[' :)
                             7493,                          (: 'char' '[' :)
                             7498,                          (: 'double' '[' :)
                             7505,                          (: 'float' '[' :)
                             7511,                          (: 'int' '[' :)
                             7513,                          (: 'long' '[' :)
                             7523)) then                    (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20097                          (: IDENTIFIER '.' IDENTIFIER :)
          or $state[$p:lk] = 20865                          (: IDENTIFIER '<' IDENTIFIER :)
          or $state[$p:lk] = 741761                         (: IDENTIFIER '<' '?' :)
          or $state[$p:lk] = 974081                         (: IDENTIFIER '[' ']' :)
          or $state[$p:lk] = 974144                         (: 'boolean' '[' ']' :)
          or $state[$p:lk] = 974146                         (: 'byte' '[' ']' :)
          or $state[$p:lk] = 974149                         (: 'char' '[' ']' :)
          or $state[$p:lk] = 974154                         (: 'double' '[' ']' :)
          or $state[$p:lk] = 974161                         (: 'float' '[' ']' :)
          or $state[$p:lk] = 974167                         (: 'int' '[' ']' :)
          or $state[$p:lk] = 974169                         (: 'long' '[' ']' :)
          or $state[$p:lk] = 974179                         (: 'short' '[' ']' :)
          or $state[$p:lk] = 1053057                        (: IDENTIFIER '<' 'boolean' :)
          or $state[$p:lk] = 1085825                        (: IDENTIFIER '<' 'byte' :)
          or $state[$p:lk] = 1134977                        (: IDENTIFIER '<' 'char' :)
          or $state[$p:lk] = 1216897                        (: IDENTIFIER '<' 'double' :)
          or $state[$p:lk] = 1331585                        (: IDENTIFIER '<' 'float' :)
          or $state[$p:lk] = 1429889                        (: IDENTIFIER '<' 'int' :)
          or $state[$p:lk] = 1462657                        (: IDENTIFIER '<' 'long' :)
          or $state[$p:lk] = 1626497) then                  (: IDENTIFIER '<' 'short' :)
      let $state := p:memoized($state, 22)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-LocalVariableDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 46                                  (: '@' :)
     or $state[$p:lk] = 62                                  (: 'abstract' :)
     or $state[$p:lk] = 79                                  (: 'final' :)
     or $state[$p:lk] = 90                                  (: 'native' :)
     or $state[$p:lk] = 95                                  (: 'private' :)
     or $state[$p:lk] = 96                                  (: 'protected' :)
     or $state[$p:lk] = 97                                  (: 'public' :)
     or $state[$p:lk] = 100                                 (: 'static' :)
     or $state[$p:lk] = 101                                 (: 'strictfp' :)
     or $state[$p:lk] = 104                                 (: 'synchronized' :)
     or $state[$p:lk] = 108                                 (: 'transient' :)
     or $state[$p:lk] = 112                                 (: 'volatile' :)
     or $state[$p:lk] = 129                                 (: IDENTIFIER IDENTIFIER :)
     or $state[$p:lk] = 192                                 (: 'boolean' IDENTIFIER :)
     or $state[$p:lk] = 194                                 (: 'byte' IDENTIFIER :)
     or $state[$p:lk] = 197                                 (: 'char' IDENTIFIER :)
     or $state[$p:lk] = 202                                 (: 'double' IDENTIFIER :)
     or $state[$p:lk] = 209                                 (: 'float' IDENTIFIER :)
     or $state[$p:lk] = 215                                 (: 'int' IDENTIFIER :)
     or $state[$p:lk] = 217                                 (: 'long' IDENTIFIER :)
     or $state[$p:lk] = 227) then                           (: 'short' IDENTIFIER :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-LocalVariableDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-StatementExpressionList($input, $state)
      return $state
  return $state
};

(:~
 : Parse ForStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(82, $input, $state)               (: 'for' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(166, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'double' |
                                                               'false' | 'final' | 'float' | 'int' | 'long' | 'native' |
                                                               'new' | 'null' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'super' |
                                                               'synchronized' | 'this' | 'transient' | 'true' | 'void' |
                                                               'volatile' :)
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(116, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | ',' | '--' | '-=' | '.' | '/=' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 129) then                      (: IDENTIFIER IDENTIFIER :)
          let $state := p:lookahead3W(86, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ':' | ';' | '=' | '[' :)
          return $state
        else if ($state[$p:lk] eq 3713) then                (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(103, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 46) then                      (: '@' :)
      let $state := p:lookahead2W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:lk] = (174,                           (: '@' IDENTIFIER :)
                             6062,                          (: '@' 'EOF' :)
                             6190,                          (: '@' 'IGNORE_CASE' :)
                             6318,                          (: '@' 'JAVACODE' :)
                             6446,                          (: '@' 'LOOKAHEAD' :)
                             6574,                          (: '@' 'MORE' :)
                             6702,                          (: '@' 'PARSER_BEGIN' :)
                             6830,                          (: '@' 'PARSER_END' :)
                             6958,                          (: '@' 'SKIP' :)
                             7086,                          (: '@' 'SPECIAL_TOKEN' :)
                             7214,                          (: '@' 'TOKEN' :)
                             7342)) then                    (: '@' 'TOKEN_MGR_DECLS' :)
          let $state := p:lookahead3W(121, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '.' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (192,                           (: 'boolean' IDENTIFIER :)
                             194,                           (: 'byte' IDENTIFIER :)
                             197,                           (: 'char' IDENTIFIER :)
                             202,                           (: 'double' IDENTIFIER :)
                             209,                           (: 'float' IDENTIFIER :)
                             215,                           (: 'int' IDENTIFIER :)
                             217,                           (: 'long' IDENTIFIER :)
                             227)) then                     (: 'short' IDENTIFIER :)
          let $state := p:lookahead3W(86, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ':' | ';' | '=' | '[' :)
          return $state
        else if ($state[$p:lk] = (7488,                     (: 'boolean' '[' :)
                                  7490,                     (: 'byte' '[' :)
                                  7493,                     (: 'char' '[' :)
                                  7498,                     (: 'double' '[' :)
                                  7505,                     (: 'float' '[' :)
                                  7511,                     (: 'int' '[' :)
                                  7513,                     (: 'long' '[' :)
                                  7523)) then               (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (62,                           (: 'abstract' :)
                              79,                           (: 'final' :)
                              90,                           (: 'native' :)
                              95,                           (: 'private' :)
                              96,                           (: 'protected' :)
                              97,                           (: 'public' :)
                              100,                          (: 'static' :)
                              101,                          (: 'strictfp' :)
                              104,                          (: 'synchronized' :)
                              108,                          (: 'transient' :)
                              112)) then                    (: 'volatile' :)
      let $state := p:lookahead2W(118, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
      let $state :=
        if ($state[$p:lk] = (190,                           (: 'abstract' IDENTIFIER :)
                             207,                           (: 'final' IDENTIFIER :)
                             218,                           (: 'native' IDENTIFIER :)
                             223,                           (: 'private' IDENTIFIER :)
                             224,                           (: 'protected' IDENTIFIER :)
                             225,                           (: 'public' IDENTIFIER :)
                             228,                           (: 'static' IDENTIFIER :)
                             229,                           (: 'strictfp' IDENTIFIER :)
                             232,                           (: 'synchronized' IDENTIFIER :)
                             236,                           (: 'transient' IDENTIFIER :)
                             240)) then                     (: 'volatile' IDENTIFIER :)
          let $state := p:lookahead3W(65, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '<' | '[' :)
          return $state
        else if ($state[$p:lk] = (5950,                     (: 'abstract' '@' :)
                                  5967,                     (: 'final' '@' :)
                                  5978,                     (: 'native' '@' :)
                                  5983,                     (: 'private' '@' :)
                                  5984,                     (: 'protected' '@' :)
                                  5985,                     (: 'public' '@' :)
                                  5988,                     (: 'static' '@' :)
                                  5989,                     (: 'strictfp' '@' :)
                                  5992,                     (: 'synchronized' '@' :)
                                  5996,                     (: 'transient' '@' :)
                                  6000)) then               (: 'volatile' '@' :)
          let $state := p:lookahead3W(94, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
          return $state
        else if ($state[$p:lk] = (8254,                     (: 'abstract' 'boolean' :)
                                  8510,                     (: 'abstract' 'byte' :)
                                  8894,                     (: 'abstract' 'char' :)
                                  9534,                     (: 'abstract' 'double' :)
                                  10430,                    (: 'abstract' 'float' :)
                                  11198,                    (: 'abstract' 'int' :)
                                  11454,                    (: 'abstract' 'long' :)
                                  12734,                    (: 'abstract' 'short' :)
                                  8271,                     (: 'final' 'boolean' :)
                                  8527,                     (: 'final' 'byte' :)
                                  8911,                     (: 'final' 'char' :)
                                  9551,                     (: 'final' 'double' :)
                                  10447,                    (: 'final' 'float' :)
                                  11215,                    (: 'final' 'int' :)
                                  11471,                    (: 'final' 'long' :)
                                  12751,                    (: 'final' 'short' :)
                                  8282,                     (: 'native' 'boolean' :)
                                  8538,                     (: 'native' 'byte' :)
                                  8922,                     (: 'native' 'char' :)
                                  9562,                     (: 'native' 'double' :)
                                  10458,                    (: 'native' 'float' :)
                                  11226,                    (: 'native' 'int' :)
                                  11482,                    (: 'native' 'long' :)
                                  12762,                    (: 'native' 'short' :)
                                  8287,                     (: 'private' 'boolean' :)
                                  8543,                     (: 'private' 'byte' :)
                                  8927,                     (: 'private' 'char' :)
                                  9567,                     (: 'private' 'double' :)
                                  10463,                    (: 'private' 'float' :)
                                  11231,                    (: 'private' 'int' :)
                                  11487,                    (: 'private' 'long' :)
                                  12767,                    (: 'private' 'short' :)
                                  8288,                     (: 'protected' 'boolean' :)
                                  8544,                     (: 'protected' 'byte' :)
                                  8928,                     (: 'protected' 'char' :)
                                  9568,                     (: 'protected' 'double' :)
                                  10464,                    (: 'protected' 'float' :)
                                  11232,                    (: 'protected' 'int' :)
                                  11488,                    (: 'protected' 'long' :)
                                  12768,                    (: 'protected' 'short' :)
                                  8289,                     (: 'public' 'boolean' :)
                                  8545,                     (: 'public' 'byte' :)
                                  8929,                     (: 'public' 'char' :)
                                  9569,                     (: 'public' 'double' :)
                                  10465,                    (: 'public' 'float' :)
                                  11233,                    (: 'public' 'int' :)
                                  11489,                    (: 'public' 'long' :)
                                  12769,                    (: 'public' 'short' :)
                                  8292,                     (: 'static' 'boolean' :)
                                  8548,                     (: 'static' 'byte' :)
                                  8932,                     (: 'static' 'char' :)
                                  9572,                     (: 'static' 'double' :)
                                  10468,                    (: 'static' 'float' :)
                                  11236,                    (: 'static' 'int' :)
                                  11492,                    (: 'static' 'long' :)
                                  12772,                    (: 'static' 'short' :)
                                  8293,                     (: 'strictfp' 'boolean' :)
                                  8549,                     (: 'strictfp' 'byte' :)
                                  8933,                     (: 'strictfp' 'char' :)
                                  9573,                     (: 'strictfp' 'double' :)
                                  10469,                    (: 'strictfp' 'float' :)
                                  11237,                    (: 'strictfp' 'int' :)
                                  11493,                    (: 'strictfp' 'long' :)
                                  12773,                    (: 'strictfp' 'short' :)
                                  8296,                     (: 'synchronized' 'boolean' :)
                                  8552,                     (: 'synchronized' 'byte' :)
                                  8936,                     (: 'synchronized' 'char' :)
                                  9576,                     (: 'synchronized' 'double' :)
                                  10472,                    (: 'synchronized' 'float' :)
                                  11240,                    (: 'synchronized' 'int' :)
                                  11496,                    (: 'synchronized' 'long' :)
                                  12776,                    (: 'synchronized' 'short' :)
                                  8300,                     (: 'transient' 'boolean' :)
                                  8556,                     (: 'transient' 'byte' :)
                                  8940,                     (: 'transient' 'char' :)
                                  9580,                     (: 'transient' 'double' :)
                                  10476,                    (: 'transient' 'float' :)
                                  11244,                    (: 'transient' 'int' :)
                                  11500,                    (: 'transient' 'long' :)
                                  12780,                    (: 'transient' 'short' :)
                                  8304,                     (: 'volatile' 'boolean' :)
                                  8560,                     (: 'volatile' 'byte' :)
                                  8944,                     (: 'volatile' 'char' :)
                                  9584,                     (: 'volatile' 'double' :)
                                  10480,                    (: 'volatile' 'float' :)
                                  11248,                    (: 'volatile' 'int' :)
                                  11504,                    (: 'volatile' 'long' :)
                                  12784)) then              (: 'volatile' 'short' :)
          let $state := p:lookahead3W(29, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '[' :)
          return $state
        else if ($state[$p:lk] = (7998,                     (: 'abstract' 'abstract' :)
                                  10174,                    (: 'abstract' 'final' :)
                                  11582,                    (: 'abstract' 'native' :)
                                  12222,                    (: 'abstract' 'private' :)
                                  12350,                    (: 'abstract' 'protected' :)
                                  12478,                    (: 'abstract' 'public' :)
                                  12862,                    (: 'abstract' 'static' :)
                                  12990,                    (: 'abstract' 'strictfp' :)
                                  13374,                    (: 'abstract' 'synchronized' :)
                                  13886,                    (: 'abstract' 'transient' :)
                                  14398,                    (: 'abstract' 'volatile' :)
                                  8015,                     (: 'final' 'abstract' :)
                                  10191,                    (: 'final' 'final' :)
                                  11599,                    (: 'final' 'native' :)
                                  12239,                    (: 'final' 'private' :)
                                  12367,                    (: 'final' 'protected' :)
                                  12495,                    (: 'final' 'public' :)
                                  12879,                    (: 'final' 'static' :)
                                  13007,                    (: 'final' 'strictfp' :)
                                  13391,                    (: 'final' 'synchronized' :)
                                  13903,                    (: 'final' 'transient' :)
                                  14415,                    (: 'final' 'volatile' :)
                                  8026,                     (: 'native' 'abstract' :)
                                  10202,                    (: 'native' 'final' :)
                                  11610,                    (: 'native' 'native' :)
                                  12250,                    (: 'native' 'private' :)
                                  12378,                    (: 'native' 'protected' :)
                                  12506,                    (: 'native' 'public' :)
                                  12890,                    (: 'native' 'static' :)
                                  13018,                    (: 'native' 'strictfp' :)
                                  13402,                    (: 'native' 'synchronized' :)
                                  13914,                    (: 'native' 'transient' :)
                                  14426,                    (: 'native' 'volatile' :)
                                  8031,                     (: 'private' 'abstract' :)
                                  10207,                    (: 'private' 'final' :)
                                  11615,                    (: 'private' 'native' :)
                                  12255,                    (: 'private' 'private' :)
                                  12383,                    (: 'private' 'protected' :)
                                  12511,                    (: 'private' 'public' :)
                                  12895,                    (: 'private' 'static' :)
                                  13023,                    (: 'private' 'strictfp' :)
                                  13407,                    (: 'private' 'synchronized' :)
                                  13919,                    (: 'private' 'transient' :)
                                  14431,                    (: 'private' 'volatile' :)
                                  8032,                     (: 'protected' 'abstract' :)
                                  10208,                    (: 'protected' 'final' :)
                                  11616,                    (: 'protected' 'native' :)
                                  12256,                    (: 'protected' 'private' :)
                                  12384,                    (: 'protected' 'protected' :)
                                  12512,                    (: 'protected' 'public' :)
                                  12896,                    (: 'protected' 'static' :)
                                  13024,                    (: 'protected' 'strictfp' :)
                                  13408,                    (: 'protected' 'synchronized' :)
                                  13920,                    (: 'protected' 'transient' :)
                                  14432,                    (: 'protected' 'volatile' :)
                                  8033,                     (: 'public' 'abstract' :)
                                  10209,                    (: 'public' 'final' :)
                                  11617,                    (: 'public' 'native' :)
                                  12257,                    (: 'public' 'private' :)
                                  12385,                    (: 'public' 'protected' :)
                                  12513,                    (: 'public' 'public' :)
                                  12897,                    (: 'public' 'static' :)
                                  13025,                    (: 'public' 'strictfp' :)
                                  13409,                    (: 'public' 'synchronized' :)
                                  13921,                    (: 'public' 'transient' :)
                                  14433,                    (: 'public' 'volatile' :)
                                  8036,                     (: 'static' 'abstract' :)
                                  10212,                    (: 'static' 'final' :)
                                  11620,                    (: 'static' 'native' :)
                                  12260,                    (: 'static' 'private' :)
                                  12388,                    (: 'static' 'protected' :)
                                  12516,                    (: 'static' 'public' :)
                                  12900,                    (: 'static' 'static' :)
                                  13028,                    (: 'static' 'strictfp' :)
                                  13412,                    (: 'static' 'synchronized' :)
                                  13924,                    (: 'static' 'transient' :)
                                  14436,                    (: 'static' 'volatile' :)
                                  8037,                     (: 'strictfp' 'abstract' :)
                                  10213,                    (: 'strictfp' 'final' :)
                                  11621,                    (: 'strictfp' 'native' :)
                                  12261,                    (: 'strictfp' 'private' :)
                                  12389,                    (: 'strictfp' 'protected' :)
                                  12517,                    (: 'strictfp' 'public' :)
                                  12901,                    (: 'strictfp' 'static' :)
                                  13029,                    (: 'strictfp' 'strictfp' :)
                                  13413,                    (: 'strictfp' 'synchronized' :)
                                  13925,                    (: 'strictfp' 'transient' :)
                                  14437,                    (: 'strictfp' 'volatile' :)
                                  8040,                     (: 'synchronized' 'abstract' :)
                                  10216,                    (: 'synchronized' 'final' :)
                                  11624,                    (: 'synchronized' 'native' :)
                                  12264,                    (: 'synchronized' 'private' :)
                                  12392,                    (: 'synchronized' 'protected' :)
                                  12520,                    (: 'synchronized' 'public' :)
                                  12904,                    (: 'synchronized' 'static' :)
                                  13032,                    (: 'synchronized' 'strictfp' :)
                                  13416,                    (: 'synchronized' 'synchronized' :)
                                  13928,                    (: 'synchronized' 'transient' :)
                                  14440,                    (: 'synchronized' 'volatile' :)
                                  8044,                     (: 'transient' 'abstract' :)
                                  10220,                    (: 'transient' 'final' :)
                                  11628,                    (: 'transient' 'native' :)
                                  12268,                    (: 'transient' 'private' :)
                                  12396,                    (: 'transient' 'protected' :)
                                  12524,                    (: 'transient' 'public' :)
                                  12908,                    (: 'transient' 'static' :)
                                  13036,                    (: 'transient' 'strictfp' :)
                                  13420,                    (: 'transient' 'synchronized' :)
                                  13932,                    (: 'transient' 'transient' :)
                                  14444,                    (: 'transient' 'volatile' :)
                                  8048,                     (: 'volatile' 'abstract' :)
                                  10224,                    (: 'volatile' 'final' :)
                                  11632,                    (: 'volatile' 'native' :)
                                  12272,                    (: 'volatile' 'private' :)
                                  12400,                    (: 'volatile' 'protected' :)
                                  12528,                    (: 'volatile' 'public' :)
                                  12912,                    (: 'volatile' 'static' :)
                                  13040,                    (: 'volatile' 'strictfp' :)
                                  13424,                    (: 'volatile' 'synchronized' :)
                                  13936,                    (: 'volatile' 'transient' :)
                                  14448)) then              (: 'volatile' 'volatile' :)
          let $state := p:lookahead3W(118, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 23                            (: '++' :)
         and $state[$p:lk] != 27                            (: '--' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 105                           (: 'this' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 1793                          (: IDENTIFIER '%=' :)
         and $state[$p:lk] != 2177                          (: IDENTIFIER '&=' :)
         and $state[$p:lk] != 2305                          (: IDENTIFIER '(' :)
         and $state[$p:lk] != 2689                          (: IDENTIFIER '*=' :)
         and $state[$p:lk] != 2945                          (: IDENTIFIER '++' :)
         and $state[$p:lk] != 3073                          (: IDENTIFIER '+=' :)
         and $state[$p:lk] != 3201                          (: IDENTIFIER ',' :)
         and $state[$p:lk] != 3457                          (: IDENTIFIER '--' :)
         and $state[$p:lk] != 3585                          (: IDENTIFIER '-=' :)
         and $state[$p:lk] != 3776                          (: 'boolean' '.' :)
         and $state[$p:lk] != 3778                          (: 'byte' '.' :)
         and $state[$p:lk] != 3781                          (: 'char' '.' :)
         and $state[$p:lk] != 3786                          (: 'double' '.' :)
         and $state[$p:lk] != 3793                          (: 'float' '.' :)
         and $state[$p:lk] != 3799                          (: 'int' '.' :)
         and $state[$p:lk] != 3801                          (: 'long' '.' :)
         and $state[$p:lk] != 3811                          (: 'short' '.' :)
         and $state[$p:lk] != 4097                          (: IDENTIFIER '/=' :)
         and $state[$p:lk] != 4353                          (: IDENTIFIER ';' :)
         and $state[$p:lk] != 4737                          (: IDENTIFIER '<<=' :)
         and $state[$p:lk] != 4993                          (: IDENTIFIER '=' :)
         and $state[$p:lk] != 5505                          (: IDENTIFIER '>>=' :)
         and $state[$p:lk] != 5633                          (: IDENTIFIER '>>>=' :)
         and $state[$p:lk] != 7809                          (: IDENTIFIER '^=' :)
         and $state[$p:lk] != 14849                         (: IDENTIFIER '|=' :)
         and $state[$p:lk] != 23809                         (: IDENTIFIER '[' IDENTIFIER :)
         and $state[$p:lk] != 72961                         (: IDENTIFIER '[' INTEGER_LITERAL :)
         and $state[$p:lk] != 89345                         (: IDENTIFIER '[' FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 105729                        (: IDENTIFIER '[' CHARACTER_LITERAL :)
         and $state[$p:lk] != 122113                        (: IDENTIFIER '[' STRING_LITERAL :)
         and $state[$p:lk] != 171265                        (: IDENTIFIER '[' '!' :)
         and $state[$p:lk] != 302337                        (: IDENTIFIER '[' '(' :)
         and $state[$p:lk] != 367873                        (: IDENTIFIER '[' '+' :)
         and $state[$p:lk] != 384257                        (: IDENTIFIER '[' '++' :)
         and $state[$p:lk] != 409729                        (: IDENTIFIER IDENTIFIER ',' :)
         and $state[$p:lk] != 409792                        (: 'boolean' IDENTIFIER ',' :)
         and $state[$p:lk] != 409794                        (: 'byte' IDENTIFIER ',' :)
         and $state[$p:lk] != 409797                        (: 'char' IDENTIFIER ',' :)
         and $state[$p:lk] != 409802                        (: 'double' IDENTIFIER ',' :)
         and $state[$p:lk] != 409809                        (: 'float' IDENTIFIER ',' :)
         and $state[$p:lk] != 409815                        (: 'int' IDENTIFIER ',' :)
         and $state[$p:lk] != 409817                        (: 'long' IDENTIFIER ',' :)
         and $state[$p:lk] != 409827                        (: 'short' IDENTIFIER ',' :)
         and $state[$p:lk] != 433409                        (: IDENTIFIER '[' '-' :)
         and $state[$p:lk] != 449793                        (: IDENTIFIER '[' '--' :)
         and $state[$p:lk] != 540801                        (: IDENTIFIER IDENTIFIER ':' :)
         and $state[$p:lk] != 540864                        (: 'boolean' IDENTIFIER ':' :)
         and $state[$p:lk] != 540866                        (: 'byte' IDENTIFIER ':' :)
         and $state[$p:lk] != 540869                        (: 'char' IDENTIFIER ':' :)
         and $state[$p:lk] != 540874                        (: 'double' IDENTIFIER ':' :)
         and $state[$p:lk] != 540881                        (: 'float' IDENTIFIER ':' :)
         and $state[$p:lk] != 540887                        (: 'int' IDENTIFIER ':' :)
         and $state[$p:lk] != 540889                        (: 'long' IDENTIFIER ':' :)
         and $state[$p:lk] != 540899                        (: 'short' IDENTIFIER ':' :)
         and $state[$p:lk] != 557185                        (: IDENTIFIER IDENTIFIER ';' :)
         and $state[$p:lk] != 557248                        (: 'boolean' IDENTIFIER ';' :)
         and $state[$p:lk] != 557250                        (: 'byte' IDENTIFIER ';' :)
         and $state[$p:lk] != 557253                        (: 'char' IDENTIFIER ';' :)
         and $state[$p:lk] != 557258                        (: 'double' IDENTIFIER ';' :)
         and $state[$p:lk] != 557265                        (: 'float' IDENTIFIER ';' :)
         and $state[$p:lk] != 557271                        (: 'int' IDENTIFIER ';' :)
         and $state[$p:lk] != 557273                        (: 'long' IDENTIFIER ';' :)
         and $state[$p:lk] != 557283                        (: 'short' IDENTIFIER ';' :)
         and $state[$p:lk] != 577153                        (: IDENTIFIER '.' '<' :)
         and $state[$p:lk] != 639105                        (: IDENTIFIER IDENTIFIER '=' :)
         and $state[$p:lk] != 639168                        (: 'boolean' IDENTIFIER '=' :)
         and $state[$p:lk] != 639170                        (: 'byte' IDENTIFIER '=' :)
         and $state[$p:lk] != 639173                        (: 'char' IDENTIFIER '=' :)
         and $state[$p:lk] != 639178                        (: 'double' IDENTIFIER '=' :)
         and $state[$p:lk] != 639185                        (: 'float' IDENTIFIER '=' :)
         and $state[$p:lk] != 639191                        (: 'int' IDENTIFIER '=' :)
         and $state[$p:lk] != 639193                        (: 'long' IDENTIFIER '=' :)
         and $state[$p:lk] != 639203                        (: 'short' IDENTIFIER '=' :)
         and $state[$p:lk] != 773761                        (: IDENTIFIER '.' 'EOF' :)
         and $state[$p:lk] != 777473                        (: IDENTIFIER '[' 'EOF' :)
         and $state[$p:lk] != 790145                        (: IDENTIFIER '.' 'IGNORE_CASE' :)
         and $state[$p:lk] != 793857                        (: IDENTIFIER '[' 'IGNORE_CASE' :)
         and $state[$p:lk] != 806529                        (: IDENTIFIER '.' 'JAVACODE' :)
         and $state[$p:lk] != 810241                        (: IDENTIFIER '[' 'JAVACODE' :)
         and $state[$p:lk] != 822913                        (: IDENTIFIER '.' 'LOOKAHEAD' :)
         and $state[$p:lk] != 826625                        (: IDENTIFIER '[' 'LOOKAHEAD' :)
         and $state[$p:lk] != 839297                        (: IDENTIFIER '.' 'MORE' :)
         and $state[$p:lk] != 843009                        (: IDENTIFIER '[' 'MORE' :)
         and $state[$p:lk] != 855681                        (: IDENTIFIER '.' 'PARSER_BEGIN' :)
         and $state[$p:lk] != 859393                        (: IDENTIFIER '[' 'PARSER_BEGIN' :)
         and $state[$p:lk] != 872065                        (: IDENTIFIER '.' 'PARSER_END' :)
         and $state[$p:lk] != 875777                        (: IDENTIFIER '[' 'PARSER_END' :)
         and $state[$p:lk] != 888449                        (: IDENTIFIER '.' 'SKIP' :)
         and $state[$p:lk] != 892161                        (: IDENTIFIER '[' 'SKIP' :)
         and $state[$p:lk] != 904833                        (: IDENTIFIER '.' 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 908545                        (: IDENTIFIER '[' 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 921217                        (: IDENTIFIER '.' 'TOKEN' :)
         and $state[$p:lk] != 924929                        (: IDENTIFIER '[' 'TOKEN' :)
         and $state[$p:lk] != 937601                        (: IDENTIFIER '.' 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 941313                        (: IDENTIFIER '[' 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 950401                        (: IDENTIFIER IDENTIFIER '[' :)
         and $state[$p:lk] != 950464                        (: 'boolean' IDENTIFIER '[' :)
         and $state[$p:lk] != 950466                        (: 'byte' IDENTIFIER '[' :)
         and $state[$p:lk] != 950469                        (: 'char' IDENTIFIER '[' :)
         and $state[$p:lk] != 950474                        (: 'double' IDENTIFIER '[' :)
         and $state[$p:lk] != 950481                        (: 'float' IDENTIFIER '[' :)
         and $state[$p:lk] != 950487                        (: 'int' IDENTIFIER '[' :)
         and $state[$p:lk] != 950489                        (: 'long' IDENTIFIER '[' :)
         and $state[$p:lk] != 950499                        (: 'short' IDENTIFIER '[' :)
         and $state[$p:lk] != 1056001                       (: IDENTIFIER '[' 'boolean' :)
         and $state[$p:lk] != 1088769                       (: IDENTIFIER '[' 'byte' :)
         and $state[$p:lk] != 1137921                       (: IDENTIFIER '[' 'char' :)
         and $state[$p:lk] != 1150593                       (: IDENTIFIER '.' 'class' :)
         and $state[$p:lk] != 1219841                       (: IDENTIFIER '[' 'double' :)
         and $state[$p:lk] != 1285377                       (: IDENTIFIER '[' 'false' :)
         and $state[$p:lk] != 1334529                       (: IDENTIFIER '[' 'float' :)
         and $state[$p:lk] != 1432833                       (: IDENTIFIER '[' 'int' :)
         and $state[$p:lk] != 1465601                       (: IDENTIFIER '[' 'long' :)
         and $state[$p:lk] != 1494657                       (: IDENTIFIER '.' 'new' :)
         and $state[$p:lk] != 1498369                       (: IDENTIFIER '[' 'new' :)
         and $state[$p:lk] != 1514753                       (: IDENTIFIER '[' 'null' :)
         and $state[$p:lk] != 1629441                       (: IDENTIFIER '[' 'short' :)
         and $state[$p:lk] != 1678593                       (: IDENTIFIER '[' 'super' :)
         and $state[$p:lk] != 1724033                       (: IDENTIFIER '.' 'this' :)
         and $state[$p:lk] != 1727745                       (: IDENTIFIER '[' 'this' :)
         and $state[$p:lk] != 1793281                       (: IDENTIFIER '[' 'true' :)
         and $state[$p:lk] != 1826049                       (: IDENTIFIER '[' 'void' :)
         and $state[$p:lk] != 1957121) then                 (: IDENTIFIER '[' '~' :)
      let $state := p:memoized($state, 21)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Modifiers($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Type($input, $state)
          let $state := p:lookahead1W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state := p:consumeT(1, $input, $state)       (: IDENTIFIER :)
          let $state := p:lookahead1W(7, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
          let $state := p:consumeT(33, $input, $state)      (: ':' :)
          let $state := p:lookahead1W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 540801                              (: IDENTIFIER IDENTIFIER ':' :)
     or $state[$p:lk] = 540864                              (: 'boolean' IDENTIFIER ':' :)
     or $state[$p:lk] = 540866                              (: 'byte' IDENTIFIER ':' :)
     or $state[$p:lk] = 540869                              (: 'char' IDENTIFIER ':' :)
     or $state[$p:lk] = 540874                              (: 'double' IDENTIFIER ':' :)
     or $state[$p:lk] = 540881                              (: 'float' IDENTIFIER ':' :)
     or $state[$p:lk] = 540887                              (: 'int' IDENTIFIER ':' :)
     or $state[$p:lk] = 540889                              (: 'long' IDENTIFIER ':' :)
     or $state[$p:lk] = 540899) then                        (: 'short' IDENTIFIER ':' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Modifiers($input, $state)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Type($input, $state)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      let $state := p:lookahead1W(7, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
      let $state := p:consume(33, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 34) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForInit($input, $state)
          return $state
        else
          $state
      let $state := p:consume(34, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(143, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 34) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(34, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(133, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '++' | '--' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 19) then                  (: ')' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForUpdate($input, $state)
          return $state
        else
          $state
      return $state
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForStatement", $count, $begin, $end)
};

(:~
 : Try parsing ForStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(82, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(166, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'double' |
                                                               'false' | 'final' | 'float' | 'int' | 'long' | 'native' |
                                                               'new' | 'null' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'super' |
                                                               'synchronized' | 'this' | 'transient' | 'true' | 'void' |
                                                               'volatile' :)
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(116, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | ',' | '--' | '-=' | '.' | '/=' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 129) then                      (: IDENTIFIER IDENTIFIER :)
          let $state := p:lookahead3W(86, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ':' | ';' | '=' | '[' :)
          return $state
        else if ($state[$p:lk] eq 3713) then                (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(103, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 46) then                      (: '@' :)
      let $state := p:lookahead2W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:lk] = (174,                           (: '@' IDENTIFIER :)
                             6062,                          (: '@' 'EOF' :)
                             6190,                          (: '@' 'IGNORE_CASE' :)
                             6318,                          (: '@' 'JAVACODE' :)
                             6446,                          (: '@' 'LOOKAHEAD' :)
                             6574,                          (: '@' 'MORE' :)
                             6702,                          (: '@' 'PARSER_BEGIN' :)
                             6830,                          (: '@' 'PARSER_END' :)
                             6958,                          (: '@' 'SKIP' :)
                             7086,                          (: '@' 'SPECIAL_TOKEN' :)
                             7214,                          (: '@' 'TOKEN' :)
                             7342)) then                    (: '@' 'TOKEN_MGR_DECLS' :)
          let $state := p:lookahead3W(121, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '.' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'final' |
                                                               'float' | 'int' | 'long' | 'native' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (192,                           (: 'boolean' IDENTIFIER :)
                             194,                           (: 'byte' IDENTIFIER :)
                             197,                           (: 'char' IDENTIFIER :)
                             202,                           (: 'double' IDENTIFIER :)
                             209,                           (: 'float' IDENTIFIER :)
                             215,                           (: 'int' IDENTIFIER :)
                             217,                           (: 'long' IDENTIFIER :)
                             227)) then                     (: 'short' IDENTIFIER :)
          let $state := p:lookahead3W(86, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ':' | ';' | '=' | '[' :)
          return $state
        else if ($state[$p:lk] = (7488,                     (: 'boolean' '[' :)
                                  7490,                     (: 'byte' '[' :)
                                  7493,                     (: 'char' '[' :)
                                  7498,                     (: 'double' '[' :)
                                  7505,                     (: 'float' '[' :)
                                  7511,                     (: 'int' '[' :)
                                  7513,                     (: 'long' '[' :)
                                  7523)) then               (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (62,                           (: 'abstract' :)
                              79,                           (: 'final' :)
                              90,                           (: 'native' :)
                              95,                           (: 'private' :)
                              96,                           (: 'protected' :)
                              97,                           (: 'public' :)
                              100,                          (: 'static' :)
                              101,                          (: 'strictfp' :)
                              104,                          (: 'synchronized' :)
                              108,                          (: 'transient' :)
                              112)) then                    (: 'volatile' :)
      let $state := p:lookahead2W(118, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
      let $state :=
        if ($state[$p:lk] = (190,                           (: 'abstract' IDENTIFIER :)
                             207,                           (: 'final' IDENTIFIER :)
                             218,                           (: 'native' IDENTIFIER :)
                             223,                           (: 'private' IDENTIFIER :)
                             224,                           (: 'protected' IDENTIFIER :)
                             225,                           (: 'public' IDENTIFIER :)
                             228,                           (: 'static' IDENTIFIER :)
                             229,                           (: 'strictfp' IDENTIFIER :)
                             232,                           (: 'synchronized' IDENTIFIER :)
                             236,                           (: 'transient' IDENTIFIER :)
                             240)) then                     (: 'volatile' IDENTIFIER :)
          let $state := p:lookahead3W(65, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '<' | '[' :)
          return $state
        else if ($state[$p:lk] = (5950,                     (: 'abstract' '@' :)
                                  5967,                     (: 'final' '@' :)
                                  5978,                     (: 'native' '@' :)
                                  5983,                     (: 'private' '@' :)
                                  5984,                     (: 'protected' '@' :)
                                  5985,                     (: 'public' '@' :)
                                  5988,                     (: 'static' '@' :)
                                  5989,                     (: 'strictfp' '@' :)
                                  5992,                     (: 'synchronized' '@' :)
                                  5996,                     (: 'transient' '@' :)
                                  6000)) then               (: 'volatile' '@' :)
          let $state := p:lookahead3W(94, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
          return $state
        else if ($state[$p:lk] = (8254,                     (: 'abstract' 'boolean' :)
                                  8510,                     (: 'abstract' 'byte' :)
                                  8894,                     (: 'abstract' 'char' :)
                                  9534,                     (: 'abstract' 'double' :)
                                  10430,                    (: 'abstract' 'float' :)
                                  11198,                    (: 'abstract' 'int' :)
                                  11454,                    (: 'abstract' 'long' :)
                                  12734,                    (: 'abstract' 'short' :)
                                  8271,                     (: 'final' 'boolean' :)
                                  8527,                     (: 'final' 'byte' :)
                                  8911,                     (: 'final' 'char' :)
                                  9551,                     (: 'final' 'double' :)
                                  10447,                    (: 'final' 'float' :)
                                  11215,                    (: 'final' 'int' :)
                                  11471,                    (: 'final' 'long' :)
                                  12751,                    (: 'final' 'short' :)
                                  8282,                     (: 'native' 'boolean' :)
                                  8538,                     (: 'native' 'byte' :)
                                  8922,                     (: 'native' 'char' :)
                                  9562,                     (: 'native' 'double' :)
                                  10458,                    (: 'native' 'float' :)
                                  11226,                    (: 'native' 'int' :)
                                  11482,                    (: 'native' 'long' :)
                                  12762,                    (: 'native' 'short' :)
                                  8287,                     (: 'private' 'boolean' :)
                                  8543,                     (: 'private' 'byte' :)
                                  8927,                     (: 'private' 'char' :)
                                  9567,                     (: 'private' 'double' :)
                                  10463,                    (: 'private' 'float' :)
                                  11231,                    (: 'private' 'int' :)
                                  11487,                    (: 'private' 'long' :)
                                  12767,                    (: 'private' 'short' :)
                                  8288,                     (: 'protected' 'boolean' :)
                                  8544,                     (: 'protected' 'byte' :)
                                  8928,                     (: 'protected' 'char' :)
                                  9568,                     (: 'protected' 'double' :)
                                  10464,                    (: 'protected' 'float' :)
                                  11232,                    (: 'protected' 'int' :)
                                  11488,                    (: 'protected' 'long' :)
                                  12768,                    (: 'protected' 'short' :)
                                  8289,                     (: 'public' 'boolean' :)
                                  8545,                     (: 'public' 'byte' :)
                                  8929,                     (: 'public' 'char' :)
                                  9569,                     (: 'public' 'double' :)
                                  10465,                    (: 'public' 'float' :)
                                  11233,                    (: 'public' 'int' :)
                                  11489,                    (: 'public' 'long' :)
                                  12769,                    (: 'public' 'short' :)
                                  8292,                     (: 'static' 'boolean' :)
                                  8548,                     (: 'static' 'byte' :)
                                  8932,                     (: 'static' 'char' :)
                                  9572,                     (: 'static' 'double' :)
                                  10468,                    (: 'static' 'float' :)
                                  11236,                    (: 'static' 'int' :)
                                  11492,                    (: 'static' 'long' :)
                                  12772,                    (: 'static' 'short' :)
                                  8293,                     (: 'strictfp' 'boolean' :)
                                  8549,                     (: 'strictfp' 'byte' :)
                                  8933,                     (: 'strictfp' 'char' :)
                                  9573,                     (: 'strictfp' 'double' :)
                                  10469,                    (: 'strictfp' 'float' :)
                                  11237,                    (: 'strictfp' 'int' :)
                                  11493,                    (: 'strictfp' 'long' :)
                                  12773,                    (: 'strictfp' 'short' :)
                                  8296,                     (: 'synchronized' 'boolean' :)
                                  8552,                     (: 'synchronized' 'byte' :)
                                  8936,                     (: 'synchronized' 'char' :)
                                  9576,                     (: 'synchronized' 'double' :)
                                  10472,                    (: 'synchronized' 'float' :)
                                  11240,                    (: 'synchronized' 'int' :)
                                  11496,                    (: 'synchronized' 'long' :)
                                  12776,                    (: 'synchronized' 'short' :)
                                  8300,                     (: 'transient' 'boolean' :)
                                  8556,                     (: 'transient' 'byte' :)
                                  8940,                     (: 'transient' 'char' :)
                                  9580,                     (: 'transient' 'double' :)
                                  10476,                    (: 'transient' 'float' :)
                                  11244,                    (: 'transient' 'int' :)
                                  11500,                    (: 'transient' 'long' :)
                                  12780,                    (: 'transient' 'short' :)
                                  8304,                     (: 'volatile' 'boolean' :)
                                  8560,                     (: 'volatile' 'byte' :)
                                  8944,                     (: 'volatile' 'char' :)
                                  9584,                     (: 'volatile' 'double' :)
                                  10480,                    (: 'volatile' 'float' :)
                                  11248,                    (: 'volatile' 'int' :)
                                  11504,                    (: 'volatile' 'long' :)
                                  12784)) then              (: 'volatile' 'short' :)
          let $state := p:lookahead3W(29, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '[' :)
          return $state
        else if ($state[$p:lk] = (7998,                     (: 'abstract' 'abstract' :)
                                  10174,                    (: 'abstract' 'final' :)
                                  11582,                    (: 'abstract' 'native' :)
                                  12222,                    (: 'abstract' 'private' :)
                                  12350,                    (: 'abstract' 'protected' :)
                                  12478,                    (: 'abstract' 'public' :)
                                  12862,                    (: 'abstract' 'static' :)
                                  12990,                    (: 'abstract' 'strictfp' :)
                                  13374,                    (: 'abstract' 'synchronized' :)
                                  13886,                    (: 'abstract' 'transient' :)
                                  14398,                    (: 'abstract' 'volatile' :)
                                  8015,                     (: 'final' 'abstract' :)
                                  10191,                    (: 'final' 'final' :)
                                  11599,                    (: 'final' 'native' :)
                                  12239,                    (: 'final' 'private' :)
                                  12367,                    (: 'final' 'protected' :)
                                  12495,                    (: 'final' 'public' :)
                                  12879,                    (: 'final' 'static' :)
                                  13007,                    (: 'final' 'strictfp' :)
                                  13391,                    (: 'final' 'synchronized' :)
                                  13903,                    (: 'final' 'transient' :)
                                  14415,                    (: 'final' 'volatile' :)
                                  8026,                     (: 'native' 'abstract' :)
                                  10202,                    (: 'native' 'final' :)
                                  11610,                    (: 'native' 'native' :)
                                  12250,                    (: 'native' 'private' :)
                                  12378,                    (: 'native' 'protected' :)
                                  12506,                    (: 'native' 'public' :)
                                  12890,                    (: 'native' 'static' :)
                                  13018,                    (: 'native' 'strictfp' :)
                                  13402,                    (: 'native' 'synchronized' :)
                                  13914,                    (: 'native' 'transient' :)
                                  14426,                    (: 'native' 'volatile' :)
                                  8031,                     (: 'private' 'abstract' :)
                                  10207,                    (: 'private' 'final' :)
                                  11615,                    (: 'private' 'native' :)
                                  12255,                    (: 'private' 'private' :)
                                  12383,                    (: 'private' 'protected' :)
                                  12511,                    (: 'private' 'public' :)
                                  12895,                    (: 'private' 'static' :)
                                  13023,                    (: 'private' 'strictfp' :)
                                  13407,                    (: 'private' 'synchronized' :)
                                  13919,                    (: 'private' 'transient' :)
                                  14431,                    (: 'private' 'volatile' :)
                                  8032,                     (: 'protected' 'abstract' :)
                                  10208,                    (: 'protected' 'final' :)
                                  11616,                    (: 'protected' 'native' :)
                                  12256,                    (: 'protected' 'private' :)
                                  12384,                    (: 'protected' 'protected' :)
                                  12512,                    (: 'protected' 'public' :)
                                  12896,                    (: 'protected' 'static' :)
                                  13024,                    (: 'protected' 'strictfp' :)
                                  13408,                    (: 'protected' 'synchronized' :)
                                  13920,                    (: 'protected' 'transient' :)
                                  14432,                    (: 'protected' 'volatile' :)
                                  8033,                     (: 'public' 'abstract' :)
                                  10209,                    (: 'public' 'final' :)
                                  11617,                    (: 'public' 'native' :)
                                  12257,                    (: 'public' 'private' :)
                                  12385,                    (: 'public' 'protected' :)
                                  12513,                    (: 'public' 'public' :)
                                  12897,                    (: 'public' 'static' :)
                                  13025,                    (: 'public' 'strictfp' :)
                                  13409,                    (: 'public' 'synchronized' :)
                                  13921,                    (: 'public' 'transient' :)
                                  14433,                    (: 'public' 'volatile' :)
                                  8036,                     (: 'static' 'abstract' :)
                                  10212,                    (: 'static' 'final' :)
                                  11620,                    (: 'static' 'native' :)
                                  12260,                    (: 'static' 'private' :)
                                  12388,                    (: 'static' 'protected' :)
                                  12516,                    (: 'static' 'public' :)
                                  12900,                    (: 'static' 'static' :)
                                  13028,                    (: 'static' 'strictfp' :)
                                  13412,                    (: 'static' 'synchronized' :)
                                  13924,                    (: 'static' 'transient' :)
                                  14436,                    (: 'static' 'volatile' :)
                                  8037,                     (: 'strictfp' 'abstract' :)
                                  10213,                    (: 'strictfp' 'final' :)
                                  11621,                    (: 'strictfp' 'native' :)
                                  12261,                    (: 'strictfp' 'private' :)
                                  12389,                    (: 'strictfp' 'protected' :)
                                  12517,                    (: 'strictfp' 'public' :)
                                  12901,                    (: 'strictfp' 'static' :)
                                  13029,                    (: 'strictfp' 'strictfp' :)
                                  13413,                    (: 'strictfp' 'synchronized' :)
                                  13925,                    (: 'strictfp' 'transient' :)
                                  14437,                    (: 'strictfp' 'volatile' :)
                                  8040,                     (: 'synchronized' 'abstract' :)
                                  10216,                    (: 'synchronized' 'final' :)
                                  11624,                    (: 'synchronized' 'native' :)
                                  12264,                    (: 'synchronized' 'private' :)
                                  12392,                    (: 'synchronized' 'protected' :)
                                  12520,                    (: 'synchronized' 'public' :)
                                  12904,                    (: 'synchronized' 'static' :)
                                  13032,                    (: 'synchronized' 'strictfp' :)
                                  13416,                    (: 'synchronized' 'synchronized' :)
                                  13928,                    (: 'synchronized' 'transient' :)
                                  14440,                    (: 'synchronized' 'volatile' :)
                                  8044,                     (: 'transient' 'abstract' :)
                                  10220,                    (: 'transient' 'final' :)
                                  11628,                    (: 'transient' 'native' :)
                                  12268,                    (: 'transient' 'private' :)
                                  12396,                    (: 'transient' 'protected' :)
                                  12524,                    (: 'transient' 'public' :)
                                  12908,                    (: 'transient' 'static' :)
                                  13036,                    (: 'transient' 'strictfp' :)
                                  13420,                    (: 'transient' 'synchronized' :)
                                  13932,                    (: 'transient' 'transient' :)
                                  14444,                    (: 'transient' 'volatile' :)
                                  8048,                     (: 'volatile' 'abstract' :)
                                  10224,                    (: 'volatile' 'final' :)
                                  11632,                    (: 'volatile' 'native' :)
                                  12272,                    (: 'volatile' 'private' :)
                                  12400,                    (: 'volatile' 'protected' :)
                                  12528,                    (: 'volatile' 'public' :)
                                  12912,                    (: 'volatile' 'static' :)
                                  13040,                    (: 'volatile' 'strictfp' :)
                                  13424,                    (: 'volatile' 'synchronized' :)
                                  13936,                    (: 'volatile' 'transient' :)
                                  14448)) then              (: 'volatile' 'volatile' :)
          let $state := p:lookahead3W(118, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 23                            (: '++' :)
         and $state[$p:lk] != 27                            (: '--' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 105                           (: 'this' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 1793                          (: IDENTIFIER '%=' :)
         and $state[$p:lk] != 2177                          (: IDENTIFIER '&=' :)
         and $state[$p:lk] != 2305                          (: IDENTIFIER '(' :)
         and $state[$p:lk] != 2689                          (: IDENTIFIER '*=' :)
         and $state[$p:lk] != 2945                          (: IDENTIFIER '++' :)
         and $state[$p:lk] != 3073                          (: IDENTIFIER '+=' :)
         and $state[$p:lk] != 3201                          (: IDENTIFIER ',' :)
         and $state[$p:lk] != 3457                          (: IDENTIFIER '--' :)
         and $state[$p:lk] != 3585                          (: IDENTIFIER '-=' :)
         and $state[$p:lk] != 3776                          (: 'boolean' '.' :)
         and $state[$p:lk] != 3778                          (: 'byte' '.' :)
         and $state[$p:lk] != 3781                          (: 'char' '.' :)
         and $state[$p:lk] != 3786                          (: 'double' '.' :)
         and $state[$p:lk] != 3793                          (: 'float' '.' :)
         and $state[$p:lk] != 3799                          (: 'int' '.' :)
         and $state[$p:lk] != 3801                          (: 'long' '.' :)
         and $state[$p:lk] != 3811                          (: 'short' '.' :)
         and $state[$p:lk] != 4097                          (: IDENTIFIER '/=' :)
         and $state[$p:lk] != 4353                          (: IDENTIFIER ';' :)
         and $state[$p:lk] != 4737                          (: IDENTIFIER '<<=' :)
         and $state[$p:lk] != 4993                          (: IDENTIFIER '=' :)
         and $state[$p:lk] != 5505                          (: IDENTIFIER '>>=' :)
         and $state[$p:lk] != 5633                          (: IDENTIFIER '>>>=' :)
         and $state[$p:lk] != 7809                          (: IDENTIFIER '^=' :)
         and $state[$p:lk] != 14849                         (: IDENTIFIER '|=' :)
         and $state[$p:lk] != 23809                         (: IDENTIFIER '[' IDENTIFIER :)
         and $state[$p:lk] != 72961                         (: IDENTIFIER '[' INTEGER_LITERAL :)
         and $state[$p:lk] != 89345                         (: IDENTIFIER '[' FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 105729                        (: IDENTIFIER '[' CHARACTER_LITERAL :)
         and $state[$p:lk] != 122113                        (: IDENTIFIER '[' STRING_LITERAL :)
         and $state[$p:lk] != 171265                        (: IDENTIFIER '[' '!' :)
         and $state[$p:lk] != 302337                        (: IDENTIFIER '[' '(' :)
         and $state[$p:lk] != 367873                        (: IDENTIFIER '[' '+' :)
         and $state[$p:lk] != 384257                        (: IDENTIFIER '[' '++' :)
         and $state[$p:lk] != 409729                        (: IDENTIFIER IDENTIFIER ',' :)
         and $state[$p:lk] != 409792                        (: 'boolean' IDENTIFIER ',' :)
         and $state[$p:lk] != 409794                        (: 'byte' IDENTIFIER ',' :)
         and $state[$p:lk] != 409797                        (: 'char' IDENTIFIER ',' :)
         and $state[$p:lk] != 409802                        (: 'double' IDENTIFIER ',' :)
         and $state[$p:lk] != 409809                        (: 'float' IDENTIFIER ',' :)
         and $state[$p:lk] != 409815                        (: 'int' IDENTIFIER ',' :)
         and $state[$p:lk] != 409817                        (: 'long' IDENTIFIER ',' :)
         and $state[$p:lk] != 409827                        (: 'short' IDENTIFIER ',' :)
         and $state[$p:lk] != 433409                        (: IDENTIFIER '[' '-' :)
         and $state[$p:lk] != 449793                        (: IDENTIFIER '[' '--' :)
         and $state[$p:lk] != 540801                        (: IDENTIFIER IDENTIFIER ':' :)
         and $state[$p:lk] != 540864                        (: 'boolean' IDENTIFIER ':' :)
         and $state[$p:lk] != 540866                        (: 'byte' IDENTIFIER ':' :)
         and $state[$p:lk] != 540869                        (: 'char' IDENTIFIER ':' :)
         and $state[$p:lk] != 540874                        (: 'double' IDENTIFIER ':' :)
         and $state[$p:lk] != 540881                        (: 'float' IDENTIFIER ':' :)
         and $state[$p:lk] != 540887                        (: 'int' IDENTIFIER ':' :)
         and $state[$p:lk] != 540889                        (: 'long' IDENTIFIER ':' :)
         and $state[$p:lk] != 540899                        (: 'short' IDENTIFIER ':' :)
         and $state[$p:lk] != 557185                        (: IDENTIFIER IDENTIFIER ';' :)
         and $state[$p:lk] != 557248                        (: 'boolean' IDENTIFIER ';' :)
         and $state[$p:lk] != 557250                        (: 'byte' IDENTIFIER ';' :)
         and $state[$p:lk] != 557253                        (: 'char' IDENTIFIER ';' :)
         and $state[$p:lk] != 557258                        (: 'double' IDENTIFIER ';' :)
         and $state[$p:lk] != 557265                        (: 'float' IDENTIFIER ';' :)
         and $state[$p:lk] != 557271                        (: 'int' IDENTIFIER ';' :)
         and $state[$p:lk] != 557273                        (: 'long' IDENTIFIER ';' :)
         and $state[$p:lk] != 557283                        (: 'short' IDENTIFIER ';' :)
         and $state[$p:lk] != 577153                        (: IDENTIFIER '.' '<' :)
         and $state[$p:lk] != 639105                        (: IDENTIFIER IDENTIFIER '=' :)
         and $state[$p:lk] != 639168                        (: 'boolean' IDENTIFIER '=' :)
         and $state[$p:lk] != 639170                        (: 'byte' IDENTIFIER '=' :)
         and $state[$p:lk] != 639173                        (: 'char' IDENTIFIER '=' :)
         and $state[$p:lk] != 639178                        (: 'double' IDENTIFIER '=' :)
         and $state[$p:lk] != 639185                        (: 'float' IDENTIFIER '=' :)
         and $state[$p:lk] != 639191                        (: 'int' IDENTIFIER '=' :)
         and $state[$p:lk] != 639193                        (: 'long' IDENTIFIER '=' :)
         and $state[$p:lk] != 639203                        (: 'short' IDENTIFIER '=' :)
         and $state[$p:lk] != 773761                        (: IDENTIFIER '.' 'EOF' :)
         and $state[$p:lk] != 777473                        (: IDENTIFIER '[' 'EOF' :)
         and $state[$p:lk] != 790145                        (: IDENTIFIER '.' 'IGNORE_CASE' :)
         and $state[$p:lk] != 793857                        (: IDENTIFIER '[' 'IGNORE_CASE' :)
         and $state[$p:lk] != 806529                        (: IDENTIFIER '.' 'JAVACODE' :)
         and $state[$p:lk] != 810241                        (: IDENTIFIER '[' 'JAVACODE' :)
         and $state[$p:lk] != 822913                        (: IDENTIFIER '.' 'LOOKAHEAD' :)
         and $state[$p:lk] != 826625                        (: IDENTIFIER '[' 'LOOKAHEAD' :)
         and $state[$p:lk] != 839297                        (: IDENTIFIER '.' 'MORE' :)
         and $state[$p:lk] != 843009                        (: IDENTIFIER '[' 'MORE' :)
         and $state[$p:lk] != 855681                        (: IDENTIFIER '.' 'PARSER_BEGIN' :)
         and $state[$p:lk] != 859393                        (: IDENTIFIER '[' 'PARSER_BEGIN' :)
         and $state[$p:lk] != 872065                        (: IDENTIFIER '.' 'PARSER_END' :)
         and $state[$p:lk] != 875777                        (: IDENTIFIER '[' 'PARSER_END' :)
         and $state[$p:lk] != 888449                        (: IDENTIFIER '.' 'SKIP' :)
         and $state[$p:lk] != 892161                        (: IDENTIFIER '[' 'SKIP' :)
         and $state[$p:lk] != 904833                        (: IDENTIFIER '.' 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 908545                        (: IDENTIFIER '[' 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 921217                        (: IDENTIFIER '.' 'TOKEN' :)
         and $state[$p:lk] != 924929                        (: IDENTIFIER '[' 'TOKEN' :)
         and $state[$p:lk] != 937601                        (: IDENTIFIER '.' 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 941313                        (: IDENTIFIER '[' 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 950401                        (: IDENTIFIER IDENTIFIER '[' :)
         and $state[$p:lk] != 950464                        (: 'boolean' IDENTIFIER '[' :)
         and $state[$p:lk] != 950466                        (: 'byte' IDENTIFIER '[' :)
         and $state[$p:lk] != 950469                        (: 'char' IDENTIFIER '[' :)
         and $state[$p:lk] != 950474                        (: 'double' IDENTIFIER '[' :)
         and $state[$p:lk] != 950481                        (: 'float' IDENTIFIER '[' :)
         and $state[$p:lk] != 950487                        (: 'int' IDENTIFIER '[' :)
         and $state[$p:lk] != 950489                        (: 'long' IDENTIFIER '[' :)
         and $state[$p:lk] != 950499                        (: 'short' IDENTIFIER '[' :)
         and $state[$p:lk] != 1056001                       (: IDENTIFIER '[' 'boolean' :)
         and $state[$p:lk] != 1088769                       (: IDENTIFIER '[' 'byte' :)
         and $state[$p:lk] != 1137921                       (: IDENTIFIER '[' 'char' :)
         and $state[$p:lk] != 1150593                       (: IDENTIFIER '.' 'class' :)
         and $state[$p:lk] != 1219841                       (: IDENTIFIER '[' 'double' :)
         and $state[$p:lk] != 1285377                       (: IDENTIFIER '[' 'false' :)
         and $state[$p:lk] != 1334529                       (: IDENTIFIER '[' 'float' :)
         and $state[$p:lk] != 1432833                       (: IDENTIFIER '[' 'int' :)
         and $state[$p:lk] != 1465601                       (: IDENTIFIER '[' 'long' :)
         and $state[$p:lk] != 1494657                       (: IDENTIFIER '.' 'new' :)
         and $state[$p:lk] != 1498369                       (: IDENTIFIER '[' 'new' :)
         and $state[$p:lk] != 1514753                       (: IDENTIFIER '[' 'null' :)
         and $state[$p:lk] != 1629441                       (: IDENTIFIER '[' 'short' :)
         and $state[$p:lk] != 1678593                       (: IDENTIFIER '[' 'super' :)
         and $state[$p:lk] != 1724033                       (: IDENTIFIER '.' 'this' :)
         and $state[$p:lk] != 1727745                       (: IDENTIFIER '[' 'this' :)
         and $state[$p:lk] != 1793281                       (: IDENTIFIER '[' 'true' :)
         and $state[$p:lk] != 1826049                       (: IDENTIFIER '[' 'void' :)
         and $state[$p:lk] != 1957121) then                 (: IDENTIFIER '[' '~' :)
      let $state := p:memoized($state, 21)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Modifiers($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Type($input, $state)
          let $state := p:lookahead1W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state := p:consumeT(1, $input, $state)       (: IDENTIFIER :)
          let $state := p:lookahead1W(7, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
          let $state := p:consumeT(33, $input, $state)      (: ':' :)
          let $state := p:lookahead1W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 540801                              (: IDENTIFIER IDENTIFIER ':' :)
     or $state[$p:lk] = 540864                              (: 'boolean' IDENTIFIER ':' :)
     or $state[$p:lk] = 540866                              (: 'byte' IDENTIFIER ':' :)
     or $state[$p:lk] = 540869                              (: 'char' IDENTIFIER ':' :)
     or $state[$p:lk] = 540874                              (: 'double' IDENTIFIER ':' :)
     or $state[$p:lk] = 540881                              (: 'float' IDENTIFIER ':' :)
     or $state[$p:lk] = 540887                              (: 'int' IDENTIFIER ':' :)
     or $state[$p:lk] = 540889                              (: 'long' IDENTIFIER ':' :)
     or $state[$p:lk] = 540899) then                        (: 'short' IDENTIFIER ':' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Modifiers($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Type($input, $state)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:consumeT(1, $input, $state)           (: IDENTIFIER :)
      let $state := p:lookahead1W(7, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
      let $state := p:consumeT(33, $input, $state)          (: ':' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 34) then                  (: ';' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ForInit($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(143, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 34) then                  (: ';' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(133, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | '++' | '--' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 19) then                  (: ')' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ForUpdate($input, $state)
          return $state
        else
          $state
      return $state
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse DoStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DoStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(73, $input, $state)               (: 'do' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Statement($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'while' :)
  let $state := p:consume(113, $input, $state)              (: 'while' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DoStatement", $count, $begin, $end)
};

(:~
 : Try parsing DoStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DoStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(73, $input, $state)              (: 'do' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Statement($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'while' :)
  let $state := p:consumeT(113, $input, $state)             (: 'while' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse WhileStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhileStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(113, $input, $state)              (: 'while' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhileStatement", $count, $begin, $end)
};

(:~
 : Try parsing WhileStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WhileStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(113, $input, $state)             (: 'while' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse IfStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(83, $input, $state)               (: 'if' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Statement($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'else' | 'false' | 'final' | 'float' |
                                                               'for' | 'if' | 'int' | 'interface' | 'long' | 'native' |
                                                               'new' | 'null' | 'private' | 'protected' | 'public' |
                                                               'return' | 'short' | 'static' | 'strictfp' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' |
                                                               'transient' | 'true' | 'try' | 'void' | 'volatile' |
                                                               'while' | '{' | '}' :)
  let $state :=
    if ($state[$p:l1] eq 75) then                           (: 'else' :)
      let $state := p:lookahead2W(167, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
      let $state :=
        if ($state[$p:lk] eq 203) then                      (: 'else' IDENTIFIER :)
          let $state := p:lookahead3W(114, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '>>=' | '>>>=' |
                                                               '[' | '^=' | '|=' :)
          return $state
        else if ($state[$p:lk] eq 4427) then                (: 'else' ';' :)
          let $state := p:lookahead3W(170, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'else' | 'false' | 'final' | 'float' |
                                                               'for' | 'if' | 'int' | 'interface' | 'long' | 'native' |
                                                               'new' | 'null' | 'private' | 'protected' | 'public' |
                                                               'return' | 'short' | 'static' | 'strictfp' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' |
                                                               'transient' | 'true' | 'try' | 'void' | 'volatile' |
                                                               'while' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] eq 9419) then                (: 'else' 'do' :)
          let $state := p:lookahead3W(167, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
          return $state
        else if ($state[$p:lk] eq 11723) then               (: 'else' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 12619) then               (: 'else' 'return' :)
          let $state := p:lookahead3W(143, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 14155) then               (: 'else' 'try' :)
          let $state := p:lookahead3W(23, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
          return $state
        else if ($state[$p:lk] eq 14667) then               (: 'else' '{' :)
          let $state := p:lookahead3W(168, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
          return $state
        else if ($state[$p:lk] = (3019,                     (: 'else' '++' :)
                                  3531)) then               (: 'else' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (8395,                     (: 'else' 'break' :)
                                  9163)) then               (: 'else' 'continue' :)
          let $state := p:lookahead3W(28, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' :)
          return $state
        else if ($state[$p:lk] = (13131,                    (: 'else' 'super' :)
                                  14283)) then              (: 'else' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (2379,                     (: 'else' '(' :)
                                  8139,                     (: 'else' 'assert' :)
                                  13643)) then              (: 'else' 'throw' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (10571,                    (: 'else' 'for' :)
                                  10699,                    (: 'else' 'if' :)
                                  13259,                    (: 'else' 'switch' :)
                                  13387,                    (: 'else' 'synchronized' :)
                                  14539)) then              (: 'else' 'while' :)
          let $state := p:lookahead3W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          return $state
        else if ($state[$p:lk] = (8267,                     (: 'else' 'boolean' :)
                                  8523,                     (: 'else' 'byte' :)
                                  8907,                     (: 'else' 'char' :)
                                  9547,                     (: 'else' 'double' :)
                                  10443,                    (: 'else' 'float' :)
                                  11211,                    (: 'else' 'int' :)
                                  11467,                    (: 'else' 'long' :)
                                  12747)) then              (: 'else' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (587,                      (: 'else' INTEGER_LITERAL :)
                                  715,                      (: 'else' FLOATING_POINT_LITERAL :)
                                  843,                      (: 'else' CHARACTER_LITERAL :)
                                  971,                      (: 'else' STRING_LITERAL :)
                                  6091,                     (: 'else' 'EOF' :)
                                  6219,                     (: 'else' 'IGNORE_CASE' :)
                                  6347,                     (: 'else' 'JAVACODE' :)
                                  6475,                     (: 'else' 'LOOKAHEAD' :)
                                  6603,                     (: 'else' 'MORE' :)
                                  6731,                     (: 'else' 'PARSER_BEGIN' :)
                                  6859,                     (: 'else' 'PARSER_END' :)
                                  6987,                     (: 'else' 'SKIP' :)
                                  7115,                     (: 'else' 'SPECIAL_TOKEN' :)
                                  7243,                     (: 'else' 'TOKEN' :)
                                  7371,                     (: 'else' 'TOKEN_MGR_DECLS' :)
                                  10059,                    (: 'else' 'false' :)
                                  11851,                    (: 'else' 'null' :)
                                  13515,                    (: 'else' 'this' :)
                                  14027)) then              (: 'else' 'true' :)
          let $state := p:lookahead3W(109, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ';' | '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' |
                                                               '|=' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 1                             (: IDENTIFIER :)
         and $state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 23                            (: '++' :)
         and $state[$p:lk] != 27                            (: '--' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 46                            (: '@' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 62                            (: 'abstract' :)
         and $state[$p:lk] != 63                            (: 'assert' :)
         and $state[$p:lk] != 64                            (: 'boolean' :)
         and $state[$p:lk] != 65                            (: 'break' :)
         and $state[$p:lk] != 66                            (: 'byte' :)
         and $state[$p:lk] != 67                            (: 'case' :)
         and $state[$p:lk] != 69                            (: 'char' :)
         and $state[$p:lk] != 70                            (: 'class' :)
         and $state[$p:lk] != 71                            (: 'continue' :)
         and $state[$p:lk] != 72                            (: 'default' :)
         and $state[$p:lk] != 73                            (: 'do' :)
         and $state[$p:lk] != 74                            (: 'double' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 79                            (: 'final' :)
         and $state[$p:lk] != 81                            (: 'float' :)
         and $state[$p:lk] != 82                            (: 'for' :)
         and $state[$p:lk] != 83                            (: 'if' :)
         and $state[$p:lk] != 87                            (: 'int' :)
         and $state[$p:lk] != 88                            (: 'interface' :)
         and $state[$p:lk] != 89                            (: 'long' :)
         and $state[$p:lk] != 90                            (: 'native' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 95                            (: 'private' :)
         and $state[$p:lk] != 96                            (: 'protected' :)
         and $state[$p:lk] != 97                            (: 'public' :)
         and $state[$p:lk] != 98                            (: 'return' :)
         and $state[$p:lk] != 99                            (: 'short' :)
         and $state[$p:lk] != 100                           (: 'static' :)
         and $state[$p:lk] != 101                           (: 'strictfp' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 103                           (: 'switch' :)
         and $state[$p:lk] != 104                           (: 'synchronized' :)
         and $state[$p:lk] != 105                           (: 'this' :)
         and $state[$p:lk] != 106                           (: 'throw' :)
         and $state[$p:lk] != 108                           (: 'transient' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 110                           (: 'try' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 112                           (: 'volatile' :)
         and $state[$p:lk] != 113                           (: 'while' :)
         and $state[$p:lk] != 114                           (: '{' :)
         and $state[$p:lk] != 118) then                     (: '}' :)
      let $state := p:memoized($state, 20)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(75, $input, $state)      (: 'else' :)
          let $state := p:lookahead1W(167, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(75, $input, $state)           (: 'else' :)
      let $state := p:lookahead1W(167, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Statement($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IfStatement", $count, $begin, $end)
};

(:~
 : Try parsing IfStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IfStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(83, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Statement($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'else' | 'false' | 'final' | 'float' |
                                                               'for' | 'if' | 'int' | 'interface' | 'long' | 'native' |
                                                               'new' | 'null' | 'private' | 'protected' | 'public' |
                                                               'return' | 'short' | 'static' | 'strictfp' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' |
                                                               'transient' | 'true' | 'try' | 'void' | 'volatile' |
                                                               'while' | '{' | '}' :)
  let $state :=
    if ($state[$p:l1] eq 75) then                           (: 'else' :)
      let $state := p:lookahead2W(167, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
      let $state :=
        if ($state[$p:lk] eq 203) then                      (: 'else' IDENTIFIER :)
          let $state := p:lookahead3W(114, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '>>=' | '>>>=' |
                                                               '[' | '^=' | '|=' :)
          return $state
        else if ($state[$p:lk] eq 4427) then                (: 'else' ';' :)
          let $state := p:lookahead3W(170, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'else' | 'false' | 'final' | 'float' |
                                                               'for' | 'if' | 'int' | 'interface' | 'long' | 'native' |
                                                               'new' | 'null' | 'private' | 'protected' | 'public' |
                                                               'return' | 'short' | 'static' | 'strictfp' | 'super' |
                                                               'switch' | 'synchronized' | 'this' | 'throw' |
                                                               'transient' | 'true' | 'try' | 'void' | 'volatile' |
                                                               'while' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] eq 9419) then                (: 'else' 'do' :)
          let $state := p:lookahead3W(167, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
          return $state
        else if ($state[$p:lk] eq 11723) then               (: 'else' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 12619) then               (: 'else' 'return' :)
          let $state := p:lookahead3W(143, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | ';' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 14155) then               (: 'else' 'try' :)
          let $state := p:lookahead3W(23, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
          return $state
        else if ($state[$p:lk] eq 14667) then               (: 'else' '{' :)
          let $state := p:lookahead3W(168, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
          return $state
        else if ($state[$p:lk] = (3019,                     (: 'else' '++' :)
                                  3531)) then               (: 'else' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (8395,                     (: 'else' 'break' :)
                                  9163)) then               (: 'else' 'continue' :)
          let $state := p:lookahead3W(28, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' :)
          return $state
        else if ($state[$p:lk] = (13131,                    (: 'else' 'super' :)
                                  14283)) then              (: 'else' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (2379,                     (: 'else' '(' :)
                                  8139,                     (: 'else' 'assert' :)
                                  13643)) then              (: 'else' 'throw' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (10571,                    (: 'else' 'for' :)
                                  10699,                    (: 'else' 'if' :)
                                  13259,                    (: 'else' 'switch' :)
                                  13387,                    (: 'else' 'synchronized' :)
                                  14539)) then              (: 'else' 'while' :)
          let $state := p:lookahead3W(3, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
          return $state
        else if ($state[$p:lk] = (8267,                     (: 'else' 'boolean' :)
                                  8523,                     (: 'else' 'byte' :)
                                  8907,                     (: 'else' 'char' :)
                                  9547,                     (: 'else' 'double' :)
                                  10443,                    (: 'else' 'float' :)
                                  11211,                    (: 'else' 'int' :)
                                  11467,                    (: 'else' 'long' :)
                                  12747)) then              (: 'else' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (587,                      (: 'else' INTEGER_LITERAL :)
                                  715,                      (: 'else' FLOATING_POINT_LITERAL :)
                                  843,                      (: 'else' CHARACTER_LITERAL :)
                                  971,                      (: 'else' STRING_LITERAL :)
                                  6091,                     (: 'else' 'EOF' :)
                                  6219,                     (: 'else' 'IGNORE_CASE' :)
                                  6347,                     (: 'else' 'JAVACODE' :)
                                  6475,                     (: 'else' 'LOOKAHEAD' :)
                                  6603,                     (: 'else' 'MORE' :)
                                  6731,                     (: 'else' 'PARSER_BEGIN' :)
                                  6859,                     (: 'else' 'PARSER_END' :)
                                  6987,                     (: 'else' 'SKIP' :)
                                  7115,                     (: 'else' 'SPECIAL_TOKEN' :)
                                  7243,                     (: 'else' 'TOKEN' :)
                                  7371,                     (: 'else' 'TOKEN_MGR_DECLS' :)
                                  10059,                    (: 'else' 'false' :)
                                  11851,                    (: 'else' 'null' :)
                                  13515,                    (: 'else' 'this' :)
                                  14027)) then              (: 'else' 'true' :)
          let $state := p:lookahead3W(109, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ';' | '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' |
                                                               '|=' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 1                             (: IDENTIFIER :)
         and $state[$p:lk] != 4                             (: INTEGER_LITERAL :)
         and $state[$p:lk] != 5                             (: FLOATING_POINT_LITERAL :)
         and $state[$p:lk] != 6                             (: CHARACTER_LITERAL :)
         and $state[$p:lk] != 7                             (: STRING_LITERAL :)
         and $state[$p:lk] != 18                            (: '(' :)
         and $state[$p:lk] != 23                            (: '++' :)
         and $state[$p:lk] != 27                            (: '--' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 46                            (: '@' :)
         and $state[$p:lk] != 47                            (: 'EOF' :)
         and $state[$p:lk] != 48                            (: 'IGNORE_CASE' :)
         and $state[$p:lk] != 49                            (: 'JAVACODE' :)
         and $state[$p:lk] != 50                            (: 'LOOKAHEAD' :)
         and $state[$p:lk] != 51                            (: 'MORE' :)
         and $state[$p:lk] != 52                            (: 'PARSER_BEGIN' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 54                            (: 'SKIP' :)
         and $state[$p:lk] != 55                            (: 'SPECIAL_TOKEN' :)
         and $state[$p:lk] != 56                            (: 'TOKEN' :)
         and $state[$p:lk] != 57                            (: 'TOKEN_MGR_DECLS' :)
         and $state[$p:lk] != 62                            (: 'abstract' :)
         and $state[$p:lk] != 63                            (: 'assert' :)
         and $state[$p:lk] != 64                            (: 'boolean' :)
         and $state[$p:lk] != 65                            (: 'break' :)
         and $state[$p:lk] != 66                            (: 'byte' :)
         and $state[$p:lk] != 67                            (: 'case' :)
         and $state[$p:lk] != 69                            (: 'char' :)
         and $state[$p:lk] != 70                            (: 'class' :)
         and $state[$p:lk] != 71                            (: 'continue' :)
         and $state[$p:lk] != 72                            (: 'default' :)
         and $state[$p:lk] != 73                            (: 'do' :)
         and $state[$p:lk] != 74                            (: 'double' :)
         and $state[$p:lk] != 78                            (: 'false' :)
         and $state[$p:lk] != 79                            (: 'final' :)
         and $state[$p:lk] != 81                            (: 'float' :)
         and $state[$p:lk] != 82                            (: 'for' :)
         and $state[$p:lk] != 83                            (: 'if' :)
         and $state[$p:lk] != 87                            (: 'int' :)
         and $state[$p:lk] != 88                            (: 'interface' :)
         and $state[$p:lk] != 89                            (: 'long' :)
         and $state[$p:lk] != 90                            (: 'native' :)
         and $state[$p:lk] != 91                            (: 'new' :)
         and $state[$p:lk] != 92                            (: 'null' :)
         and $state[$p:lk] != 95                            (: 'private' :)
         and $state[$p:lk] != 96                            (: 'protected' :)
         and $state[$p:lk] != 97                            (: 'public' :)
         and $state[$p:lk] != 98                            (: 'return' :)
         and $state[$p:lk] != 99                            (: 'short' :)
         and $state[$p:lk] != 100                           (: 'static' :)
         and $state[$p:lk] != 101                           (: 'strictfp' :)
         and $state[$p:lk] != 102                           (: 'super' :)
         and $state[$p:lk] != 103                           (: 'switch' :)
         and $state[$p:lk] != 104                           (: 'synchronized' :)
         and $state[$p:lk] != 105                           (: 'this' :)
         and $state[$p:lk] != 106                           (: 'throw' :)
         and $state[$p:lk] != 108                           (: 'transient' :)
         and $state[$p:lk] != 109                           (: 'true' :)
         and $state[$p:lk] != 110                           (: 'try' :)
         and $state[$p:lk] != 111                           (: 'void' :)
         and $state[$p:lk] != 112                           (: 'volatile' :)
         and $state[$p:lk] != 113                           (: 'while' :)
         and $state[$p:lk] != 114                           (: '{' :)
         and $state[$p:lk] != 118) then                     (: '}' :)
      let $state := p:memoized($state, 20)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(75, $input, $state)      (: 'else' :)
          let $state := p:lookahead1W(167, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consumeT(75, $input, $state)          (: 'else' :)
      let $state := p:lookahead1W(167, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Statement($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SwitchLabel.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchLabel($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: 'case' :)
      let $state := p:consume(67, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      let $state := p:consume(33, $input, $state)           (: ':' :)
      return $state
    else
      let $state := p:consume(72, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(7, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
      let $state := p:consume(33, $input, $state)           (: ':' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchLabel", $count, $begin, $end)
};

(:~
 : Try parsing SwitchLabel.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchLabel($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: 'case' :)
      let $state := p:consumeT(67, $input, $state)          (: 'case' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      let $state := p:consumeT(33, $input, $state)          (: ':' :)
      return $state
    else
      let $state := p:consumeT(72, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(7, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
      let $state := p:consumeT(33, $input, $state)          (: ':' :)
      return $state
  return $state
};

(:~
 : Parse the 2nd loop of production SwitchStatement (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchStatement-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'false' | 'final' | 'float' | 'for' |
                                                               'if' | 'int' | 'interface' | 'long' | 'native' | 'new' |
                                                               'null' | 'private' | 'protected' | 'public' | 'return' |
                                                               'short' | 'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] = 67                                (: 'case' :)
       or $state[$p:l1] = 72                                (: 'default' :)
       or $state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-BlockStatement($input, $state)
        return p:parse-SwitchStatement-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production SwitchStatement (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchStatement-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'case' | 'char' | 'class' | 'continue' | 'default' |
                                                               'do' | 'double' | 'false' | 'final' | 'float' | 'for' |
                                                               'if' | 'int' | 'interface' | 'long' | 'native' | 'new' |
                                                               'null' | 'private' | 'protected' | 'public' | 'return' |
                                                               'short' | 'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] = 67                                (: 'case' :)
       or $state[$p:l1] = 72                                (: 'default' :)
       or $state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-BlockStatement($input, $state)
        return p:try-SwitchStatement-2($input, $state)
};

(:~
 : Parse the 1st loop of production SwitchStatement (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchStatement-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(63, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'case' | 'default' | '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SwitchLabel($input, $state)
        let $state := p:parse-SwitchStatement-2($input, $state)
        return p:parse-SwitchStatement-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchStatement (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchStatement-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(63, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'case' | 'default' | '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-SwitchLabel($input, $state)
        let $state := p:try-SwitchStatement-2($input, $state)
        return p:try-SwitchStatement-1($input, $state)
};

(:~
 : Parse SwitchStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(103, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:parse-SwitchStatement-1($input, $state)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchStatement", $count, $begin, $end)
};

(:~
 : Try parsing SwitchStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(103, $input, $state)             (: 'switch' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:consumeT(114, $input, $state)             (: '{' :)
  let $state := p:try-SwitchStatement-1($input, $state)
  let $state := p:consumeT(118, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse PreDecrementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreDecrementExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(27, $input, $state)               (: '--' :)
  let $state := p:lookahead1W(129, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpression($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PreDecrementExpression", $count, $begin, $end)
};

(:~
 : Try parsing PreDecrementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PreDecrementExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(27, $input, $state)              (: '--' :)
  let $state := p:lookahead1W(129, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryExpression($input, $state)
  return $state
};

(:~
 : Parse StatementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StatementExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: '++' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreIncrementExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreDecrementExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrimaryExpression($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 19                        (: ')' :)
             and $state[$p:l1] != 25                        (: ',' :)
             and $state[$p:l1] != 34) then                  (: ';' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 23) then               (: '++' :)
              let $state := p:consume(23, $input, $state)   (: '++' :)
              return $state
            else if ($state[$p:l1] = 27) then               (: '--' :)
              let $state := p:consume(27, $input, $state)   (: '--' :)
              return $state
            else
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-AssignmentOperator($input, $state)
              let $state := p:lookahead1W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                  '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                  'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                  'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                  'double' | 'false' | 'float' | 'int' | 'long' |
                                                                  'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                                  'void' | '~' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-Expression($input, $state)
              return $state
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StatementExpression", $count, $begin, $end)
};

(:~
 : Try parsing StatementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StatementExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: '++' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PreIncrementExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PreDecrementExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PrimaryExpression($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 19                        (: ')' :)
             and $state[$p:l1] != 25                        (: ',' :)
             and $state[$p:l1] != 34) then                  (: ';' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 23) then               (: '++' :)
              let $state := p:consumeT(23, $input, $state)  (: '++' :)
              return $state
            else if ($state[$p:l1] = 27) then               (: '--' :)
              let $state := p:consumeT(27, $input, $state)  (: '--' :)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-AssignmentOperator($input, $state)
              let $state := p:lookahead1W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                  FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                  STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                  MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                  '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                  'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                  'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                  'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                  'double' | 'false' | 'float' | 'int' | 'long' |
                                                                  'new' | 'null' | 'short' | 'super' | 'this' | 'true' |
                                                                  'void' | '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-Expression($input, $state)
              return $state
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse EmptyStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyStatement", $count, $begin, $end)
};

(:~
 : Try parsing EmptyStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EmptyStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse AssertStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AssertStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(63, $input, $state)               (: 'assert' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 33) then                       (: ':' :)
      let $state := p:consume(33, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AssertStatement", $count, $begin, $end)
};

(:~
 : Try parsing AssertStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AssertStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(63, $input, $state)              (: 'assert' :)
  let $state := p:lookahead1W(139, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 33) then                       (: ':' :)
      let $state := p:consumeT(33, $input, $state)          (: ':' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse LabeledStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LabeledStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(7, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
  let $state := p:consume(33, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LabeledStatement", $count, $begin, $end)
};

(:~
 : Try parsing LabeledStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LabeledStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(7, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ':' :)
  let $state := p:consumeT(33, $input, $state)              (: ':' :)
  let $state := p:lookahead1W(167, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | 'EOF' |
                                                               'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' | 'MORE' |
                                                               'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'assert' | 'boolean' | 'break' | 'byte' | 'char' |
                                                               'continue' | 'do' | 'double' | 'false' | 'float' |
                                                               'for' | 'if' | 'int' | 'long' | 'new' | 'null' |
                                                               'return' | 'short' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'true' | 'try' |
                                                               'void' | 'while' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse Statement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Statement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(114, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '>>=' | '>>>=' |
                                                               '[' | '^=' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 4225) then                     (: IDENTIFIER ':' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LabeledStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 63) then                       (: 'assert' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AssertStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Block($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 103) then                      (: 'switch' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SwitchStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 83) then                       (: 'if' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 113) then                      (: 'while' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhileStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 73) then                       (: 'do' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DoStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 82) then                       (: 'for' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 65) then                       (: 'break' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BreakStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 71) then                       (: 'continue' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContinueStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 98) then                       (: 'return' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReturnStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 106) then                      (: 'throw' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ThrowStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 104) then                      (: 'synchronized' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SynchronizedStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 110) then                      (: 'try' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TryStatement($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StatementExpression($input, $state)
      let $state := p:lookahead1W(8, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Statement", $count, $begin, $end)
};

(:~
 : Try parsing Statement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Statement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(114, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '%=' |
                                                               '&=' | '(' | '*=' | '++' | '+=' | '--' | '-=' | '.' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '>>=' | '>>>=' |
                                                               '[' | '^=' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 4225) then                     (: IDENTIFIER ':' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-LabeledStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 63) then                       (: 'assert' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AssertStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Block($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EmptyStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 103) then                      (: 'switch' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SwitchStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 83) then                       (: 'if' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-IfStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 113) then                      (: 'while' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-WhileStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 73) then                       (: 'do' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DoStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 82) then                       (: 'for' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ForStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 65) then                       (: 'break' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-BreakStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 71) then                       (: 'continue' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ContinueStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 98) then                       (: 'return' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReturnStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 106) then                      (: 'throw' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ThrowStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 104) then                      (: 'synchronized' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SynchronizedStatement($input, $state)
      return $state
    else if ($state[$p:lk] = 110) then                      (: 'try' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TryStatement($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-StatementExpression($input, $state)
      let $state := p:lookahead1W(8, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production VariableDeclaratorId (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VariableDeclaratorId-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(84, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               ',' | ';' | '=' | '[' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        let $state := p:consume(58, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consume(59, $input, $state)         (: ']' :)
        return p:parse-VariableDeclaratorId-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production VariableDeclaratorId (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VariableDeclaratorId-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(84, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               ',' | ';' | '=' | '[' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(58, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consumeT(59, $input, $state)        (: ']' :)
        return p:try-VariableDeclaratorId-1($input, $state)
};

(:~
 : Parse VariableDeclaratorId.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VariableDeclaratorId($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:parse-VariableDeclaratorId-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclaratorId", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclaratorId.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VariableDeclaratorId($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:try-VariableDeclaratorId-1($input, $state)
  return $state
};

(:~
 : Parse VariableDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VariableDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VariableDeclaratorId($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39) then                       (: '=' :)
      let $state := p:consume(39, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(147, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VariableInitializer($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclarator", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclarator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VariableDeclarator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VariableDeclaratorId($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39) then                       (: '=' :)
      let $state := p:consumeT(39, $input, $state)          (: '=' :)
      let $state := p:lookahead1W(147, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VariableInitializer($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Type.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Type($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (64,                                (: 'boolean' :)
                         66,                                (: 'byte' :)
                         69,                                (: 'char' :)
                         74,                                (: 'double' :)
                         81,                                (: 'float' :)
                         87,                                (: 'int' :)
                         89,                                (: 'long' :)
                         99)) then                          (: 'short' :)
      let $state := p:lookahead2W(127, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' | '/=' |
                                                               ':' | ';' | '<<=' | '=' | '==' | '>>=' | '>>>=' | '?' |
                                                               '[' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IDENTIFIER :)
          or $state[$p:lk] = 7488                           (: 'boolean' '[' :)
          or $state[$p:lk] = 7490                           (: 'byte' '[' :)
          or $state[$p:lk] = 7493                           (: 'char' '[' :)
          or $state[$p:lk] = 7498                           (: 'double' '[' :)
          or $state[$p:lk] = 7505                           (: 'float' '[' :)
          or $state[$p:lk] = 7511                           (: 'int' '[' :)
          or $state[$p:lk] = 7513                           (: 'long' '[' :)
          or $state[$p:lk] = 7523) then                     (: 'short' '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReferenceType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrimitiveType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Type", $count, $begin, $end)
};

(:~
 : Try parsing Type.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Type($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (64,                                (: 'boolean' :)
                         66,                                (: 'byte' :)
                         69,                                (: 'char' :)
                         74,                                (: 'double' :)
                         81,                                (: 'float' :)
                         87,                                (: 'int' :)
                         89,                                (: 'long' :)
                         99)) then                          (: 'short' :)
      let $state := p:lookahead2W(127, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' | '/=' |
                                                               ':' | ';' | '<<=' | '=' | '==' | '>>=' | '>>>=' | '?' |
                                                               '[' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IDENTIFIER :)
          or $state[$p:lk] = 7488                           (: 'boolean' '[' :)
          or $state[$p:lk] = 7490                           (: 'byte' '[' :)
          or $state[$p:lk] = 7493                           (: 'char' '[' :)
          or $state[$p:lk] = 7498                           (: 'double' '[' :)
          or $state[$p:lk] = 7505                           (: 'float' '[' :)
          or $state[$p:lk] = 7511                           (: 'int' '[' :)
          or $state[$p:lk] = 7513                           (: 'long' '[' :)
          or $state[$p:lk] = 7523) then                     (: 'short' '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReferenceType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PrimitiveType($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production LocalVariableDeclaration (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LocalVariableDeclaration-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VariableDeclarator($input, $state)
        return p:parse-LocalVariableDeclaration-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LocalVariableDeclaration (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LocalVariableDeclaration-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               ';' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-VariableDeclarator($input, $state)
        return p:try-LocalVariableDeclaration-1($input, $state)
};

(:~
 : Parse LocalVariableDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LocalVariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Modifiers($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Type($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VariableDeclarator($input, $state)
  let $state := p:parse-LocalVariableDeclaration-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LocalVariableDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing LocalVariableDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LocalVariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Modifiers($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Type($input, $state)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VariableDeclarator($input, $state)
  let $state := p:try-LocalVariableDeclaration-1($input, $state)
  return $state
};

(:~
 : Parse BlockStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BlockStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(117, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | '--' | '-=' | '.' | '/=' | ':' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 3713) then                     (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(103, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 104) then                     (: 'synchronized' :)
      let $state := p:lookahead2W(119, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (7488,                          (: 'boolean' '[' :)
                             7490,                          (: 'byte' '[' :)
                             7493,                          (: 'char' '[' :)
                             7498,                          (: 'double' '[' :)
                             7505,                          (: 'float' '[' :)
                             7511,                          (: 'int' '[' :)
                             7513,                          (: 'long' '[' :)
                             7523)) then                    (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20097                          (: IDENTIFIER '.' IDENTIFIER :)
          or $state[$p:lk] = 20865                          (: IDENTIFIER '<' IDENTIFIER :)
          or $state[$p:lk] = 741761                         (: IDENTIFIER '<' '?' :)
          or $state[$p:lk] = 974081                         (: IDENTIFIER '[' ']' :)
          or $state[$p:lk] = 974144                         (: 'boolean' '[' ']' :)
          or $state[$p:lk] = 974146                         (: 'byte' '[' ']' :)
          or $state[$p:lk] = 974149                         (: 'char' '[' ']' :)
          or $state[$p:lk] = 974154                         (: 'double' '[' ']' :)
          or $state[$p:lk] = 974161                         (: 'float' '[' ']' :)
          or $state[$p:lk] = 974167                         (: 'int' '[' ']' :)
          or $state[$p:lk] = 974169                         (: 'long' '[' ']' :)
          or $state[$p:lk] = 974179                         (: 'short' '[' ']' :)
          or $state[$p:lk] = 1053057                        (: IDENTIFIER '<' 'boolean' :)
          or $state[$p:lk] = 1085825                        (: IDENTIFIER '<' 'byte' :)
          or $state[$p:lk] = 1134977                        (: IDENTIFIER '<' 'char' :)
          or $state[$p:lk] = 1216897                        (: IDENTIFIER '<' 'double' :)
          or $state[$p:lk] = 1331585                        (: IDENTIFIER '<' 'float' :)
          or $state[$p:lk] = 1429889                        (: IDENTIFIER '<' 'int' :)
          or $state[$p:lk] = 1462657                        (: IDENTIFIER '<' 'long' :)
          or $state[$p:lk] = 1626497) then                  (: IDENTIFIER '<' 'short' :)
      let $state := p:memoized($state, 19)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-LocalVariableDeclaration($input, $state)
          let $state := p:consumeT(34, $input, $state)      (: ';' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 46                                  (: '@' :)
     or $state[$p:lk] = 62                                  (: 'abstract' :)
     or $state[$p:lk] = 79                                  (: 'final' :)
     or $state[$p:lk] = 90                                  (: 'native' :)
     or $state[$p:lk] = 95                                  (: 'private' :)
     or $state[$p:lk] = 96                                  (: 'protected' :)
     or $state[$p:lk] = 97                                  (: 'public' :)
     or $state[$p:lk] = 100                                 (: 'static' :)
     or $state[$p:lk] = 101                                 (: 'strictfp' :)
     or $state[$p:lk] = 108                                 (: 'transient' :)
     or $state[$p:lk] = 112                                 (: 'volatile' :)
     or $state[$p:lk] = 129                                 (: IDENTIFIER IDENTIFIER :)
     or $state[$p:lk] = 192                                 (: 'boolean' IDENTIFIER :)
     or $state[$p:lk] = 194                                 (: 'byte' IDENTIFIER :)
     or $state[$p:lk] = 197                                 (: 'char' IDENTIFIER :)
     or $state[$p:lk] = 202                                 (: 'double' IDENTIFIER :)
     or $state[$p:lk] = 209                                 (: 'float' IDENTIFIER :)
     or $state[$p:lk] = 215                                 (: 'int' IDENTIFIER :)
     or $state[$p:lk] = 217                                 (: 'long' IDENTIFIER :)
     or $state[$p:lk] = 227                                 (: 'short' IDENTIFIER :)
     or $state[$p:lk] = 232                                 (: 'synchronized' IDENTIFIER :)
     or $state[$p:lk] = 5992                                (: 'synchronized' '@' :)
     or $state[$p:lk] = 8040                                (: 'synchronized' 'abstract' :)
     or $state[$p:lk] = 8296                                (: 'synchronized' 'boolean' :)
     or $state[$p:lk] = 8552                                (: 'synchronized' 'byte' :)
     or $state[$p:lk] = 8936                                (: 'synchronized' 'char' :)
     or $state[$p:lk] = 9576                                (: 'synchronized' 'double' :)
     or $state[$p:lk] = 10216                               (: 'synchronized' 'final' :)
     or $state[$p:lk] = 10472                               (: 'synchronized' 'float' :)
     or $state[$p:lk] = 11240                               (: 'synchronized' 'int' :)
     or $state[$p:lk] = 11496                               (: 'synchronized' 'long' :)
     or $state[$p:lk] = 11624                               (: 'synchronized' 'native' :)
     or $state[$p:lk] = 12264                               (: 'synchronized' 'private' :)
     or $state[$p:lk] = 12392                               (: 'synchronized' 'protected' :)
     or $state[$p:lk] = 12520                               (: 'synchronized' 'public' :)
     or $state[$p:lk] = 12776                               (: 'synchronized' 'short' :)
     or $state[$p:lk] = 12904                               (: 'synchronized' 'static' :)
     or $state[$p:lk] = 13032                               (: 'synchronized' 'strictfp' :)
     or $state[$p:lk] = 13416                               (: 'synchronized' 'synchronized' :)
     or $state[$p:lk] = 13928                               (: 'synchronized' 'transient' :)
     or $state[$p:lk] = 14440) then                         (: 'synchronized' 'volatile' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LocalVariableDeclaration($input, $state)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
    else if ($state[$p:lk] = 70                             (: 'class' :)
          or $state[$p:lk] = 88) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ClassOrInterfaceDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Statement($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BlockStatement", $count, $begin, $end)
};

(:~
 : Try parsing BlockStatement.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BlockStatement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(117, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '%=' | '&=' | '(' | '*=' | '++' |
                                                               '+=' | '--' | '-=' | '.' | '/=' | ':' | ';' | '<' |
                                                               '<<=' | '=' | '>>=' | '>>>=' | '[' | '^=' | '|=' :)
      let $state :=
        if ($state[$p:lk] eq 3713) then                     (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(103, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(92, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 104) then                     (: 'synchronized' :)
      let $state := p:lookahead2W(119, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'double' | 'final' | 'float' | 'int' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
      return $state
    else if ($state[$p:l1] = (64,                           (: 'boolean' :)
                              66,                           (: 'byte' :)
                              69,                           (: 'char' :)
                              74,                           (: 'double' :)
                              81,                           (: 'float' :)
                              87,                           (: 'int' :)
                              89,                           (: 'long' :)
                              99)) then                     (: 'short' :)
      let $state := p:lookahead2W(55, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '.' | '[' :)
      let $state :=
        if ($state[$p:lk] = (7488,                          (: 'boolean' '[' :)
                             7490,                          (: 'byte' '[' :)
                             7493,                          (: 'char' '[' :)
                             7498,                          (: 'double' '[' :)
                             7505,                          (: 'float' '[' :)
                             7511,                          (: 'int' '[' :)
                             7513,                          (: 'long' '[' :)
                             7523)) then                    (: 'short' '[' :)
          let $state := p:lookahead3W(16, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20097                          (: IDENTIFIER '.' IDENTIFIER :)
          or $state[$p:lk] = 20865                          (: IDENTIFIER '<' IDENTIFIER :)
          or $state[$p:lk] = 741761                         (: IDENTIFIER '<' '?' :)
          or $state[$p:lk] = 974081                         (: IDENTIFIER '[' ']' :)
          or $state[$p:lk] = 974144                         (: 'boolean' '[' ']' :)
          or $state[$p:lk] = 974146                         (: 'byte' '[' ']' :)
          or $state[$p:lk] = 974149                         (: 'char' '[' ']' :)
          or $state[$p:lk] = 974154                         (: 'double' '[' ']' :)
          or $state[$p:lk] = 974161                         (: 'float' '[' ']' :)
          or $state[$p:lk] = 974167                         (: 'int' '[' ']' :)
          or $state[$p:lk] = 974169                         (: 'long' '[' ']' :)
          or $state[$p:lk] = 974179                         (: 'short' '[' ']' :)
          or $state[$p:lk] = 1053057                        (: IDENTIFIER '<' 'boolean' :)
          or $state[$p:lk] = 1085825                        (: IDENTIFIER '<' 'byte' :)
          or $state[$p:lk] = 1134977                        (: IDENTIFIER '<' 'char' :)
          or $state[$p:lk] = 1216897                        (: IDENTIFIER '<' 'double' :)
          or $state[$p:lk] = 1331585                        (: IDENTIFIER '<' 'float' :)
          or $state[$p:lk] = 1429889                        (: IDENTIFIER '<' 'int' :)
          or $state[$p:lk] = 1462657                        (: IDENTIFIER '<' 'long' :)
          or $state[$p:lk] = 1626497) then                  (: IDENTIFIER '<' 'short' :)
      let $state := p:memoized($state, 19)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-LocalVariableDeclaration($input, $state)
          let $state := p:consumeT(34, $input, $state)      (: ';' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 46                                  (: '@' :)
     or $state[$p:lk] = 62                                  (: 'abstract' :)
     or $state[$p:lk] = 79                                  (: 'final' :)
     or $state[$p:lk] = 90                                  (: 'native' :)
     or $state[$p:lk] = 95                                  (: 'private' :)
     or $state[$p:lk] = 96                                  (: 'protected' :)
     or $state[$p:lk] = 97                                  (: 'public' :)
     or $state[$p:lk] = 100                                 (: 'static' :)
     or $state[$p:lk] = 101                                 (: 'strictfp' :)
     or $state[$p:lk] = 108                                 (: 'transient' :)
     or $state[$p:lk] = 112                                 (: 'volatile' :)
     or $state[$p:lk] = 129                                 (: IDENTIFIER IDENTIFIER :)
     or $state[$p:lk] = 192                                 (: 'boolean' IDENTIFIER :)
     or $state[$p:lk] = 194                                 (: 'byte' IDENTIFIER :)
     or $state[$p:lk] = 197                                 (: 'char' IDENTIFIER :)
     or $state[$p:lk] = 202                                 (: 'double' IDENTIFIER :)
     or $state[$p:lk] = 209                                 (: 'float' IDENTIFIER :)
     or $state[$p:lk] = 215                                 (: 'int' IDENTIFIER :)
     or $state[$p:lk] = 217                                 (: 'long' IDENTIFIER :)
     or $state[$p:lk] = 227                                 (: 'short' IDENTIFIER :)
     or $state[$p:lk] = 232                                 (: 'synchronized' IDENTIFIER :)
     or $state[$p:lk] = 5992                                (: 'synchronized' '@' :)
     or $state[$p:lk] = 8040                                (: 'synchronized' 'abstract' :)
     or $state[$p:lk] = 8296                                (: 'synchronized' 'boolean' :)
     or $state[$p:lk] = 8552                                (: 'synchronized' 'byte' :)
     or $state[$p:lk] = 8936                                (: 'synchronized' 'char' :)
     or $state[$p:lk] = 9576                                (: 'synchronized' 'double' :)
     or $state[$p:lk] = 10216                               (: 'synchronized' 'final' :)
     or $state[$p:lk] = 10472                               (: 'synchronized' 'float' :)
     or $state[$p:lk] = 11240                               (: 'synchronized' 'int' :)
     or $state[$p:lk] = 11496                               (: 'synchronized' 'long' :)
     or $state[$p:lk] = 11624                               (: 'synchronized' 'native' :)
     or $state[$p:lk] = 12264                               (: 'synchronized' 'private' :)
     or $state[$p:lk] = 12392                               (: 'synchronized' 'protected' :)
     or $state[$p:lk] = 12520                               (: 'synchronized' 'public' :)
     or $state[$p:lk] = 12776                               (: 'synchronized' 'short' :)
     or $state[$p:lk] = 12904                               (: 'synchronized' 'static' :)
     or $state[$p:lk] = 13032                               (: 'synchronized' 'strictfp' :)
     or $state[$p:lk] = 13416                               (: 'synchronized' 'synchronized' :)
     or $state[$p:lk] = 13928                               (: 'synchronized' 'transient' :)
     or $state[$p:lk] = 14440) then                         (: 'synchronized' 'volatile' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-LocalVariableDeclaration($input, $state)
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      return $state
    else if ($state[$p:lk] = 70                             (: 'class' :)
          or $state[$p:lk] = 88) then                       (: 'interface' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ClassOrInterfaceDeclaration($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Statement($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Block (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Block-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(168, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-BlockStatement($input, $state)
        return p:parse-Block-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Block (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Block-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(168, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '++' | '--' | ';' | '@' |
                                                               'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'abstract' | 'assert' | 'boolean' | 'break' | 'byte' |
                                                               'char' | 'class' | 'continue' | 'do' | 'double' |
                                                               'false' | 'final' | 'float' | 'for' | 'if' | 'int' |
                                                               'interface' | 'long' | 'native' | 'new' | 'null' |
                                                               'private' | 'protected' | 'public' | 'return' | 'short' |
                                                               'static' | 'strictfp' | 'super' | 'switch' |
                                                               'synchronized' | 'this' | 'throw' | 'transient' |
                                                               'true' | 'try' | 'void' | 'volatile' | 'while' | '{' |
                                                               '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-BlockStatement($input, $state)
        return p:try-Block-1($input, $state)
};

(:~
 : Parse Block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Block($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:parse-Block-1($input, $state)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Block", $count, $begin, $end)
};

(:~
 : Try parsing Block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Block($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(114, $input, $state)             (: '{' :)
  let $state := p:try-Block-1($input, $state)
  let $state := p:consumeT(118, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse Initializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Initializer($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 100) then                      (: 'static' :)
      let $state := p:consume(100, $input, $state)          (: 'static' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Initializer", $count, $begin, $end)
};

(:~
 : Try parsing Initializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Initializer($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 100) then                      (: 'static' :)
      let $state := p:consumeT(100, $input, $state)         (: 'static' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Block($input, $state)
  return $state
};

(:~
 : Parse ClassOrInterfaceBodyDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ClassOrInterfaceBodyDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 100) then                          (: 'static' :)
      let $state := p:lookahead2W(125, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'class' | 'double' | 'enum' | 'final' |
                                                               'float' | 'int' | 'interface' | 'long' | 'native' |
                                                               'private' | 'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 114                            (: '{' :)
          or $state[$p:lk] = 14692) then                    (: 'static' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Initializer($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: ';' :)
      let $state := p:consume(34, $input, $state)           (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Modifiers($input, $state)
      let $state :=
        if ($state[$p:l1] eq 1) then                        (: IDENTIFIER :)
          let $state := p:lookahead2W(77, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '.' | '<' | '[' :)
          let $state :=
            if ($state[$p:lk] eq 129) then                  (: IDENTIFIER IDENTIFIER :)
              let $state := p:lookahead3W(81, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                                 ',' | ';' | '=' | '[' :)
              return $state
            else if ($state[$p:lk] eq 3713) then            (: IDENTIFIER '.' :)
              let $state := p:lookahead3W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              return $state
            else if ($state[$p:lk] eq 4481) then            (: IDENTIFIER '<' :)
              let $state := p:lookahead3W(92, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                 MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' |
                                                                 'char' | 'double' | 'float' | 'int' | 'long' | 'short' :)
              return $state
            else if ($state[$p:lk] eq 7425) then            (: IDENTIFIER '[' :)
              let $state := p:lookahead3W(16, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 35) then                  (: '<' :)
          let $state := p:lookahead2W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state :=
            if ($state[$p:lk] eq 163) then                  (: '<' IDENTIFIER :)
              let $state := p:lookahead3W(61, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                                 '>' | 'extends' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] = (64,                       (: 'boolean' :)
                                  66,                       (: 'byte' :)
                                  69,                       (: 'char' :)
                                  74,                       (: 'double' :)
                                  81,                       (: 'float' :)
                                  87,                       (: 'int' :)
                                  89,                       (: 'long' :)
                                  99)) then                 (: 'short' :)
          let $state := p:lookahead2W(29, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '[' :)
          let $state :=
            if ($state[$p:lk] = (192,                       (: 'boolean' IDENTIFIER :)
                                 194,                       (: 'byte' IDENTIFIER :)
                                 197,                       (: 'char' IDENTIFIER :)
                                 202,                       (: 'double' IDENTIFIER :)
                                 209,                       (: 'float' IDENTIFIER :)
                                 215,                       (: 'int' IDENTIFIER :)
                                 217,                       (: 'long' IDENTIFIER :)
                                 227)) then                 (: 'short' IDENTIFIER :)
              let $state := p:lookahead3W(81, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                                 ',' | ';' | '=' | '[' :)
              return $state
            else if ($state[$p:lk] = (7488,                 (: 'boolean' '[' :)
                                      7490,                 (: 'byte' '[' :)
                                      7493,                 (: 'char' '[' :)
                                      7498,                 (: 'double' '[' :)
                                      7505,                 (: 'float' '[' :)
                                      7511,                 (: 'int' '[' :)
                                      7513,                 (: 'long' '[' :)
                                      7523)) then           (: 'short' '[' :)
              let $state := p:lookahead3W(16, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 20097                      (: IDENTIFIER '.' IDENTIFIER :)
              or $state[$p:lk] = 20865                      (: IDENTIFIER '<' IDENTIFIER :)
              or $state[$p:lk] = 409763                     (: '<' IDENTIFIER ',' :)
              or $state[$p:lk] = 671907                     (: '<' IDENTIFIER '>' :)
              or $state[$p:lk] = 741761                     (: IDENTIFIER '<' '?' :)
              or $state[$p:lk] = 974081                     (: IDENTIFIER '[' ']' :)
              or $state[$p:lk] = 974144                     (: 'boolean' '[' ']' :)
              or $state[$p:lk] = 974146                     (: 'byte' '[' ']' :)
              or $state[$p:lk] = 974149                     (: 'char' '[' ']' :)
              or $state[$p:lk] = 974154                     (: 'double' '[' ']' :)
              or $state[$p:lk] = 974161                     (: 'float' '[' ']' :)
              or $state[$p:lk] = 974167                     (: 'int' '[' ']' :)
              or $state[$p:lk] = 974169                     (: 'long' '[' ']' :)
              or $state[$p:lk] = 974179                     (: 'short' '[' ']' :)
              or $state[$p:lk] = 1053057                    (: IDENTIFIER '<' 'boolean' :)
              or $state[$p:lk] = 1085825                    (: IDENTIFIER '<' 'byte' :)
              or $state[$p:lk] = 1134977                    (: IDENTIFIER '<' 'char' :)
              or $state[$p:lk] = 1216897                    (: IDENTIFIER '<' 'double' :)
              or $state[$p:lk] = 1261731                    (: '<' IDENTIFIER 'extends' :)
              or $state[$p:lk] = 1331585                    (: IDENTIFIER '<' 'float' :)
              or $state[$p:lk] = 1429889                    (: IDENTIFIER '<' 'int' :)
              or $state[$p:lk] = 1462657                    (: IDENTIFIER '<' 'long' :)
              or $state[$p:lk] = 1626497) then              (: IDENTIFIER '<' 'short' :)
          let $state := p:memoized($state, 8)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ConstructorDeclaration($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -3, -3)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-FieldDeclaration($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -4, -4)
                    else
                      p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -5, -5)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 70                         (: 'class' :)
              or $state[$p:lk] = 88) then                   (: 'interface' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ClassOrInterfaceDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = 76) then                   (: 'enum' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-EnumDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = -3
         or $state[$p:lk] = 2305) then                      (: IDENTIFIER '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ConstructorDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = -5
         or $state[$p:lk] = 111                             (: 'void' :)
         or $state[$p:lk] = 295041                          (: IDENTIFIER IDENTIFIER '(' :)
         or $state[$p:lk] = 295104                          (: 'boolean' IDENTIFIER '(' :)
         or $state[$p:lk] = 295106                          (: 'byte' IDENTIFIER '(' :)
         or $state[$p:lk] = 295109                          (: 'char' IDENTIFIER '(' :)
         or $state[$p:lk] = 295114                          (: 'double' IDENTIFIER '(' :)
         or $state[$p:lk] = 295121                          (: 'float' IDENTIFIER '(' :)
         or $state[$p:lk] = 295127                          (: 'int' IDENTIFIER '(' :)
         or $state[$p:lk] = 295129                          (: 'long' IDENTIFIER '(' :)
         or $state[$p:lk] = 295139) then                    (: 'short' IDENTIFIER '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-MethodDeclaration($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FieldDeclaration($input, $state)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ClassOrInterfaceBodyDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing ClassOrInterfaceBodyDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ClassOrInterfaceBodyDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 100) then                          (: 'static' :)
      let $state := p:lookahead2W(125, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'class' | 'double' | 'enum' | 'final' |
                                                               'float' | 'int' | 'interface' | 'long' | 'native' |
                                                               'private' | 'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 114                            (: '{' :)
          or $state[$p:lk] = 14692) then                    (: 'static' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Initializer($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: ';' :)
      let $state := p:consumeT(34, $input, $state)          (: ';' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Modifiers($input, $state)
      let $state :=
        if ($state[$p:l1] eq 1) then                        (: IDENTIFIER :)
          let $state := p:lookahead2W(77, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | '.' | '<' | '[' :)
          let $state :=
            if ($state[$p:lk] eq 129) then                  (: IDENTIFIER IDENTIFIER :)
              let $state := p:lookahead3W(81, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                                 ',' | ';' | '=' | '[' :)
              return $state
            else if ($state[$p:lk] eq 3713) then            (: IDENTIFIER '.' :)
              let $state := p:lookahead3W(0, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT :)
              return $state
            else if ($state[$p:lk] eq 4481) then            (: IDENTIFIER '<' :)
              let $state := p:lookahead3W(92, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                 MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' |
                                                                 'char' | 'double' | 'float' | 'int' | 'long' | 'short' :)
              return $state
            else if ($state[$p:lk] eq 7425) then            (: IDENTIFIER '[' :)
              let $state := p:lookahead3W(16, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 35) then                  (: '<' :)
          let $state := p:lookahead2W(0, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
          let $state :=
            if ($state[$p:lk] eq 163) then                  (: '<' IDENTIFIER :)
              let $state := p:lookahead3W(61, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                                 '>' | 'extends' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] = (64,                       (: 'boolean' :)
                                  66,                       (: 'byte' :)
                                  69,                       (: 'char' :)
                                  74,                       (: 'double' :)
                                  81,                       (: 'float' :)
                                  87,                       (: 'int' :)
                                  89,                       (: 'long' :)
                                  99)) then                 (: 'short' :)
          let $state := p:lookahead2W(29, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '[' :)
          let $state :=
            if ($state[$p:lk] = (192,                       (: 'boolean' IDENTIFIER :)
                                 194,                       (: 'byte' IDENTIFIER :)
                                 197,                       (: 'char' IDENTIFIER :)
                                 202,                       (: 'double' IDENTIFIER :)
                                 209,                       (: 'float' IDENTIFIER :)
                                 215,                       (: 'int' IDENTIFIER :)
                                 217,                       (: 'long' IDENTIFIER :)
                                 227)) then                 (: 'short' IDENTIFIER :)
              let $state := p:lookahead3W(81, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                                 ',' | ';' | '=' | '[' :)
              return $state
            else if ($state[$p:lk] = (7488,                 (: 'boolean' '[' :)
                                      7490,                 (: 'byte' '[' :)
                                      7493,                 (: 'char' '[' :)
                                      7498,                 (: 'double' '[' :)
                                      7505,                 (: 'float' '[' :)
                                      7511,                 (: 'int' '[' :)
                                      7513,                 (: 'long' '[' :)
                                      7523)) then           (: 'short' '[' :)
              let $state := p:lookahead3W(16, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 20097                      (: IDENTIFIER '.' IDENTIFIER :)
              or $state[$p:lk] = 20865                      (: IDENTIFIER '<' IDENTIFIER :)
              or $state[$p:lk] = 409763                     (: '<' IDENTIFIER ',' :)
              or $state[$p:lk] = 671907                     (: '<' IDENTIFIER '>' :)
              or $state[$p:lk] = 741761                     (: IDENTIFIER '<' '?' :)
              or $state[$p:lk] = 974081                     (: IDENTIFIER '[' ']' :)
              or $state[$p:lk] = 974144                     (: 'boolean' '[' ']' :)
              or $state[$p:lk] = 974146                     (: 'byte' '[' ']' :)
              or $state[$p:lk] = 974149                     (: 'char' '[' ']' :)
              or $state[$p:lk] = 974154                     (: 'double' '[' ']' :)
              or $state[$p:lk] = 974161                     (: 'float' '[' ']' :)
              or $state[$p:lk] = 974167                     (: 'int' '[' ']' :)
              or $state[$p:lk] = 974169                     (: 'long' '[' ']' :)
              or $state[$p:lk] = 974179                     (: 'short' '[' ']' :)
              or $state[$p:lk] = 1053057                    (: IDENTIFIER '<' 'boolean' :)
              or $state[$p:lk] = 1085825                    (: IDENTIFIER '<' 'byte' :)
              or $state[$p:lk] = 1134977                    (: IDENTIFIER '<' 'char' :)
              or $state[$p:lk] = 1216897                    (: IDENTIFIER '<' 'double' :)
              or $state[$p:lk] = 1261731                    (: '<' IDENTIFIER 'extends' :)
              or $state[$p:lk] = 1331585                    (: IDENTIFIER '<' 'float' :)
              or $state[$p:lk] = 1429889                    (: IDENTIFIER '<' 'int' :)
              or $state[$p:lk] = 1462657                    (: IDENTIFIER '<' 'long' :)
              or $state[$p:lk] = 1626497) then              (: IDENTIFIER '<' 'short' :)
          let $state := p:memoized($state, 8)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ConstructorDeclaration($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -3, -3)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-FieldDeclaration($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -4, -4)
                    else
                      p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -5, -5)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 70                         (: 'class' :)
              or $state[$p:lk] = 88) then                   (: 'interface' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ClassOrInterfaceDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = 76) then                   (: 'enum' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-EnumDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = -3
         or $state[$p:lk] = 2305) then                      (: IDENTIFIER '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ConstructorDeclaration($input, $state)
          return $state
        else if ($state[$p:lk] = -5
         or $state[$p:lk] = 111                             (: 'void' :)
         or $state[$p:lk] = 295041                          (: IDENTIFIER IDENTIFIER '(' :)
         or $state[$p:lk] = 295104                          (: 'boolean' IDENTIFIER '(' :)
         or $state[$p:lk] = 295106                          (: 'byte' IDENTIFIER '(' :)
         or $state[$p:lk] = 295109                          (: 'char' IDENTIFIER '(' :)
         or $state[$p:lk] = 295114                          (: 'double' IDENTIFIER '(' :)
         or $state[$p:lk] = 295121                          (: 'float' IDENTIFIER '(' :)
         or $state[$p:lk] = 295127                          (: 'int' IDENTIFIER '(' :)
         or $state[$p:lk] = 295129                          (: 'long' IDENTIFIER '(' :)
         or $state[$p:lk] = 295139) then                    (: 'short' IDENTIFIER '(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-MethodDeclaration($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FieldDeclaration($input, $state)
          return $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ClassOrInterfaceBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ClassOrInterfaceBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' | '<' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'class' | 'double' |
                                                               'enum' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'void' | 'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ClassOrInterfaceBodyDeclaration($input, $state)
        return p:parse-ClassOrInterfaceBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ClassOrInterfaceBody (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ClassOrInterfaceBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ';' | '<' | '@' | 'abstract' |
                                                               'boolean' | 'byte' | 'char' | 'class' | 'double' |
                                                               'enum' | 'final' | 'float' | 'int' | 'interface' |
                                                               'long' | 'native' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'void' | 'volatile' | '{' | '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ClassOrInterfaceBodyDeclaration($input, $state)
        return p:try-ClassOrInterfaceBody-1($input, $state)
};

(:~
 : Parse ClassOrInterfaceBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ClassOrInterfaceBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:parse-ClassOrInterfaceBody-1($input, $state)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ClassOrInterfaceBody", $count, $begin, $end)
};

(:~
 : Try parsing ClassOrInterfaceBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ClassOrInterfaceBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(114, $input, $state)             (: '{' :)
  let $state := p:try-ClassOrInterfaceBody-1($input, $state)
  let $state := p:consumeT(118, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      return p:try-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expression($input, $state)
  let $state := p:parse-ArgumentList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentList", $count, $begin, $end)
};

(:~
 : Try parsing ArgumentList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expression($input, $state)
  let $state := p:try-ArgumentList-1($input, $state)
  return $state
};

(:~
 : Parse Arguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Arguments($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(142, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 19) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArgumentList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Arguments", $count, $begin, $end)
};

(:~
 : Try parsing Arguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Arguments($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(142, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | ')' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 19) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArgumentList($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse WildcardBounds.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WildcardBounds($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'extends' :)
      let $state := p:consume(77, $input, $state)           (: 'extends' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReferenceType($input, $state)
      return $state
    else
      let $state := p:consume(102, $input, $state)          (: 'super' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReferenceType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WildcardBounds", $count, $begin, $end)
};

(:~
 : Try parsing WildcardBounds.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WildcardBounds($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'extends' :)
      let $state := p:consumeT(77, $input, $state)          (: 'extends' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReferenceType($input, $state)
      return $state
    else
      let $state := p:consumeT(102, $input, $state)         (: 'super' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReferenceType($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ReferenceType (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReferenceType-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(15, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
    let $state := p:consume(58, $input, $state)             (: '[' :)
    let $state := p:lookahead1W(16, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
    let $state := p:consume(59, $input, $state)             (: ']' :)
    let $state := p:lookahead1W(128, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' | '/=' |
                                                               ':' | ';' | '<<=' | '=' | '==' | '>' | '>>=' | '>>>=' |
                                                               '?' | '[' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        p:parse-ReferenceType-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ReferenceType (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReferenceType-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(15, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
    let $state := p:consumeT(58, $input, $state)            (: '[' :)
    let $state := p:lookahead1W(16, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
    let $state := p:consumeT(59, $input, $state)            (: ']' :)
    let $state := p:lookahead1W(128, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' | '/=' |
                                                               ':' | ';' | '<<=' | '=' | '==' | '>' | '>>=' | '>>>=' |
                                                               '?' | '[' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        p:try-ReferenceType-1($input, $state)
};

(:~
 : Parse the 2nd loop of production ReferenceType (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReferenceType-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' | '/=' |
                                                               ':' | ';' | '<<=' | '=' | '==' | '>' | '>>=' | '>>>=' |
                                                               '?' | '[' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        let $state := p:consume(58, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consume(59, $input, $state)         (: ']' :)
        return p:parse-ReferenceType-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production ReferenceType (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReferenceType-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' | '/=' |
                                                               ':' | ';' | '<<=' | '=' | '==' | '>' | '>>=' | '>>>=' |
                                                               '?' | '[' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        let $state := p:consumeT(58, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consumeT(59, $input, $state)        (: ']' :)
        return p:try-ReferenceType-2($input, $state)
};

(:~
 : Parse ReferenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReferenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ClassOrInterfaceType($input, $state)
      let $state := p:parse-ReferenceType-2($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrimitiveType($input, $state)
      let $state := p:parse-ReferenceType-1($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReferenceType", $count, $begin, $end)
};

(:~
 : Try parsing ReferenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReferenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ClassOrInterfaceType($input, $state)
      let $state := p:try-ReferenceType-2($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PrimitiveType($input, $state)
      let $state := p:try-ReferenceType-1($input, $state)
      return $state
  return $state
};

(:~
 : Parse TypeArgument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeArgument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '?' :)
      let $state := p:consume(45, $input, $state)           (: '?' :)
      let $state := p:lookahead1W(72, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '>' | 'extends' | 'super' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 77                         (: 'extends' :)
              or $state[$p:l1] = 102) then                  (: 'super' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-WildcardBounds($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReferenceType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeArgument", $count, $begin, $end)
};

(:~
 : Try parsing TypeArgument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeArgument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '?' :)
      let $state := p:consumeT(45, $input, $state)          (: '?' :)
      let $state := p:lookahead1W(72, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '>' | 'extends' | 'super' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 77                         (: 'extends' :)
              or $state[$p:l1] = 102) then                  (: 'super' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-WildcardBounds($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReferenceType($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production TypeArguments (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeArguments-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(92, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeArgument($input, $state)
      return p:parse-TypeArguments-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypeArguments (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeArguments-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(92, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeArgument($input, $state)
      return p:try-TypeArguments-1($input, $state)
};

(:~
 : Parse TypeArguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeArguments($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(35, $input, $state)               (: '<' :)
  let $state := p:lookahead1W(92, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TypeArgument($input, $state)
  let $state := p:parse-TypeArguments-1($input, $state)
  let $state := p:consume(41, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeArguments", $count, $begin, $end)
};

(:~
 : Try parsing TypeArguments.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeArguments($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(35, $input, $state)              (: '<' :)
  let $state := p:lookahead1W(92, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TypeArgument($input, $state)
  let $state := p:try-TypeArguments-1($input, $state)
  let $state := p:consumeT(41, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse the 1st loop of production ClassOrInterfaceType (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ClassOrInterfaceType-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(134, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               '(' | ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 29) then                         (: '.' :)
        let $state := p:lookahead2W(30, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'class' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 157) then                        (: '.' IDENTIFIER :)
        $state
      else
        let $state := p:consume(29, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state := p:consume(1, $input, $state)          (: IDENTIFIER :)
        let $state := p:lookahead1W(134, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               '(' | ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
        let $state :=
          if ($state[$p:l1] eq 35) then                     (: '<' :)
            let $state := p:lookahead2W(92, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
            let $state :=
              if ($state[$p:lk] eq 163) then                (: '<' IDENTIFIER :)
                let $state := p:lookahead3W(85, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                   ',' | '.' | '<' | '>' | '[' :)
                return $state
              else if ($state[$p:lk] eq 5795) then          (: '<' '?' :)
                let $state := p:lookahead3W(72, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                   ',' | '>' | 'extends' | 'super' :)
                return $state
              else if ($state[$p:lk] = (8227,               (: '<' 'boolean' :)
                                        8483,               (: '<' 'byte' :)
                                        8867,               (: '<' 'char' :)
                                        9507,               (: '<' 'double' :)
                                        10403,              (: '<' 'float' :)
                                        11171,              (: '<' 'int' :)
                                        11427,              (: '<' 'long' :)
                                        12707)) then        (: '<' 'short' :)
                let $state := p:lookahead3W(15, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 409763                   (: '<' IDENTIFIER ',' :)
                or $state[$p:lk] = 415395                   (: '<' '?' ',' :)
                or $state[$p:lk] = 475299                   (: '<' IDENTIFIER '.' :)
                or $state[$p:lk] = 573603                   (: '<' IDENTIFIER '<' :)
                or $state[$p:lk] = 671907                   (: '<' IDENTIFIER '>' :)
                or $state[$p:lk] = 677539                   (: '<' '?' '>' :)
                or $state[$p:lk] = 950435                   (: '<' IDENTIFIER '[' :)
                or $state[$p:lk] = 958499                   (: '<' 'boolean' '[' :)
                or $state[$p:lk] = 958755                   (: '<' 'byte' '[' :)
                or $state[$p:lk] = 959139                   (: '<' 'char' '[' :)
                or $state[$p:lk] = 959779                   (: '<' 'double' '[' :)
                or $state[$p:lk] = 960675                   (: '<' 'float' '[' :)
                or $state[$p:lk] = 961443                   (: '<' 'int' '[' :)
                or $state[$p:lk] = 961699                   (: '<' 'long' '[' :)
                or $state[$p:lk] = 962979                   (: '<' 'short' '[' :)
                or $state[$p:lk] = 1267363                  (: '<' '?' 'extends' :)
                or $state[$p:lk] = 1676963) then            (: '<' '?' 'super' :)
            let $state := p:memoized($state, 12)
            return
              if ($state[$p:lk] != 0) then
                $state
              else
                let $backtrack := $state
                let $state := p:strip-result($state)
                let $state :=
                  if ($state[$p:error]) then
                    $state
                  else
                    p:try-TypeArguments($input, $state)
                return
                  if (not($state[$p:error])) then
                    p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -1, -1)
                  else
                    p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -2, -2)
          else
            $state
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = -1) then
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-TypeArguments($input, $state)
            return $state
          else
            $state
        return p:parse-ClassOrInterfaceType-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ClassOrInterfaceType (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ClassOrInterfaceType-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(134, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               '(' | ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 29) then                         (: '.' :)
        let $state := p:lookahead2W(30, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'class' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 157) then                        (: '.' IDENTIFIER :)
        $state
      else
        let $state := p:consumeT(29, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state := p:consumeT(1, $input, $state)         (: IDENTIFIER :)
        let $state := p:lookahead1W(134, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               '(' | ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
        let $state :=
          if ($state[$p:l1] eq 35) then                     (: '<' :)
            let $state := p:lookahead2W(92, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
            let $state :=
              if ($state[$p:lk] eq 163) then                (: '<' IDENTIFIER :)
                let $state := p:lookahead3W(85, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                   ',' | '.' | '<' | '>' | '[' :)
                return $state
              else if ($state[$p:lk] eq 5795) then          (: '<' '?' :)
                let $state := p:lookahead3W(72, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                                   ',' | '>' | 'extends' | 'super' :)
                return $state
              else if ($state[$p:lk] = (8227,               (: '<' 'boolean' :)
                                        8483,               (: '<' 'byte' :)
                                        8867,               (: '<' 'char' :)
                                        9507,               (: '<' 'double' :)
                                        10403,              (: '<' 'float' :)
                                        11171,              (: '<' 'int' :)
                                        11427,              (: '<' 'long' :)
                                        12707)) then        (: '<' 'short' :)
                let $state := p:lookahead3W(15, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 409763                   (: '<' IDENTIFIER ',' :)
                or $state[$p:lk] = 415395                   (: '<' '?' ',' :)
                or $state[$p:lk] = 475299                   (: '<' IDENTIFIER '.' :)
                or $state[$p:lk] = 573603                   (: '<' IDENTIFIER '<' :)
                or $state[$p:lk] = 671907                   (: '<' IDENTIFIER '>' :)
                or $state[$p:lk] = 677539                   (: '<' '?' '>' :)
                or $state[$p:lk] = 950435                   (: '<' IDENTIFIER '[' :)
                or $state[$p:lk] = 958499                   (: '<' 'boolean' '[' :)
                or $state[$p:lk] = 958755                   (: '<' 'byte' '[' :)
                or $state[$p:lk] = 959139                   (: '<' 'char' '[' :)
                or $state[$p:lk] = 959779                   (: '<' 'double' '[' :)
                or $state[$p:lk] = 960675                   (: '<' 'float' '[' :)
                or $state[$p:lk] = 961443                   (: '<' 'int' '[' :)
                or $state[$p:lk] = 961699                   (: '<' 'long' '[' :)
                or $state[$p:lk] = 962979                   (: '<' 'short' '[' :)
                or $state[$p:lk] = 1267363                  (: '<' '?' 'extends' :)
                or $state[$p:lk] = 1676963) then            (: '<' '?' 'super' :)
            let $state := p:memoized($state, 12)
            return
              if ($state[$p:lk] != 0) then
                $state
              else
                let $backtrack := $state
                let $state := p:strip-result($state)
                let $state :=
                  if ($state[$p:error]) then
                    $state
                  else
                    p:try-TypeArguments($input, $state)
                return
                  if (not($state[$p:error])) then
                    p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -1, -1)
                  else
                    p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -2, -2)
          else
            $state
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = -1) then
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-TypeArguments($input, $state)
            return $state
          else
            $state
        return p:try-ClassOrInterfaceType-1($input, $state)
};

(:~
 : Parse ClassOrInterfaceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ClassOrInterfaceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(134, $input, $state)          (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               '(' | ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
  let $state :=
    if ($state[$p:l1] eq 35) then                           (: '<' :)
      let $state := p:lookahead2W(92, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:lk] eq 163) then                      (: '<' IDENTIFIER :)
          let $state := p:lookahead3W(85, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '.' | '<' | '>' | '[' :)
          return $state
        else if ($state[$p:lk] eq 5795) then                (: '<' '?' :)
          let $state := p:lookahead3W(72, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '>' | 'extends' | 'super' :)
          return $state
        else if ($state[$p:lk] = (8227,                     (: '<' 'boolean' :)
                                  8483,                     (: '<' 'byte' :)
                                  8867,                     (: '<' 'char' :)
                                  9507,                     (: '<' 'double' :)
                                  10403,                    (: '<' 'float' :)
                                  11171,                    (: '<' 'int' :)
                                  11427,                    (: '<' 'long' :)
                                  12707)) then              (: '<' 'short' :)
          let $state := p:lookahead3W(15, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 409763                         (: '<' IDENTIFIER ',' :)
          or $state[$p:lk] = 415395                         (: '<' '?' ',' :)
          or $state[$p:lk] = 475299                         (: '<' IDENTIFIER '.' :)
          or $state[$p:lk] = 573603                         (: '<' IDENTIFIER '<' :)
          or $state[$p:lk] = 671907                         (: '<' IDENTIFIER '>' :)
          or $state[$p:lk] = 677539                         (: '<' '?' '>' :)
          or $state[$p:lk] = 950435                         (: '<' IDENTIFIER '[' :)
          or $state[$p:lk] = 958499                         (: '<' 'boolean' '[' :)
          or $state[$p:lk] = 958755                         (: '<' 'byte' '[' :)
          or $state[$p:lk] = 959139                         (: '<' 'char' '[' :)
          or $state[$p:lk] = 959779                         (: '<' 'double' '[' :)
          or $state[$p:lk] = 960675                         (: '<' 'float' '[' :)
          or $state[$p:lk] = 961443                         (: '<' 'int' '[' :)
          or $state[$p:lk] = 961699                         (: '<' 'long' '[' :)
          or $state[$p:lk] = 962979                         (: '<' 'short' '[' :)
          or $state[$p:lk] = 1267363                        (: '<' '?' 'extends' :)
          or $state[$p:lk] = 1676963) then                  (: '<' '?' 'super' :)
      let $state := p:memoized($state, 11)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeArguments($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeArguments($input, $state)
      return $state
    else
      $state
  let $state := p:parse-ClassOrInterfaceType-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ClassOrInterfaceType", $count, $begin, $end)
};

(:~
 : Try parsing ClassOrInterfaceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ClassOrInterfaceType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(134, $input, $state)          (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%=' | '&' | '&&' | '&=' |
                                                               '(' | ')' | '*=' | '+=' | ',' | '-=' | '.' | '...' |
                                                               '/=' | ':' | ';' | '<' | '<<=' | '=' | '==' | '>' |
                                                               '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                               'implements' | '{' | '|' | '|=' | '||' | '}' :)
  let $state :=
    if ($state[$p:l1] eq 35) then                           (: '<' :)
      let $state := p:lookahead2W(92, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '?' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:lk] eq 163) then                      (: '<' IDENTIFIER :)
          let $state := p:lookahead3W(85, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '.' | '<' | '>' | '[' :)
          return $state
        else if ($state[$p:lk] eq 5795) then                (: '<' '?' :)
          let $state := p:lookahead3W(72, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '>' | 'extends' | 'super' :)
          return $state
        else if ($state[$p:lk] = (8227,                     (: '<' 'boolean' :)
                                  8483,                     (: '<' 'byte' :)
                                  8867,                     (: '<' 'char' :)
                                  9507,                     (: '<' 'double' :)
                                  10403,                    (: '<' 'float' :)
                                  11171,                    (: '<' 'int' :)
                                  11427,                    (: '<' 'long' :)
                                  12707)) then              (: '<' 'short' :)
          let $state := p:lookahead3W(15, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 409763                         (: '<' IDENTIFIER ',' :)
          or $state[$p:lk] = 415395                         (: '<' '?' ',' :)
          or $state[$p:lk] = 475299                         (: '<' IDENTIFIER '.' :)
          or $state[$p:lk] = 573603                         (: '<' IDENTIFIER '<' :)
          or $state[$p:lk] = 671907                         (: '<' IDENTIFIER '>' :)
          or $state[$p:lk] = 677539                         (: '<' '?' '>' :)
          or $state[$p:lk] = 950435                         (: '<' IDENTIFIER '[' :)
          or $state[$p:lk] = 958499                         (: '<' 'boolean' '[' :)
          or $state[$p:lk] = 958755                         (: '<' 'byte' '[' :)
          or $state[$p:lk] = 959139                         (: '<' 'char' '[' :)
          or $state[$p:lk] = 959779                         (: '<' 'double' '[' :)
          or $state[$p:lk] = 960675                         (: '<' 'float' '[' :)
          or $state[$p:lk] = 961443                         (: '<' 'int' '[' :)
          or $state[$p:lk] = 961699                         (: '<' 'long' '[' :)
          or $state[$p:lk] = 962979                         (: '<' 'short' '[' :)
          or $state[$p:lk] = 1267363                        (: '<' '?' 'extends' :)
          or $state[$p:lk] = 1676963) then                  (: '<' '?' 'super' :)
      let $state := p:memoized($state, 11)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeArguments($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeArguments($input, $state)
      return $state
    else
      $state
  let $state := p:try-ClassOrInterfaceType-1($input, $state)
  return $state
};

(:~
 : Parse VariableInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VariableInitializer($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableInitializer", $count, $begin, $end)
};

(:~
 : Try parsing VariableInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VariableInitializer($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ArrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '}' :)
    let $state :=
      if ($state[$p:l1] eq 25) then                         (: ',' :)
        let $state := p:lookahead2W(151, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 118                               (: '}' :)
       or $state[$p:lk] = 15129) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(147, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VariableInitializer($input, $state)
        return p:parse-ArrayInitializer-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '}' :)
    let $state :=
      if ($state[$p:l1] eq 25) then                         (: ',' :)
        let $state := p:lookahead2W(151, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 118                               (: '}' :)
       or $state[$p:lk] = 15129) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(147, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-VariableInitializer($input, $state)
        return p:try-ArrayInitializer-1($input, $state)
};

(:~
 : Parse ArrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(154, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | ',' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 25                            (: ',' :)
         and $state[$p:l1] != 118) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VariableInitializer($input, $state)
      let $state := p:parse-ArrayInitializer-1($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consume(25, $input, $state)           (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '}' :)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayInitializer", $count, $begin, $end)
};

(:~
 : Try parsing ArrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(114, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(154, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | ',' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 25                            (: ',' :)
         and $state[$p:l1] != 118) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VariableInitializer($input, $state)
      let $state := p:try-ArrayInitializer-1($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '}' :)
  let $state := p:consumeT(118, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production ArrayDimsAndInits (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayDimsAndInits-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(58, $input, $state)             (: '[' :)
    let $state := p:lookahead1W(139, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expression($input, $state)
    let $state := p:consume(59, $input, $state)             (: ']' :)
    let $state := p:lookahead1W(159, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 58) then                         (: '[' :)
        let $state := p:lookahead2W(146, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state :=
          if ($state[$p:lk] eq 11706) then                  (: '[' 'new' :)
            let $state := p:lookahead3W(91, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
            return $state
          else if ($state[$p:lk] = (3002,                   (: '[' '++' :)
                                    3514)) then             (: '[' '--' :)
            let $state := p:lookahead3W(129, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                                'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                                'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
            return $state
          else if ($state[$p:lk] = (13114,                  (: '[' 'super' :)
                                    14266)) then            (: '[' 'void' :)
            let $state := p:lookahead3W(6, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
            return $state
          else if ($state[$p:lk] = (1338,                   (: '[' '!' :)
                                    2362,                   (: '[' '(' :)
                                    2874,                   (: '[' '+' :)
                                    3386,                   (: '[' '-' :)
                                    15290)) then            (: '[' '~' :)
            let $state := p:lookahead3W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'void' | '~' :)
            return $state
          else if ($state[$p:lk] = (8250,                   (: '[' 'boolean' :)
                                    8506,                   (: '[' 'byte' :)
                                    8890,                   (: '[' 'char' :)
                                    9530,                   (: '[' 'double' :)
                                    10426,                  (: '[' 'float' :)
                                    11194,                  (: '[' 'int' :)
                                    11450,                  (: '[' 'long' :)
                                    12730)) then            (: '[' 'short' :)
            let $state := p:lookahead3W(43, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
            return $state
          else if ($state[$p:lk] = (186,                    (: '[' IDENTIFIER :)
                                    570,                    (: '[' INTEGER_LITERAL :)
                                    698,                    (: '[' FLOATING_POINT_LITERAL :)
                                    826,                    (: '[' CHARACTER_LITERAL :)
                                    954,                    (: '[' STRING_LITERAL :)
                                    6074,                   (: '[' 'EOF' :)
                                    6202,                   (: '[' 'IGNORE_CASE' :)
                                    6330,                   (: '[' 'JAVACODE' :)
                                    6458,                   (: '[' 'LOOKAHEAD' :)
                                    6586,                   (: '[' 'MORE' :)
                                    6714,                   (: '[' 'PARSER_BEGIN' :)
                                    6842,                   (: '[' 'PARSER_END' :)
                                    6970,                   (: '[' 'SKIP' :)
                                    7098,                   (: '[' 'SPECIAL_TOKEN' :)
                                    7226,                   (: '[' 'TOKEN' :)
                                    7354,                   (: '[' 'TOKEN_MGR_DECLS' :)
                                    10042,                  (: '[' 'false' :)
                                    11834,                  (: '[' 'null' :)
                                    13498,                  (: '[' 'this' :)
                                    14010)) then            (: '[' 'true' :)
            let $state := p:lookahead3W(137, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                                '%' | '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' |
                                                                '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                                '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                                '>=' | '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                                'instanceof' | '|' | '|=' | '||' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 11                          (: '!=' :)
           and $state[$p:lk] != 13                          (: '%' :)
           and $state[$p:lk] != 14                          (: '%=' :)
           and $state[$p:lk] != 15                          (: '&' :)
           and $state[$p:lk] != 16                          (: '&&' :)
           and $state[$p:lk] != 17                          (: '&=' :)
           and $state[$p:lk] != 18                          (: '(' :)
           and $state[$p:lk] != 19                          (: ')' :)
           and $state[$p:lk] != 20                          (: '*' :)
           and $state[$p:lk] != 21                          (: '*=' :)
           and $state[$p:lk] != 22                          (: '+' :)
           and $state[$p:lk] != 23                          (: '++' :)
           and $state[$p:lk] != 24                          (: '+=' :)
           and $state[$p:lk] != 25                          (: ',' :)
           and $state[$p:lk] != 26                          (: '-' :)
           and $state[$p:lk] != 27                          (: '--' :)
           and $state[$p:lk] != 28                          (: '-=' :)
           and $state[$p:lk] != 29                          (: '.' :)
           and $state[$p:lk] != 31                          (: '/' :)
           and $state[$p:lk] != 32                          (: '/=' :)
           and $state[$p:lk] != 33                          (: ':' :)
           and $state[$p:lk] != 34                          (: ';' :)
           and $state[$p:lk] != 35                          (: '<' :)
           and $state[$p:lk] != 36                          (: '<<' :)
           and $state[$p:lk] != 37                          (: '<<=' :)
           and $state[$p:lk] != 38                          (: '<=' :)
           and $state[$p:lk] != 39                          (: '=' :)
           and $state[$p:lk] != 40                          (: '==' :)
           and $state[$p:lk] != 41                          (: '>' :)
           and $state[$p:lk] != 42                          (: '>=' :)
           and $state[$p:lk] != 43                          (: '>>=' :)
           and $state[$p:lk] != 44                          (: '>>>=' :)
           and $state[$p:lk] != 45                          (: '?' :)
           and $state[$p:lk] != 59                          (: ']' :)
           and $state[$p:lk] != 60                          (: '^' :)
           and $state[$p:lk] != 61                          (: '^=' :)
           and $state[$p:lk] != 86                          (: 'instanceof' :)
           and $state[$p:lk] != 115                         (: '|' :)
           and $state[$p:lk] != 116                         (: '|=' :)
           and $state[$p:lk] != 117                         (: '||' :)
           and $state[$p:lk] != 118                         (: '}' :)
           and $state[$p:lk] != 7610) then                  (: '[' ']' :)
        let $state := p:memoized($state, 18)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(58, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'void' | '~' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Expression($input, $state)
            let $state := p:consumeT(59, $input, $state)    (: ']' :)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        p:parse-ArrayDimsAndInits-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArrayDimsAndInits (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayDimsAndInits-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consumeT(58, $input, $state)            (: '[' :)
    let $state := p:lookahead1W(139, $input, $state)        (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-Expression($input, $state)
    let $state := p:consumeT(59, $input, $state)            (: ']' :)
    let $state := p:lookahead1W(159, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 58) then                         (: '[' :)
        let $state := p:lookahead2W(146, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state :=
          if ($state[$p:lk] eq 11706) then                  (: '[' 'new' :)
            let $state := p:lookahead3W(91, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
            return $state
          else if ($state[$p:lk] = (3002,                   (: '[' '++' :)
                                    3514)) then             (: '[' '--' :)
            let $state := p:lookahead3W(129, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                                'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                                'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
            return $state
          else if ($state[$p:lk] = (13114,                  (: '[' 'super' :)
                                    14266)) then            (: '[' 'void' :)
            let $state := p:lookahead3W(6, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
            return $state
          else if ($state[$p:lk] = (1338,                   (: '[' '!' :)
                                    2362,                   (: '[' '(' :)
                                    2874,                   (: '[' '+' :)
                                    3386,                   (: '[' '-' :)
                                    15290)) then            (: '[' '~' :)
            let $state := p:lookahead3W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'void' | '~' :)
            return $state
          else if ($state[$p:lk] = (8250,                   (: '[' 'boolean' :)
                                    8506,                   (: '[' 'byte' :)
                                    8890,                   (: '[' 'char' :)
                                    9530,                   (: '[' 'double' :)
                                    10426,                  (: '[' 'float' :)
                                    11194,                  (: '[' 'int' :)
                                    11450,                  (: '[' 'long' :)
                                    12730)) then            (: '[' 'short' :)
            let $state := p:lookahead3W(43, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
            return $state
          else if ($state[$p:lk] = (186,                    (: '[' IDENTIFIER :)
                                    570,                    (: '[' INTEGER_LITERAL :)
                                    698,                    (: '[' FLOATING_POINT_LITERAL :)
                                    826,                    (: '[' CHARACTER_LITERAL :)
                                    954,                    (: '[' STRING_LITERAL :)
                                    6074,                   (: '[' 'EOF' :)
                                    6202,                   (: '[' 'IGNORE_CASE' :)
                                    6330,                   (: '[' 'JAVACODE' :)
                                    6458,                   (: '[' 'LOOKAHEAD' :)
                                    6586,                   (: '[' 'MORE' :)
                                    6714,                   (: '[' 'PARSER_BEGIN' :)
                                    6842,                   (: '[' 'PARSER_END' :)
                                    6970,                   (: '[' 'SKIP' :)
                                    7098,                   (: '[' 'SPECIAL_TOKEN' :)
                                    7226,                   (: '[' 'TOKEN' :)
                                    7354,                   (: '[' 'TOKEN_MGR_DECLS' :)
                                    10042,                  (: '[' 'false' :)
                                    11834,                  (: '[' 'null' :)
                                    13498,                  (: '[' 'this' :)
                                    14010)) then            (: '[' 'true' :)
            let $state := p:lookahead3W(137, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                                '%' | '%=' | '&' | '&&' | '&=' | '(' | '*' | '*=' |
                                                                '+' | '++' | '+=' | '-' | '--' | '-=' | '.' | '/' |
                                                                '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' |
                                                                '>=' | '>>=' | '>>>=' | '?' | '[' | ']' | '^' | '^=' |
                                                                'instanceof' | '|' | '|=' | '||' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 11                          (: '!=' :)
           and $state[$p:lk] != 13                          (: '%' :)
           and $state[$p:lk] != 14                          (: '%=' :)
           and $state[$p:lk] != 15                          (: '&' :)
           and $state[$p:lk] != 16                          (: '&&' :)
           and $state[$p:lk] != 17                          (: '&=' :)
           and $state[$p:lk] != 18                          (: '(' :)
           and $state[$p:lk] != 19                          (: ')' :)
           and $state[$p:lk] != 20                          (: '*' :)
           and $state[$p:lk] != 21                          (: '*=' :)
           and $state[$p:lk] != 22                          (: '+' :)
           and $state[$p:lk] != 23                          (: '++' :)
           and $state[$p:lk] != 24                          (: '+=' :)
           and $state[$p:lk] != 25                          (: ',' :)
           and $state[$p:lk] != 26                          (: '-' :)
           and $state[$p:lk] != 27                          (: '--' :)
           and $state[$p:lk] != 28                          (: '-=' :)
           and $state[$p:lk] != 29                          (: '.' :)
           and $state[$p:lk] != 31                          (: '/' :)
           and $state[$p:lk] != 32                          (: '/=' :)
           and $state[$p:lk] != 33                          (: ':' :)
           and $state[$p:lk] != 34                          (: ';' :)
           and $state[$p:lk] != 35                          (: '<' :)
           and $state[$p:lk] != 36                          (: '<<' :)
           and $state[$p:lk] != 37                          (: '<<=' :)
           and $state[$p:lk] != 38                          (: '<=' :)
           and $state[$p:lk] != 39                          (: '=' :)
           and $state[$p:lk] != 40                          (: '==' :)
           and $state[$p:lk] != 41                          (: '>' :)
           and $state[$p:lk] != 42                          (: '>=' :)
           and $state[$p:lk] != 43                          (: '>>=' :)
           and $state[$p:lk] != 44                          (: '>>>=' :)
           and $state[$p:lk] != 45                          (: '?' :)
           and $state[$p:lk] != 59                          (: ']' :)
           and $state[$p:lk] != 60                          (: '^' :)
           and $state[$p:lk] != 61                          (: '^=' :)
           and $state[$p:lk] != 86                          (: 'instanceof' :)
           and $state[$p:lk] != 115                         (: '|' :)
           and $state[$p:lk] != 116                         (: '|=' :)
           and $state[$p:lk] != 117                         (: '||' :)
           and $state[$p:lk] != 118                         (: '}' :)
           and $state[$p:lk] != 7610) then                  (: '[' ']' :)
        let $state := p:memoized($state, 18)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(58, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(139, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                                'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                                'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                                'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                                'super' | 'this' | 'true' | 'void' | '~' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Expression($input, $state)
            let $state := p:consumeT(59, $input, $state)    (: ']' :)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 18, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-ArrayDimsAndInits-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        p:try-ArrayDimsAndInits-1($input, $state)
};

(:~
 : Parse the 2nd loop of production ArrayDimsAndInits (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayDimsAndInits-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(159, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 58) then                         (: '[' :)
        let $state := p:lookahead2W(146, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 7610) then                       (: '[' ']' :)
        $state
      else
        let $state := p:consume(58, $input, $state)         (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consume(59, $input, $state)         (: ']' :)
        return p:parse-ArrayDimsAndInits-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production ArrayDimsAndInits (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayDimsAndInits-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(159, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 58) then                         (: '[' :)
        let $state := p:lookahead2W(146, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 7610) then                       (: '[' ']' :)
        $state
      else
        let $state := p:consumeT(58, $input, $state)        (: '[' :)
        let $state := p:lookahead1W(16, $input, $state)     (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
        let $state := p:consumeT(59, $input, $state)        (: ']' :)
        return p:try-ArrayDimsAndInits-2($input, $state)
};

(:~
 : Parse the 3rd loop of production ArrayDimsAndInits (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayDimsAndInits-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(58, $input, $state)             (: '[' :)
    let $state := p:lookahead1W(16, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
    let $state := p:consume(59, $input, $state)             (: ']' :)
    let $state := p:lookahead1W(50, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' |
                                                               '{' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        p:parse-ArrayDimsAndInits-3($input, $state)
};

(:~
 : Try parsing the 3rd loop of production ArrayDimsAndInits (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayDimsAndInits-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consumeT(58, $input, $state)            (: '[' :)
    let $state := p:lookahead1W(16, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ']' :)
    let $state := p:consumeT(59, $input, $state)            (: ']' :)
    let $state := p:lookahead1W(50, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' |
                                                               '{' :)
    return
      if ($state[$p:l1] != 58) then                         (: '[' :)
        $state
      else
        p:try-ArrayDimsAndInits-3($input, $state)
};

(:~
 : Parse ArrayDimsAndInits.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayDimsAndInits($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 58) then                           (: '[' :)
      let $state := p:lookahead2W(146, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7610) then                     (: '[' ']' :)
      let $state := p:parse-ArrayDimsAndInits-3($input, $state)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArrayInitializer($input, $state)
      return $state
    else
      let $state := p:parse-ArrayDimsAndInits-1($input, $state)
      let $state := p:parse-ArrayDimsAndInits-2($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayDimsAndInits", $count, $begin, $end)
};

(:~
 : Try parsing ArrayDimsAndInits.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayDimsAndInits($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 58) then                           (: '[' :)
      let $state := p:lookahead2W(146, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7610) then                     (: '[' ']' :)
      let $state := p:try-ArrayDimsAndInits-3($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArrayInitializer($input, $state)
      return $state
    else
      let $state := p:try-ArrayDimsAndInits-1($input, $state)
      let $state := p:try-ArrayDimsAndInits-2($input, $state)
      return $state
  return $state
};

(:~
 : Parse PrimitiveType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimitiveType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: 'boolean' :)
      let $state := p:consume(64, $input, $state)           (: 'boolean' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'char' :)
      let $state := p:consume(69, $input, $state)           (: 'char' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'byte' :)
      let $state := p:consume(66, $input, $state)           (: 'byte' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'short' :)
      let $state := p:consume(99, $input, $state)           (: 'short' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'int' :)
      let $state := p:consume(87, $input, $state)           (: 'int' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'long' :)
      let $state := p:consume(89, $input, $state)           (: 'long' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'float' :)
      let $state := p:consume(81, $input, $state)           (: 'float' :)
      return $state
    else
      let $state := p:consume(74, $input, $state)           (: 'double' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimitiveType", $count, $begin, $end)
};

(:~
 : Try parsing PrimitiveType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrimitiveType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: 'boolean' :)
      let $state := p:consumeT(64, $input, $state)          (: 'boolean' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'char' :)
      let $state := p:consumeT(69, $input, $state)          (: 'char' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'byte' :)
      let $state := p:consumeT(66, $input, $state)          (: 'byte' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'short' :)
      let $state := p:consumeT(99, $input, $state)          (: 'short' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'int' :)
      let $state := p:consumeT(87, $input, $state)          (: 'int' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'long' :)
      let $state := p:consumeT(89, $input, $state)          (: 'long' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'float' :)
      let $state := p:consumeT(81, $input, $state)          (: 'float' :)
      return $state
    else
      let $state := p:consumeT(74, $input, $state)          (: 'double' :)
      return $state
  return $state
};

(:~
 : Parse AllocationExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AllocationExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 91) then                           (: 'new' :)
      let $state := p:lookahead2W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 219) then                      (: 'new' IDENTIFIER :)
      let $state := p:consume(91, $input, $state)           (: 'new' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ClassOrInterfaceType($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: '<' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeArguments($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(35, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 58) then                   (: '[' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayDimsAndInits($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Arguments($input, $state)
          let $state := p:lookahead1W(163, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '{' | '|' | '|=' | '||' | '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 114) then              (: '{' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-ClassOrInterfaceBody($input, $state)
              return $state
            else
              $state
          return $state
      return $state
    else
      let $state := p:consume(91, $input, $state)           (: 'new' :)
      let $state := p:lookahead1W(90, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrimitiveType($input, $state)
      let $state := p:lookahead1W(15, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArrayDimsAndInits($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AllocationExpression", $count, $begin, $end)
};

(:~
 : Try parsing AllocationExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AllocationExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 91) then                           (: 'new' :)
      let $state := p:lookahead2W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 219) then                      (: 'new' IDENTIFIER :)
      let $state := p:consumeT(91, $input, $state)          (: 'new' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ClassOrInterfaceType($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: '<' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeArguments($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(35, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 58) then                   (: '[' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ArrayDimsAndInits($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Arguments($input, $state)
          let $state := p:lookahead1W(163, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '{' | '|' | '|=' | '||' | '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 114) then              (: '{' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ClassOrInterfaceBody($input, $state)
              return $state
            else
              $state
          return $state
      return $state
    else
      let $state := p:consumeT(91, $input, $state)          (: 'new' :)
      let $state := p:lookahead1W(90, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PrimitiveType($input, $state)
      let $state := p:lookahead1W(15, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArrayDimsAndInits($input, $state)
      return $state
  return $state
};

(:~
 : Parse AssignmentOperator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AssignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39) then                       (: '=' :)
      let $state := p:consume(39, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 21) then                       (: '*=' :)
      let $state := p:consume(21, $input, $state)           (: '*=' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: '/=' :)
      let $state := p:consume(32, $input, $state)           (: '/=' :)
      return $state
    else if ($state[$p:l1] = 14) then                       (: '%=' :)
      let $state := p:consume(14, $input, $state)           (: '%=' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: '+=' :)
      let $state := p:consume(24, $input, $state)           (: '+=' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: '-=' :)
      let $state := p:consume(28, $input, $state)           (: '-=' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: '<<=' :)
      let $state := p:consume(37, $input, $state)           (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 43) then                       (: '>>=' :)
      let $state := p:consume(43, $input, $state)           (: '>>=' :)
      return $state
    else if ($state[$p:l1] = 44) then                       (: '>>>=' :)
      let $state := p:consume(44, $input, $state)           (: '>>>=' :)
      return $state
    else if ($state[$p:l1] = 17) then                       (: '&=' :)
      let $state := p:consume(17, $input, $state)           (: '&=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '^=' :)
      let $state := p:consume(61, $input, $state)           (: '^=' :)
      return $state
    else
      let $state := p:consume(116, $input, $state)          (: '|=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentOperator", $count, $begin, $end)
};

(:~
 : Try parsing AssignmentOperator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AssignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39) then                       (: '=' :)
      let $state := p:consumeT(39, $input, $state)          (: '=' :)
      return $state
    else if ($state[$p:l1] = 21) then                       (: '*=' :)
      let $state := p:consumeT(21, $input, $state)          (: '*=' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: '/=' :)
      let $state := p:consumeT(32, $input, $state)          (: '/=' :)
      return $state
    else if ($state[$p:l1] = 14) then                       (: '%=' :)
      let $state := p:consumeT(14, $input, $state)          (: '%=' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: '+=' :)
      let $state := p:consumeT(24, $input, $state)          (: '+=' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: '-=' :)
      let $state := p:consumeT(28, $input, $state)          (: '-=' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: '<<=' :)
      let $state := p:consumeT(37, $input, $state)          (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 43) then                       (: '>>=' :)
      let $state := p:consumeT(43, $input, $state)          (: '>>=' :)
      return $state
    else if ($state[$p:l1] = 44) then                       (: '>>>=' :)
      let $state := p:consumeT(44, $input, $state)          (: '>>>=' :)
      return $state
    else if ($state[$p:l1] = 17) then                       (: '&=' :)
      let $state := p:consumeT(17, $input, $state)          (: '&=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '^=' :)
      let $state := p:consumeT(61, $input, $state)          (: '^=' :)
      return $state
    else
      let $state := p:consumeT(116, $input, $state)         (: '|=' :)
      return $state
  return $state
};

(:~
 : Parse Expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ConditionalExpression($input, $state)
  let $state :=
    if ($state[$p:l1] = (14,                                (: '%=' :)
                         17,                                (: '&=' :)
                         21,                                (: '*=' :)
                         24,                                (: '+=' :)
                         28,                                (: '-=' :)
                         32,                                (: '/=' :)
                         37,                                (: '<<=' :)
                         39,                                (: '=' :)
                         43,                                (: '>>=' :)
                         44,                                (: '>>>=' :)
                         61,                                (: '^=' :)
                         116)) then                         (: '|=' :)
      let $state := p:lookahead2W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:lk] = (11662,                         (: '%=' 'new' :)
                             11665,                         (: '&=' 'new' :)
                             11669,                         (: '*=' 'new' :)
                             11672,                         (: '+=' 'new' :)
                             11676,                         (: '-=' 'new' :)
                             11680,                         (: '/=' 'new' :)
                             11685,                         (: '<<=' 'new' :)
                             11687,                         (: '=' 'new' :)
                             11691,                         (: '>>=' 'new' :)
                             11692,                         (: '>>>=' 'new' :)
                             11709,                         (: '^=' 'new' :)
                             11764)) then                   (: '|=' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] = (2958,                     (: '%=' '++' :)
                                  3470,                     (: '%=' '--' :)
                                  2961,                     (: '&=' '++' :)
                                  3473,                     (: '&=' '--' :)
                                  2965,                     (: '*=' '++' :)
                                  3477,                     (: '*=' '--' :)
                                  2968,                     (: '+=' '++' :)
                                  3480,                     (: '+=' '--' :)
                                  2972,                     (: '-=' '++' :)
                                  3484,                     (: '-=' '--' :)
                                  2976,                     (: '/=' '++' :)
                                  3488,                     (: '/=' '--' :)
                                  2981,                     (: '<<=' '++' :)
                                  3493,                     (: '<<=' '--' :)
                                  2983,                     (: '=' '++' :)
                                  3495,                     (: '=' '--' :)
                                  2987,                     (: '>>=' '++' :)
                                  3499,                     (: '>>=' '--' :)
                                  2988,                     (: '>>>=' '++' :)
                                  3500,                     (: '>>>=' '--' :)
                                  3005,                     (: '^=' '++' :)
                                  3517,                     (: '^=' '--' :)
                                  3060,                     (: '|=' '++' :)
                                  3572)) then               (: '|=' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (13070,                    (: '%=' 'super' :)
                                  14222,                    (: '%=' 'void' :)
                                  13073,                    (: '&=' 'super' :)
                                  14225,                    (: '&=' 'void' :)
                                  13077,                    (: '*=' 'super' :)
                                  14229,                    (: '*=' 'void' :)
                                  13080,                    (: '+=' 'super' :)
                                  14232,                    (: '+=' 'void' :)
                                  13084,                    (: '-=' 'super' :)
                                  14236,                    (: '-=' 'void' :)
                                  13088,                    (: '/=' 'super' :)
                                  14240,                    (: '/=' 'void' :)
                                  13093,                    (: '<<=' 'super' :)
                                  14245,                    (: '<<=' 'void' :)
                                  13095,                    (: '=' 'super' :)
                                  14247,                    (: '=' 'void' :)
                                  13099,                    (: '>>=' 'super' :)
                                  14251,                    (: '>>=' 'void' :)
                                  13100,                    (: '>>>=' 'super' :)
                                  14252,                    (: '>>>=' 'void' :)
                                  13117,                    (: '^=' 'super' :)
                                  14269,                    (: '^=' 'void' :)
                                  13172,                    (: '|=' 'super' :)
                                  14324)) then              (: '|=' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (1294,                     (: '%=' '!' :)
                                  2318,                     (: '%=' '(' :)
                                  2830,                     (: '%=' '+' :)
                                  3342,                     (: '%=' '-' :)
                                  15246,                    (: '%=' '~' :)
                                  1297,                     (: '&=' '!' :)
                                  2321,                     (: '&=' '(' :)
                                  2833,                     (: '&=' '+' :)
                                  3345,                     (: '&=' '-' :)
                                  15249,                    (: '&=' '~' :)
                                  1301,                     (: '*=' '!' :)
                                  2325,                     (: '*=' '(' :)
                                  2837,                     (: '*=' '+' :)
                                  3349,                     (: '*=' '-' :)
                                  15253,                    (: '*=' '~' :)
                                  1304,                     (: '+=' '!' :)
                                  2328,                     (: '+=' '(' :)
                                  2840,                     (: '+=' '+' :)
                                  3352,                     (: '+=' '-' :)
                                  15256,                    (: '+=' '~' :)
                                  1308,                     (: '-=' '!' :)
                                  2332,                     (: '-=' '(' :)
                                  2844,                     (: '-=' '+' :)
                                  3356,                     (: '-=' '-' :)
                                  15260,                    (: '-=' '~' :)
                                  1312,                     (: '/=' '!' :)
                                  2336,                     (: '/=' '(' :)
                                  2848,                     (: '/=' '+' :)
                                  3360,                     (: '/=' '-' :)
                                  15264,                    (: '/=' '~' :)
                                  1317,                     (: '<<=' '!' :)
                                  2341,                     (: '<<=' '(' :)
                                  2853,                     (: '<<=' '+' :)
                                  3365,                     (: '<<=' '-' :)
                                  15269,                    (: '<<=' '~' :)
                                  1319,                     (: '=' '!' :)
                                  2343,                     (: '=' '(' :)
                                  2855,                     (: '=' '+' :)
                                  3367,                     (: '=' '-' :)
                                  15271,                    (: '=' '~' :)
                                  1323,                     (: '>>=' '!' :)
                                  2347,                     (: '>>=' '(' :)
                                  2859,                     (: '>>=' '+' :)
                                  3371,                     (: '>>=' '-' :)
                                  15275,                    (: '>>=' '~' :)
                                  1324,                     (: '>>>=' '!' :)
                                  2348,                     (: '>>>=' '(' :)
                                  2860,                     (: '>>>=' '+' :)
                                  3372,                     (: '>>>=' '-' :)
                                  15276,                    (: '>>>=' '~' :)
                                  1341,                     (: '^=' '!' :)
                                  2365,                     (: '^=' '(' :)
                                  2877,                     (: '^=' '+' :)
                                  3389,                     (: '^=' '-' :)
                                  15293,                    (: '^=' '~' :)
                                  1396,                     (: '|=' '!' :)
                                  2420,                     (: '|=' '(' :)
                                  2932,                     (: '|=' '+' :)
                                  3444,                     (: '|=' '-' :)
                                  15348)) then              (: '|=' '~' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (8206,                     (: '%=' 'boolean' :)
                                  8462,                     (: '%=' 'byte' :)
                                  8846,                     (: '%=' 'char' :)
                                  9486,                     (: '%=' 'double' :)
                                  10382,                    (: '%=' 'float' :)
                                  11150,                    (: '%=' 'int' :)
                                  11406,                    (: '%=' 'long' :)
                                  12686,                    (: '%=' 'short' :)
                                  8209,                     (: '&=' 'boolean' :)
                                  8465,                     (: '&=' 'byte' :)
                                  8849,                     (: '&=' 'char' :)
                                  9489,                     (: '&=' 'double' :)
                                  10385,                    (: '&=' 'float' :)
                                  11153,                    (: '&=' 'int' :)
                                  11409,                    (: '&=' 'long' :)
                                  12689,                    (: '&=' 'short' :)
                                  8213,                     (: '*=' 'boolean' :)
                                  8469,                     (: '*=' 'byte' :)
                                  8853,                     (: '*=' 'char' :)
                                  9493,                     (: '*=' 'double' :)
                                  10389,                    (: '*=' 'float' :)
                                  11157,                    (: '*=' 'int' :)
                                  11413,                    (: '*=' 'long' :)
                                  12693,                    (: '*=' 'short' :)
                                  8216,                     (: '+=' 'boolean' :)
                                  8472,                     (: '+=' 'byte' :)
                                  8856,                     (: '+=' 'char' :)
                                  9496,                     (: '+=' 'double' :)
                                  10392,                    (: '+=' 'float' :)
                                  11160,                    (: '+=' 'int' :)
                                  11416,                    (: '+=' 'long' :)
                                  12696,                    (: '+=' 'short' :)
                                  8220,                     (: '-=' 'boolean' :)
                                  8476,                     (: '-=' 'byte' :)
                                  8860,                     (: '-=' 'char' :)
                                  9500,                     (: '-=' 'double' :)
                                  10396,                    (: '-=' 'float' :)
                                  11164,                    (: '-=' 'int' :)
                                  11420,                    (: '-=' 'long' :)
                                  12700,                    (: '-=' 'short' :)
                                  8224,                     (: '/=' 'boolean' :)
                                  8480,                     (: '/=' 'byte' :)
                                  8864,                     (: '/=' 'char' :)
                                  9504,                     (: '/=' 'double' :)
                                  10400,                    (: '/=' 'float' :)
                                  11168,                    (: '/=' 'int' :)
                                  11424,                    (: '/=' 'long' :)
                                  12704,                    (: '/=' 'short' :)
                                  8229,                     (: '<<=' 'boolean' :)
                                  8485,                     (: '<<=' 'byte' :)
                                  8869,                     (: '<<=' 'char' :)
                                  9509,                     (: '<<=' 'double' :)
                                  10405,                    (: '<<=' 'float' :)
                                  11173,                    (: '<<=' 'int' :)
                                  11429,                    (: '<<=' 'long' :)
                                  12709,                    (: '<<=' 'short' :)
                                  8231,                     (: '=' 'boolean' :)
                                  8487,                     (: '=' 'byte' :)
                                  8871,                     (: '=' 'char' :)
                                  9511,                     (: '=' 'double' :)
                                  10407,                    (: '=' 'float' :)
                                  11175,                    (: '=' 'int' :)
                                  11431,                    (: '=' 'long' :)
                                  12711,                    (: '=' 'short' :)
                                  8235,                     (: '>>=' 'boolean' :)
                                  8491,                     (: '>>=' 'byte' :)
                                  8875,                     (: '>>=' 'char' :)
                                  9515,                     (: '>>=' 'double' :)
                                  10411,                    (: '>>=' 'float' :)
                                  11179,                    (: '>>=' 'int' :)
                                  11435,                    (: '>>=' 'long' :)
                                  12715,                    (: '>>=' 'short' :)
                                  8236,                     (: '>>>=' 'boolean' :)
                                  8492,                     (: '>>>=' 'byte' :)
                                  8876,                     (: '>>>=' 'char' :)
                                  9516,                     (: '>>>=' 'double' :)
                                  10412,                    (: '>>>=' 'float' :)
                                  11180,                    (: '>>>=' 'int' :)
                                  11436,                    (: '>>>=' 'long' :)
                                  12716,                    (: '>>>=' 'short' :)
                                  8253,                     (: '^=' 'boolean' :)
                                  8509,                     (: '^=' 'byte' :)
                                  8893,                     (: '^=' 'char' :)
                                  9533,                     (: '^=' 'double' :)
                                  10429,                    (: '^=' 'float' :)
                                  11197,                    (: '^=' 'int' :)
                                  11453,                    (: '^=' 'long' :)
                                  12733,                    (: '^=' 'short' :)
                                  8308,                     (: '|=' 'boolean' :)
                                  8564,                     (: '|=' 'byte' :)
                                  8948,                     (: '|=' 'char' :)
                                  9588,                     (: '|=' 'double' :)
                                  10484,                    (: '|=' 'float' :)
                                  11252,                    (: '|=' 'int' :)
                                  11508,                    (: '|=' 'long' :)
                                  12788)) then              (: '|=' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (142,                      (: '%=' IDENTIFIER :)
                                  526,                      (: '%=' INTEGER_LITERAL :)
                                  654,                      (: '%=' FLOATING_POINT_LITERAL :)
                                  782,                      (: '%=' CHARACTER_LITERAL :)
                                  910,                      (: '%=' STRING_LITERAL :)
                                  6030,                     (: '%=' 'EOF' :)
                                  6158,                     (: '%=' 'IGNORE_CASE' :)
                                  6286,                     (: '%=' 'JAVACODE' :)
                                  6414,                     (: '%=' 'LOOKAHEAD' :)
                                  6542,                     (: '%=' 'MORE' :)
                                  6670,                     (: '%=' 'PARSER_BEGIN' :)
                                  6798,                     (: '%=' 'PARSER_END' :)
                                  6926,                     (: '%=' 'SKIP' :)
                                  7054,                     (: '%=' 'SPECIAL_TOKEN' :)
                                  7182,                     (: '%=' 'TOKEN' :)
                                  7310,                     (: '%=' 'TOKEN_MGR_DECLS' :)
                                  9998,                     (: '%=' 'false' :)
                                  11790,                    (: '%=' 'null' :)
                                  13454,                    (: '%=' 'this' :)
                                  13966,                    (: '%=' 'true' :)
                                  145,                      (: '&=' IDENTIFIER :)
                                  529,                      (: '&=' INTEGER_LITERAL :)
                                  657,                      (: '&=' FLOATING_POINT_LITERAL :)
                                  785,                      (: '&=' CHARACTER_LITERAL :)
                                  913,                      (: '&=' STRING_LITERAL :)
                                  6033,                     (: '&=' 'EOF' :)
                                  6161,                     (: '&=' 'IGNORE_CASE' :)
                                  6289,                     (: '&=' 'JAVACODE' :)
                                  6417,                     (: '&=' 'LOOKAHEAD' :)
                                  6545,                     (: '&=' 'MORE' :)
                                  6673,                     (: '&=' 'PARSER_BEGIN' :)
                                  6801,                     (: '&=' 'PARSER_END' :)
                                  6929,                     (: '&=' 'SKIP' :)
                                  7057,                     (: '&=' 'SPECIAL_TOKEN' :)
                                  7185,                     (: '&=' 'TOKEN' :)
                                  7313,                     (: '&=' 'TOKEN_MGR_DECLS' :)
                                  10001,                    (: '&=' 'false' :)
                                  11793,                    (: '&=' 'null' :)
                                  13457,                    (: '&=' 'this' :)
                                  13969,                    (: '&=' 'true' :)
                                  149,                      (: '*=' IDENTIFIER :)
                                  533,                      (: '*=' INTEGER_LITERAL :)
                                  661,                      (: '*=' FLOATING_POINT_LITERAL :)
                                  789,                      (: '*=' CHARACTER_LITERAL :)
                                  917,                      (: '*=' STRING_LITERAL :)
                                  6037,                     (: '*=' 'EOF' :)
                                  6165,                     (: '*=' 'IGNORE_CASE' :)
                                  6293,                     (: '*=' 'JAVACODE' :)
                                  6421,                     (: '*=' 'LOOKAHEAD' :)
                                  6549,                     (: '*=' 'MORE' :)
                                  6677,                     (: '*=' 'PARSER_BEGIN' :)
                                  6805,                     (: '*=' 'PARSER_END' :)
                                  6933,                     (: '*=' 'SKIP' :)
                                  7061,                     (: '*=' 'SPECIAL_TOKEN' :)
                                  7189,                     (: '*=' 'TOKEN' :)
                                  7317,                     (: '*=' 'TOKEN_MGR_DECLS' :)
                                  10005,                    (: '*=' 'false' :)
                                  11797,                    (: '*=' 'null' :)
                                  13461,                    (: '*=' 'this' :)
                                  13973,                    (: '*=' 'true' :)
                                  152,                      (: '+=' IDENTIFIER :)
                                  536,                      (: '+=' INTEGER_LITERAL :)
                                  664,                      (: '+=' FLOATING_POINT_LITERAL :)
                                  792,                      (: '+=' CHARACTER_LITERAL :)
                                  920,                      (: '+=' STRING_LITERAL :)
                                  6040,                     (: '+=' 'EOF' :)
                                  6168,                     (: '+=' 'IGNORE_CASE' :)
                                  6296,                     (: '+=' 'JAVACODE' :)
                                  6424,                     (: '+=' 'LOOKAHEAD' :)
                                  6552,                     (: '+=' 'MORE' :)
                                  6680,                     (: '+=' 'PARSER_BEGIN' :)
                                  6808,                     (: '+=' 'PARSER_END' :)
                                  6936,                     (: '+=' 'SKIP' :)
                                  7064,                     (: '+=' 'SPECIAL_TOKEN' :)
                                  7192,                     (: '+=' 'TOKEN' :)
                                  7320,                     (: '+=' 'TOKEN_MGR_DECLS' :)
                                  10008,                    (: '+=' 'false' :)
                                  11800,                    (: '+=' 'null' :)
                                  13464,                    (: '+=' 'this' :)
                                  13976,                    (: '+=' 'true' :)
                                  156,                      (: '-=' IDENTIFIER :)
                                  540,                      (: '-=' INTEGER_LITERAL :)
                                  668,                      (: '-=' FLOATING_POINT_LITERAL :)
                                  796,                      (: '-=' CHARACTER_LITERAL :)
                                  924,                      (: '-=' STRING_LITERAL :)
                                  6044,                     (: '-=' 'EOF' :)
                                  6172,                     (: '-=' 'IGNORE_CASE' :)
                                  6300,                     (: '-=' 'JAVACODE' :)
                                  6428,                     (: '-=' 'LOOKAHEAD' :)
                                  6556,                     (: '-=' 'MORE' :)
                                  6684,                     (: '-=' 'PARSER_BEGIN' :)
                                  6812,                     (: '-=' 'PARSER_END' :)
                                  6940,                     (: '-=' 'SKIP' :)
                                  7068,                     (: '-=' 'SPECIAL_TOKEN' :)
                                  7196,                     (: '-=' 'TOKEN' :)
                                  7324,                     (: '-=' 'TOKEN_MGR_DECLS' :)
                                  10012,                    (: '-=' 'false' :)
                                  11804,                    (: '-=' 'null' :)
                                  13468,                    (: '-=' 'this' :)
                                  13980,                    (: '-=' 'true' :)
                                  160,                      (: '/=' IDENTIFIER :)
                                  544,                      (: '/=' INTEGER_LITERAL :)
                                  672,                      (: '/=' FLOATING_POINT_LITERAL :)
                                  800,                      (: '/=' CHARACTER_LITERAL :)
                                  928,                      (: '/=' STRING_LITERAL :)
                                  6048,                     (: '/=' 'EOF' :)
                                  6176,                     (: '/=' 'IGNORE_CASE' :)
                                  6304,                     (: '/=' 'JAVACODE' :)
                                  6432,                     (: '/=' 'LOOKAHEAD' :)
                                  6560,                     (: '/=' 'MORE' :)
                                  6688,                     (: '/=' 'PARSER_BEGIN' :)
                                  6816,                     (: '/=' 'PARSER_END' :)
                                  6944,                     (: '/=' 'SKIP' :)
                                  7072,                     (: '/=' 'SPECIAL_TOKEN' :)
                                  7200,                     (: '/=' 'TOKEN' :)
                                  7328,                     (: '/=' 'TOKEN_MGR_DECLS' :)
                                  10016,                    (: '/=' 'false' :)
                                  11808,                    (: '/=' 'null' :)
                                  13472,                    (: '/=' 'this' :)
                                  13984,                    (: '/=' 'true' :)
                                  165,                      (: '<<=' IDENTIFIER :)
                                  549,                      (: '<<=' INTEGER_LITERAL :)
                                  677,                      (: '<<=' FLOATING_POINT_LITERAL :)
                                  805,                      (: '<<=' CHARACTER_LITERAL :)
                                  933,                      (: '<<=' STRING_LITERAL :)
                                  6053,                     (: '<<=' 'EOF' :)
                                  6181,                     (: '<<=' 'IGNORE_CASE' :)
                                  6309,                     (: '<<=' 'JAVACODE' :)
                                  6437,                     (: '<<=' 'LOOKAHEAD' :)
                                  6565,                     (: '<<=' 'MORE' :)
                                  6693,                     (: '<<=' 'PARSER_BEGIN' :)
                                  6821,                     (: '<<=' 'PARSER_END' :)
                                  6949,                     (: '<<=' 'SKIP' :)
                                  7077,                     (: '<<=' 'SPECIAL_TOKEN' :)
                                  7205,                     (: '<<=' 'TOKEN' :)
                                  7333,                     (: '<<=' 'TOKEN_MGR_DECLS' :)
                                  10021,                    (: '<<=' 'false' :)
                                  11813,                    (: '<<=' 'null' :)
                                  13477,                    (: '<<=' 'this' :)
                                  13989,                    (: '<<=' 'true' :)
                                  167,                      (: '=' IDENTIFIER :)
                                  551,                      (: '=' INTEGER_LITERAL :)
                                  679,                      (: '=' FLOATING_POINT_LITERAL :)
                                  807,                      (: '=' CHARACTER_LITERAL :)
                                  935,                      (: '=' STRING_LITERAL :)
                                  6055,                     (: '=' 'EOF' :)
                                  6183,                     (: '=' 'IGNORE_CASE' :)
                                  6311,                     (: '=' 'JAVACODE' :)
                                  6439,                     (: '=' 'LOOKAHEAD' :)
                                  6567,                     (: '=' 'MORE' :)
                                  6695,                     (: '=' 'PARSER_BEGIN' :)
                                  6823,                     (: '=' 'PARSER_END' :)
                                  6951,                     (: '=' 'SKIP' :)
                                  7079,                     (: '=' 'SPECIAL_TOKEN' :)
                                  7207,                     (: '=' 'TOKEN' :)
                                  7335,                     (: '=' 'TOKEN_MGR_DECLS' :)
                                  10023,                    (: '=' 'false' :)
                                  11815,                    (: '=' 'null' :)
                                  13479,                    (: '=' 'this' :)
                                  13991,                    (: '=' 'true' :)
                                  171,                      (: '>>=' IDENTIFIER :)
                                  555,                      (: '>>=' INTEGER_LITERAL :)
                                  683,                      (: '>>=' FLOATING_POINT_LITERAL :)
                                  811,                      (: '>>=' CHARACTER_LITERAL :)
                                  939,                      (: '>>=' STRING_LITERAL :)
                                  6059,                     (: '>>=' 'EOF' :)
                                  6187,                     (: '>>=' 'IGNORE_CASE' :)
                                  6315,                     (: '>>=' 'JAVACODE' :)
                                  6443,                     (: '>>=' 'LOOKAHEAD' :)
                                  6571,                     (: '>>=' 'MORE' :)
                                  6699,                     (: '>>=' 'PARSER_BEGIN' :)
                                  6827,                     (: '>>=' 'PARSER_END' :)
                                  6955,                     (: '>>=' 'SKIP' :)
                                  7083,                     (: '>>=' 'SPECIAL_TOKEN' :)
                                  7211,                     (: '>>=' 'TOKEN' :)
                                  7339,                     (: '>>=' 'TOKEN_MGR_DECLS' :)
                                  10027,                    (: '>>=' 'false' :)
                                  11819,                    (: '>>=' 'null' :)
                                  13483,                    (: '>>=' 'this' :)
                                  13995,                    (: '>>=' 'true' :)
                                  172,                      (: '>>>=' IDENTIFIER :)
                                  556,                      (: '>>>=' INTEGER_LITERAL :)
                                  684,                      (: '>>>=' FLOATING_POINT_LITERAL :)
                                  812,                      (: '>>>=' CHARACTER_LITERAL :)
                                  940,                      (: '>>>=' STRING_LITERAL :)
                                  6060,                     (: '>>>=' 'EOF' :)
                                  6188,                     (: '>>>=' 'IGNORE_CASE' :)
                                  6316,                     (: '>>>=' 'JAVACODE' :)
                                  6444,                     (: '>>>=' 'LOOKAHEAD' :)
                                  6572,                     (: '>>>=' 'MORE' :)
                                  6700,                     (: '>>>=' 'PARSER_BEGIN' :)
                                  6828,                     (: '>>>=' 'PARSER_END' :)
                                  6956,                     (: '>>>=' 'SKIP' :)
                                  7084,                     (: '>>>=' 'SPECIAL_TOKEN' :)
                                  7212,                     (: '>>>=' 'TOKEN' :)
                                  7340,                     (: '>>>=' 'TOKEN_MGR_DECLS' :)
                                  10028,                    (: '>>>=' 'false' :)
                                  11820,                    (: '>>>=' 'null' :)
                                  13484,                    (: '>>>=' 'this' :)
                                  13996,                    (: '>>>=' 'true' :)
                                  189,                      (: '^=' IDENTIFIER :)
                                  573,                      (: '^=' INTEGER_LITERAL :)
                                  701,                      (: '^=' FLOATING_POINT_LITERAL :)
                                  829,                      (: '^=' CHARACTER_LITERAL :)
                                  957,                      (: '^=' STRING_LITERAL :)
                                  6077,                     (: '^=' 'EOF' :)
                                  6205,                     (: '^=' 'IGNORE_CASE' :)
                                  6333,                     (: '^=' 'JAVACODE' :)
                                  6461,                     (: '^=' 'LOOKAHEAD' :)
                                  6589,                     (: '^=' 'MORE' :)
                                  6717,                     (: '^=' 'PARSER_BEGIN' :)
                                  6845,                     (: '^=' 'PARSER_END' :)
                                  6973,                     (: '^=' 'SKIP' :)
                                  7101,                     (: '^=' 'SPECIAL_TOKEN' :)
                                  7229,                     (: '^=' 'TOKEN' :)
                                  7357,                     (: '^=' 'TOKEN_MGR_DECLS' :)
                                  10045,                    (: '^=' 'false' :)
                                  11837,                    (: '^=' 'null' :)
                                  13501,                    (: '^=' 'this' :)
                                  14013,                    (: '^=' 'true' :)
                                  244,                      (: '|=' IDENTIFIER :)
                                  628,                      (: '|=' INTEGER_LITERAL :)
                                  756,                      (: '|=' FLOATING_POINT_LITERAL :)
                                  884,                      (: '|=' CHARACTER_LITERAL :)
                                  1012,                     (: '|=' STRING_LITERAL :)
                                  6132,                     (: '|=' 'EOF' :)
                                  6260,                     (: '|=' 'IGNORE_CASE' :)
                                  6388,                     (: '|=' 'JAVACODE' :)
                                  6516,                     (: '|=' 'LOOKAHEAD' :)
                                  6644,                     (: '|=' 'MORE' :)
                                  6772,                     (: '|=' 'PARSER_BEGIN' :)
                                  6900,                     (: '|=' 'PARSER_END' :)
                                  7028,                     (: '|=' 'SKIP' :)
                                  7156,                     (: '|=' 'SPECIAL_TOKEN' :)
                                  7284,                     (: '|=' 'TOKEN' :)
                                  7412,                     (: '|=' 'TOKEN_MGR_DECLS' :)
                                  10100,                    (: '|=' 'false' :)
                                  11892,                    (: '|=' 'null' :)
                                  13556,                    (: '|=' 'this' :)
                                  14068)) then              (: '|=' 'true' :)
          let $state := p:lookahead3W(159, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 19                            (: ')' :)
         and $state[$p:lk] != 25                            (: ',' :)
         and $state[$p:lk] != 33                            (: ':' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 59                            (: ']' :)
         and $state[$p:lk] != 118) then                     (: '}' :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Expression", $count, $begin, $end)
};

(:~
 : Try parsing Expression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Expression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ConditionalExpression($input, $state)
  let $state :=
    if ($state[$p:l1] = (14,                                (: '%=' :)
                         17,                                (: '&=' :)
                         21,                                (: '*=' :)
                         24,                                (: '+=' :)
                         28,                                (: '-=' :)
                         32,                                (: '/=' :)
                         37,                                (: '<<=' :)
                         39,                                (: '=' :)
                         43,                                (: '>>=' :)
                         44,                                (: '>>>=' :)
                         61,                                (: '^=' :)
                         116)) then                         (: '|=' :)
      let $state := p:lookahead2W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:lk] = (11662,                         (: '%=' 'new' :)
                             11665,                         (: '&=' 'new' :)
                             11669,                         (: '*=' 'new' :)
                             11672,                         (: '+=' 'new' :)
                             11676,                         (: '-=' 'new' :)
                             11680,                         (: '/=' 'new' :)
                             11685,                         (: '<<=' 'new' :)
                             11687,                         (: '=' 'new' :)
                             11691,                         (: '>>=' 'new' :)
                             11692,                         (: '>>>=' 'new' :)
                             11709,                         (: '^=' 'new' :)
                             11764)) then                   (: '|=' 'new' :)
          let $state := p:lookahead3W(91, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
          return $state
        else if ($state[$p:lk] = (2958,                     (: '%=' '++' :)
                                  3470,                     (: '%=' '--' :)
                                  2961,                     (: '&=' '++' :)
                                  3473,                     (: '&=' '--' :)
                                  2965,                     (: '*=' '++' :)
                                  3477,                     (: '*=' '--' :)
                                  2968,                     (: '+=' '++' :)
                                  3480,                     (: '+=' '--' :)
                                  2972,                     (: '-=' '++' :)
                                  3484,                     (: '-=' '--' :)
                                  2976,                     (: '/=' '++' :)
                                  3488,                     (: '/=' '--' :)
                                  2981,                     (: '<<=' '++' :)
                                  3493,                     (: '<<=' '--' :)
                                  2983,                     (: '=' '++' :)
                                  3495,                     (: '=' '--' :)
                                  2987,                     (: '>>=' '++' :)
                                  3499,                     (: '>>=' '--' :)
                                  2988,                     (: '>>>=' '++' :)
                                  3500,                     (: '>>>=' '--' :)
                                  3005,                     (: '^=' '++' :)
                                  3517,                     (: '^=' '--' :)
                                  3060,                     (: '|=' '++' :)
                                  3572)) then               (: '|=' '--' :)
          let $state := p:lookahead3W(129, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
          return $state
        else if ($state[$p:lk] = (13070,                    (: '%=' 'super' :)
                                  14222,                    (: '%=' 'void' :)
                                  13073,                    (: '&=' 'super' :)
                                  14225,                    (: '&=' 'void' :)
                                  13077,                    (: '*=' 'super' :)
                                  14229,                    (: '*=' 'void' :)
                                  13080,                    (: '+=' 'super' :)
                                  14232,                    (: '+=' 'void' :)
                                  13084,                    (: '-=' 'super' :)
                                  14236,                    (: '-=' 'void' :)
                                  13088,                    (: '/=' 'super' :)
                                  14240,                    (: '/=' 'void' :)
                                  13093,                    (: '<<=' 'super' :)
                                  14245,                    (: '<<=' 'void' :)
                                  13095,                    (: '=' 'super' :)
                                  14247,                    (: '=' 'void' :)
                                  13099,                    (: '>>=' 'super' :)
                                  14251,                    (: '>>=' 'void' :)
                                  13100,                    (: '>>>=' 'super' :)
                                  14252,                    (: '>>>=' 'void' :)
                                  13117,                    (: '^=' 'super' :)
                                  14269,                    (: '^=' 'void' :)
                                  13172,                    (: '|=' 'super' :)
                                  14324)) then              (: '|=' 'void' :)
          let $state := p:lookahead3W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          return $state
        else if ($state[$p:lk] = (1294,                     (: '%=' '!' :)
                                  2318,                     (: '%=' '(' :)
                                  2830,                     (: '%=' '+' :)
                                  3342,                     (: '%=' '-' :)
                                  15246,                    (: '%=' '~' :)
                                  1297,                     (: '&=' '!' :)
                                  2321,                     (: '&=' '(' :)
                                  2833,                     (: '&=' '+' :)
                                  3345,                     (: '&=' '-' :)
                                  15249,                    (: '&=' '~' :)
                                  1301,                     (: '*=' '!' :)
                                  2325,                     (: '*=' '(' :)
                                  2837,                     (: '*=' '+' :)
                                  3349,                     (: '*=' '-' :)
                                  15253,                    (: '*=' '~' :)
                                  1304,                     (: '+=' '!' :)
                                  2328,                     (: '+=' '(' :)
                                  2840,                     (: '+=' '+' :)
                                  3352,                     (: '+=' '-' :)
                                  15256,                    (: '+=' '~' :)
                                  1308,                     (: '-=' '!' :)
                                  2332,                     (: '-=' '(' :)
                                  2844,                     (: '-=' '+' :)
                                  3356,                     (: '-=' '-' :)
                                  15260,                    (: '-=' '~' :)
                                  1312,                     (: '/=' '!' :)
                                  2336,                     (: '/=' '(' :)
                                  2848,                     (: '/=' '+' :)
                                  3360,                     (: '/=' '-' :)
                                  15264,                    (: '/=' '~' :)
                                  1317,                     (: '<<=' '!' :)
                                  2341,                     (: '<<=' '(' :)
                                  2853,                     (: '<<=' '+' :)
                                  3365,                     (: '<<=' '-' :)
                                  15269,                    (: '<<=' '~' :)
                                  1319,                     (: '=' '!' :)
                                  2343,                     (: '=' '(' :)
                                  2855,                     (: '=' '+' :)
                                  3367,                     (: '=' '-' :)
                                  15271,                    (: '=' '~' :)
                                  1323,                     (: '>>=' '!' :)
                                  2347,                     (: '>>=' '(' :)
                                  2859,                     (: '>>=' '+' :)
                                  3371,                     (: '>>=' '-' :)
                                  15275,                    (: '>>=' '~' :)
                                  1324,                     (: '>>>=' '!' :)
                                  2348,                     (: '>>>=' '(' :)
                                  2860,                     (: '>>>=' '+' :)
                                  3372,                     (: '>>>=' '-' :)
                                  15276,                    (: '>>>=' '~' :)
                                  1341,                     (: '^=' '!' :)
                                  2365,                     (: '^=' '(' :)
                                  2877,                     (: '^=' '+' :)
                                  3389,                     (: '^=' '-' :)
                                  15293,                    (: '^=' '~' :)
                                  1396,                     (: '|=' '!' :)
                                  2420,                     (: '|=' '(' :)
                                  2932,                     (: '|=' '+' :)
                                  3444,                     (: '|=' '-' :)
                                  15348)) then              (: '|=' '~' :)
          let $state := p:lookahead3W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] = (8206,                     (: '%=' 'boolean' :)
                                  8462,                     (: '%=' 'byte' :)
                                  8846,                     (: '%=' 'char' :)
                                  9486,                     (: '%=' 'double' :)
                                  10382,                    (: '%=' 'float' :)
                                  11150,                    (: '%=' 'int' :)
                                  11406,                    (: '%=' 'long' :)
                                  12686,                    (: '%=' 'short' :)
                                  8209,                     (: '&=' 'boolean' :)
                                  8465,                     (: '&=' 'byte' :)
                                  8849,                     (: '&=' 'char' :)
                                  9489,                     (: '&=' 'double' :)
                                  10385,                    (: '&=' 'float' :)
                                  11153,                    (: '&=' 'int' :)
                                  11409,                    (: '&=' 'long' :)
                                  12689,                    (: '&=' 'short' :)
                                  8213,                     (: '*=' 'boolean' :)
                                  8469,                     (: '*=' 'byte' :)
                                  8853,                     (: '*=' 'char' :)
                                  9493,                     (: '*=' 'double' :)
                                  10389,                    (: '*=' 'float' :)
                                  11157,                    (: '*=' 'int' :)
                                  11413,                    (: '*=' 'long' :)
                                  12693,                    (: '*=' 'short' :)
                                  8216,                     (: '+=' 'boolean' :)
                                  8472,                     (: '+=' 'byte' :)
                                  8856,                     (: '+=' 'char' :)
                                  9496,                     (: '+=' 'double' :)
                                  10392,                    (: '+=' 'float' :)
                                  11160,                    (: '+=' 'int' :)
                                  11416,                    (: '+=' 'long' :)
                                  12696,                    (: '+=' 'short' :)
                                  8220,                     (: '-=' 'boolean' :)
                                  8476,                     (: '-=' 'byte' :)
                                  8860,                     (: '-=' 'char' :)
                                  9500,                     (: '-=' 'double' :)
                                  10396,                    (: '-=' 'float' :)
                                  11164,                    (: '-=' 'int' :)
                                  11420,                    (: '-=' 'long' :)
                                  12700,                    (: '-=' 'short' :)
                                  8224,                     (: '/=' 'boolean' :)
                                  8480,                     (: '/=' 'byte' :)
                                  8864,                     (: '/=' 'char' :)
                                  9504,                     (: '/=' 'double' :)
                                  10400,                    (: '/=' 'float' :)
                                  11168,                    (: '/=' 'int' :)
                                  11424,                    (: '/=' 'long' :)
                                  12704,                    (: '/=' 'short' :)
                                  8229,                     (: '<<=' 'boolean' :)
                                  8485,                     (: '<<=' 'byte' :)
                                  8869,                     (: '<<=' 'char' :)
                                  9509,                     (: '<<=' 'double' :)
                                  10405,                    (: '<<=' 'float' :)
                                  11173,                    (: '<<=' 'int' :)
                                  11429,                    (: '<<=' 'long' :)
                                  12709,                    (: '<<=' 'short' :)
                                  8231,                     (: '=' 'boolean' :)
                                  8487,                     (: '=' 'byte' :)
                                  8871,                     (: '=' 'char' :)
                                  9511,                     (: '=' 'double' :)
                                  10407,                    (: '=' 'float' :)
                                  11175,                    (: '=' 'int' :)
                                  11431,                    (: '=' 'long' :)
                                  12711,                    (: '=' 'short' :)
                                  8235,                     (: '>>=' 'boolean' :)
                                  8491,                     (: '>>=' 'byte' :)
                                  8875,                     (: '>>=' 'char' :)
                                  9515,                     (: '>>=' 'double' :)
                                  10411,                    (: '>>=' 'float' :)
                                  11179,                    (: '>>=' 'int' :)
                                  11435,                    (: '>>=' 'long' :)
                                  12715,                    (: '>>=' 'short' :)
                                  8236,                     (: '>>>=' 'boolean' :)
                                  8492,                     (: '>>>=' 'byte' :)
                                  8876,                     (: '>>>=' 'char' :)
                                  9516,                     (: '>>>=' 'double' :)
                                  10412,                    (: '>>>=' 'float' :)
                                  11180,                    (: '>>>=' 'int' :)
                                  11436,                    (: '>>>=' 'long' :)
                                  12716,                    (: '>>>=' 'short' :)
                                  8253,                     (: '^=' 'boolean' :)
                                  8509,                     (: '^=' 'byte' :)
                                  8893,                     (: '^=' 'char' :)
                                  9533,                     (: '^=' 'double' :)
                                  10429,                    (: '^=' 'float' :)
                                  11197,                    (: '^=' 'int' :)
                                  11453,                    (: '^=' 'long' :)
                                  12733,                    (: '^=' 'short' :)
                                  8308,                     (: '|=' 'boolean' :)
                                  8564,                     (: '|=' 'byte' :)
                                  8948,                     (: '|=' 'char' :)
                                  9588,                     (: '|=' 'double' :)
                                  10484,                    (: '|=' 'float' :)
                                  11252,                    (: '|=' 'int' :)
                                  11508,                    (: '|=' 'long' :)
                                  12788)) then              (: '|=' 'short' :)
          let $state := p:lookahead3W(43, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' |
                                                               '[' :)
          return $state
        else if ($state[$p:lk] = (142,                      (: '%=' IDENTIFIER :)
                                  526,                      (: '%=' INTEGER_LITERAL :)
                                  654,                      (: '%=' FLOATING_POINT_LITERAL :)
                                  782,                      (: '%=' CHARACTER_LITERAL :)
                                  910,                      (: '%=' STRING_LITERAL :)
                                  6030,                     (: '%=' 'EOF' :)
                                  6158,                     (: '%=' 'IGNORE_CASE' :)
                                  6286,                     (: '%=' 'JAVACODE' :)
                                  6414,                     (: '%=' 'LOOKAHEAD' :)
                                  6542,                     (: '%=' 'MORE' :)
                                  6670,                     (: '%=' 'PARSER_BEGIN' :)
                                  6798,                     (: '%=' 'PARSER_END' :)
                                  6926,                     (: '%=' 'SKIP' :)
                                  7054,                     (: '%=' 'SPECIAL_TOKEN' :)
                                  7182,                     (: '%=' 'TOKEN' :)
                                  7310,                     (: '%=' 'TOKEN_MGR_DECLS' :)
                                  9998,                     (: '%=' 'false' :)
                                  11790,                    (: '%=' 'null' :)
                                  13454,                    (: '%=' 'this' :)
                                  13966,                    (: '%=' 'true' :)
                                  145,                      (: '&=' IDENTIFIER :)
                                  529,                      (: '&=' INTEGER_LITERAL :)
                                  657,                      (: '&=' FLOATING_POINT_LITERAL :)
                                  785,                      (: '&=' CHARACTER_LITERAL :)
                                  913,                      (: '&=' STRING_LITERAL :)
                                  6033,                     (: '&=' 'EOF' :)
                                  6161,                     (: '&=' 'IGNORE_CASE' :)
                                  6289,                     (: '&=' 'JAVACODE' :)
                                  6417,                     (: '&=' 'LOOKAHEAD' :)
                                  6545,                     (: '&=' 'MORE' :)
                                  6673,                     (: '&=' 'PARSER_BEGIN' :)
                                  6801,                     (: '&=' 'PARSER_END' :)
                                  6929,                     (: '&=' 'SKIP' :)
                                  7057,                     (: '&=' 'SPECIAL_TOKEN' :)
                                  7185,                     (: '&=' 'TOKEN' :)
                                  7313,                     (: '&=' 'TOKEN_MGR_DECLS' :)
                                  10001,                    (: '&=' 'false' :)
                                  11793,                    (: '&=' 'null' :)
                                  13457,                    (: '&=' 'this' :)
                                  13969,                    (: '&=' 'true' :)
                                  149,                      (: '*=' IDENTIFIER :)
                                  533,                      (: '*=' INTEGER_LITERAL :)
                                  661,                      (: '*=' FLOATING_POINT_LITERAL :)
                                  789,                      (: '*=' CHARACTER_LITERAL :)
                                  917,                      (: '*=' STRING_LITERAL :)
                                  6037,                     (: '*=' 'EOF' :)
                                  6165,                     (: '*=' 'IGNORE_CASE' :)
                                  6293,                     (: '*=' 'JAVACODE' :)
                                  6421,                     (: '*=' 'LOOKAHEAD' :)
                                  6549,                     (: '*=' 'MORE' :)
                                  6677,                     (: '*=' 'PARSER_BEGIN' :)
                                  6805,                     (: '*=' 'PARSER_END' :)
                                  6933,                     (: '*=' 'SKIP' :)
                                  7061,                     (: '*=' 'SPECIAL_TOKEN' :)
                                  7189,                     (: '*=' 'TOKEN' :)
                                  7317,                     (: '*=' 'TOKEN_MGR_DECLS' :)
                                  10005,                    (: '*=' 'false' :)
                                  11797,                    (: '*=' 'null' :)
                                  13461,                    (: '*=' 'this' :)
                                  13973,                    (: '*=' 'true' :)
                                  152,                      (: '+=' IDENTIFIER :)
                                  536,                      (: '+=' INTEGER_LITERAL :)
                                  664,                      (: '+=' FLOATING_POINT_LITERAL :)
                                  792,                      (: '+=' CHARACTER_LITERAL :)
                                  920,                      (: '+=' STRING_LITERAL :)
                                  6040,                     (: '+=' 'EOF' :)
                                  6168,                     (: '+=' 'IGNORE_CASE' :)
                                  6296,                     (: '+=' 'JAVACODE' :)
                                  6424,                     (: '+=' 'LOOKAHEAD' :)
                                  6552,                     (: '+=' 'MORE' :)
                                  6680,                     (: '+=' 'PARSER_BEGIN' :)
                                  6808,                     (: '+=' 'PARSER_END' :)
                                  6936,                     (: '+=' 'SKIP' :)
                                  7064,                     (: '+=' 'SPECIAL_TOKEN' :)
                                  7192,                     (: '+=' 'TOKEN' :)
                                  7320,                     (: '+=' 'TOKEN_MGR_DECLS' :)
                                  10008,                    (: '+=' 'false' :)
                                  11800,                    (: '+=' 'null' :)
                                  13464,                    (: '+=' 'this' :)
                                  13976,                    (: '+=' 'true' :)
                                  156,                      (: '-=' IDENTIFIER :)
                                  540,                      (: '-=' INTEGER_LITERAL :)
                                  668,                      (: '-=' FLOATING_POINT_LITERAL :)
                                  796,                      (: '-=' CHARACTER_LITERAL :)
                                  924,                      (: '-=' STRING_LITERAL :)
                                  6044,                     (: '-=' 'EOF' :)
                                  6172,                     (: '-=' 'IGNORE_CASE' :)
                                  6300,                     (: '-=' 'JAVACODE' :)
                                  6428,                     (: '-=' 'LOOKAHEAD' :)
                                  6556,                     (: '-=' 'MORE' :)
                                  6684,                     (: '-=' 'PARSER_BEGIN' :)
                                  6812,                     (: '-=' 'PARSER_END' :)
                                  6940,                     (: '-=' 'SKIP' :)
                                  7068,                     (: '-=' 'SPECIAL_TOKEN' :)
                                  7196,                     (: '-=' 'TOKEN' :)
                                  7324,                     (: '-=' 'TOKEN_MGR_DECLS' :)
                                  10012,                    (: '-=' 'false' :)
                                  11804,                    (: '-=' 'null' :)
                                  13468,                    (: '-=' 'this' :)
                                  13980,                    (: '-=' 'true' :)
                                  160,                      (: '/=' IDENTIFIER :)
                                  544,                      (: '/=' INTEGER_LITERAL :)
                                  672,                      (: '/=' FLOATING_POINT_LITERAL :)
                                  800,                      (: '/=' CHARACTER_LITERAL :)
                                  928,                      (: '/=' STRING_LITERAL :)
                                  6048,                     (: '/=' 'EOF' :)
                                  6176,                     (: '/=' 'IGNORE_CASE' :)
                                  6304,                     (: '/=' 'JAVACODE' :)
                                  6432,                     (: '/=' 'LOOKAHEAD' :)
                                  6560,                     (: '/=' 'MORE' :)
                                  6688,                     (: '/=' 'PARSER_BEGIN' :)
                                  6816,                     (: '/=' 'PARSER_END' :)
                                  6944,                     (: '/=' 'SKIP' :)
                                  7072,                     (: '/=' 'SPECIAL_TOKEN' :)
                                  7200,                     (: '/=' 'TOKEN' :)
                                  7328,                     (: '/=' 'TOKEN_MGR_DECLS' :)
                                  10016,                    (: '/=' 'false' :)
                                  11808,                    (: '/=' 'null' :)
                                  13472,                    (: '/=' 'this' :)
                                  13984,                    (: '/=' 'true' :)
                                  165,                      (: '<<=' IDENTIFIER :)
                                  549,                      (: '<<=' INTEGER_LITERAL :)
                                  677,                      (: '<<=' FLOATING_POINT_LITERAL :)
                                  805,                      (: '<<=' CHARACTER_LITERAL :)
                                  933,                      (: '<<=' STRING_LITERAL :)
                                  6053,                     (: '<<=' 'EOF' :)
                                  6181,                     (: '<<=' 'IGNORE_CASE' :)
                                  6309,                     (: '<<=' 'JAVACODE' :)
                                  6437,                     (: '<<=' 'LOOKAHEAD' :)
                                  6565,                     (: '<<=' 'MORE' :)
                                  6693,                     (: '<<=' 'PARSER_BEGIN' :)
                                  6821,                     (: '<<=' 'PARSER_END' :)
                                  6949,                     (: '<<=' 'SKIP' :)
                                  7077,                     (: '<<=' 'SPECIAL_TOKEN' :)
                                  7205,                     (: '<<=' 'TOKEN' :)
                                  7333,                     (: '<<=' 'TOKEN_MGR_DECLS' :)
                                  10021,                    (: '<<=' 'false' :)
                                  11813,                    (: '<<=' 'null' :)
                                  13477,                    (: '<<=' 'this' :)
                                  13989,                    (: '<<=' 'true' :)
                                  167,                      (: '=' IDENTIFIER :)
                                  551,                      (: '=' INTEGER_LITERAL :)
                                  679,                      (: '=' FLOATING_POINT_LITERAL :)
                                  807,                      (: '=' CHARACTER_LITERAL :)
                                  935,                      (: '=' STRING_LITERAL :)
                                  6055,                     (: '=' 'EOF' :)
                                  6183,                     (: '=' 'IGNORE_CASE' :)
                                  6311,                     (: '=' 'JAVACODE' :)
                                  6439,                     (: '=' 'LOOKAHEAD' :)
                                  6567,                     (: '=' 'MORE' :)
                                  6695,                     (: '=' 'PARSER_BEGIN' :)
                                  6823,                     (: '=' 'PARSER_END' :)
                                  6951,                     (: '=' 'SKIP' :)
                                  7079,                     (: '=' 'SPECIAL_TOKEN' :)
                                  7207,                     (: '=' 'TOKEN' :)
                                  7335,                     (: '=' 'TOKEN_MGR_DECLS' :)
                                  10023,                    (: '=' 'false' :)
                                  11815,                    (: '=' 'null' :)
                                  13479,                    (: '=' 'this' :)
                                  13991,                    (: '=' 'true' :)
                                  171,                      (: '>>=' IDENTIFIER :)
                                  555,                      (: '>>=' INTEGER_LITERAL :)
                                  683,                      (: '>>=' FLOATING_POINT_LITERAL :)
                                  811,                      (: '>>=' CHARACTER_LITERAL :)
                                  939,                      (: '>>=' STRING_LITERAL :)
                                  6059,                     (: '>>=' 'EOF' :)
                                  6187,                     (: '>>=' 'IGNORE_CASE' :)
                                  6315,                     (: '>>=' 'JAVACODE' :)
                                  6443,                     (: '>>=' 'LOOKAHEAD' :)
                                  6571,                     (: '>>=' 'MORE' :)
                                  6699,                     (: '>>=' 'PARSER_BEGIN' :)
                                  6827,                     (: '>>=' 'PARSER_END' :)
                                  6955,                     (: '>>=' 'SKIP' :)
                                  7083,                     (: '>>=' 'SPECIAL_TOKEN' :)
                                  7211,                     (: '>>=' 'TOKEN' :)
                                  7339,                     (: '>>=' 'TOKEN_MGR_DECLS' :)
                                  10027,                    (: '>>=' 'false' :)
                                  11819,                    (: '>>=' 'null' :)
                                  13483,                    (: '>>=' 'this' :)
                                  13995,                    (: '>>=' 'true' :)
                                  172,                      (: '>>>=' IDENTIFIER :)
                                  556,                      (: '>>>=' INTEGER_LITERAL :)
                                  684,                      (: '>>>=' FLOATING_POINT_LITERAL :)
                                  812,                      (: '>>>=' CHARACTER_LITERAL :)
                                  940,                      (: '>>>=' STRING_LITERAL :)
                                  6060,                     (: '>>>=' 'EOF' :)
                                  6188,                     (: '>>>=' 'IGNORE_CASE' :)
                                  6316,                     (: '>>>=' 'JAVACODE' :)
                                  6444,                     (: '>>>=' 'LOOKAHEAD' :)
                                  6572,                     (: '>>>=' 'MORE' :)
                                  6700,                     (: '>>>=' 'PARSER_BEGIN' :)
                                  6828,                     (: '>>>=' 'PARSER_END' :)
                                  6956,                     (: '>>>=' 'SKIP' :)
                                  7084,                     (: '>>>=' 'SPECIAL_TOKEN' :)
                                  7212,                     (: '>>>=' 'TOKEN' :)
                                  7340,                     (: '>>>=' 'TOKEN_MGR_DECLS' :)
                                  10028,                    (: '>>>=' 'false' :)
                                  11820,                    (: '>>>=' 'null' :)
                                  13484,                    (: '>>>=' 'this' :)
                                  13996,                    (: '>>>=' 'true' :)
                                  189,                      (: '^=' IDENTIFIER :)
                                  573,                      (: '^=' INTEGER_LITERAL :)
                                  701,                      (: '^=' FLOATING_POINT_LITERAL :)
                                  829,                      (: '^=' CHARACTER_LITERAL :)
                                  957,                      (: '^=' STRING_LITERAL :)
                                  6077,                     (: '^=' 'EOF' :)
                                  6205,                     (: '^=' 'IGNORE_CASE' :)
                                  6333,                     (: '^=' 'JAVACODE' :)
                                  6461,                     (: '^=' 'LOOKAHEAD' :)
                                  6589,                     (: '^=' 'MORE' :)
                                  6717,                     (: '^=' 'PARSER_BEGIN' :)
                                  6845,                     (: '^=' 'PARSER_END' :)
                                  6973,                     (: '^=' 'SKIP' :)
                                  7101,                     (: '^=' 'SPECIAL_TOKEN' :)
                                  7229,                     (: '^=' 'TOKEN' :)
                                  7357,                     (: '^=' 'TOKEN_MGR_DECLS' :)
                                  10045,                    (: '^=' 'false' :)
                                  11837,                    (: '^=' 'null' :)
                                  13501,                    (: '^=' 'this' :)
                                  14013,                    (: '^=' 'true' :)
                                  244,                      (: '|=' IDENTIFIER :)
                                  628,                      (: '|=' INTEGER_LITERAL :)
                                  756,                      (: '|=' FLOATING_POINT_LITERAL :)
                                  884,                      (: '|=' CHARACTER_LITERAL :)
                                  1012,                     (: '|=' STRING_LITERAL :)
                                  6132,                     (: '|=' 'EOF' :)
                                  6260,                     (: '|=' 'IGNORE_CASE' :)
                                  6388,                     (: '|=' 'JAVACODE' :)
                                  6516,                     (: '|=' 'LOOKAHEAD' :)
                                  6644,                     (: '|=' 'MORE' :)
                                  6772,                     (: '|=' 'PARSER_BEGIN' :)
                                  6900,                     (: '|=' 'PARSER_END' :)
                                  7028,                     (: '|=' 'SKIP' :)
                                  7156,                     (: '|=' 'SPECIAL_TOKEN' :)
                                  7284,                     (: '|=' 'TOKEN' :)
                                  7412,                     (: '|=' 'TOKEN_MGR_DECLS' :)
                                  10100,                    (: '|=' 'false' :)
                                  11892,                    (: '|=' 'null' :)
                                  13556,                    (: '|=' 'this' :)
                                  14068)) then              (: '|=' 'true' :)
          let $state := p:lookahead3W(159, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 19                            (: ')' :)
         and $state[$p:lk] != 25                            (: ',' :)
         and $state[$p:lk] != 33                            (: ':' :)
         and $state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 59                            (: ']' :)
         and $state[$p:lk] != 118) then                     (: '}' :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(139, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse NullLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NullLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(92, $input, $state)               (: 'null' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NullLiteral", $count, $begin, $end)
};

(:~
 : Try parsing NullLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NullLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(92, $input, $state)              (: 'null' :)
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: INTEGER_LITERAL :)
      let $state := p:consume(4, $input, $state)            (: INTEGER_LITERAL :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: FLOATING_POINT_LITERAL :)
      let $state := p:consume(5, $input, $state)            (: FLOATING_POINT_LITERAL :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: CHARACTER_LITERAL :)
      let $state := p:consume(6, $input, $state)            (: CHARACTER_LITERAL :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: STRING_LITERAL :)
      let $state := p:consume(7, $input, $state)            (: STRING_LITERAL :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'null' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NullLiteral($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BooleanLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Try parsing Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: INTEGER_LITERAL :)
      let $state := p:consumeT(4, $input, $state)           (: INTEGER_LITERAL :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: FLOATING_POINT_LITERAL :)
      let $state := p:consumeT(5, $input, $state)           (: FLOATING_POINT_LITERAL :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: CHARACTER_LITERAL :)
      let $state := p:consumeT(6, $input, $state)           (: CHARACTER_LITERAL :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: STRING_LITERAL :)
      let $state := p:consumeT(7, $input, $state)           (: STRING_LITERAL :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'null' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NullLiteral($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-BooleanLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse PrimaryPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(159, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 3713) then                     (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(107, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(145, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '?' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20097                          (: IDENTIFIER '.' IDENTIFIER :)
          or $state[$p:lk] = 20865                          (: IDENTIFIER '<' IDENTIFIER :)
          or $state[$p:lk] = 1053057                        (: IDENTIFIER '<' 'boolean' :)
          or $state[$p:lk] = 1085825                        (: IDENTIFIER '<' 'byte' :)
          or $state[$p:lk] = 1134977                        (: IDENTIFIER '<' 'char' :)
          or $state[$p:lk] = 1216897                        (: IDENTIFIER '<' 'double' :)
          or $state[$p:lk] = 1331585                        (: IDENTIFIER '<' 'float' :)
          or $state[$p:lk] = 1429889                        (: IDENTIFIER '<' 'int' :)
          or $state[$p:lk] = 1462657                        (: IDENTIFIER '<' 'long' :)
          or $state[$p:lk] = 1626497) then                  (: IDENTIFIER '<' 'short' :)
      let $state := p:memoized($state, 17)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ResultType($input, $state)
          let $state := p:lookahead1W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          let $state := p:consumeT(29, $input, $state)      (: '.' :)
          let $state := p:lookahead1W(17, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
          let $state := p:consumeT(70, $input, $state)      (: 'class' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -6, -6)
            else
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -7, -7)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 4                              (: INTEGER_LITERAL :)
          or $state[$p:lk] = 5                              (: FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 6                              (: CHARACTER_LITERAL :)
          or $state[$p:lk] = 7                              (: STRING_LITERAL :)
          or $state[$p:lk] = 78                             (: 'false' :)
          or $state[$p:lk] = 92                             (: 'null' :)
          or $state[$p:lk] = 109) then                      (: 'true' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 105) then                      (: 'this' :)
      let $state := p:consume(105, $input, $state)          (: 'this' :)
      return $state
    else if ($state[$p:lk] = 102) then                      (: 'super' :)
      let $state := p:consume(102, $input, $state)          (: 'super' :)
      let $state := p:lookahead1W(6, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
      let $state := p:consume(29, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      return $state
    else if ($state[$p:lk] = 18) then                       (: '(' :)
      let $state := p:consume(18, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      let $state := p:consume(19, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 91) then                       (: 'new' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AllocationExpression($input, $state)
      return $state
    else if ($state[$p:lk] = -6
     or $state[$p:lk] = 64                                  (: 'boolean' :)
     or $state[$p:lk] = 66                                  (: 'byte' :)
     or $state[$p:lk] = 69                                  (: 'char' :)
     or $state[$p:lk] = 74                                  (: 'double' :)
     or $state[$p:lk] = 81                                  (: 'float' :)
     or $state[$p:lk] = 87                                  (: 'int' :)
     or $state[$p:lk] = 89                                  (: 'long' :)
     or $state[$p:lk] = 99                                  (: 'short' :)
     or $state[$p:lk] = 111                                 (: 'void' :)
     or $state[$p:lk] = 741761                              (: IDENTIFIER '<' '?' :)
     or $state[$p:lk] = 974081                              (: IDENTIFIER '[' ']' :)
     or $state[$p:lk] = 1150593) then                       (: IDENTIFIER '.' 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ResultType($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
      let $state := p:consume(29, $input, $state)           (: '.' :)
      let $state := p:lookahead1W(17, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
      let $state := p:consume(70, $input, $state)           (: 'class' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryPrefix", $count, $begin, $end)
};

(:~
 : Try parsing PrimaryPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrimaryPrefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 1) then                            (: IDENTIFIER :)
      let $state := p:lookahead2W(159, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 3713) then                     (: IDENTIFIER '.' :)
          let $state := p:lookahead3W(107, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'class' | 'new' | 'super' | 'this' :)
          return $state
        else if ($state[$p:lk] eq 4481) then                (: IDENTIFIER '<' :)
          let $state := p:lookahead3W(145, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '?' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else if ($state[$p:lk] eq 7425) then                (: IDENTIFIER '[' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' | ']' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20097                          (: IDENTIFIER '.' IDENTIFIER :)
          or $state[$p:lk] = 20865                          (: IDENTIFIER '<' IDENTIFIER :)
          or $state[$p:lk] = 1053057                        (: IDENTIFIER '<' 'boolean' :)
          or $state[$p:lk] = 1085825                        (: IDENTIFIER '<' 'byte' :)
          or $state[$p:lk] = 1134977                        (: IDENTIFIER '<' 'char' :)
          or $state[$p:lk] = 1216897                        (: IDENTIFIER '<' 'double' :)
          or $state[$p:lk] = 1331585                        (: IDENTIFIER '<' 'float' :)
          or $state[$p:lk] = 1429889                        (: IDENTIFIER '<' 'int' :)
          or $state[$p:lk] = 1462657                        (: IDENTIFIER '<' 'long' :)
          or $state[$p:lk] = 1626497) then                  (: IDENTIFIER '<' 'short' :)
      let $state := p:memoized($state, 17)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ResultType($input, $state)
          let $state := p:lookahead1W(6, $input, $state)    (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
          let $state := p:consumeT(29, $input, $state)      (: '.' :)
          let $state := p:lookahead1W(17, $input, $state)   (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
          let $state := p:consumeT(70, $input, $state)      (: 'class' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -6, -6)
            else
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -7, -7)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 4                              (: INTEGER_LITERAL :)
          or $state[$p:lk] = 5                              (: FLOATING_POINT_LITERAL :)
          or $state[$p:lk] = 6                              (: CHARACTER_LITERAL :)
          or $state[$p:lk] = 7                              (: STRING_LITERAL :)
          or $state[$p:lk] = 78                             (: 'false' :)
          or $state[$p:lk] = 92                             (: 'null' :)
          or $state[$p:lk] = 109) then                      (: 'true' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 105) then                      (: 'this' :)
      let $state := p:consumeT(105, $input, $state)         (: 'this' :)
      return $state
    else if ($state[$p:lk] = 102) then                      (: 'super' :)
      let $state := p:consumeT(102, $input, $state)         (: 'super' :)
      let $state := p:lookahead1W(6, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
      let $state := p:consumeT(29, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(0, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
      let $state := p:consumeT(1, $input, $state)           (: IDENTIFIER :)
      return $state
    else if ($state[$p:lk] = 18) then                       (: '(' :)
      let $state := p:consumeT(18, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      let $state := p:consumeT(19, $input, $state)          (: ')' :)
      return $state
    else if ($state[$p:lk] = 91) then                       (: 'new' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AllocationExpression($input, $state)
      return $state
    else if ($state[$p:lk] = -6
     or $state[$p:lk] = 64                                  (: 'boolean' :)
     or $state[$p:lk] = 66                                  (: 'byte' :)
     or $state[$p:lk] = 69                                  (: 'char' :)
     or $state[$p:lk] = 74                                  (: 'double' :)
     or $state[$p:lk] = 81                                  (: 'float' :)
     or $state[$p:lk] = 87                                  (: 'int' :)
     or $state[$p:lk] = 89                                  (: 'long' :)
     or $state[$p:lk] = 99                                  (: 'short' :)
     or $state[$p:lk] = 111                                 (: 'void' :)
     or $state[$p:lk] = 741761                              (: IDENTIFIER '<' '?' :)
     or $state[$p:lk] = 974081                              (: IDENTIFIER '[' ']' :)
     or $state[$p:lk] = 1150593) then                       (: IDENTIFIER '.' 'class' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ResultType($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '.' :)
      let $state := p:consumeT(29, $input, $state)          (: '.' :)
      let $state := p:lookahead1W(17, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'class' :)
      let $state := p:consumeT(70, $input, $state)          (: 'class' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Name($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production PrimaryExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(159, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 29) then                         (: '.' :)
        let $state := p:lookahead2W(78, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'new' | 'super' | 'this' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 18                               (: '(' :)
      and $state[$p:lk] != 58                               (: '[' :)
      and $state[$p:lk] != 157                              (: '.' IDENTIFIER :)
      and $state[$p:lk] != 4509                             (: '.' '<' :)
      and $state[$p:lk] != 11677                            (: '.' 'new' :)
      and $state[$p:lk] != 13469) then                      (: '.' 'this' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-PrimarySuffix($input, $state)
        return p:parse-PrimaryExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PrimaryExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrimaryExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(159, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' |
                                                               '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '>' | '>=' | '>>=' | '>>>=' | '?' | '[' | ']' |
                                                               '^' | '^=' | 'instanceof' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 29) then                         (: '.' :)
        let $state := p:lookahead2W(78, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'new' | 'super' | 'this' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 18                               (: '(' :)
      and $state[$p:lk] != 58                               (: '[' :)
      and $state[$p:lk] != 157                              (: '.' IDENTIFIER :)
      and $state[$p:lk] != 4509                             (: '.' '<' :)
      and $state[$p:lk] != 11677                            (: '.' 'new' :)
      and $state[$p:lk] != 13469) then                      (: '.' 'this' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-PrimarySuffix($input, $state)
        return p:try-PrimaryExpression-1($input, $state)
};

(:~
 : Parse PrimaryExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryPrefix($input, $state)
  let $state := p:parse-PrimaryExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpression", $count, $begin, $end)
};

(:~
 : Try parsing PrimaryExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrimaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryPrefix($input, $state)
  let $state := p:try-PrimaryExpression-1($input, $state)
  return $state
};

(:~
 : Parse PreIncrementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreIncrementExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(23, $input, $state)               (: '++' :)
  let $state := p:lookahead1W(129, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpression($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PreIncrementExpression", $count, $begin, $end)
};

(:~
 : Try parsing PreIncrementExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PreIncrementExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(23, $input, $state)              (: '++' :)
  let $state := p:lookahead1W(129, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'false' | 'float' | 'int' | 'long' | 'new' |
                                                               'null' | 'short' | 'super' | 'this' | 'true' | 'void' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryExpression($input, $state)
  return $state
};

(:~
 : Parse UnaryExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22                             (: '+' :)
          or $state[$p:l1] = 26) then                       (: '-' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 22) then                   (: '+' :)
          let $state := p:consume(22, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(26, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '++' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreIncrementExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreDecrementExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnaryExpressionNotPlusMinus($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpression", $count, $begin, $end)
};

(:~
 : Try parsing UnaryExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22                             (: '+' :)
          or $state[$p:l1] = 26) then                       (: '-' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 22) then                   (: '+' :)
          let $state := p:consumeT(22, $input, $state)      (: '+' :)
          return $state
        else
          let $state := p:consumeT(26, $input, $state)      (: '-' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '++' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PreIncrementExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PreDecrementExpression($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnaryExpressionNotPlusMinus($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(138, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | ')' | '*' | '*=' | '+' |
                                                               '+=' | ',' | '-' | '-=' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' |
                                                               '>>>=' | '?' | ']' | '^' | '^=' | 'instanceof' | '|' |
                                                               '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 13                               (: '%' :)
      and $state[$p:l1] != 20                               (: '*' :)
      and $state[$p:l1] != 31) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 20) then                 (: '*' :)
            let $state := p:consume(20, $input, $state)     (: '*' :)
            return $state
          else if ($state[$p:l1] = 31) then                 (: '/' :)
            let $state := p:consume(31, $input, $state)     (: '/' :)
            return $state
          else
            let $state := p:consume(13, $input, $state)     (: '%' :)
            return $state
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-UnaryExpression($input, $state)
        return p:parse-MultiplicativeExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MultiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MultiplicativeExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(138, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%' | '%=' | '&' | '&&' | '&=' | ')' | '*' | '*=' | '+' |
                                                               '+=' | ',' | '-' | '-=' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' |
                                                               '>>>=' | '?' | ']' | '^' | '^=' | 'instanceof' | '|' |
                                                               '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 13                               (: '%' :)
      and $state[$p:l1] != 20                               (: '*' :)
      and $state[$p:l1] != 31) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 20) then                 (: '*' :)
            let $state := p:consumeT(20, $input, $state)    (: '*' :)
            return $state
          else if ($state[$p:l1] = 31) then                 (: '/' :)
            let $state := p:consumeT(31, $input, $state)    (: '/' :)
            return $state
          else
            let $state := p:consumeT(13, $input, $state)    (: '%' :)
            return $state
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-UnaryExpression($input, $state)
        return p:try-MultiplicativeExpression-1($input, $state)
};

(:~
 : Parse MultiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpression($input, $state)
  let $state := p:parse-MultiplicativeExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpression", $count, $begin, $end)
};

(:~
 : Try parsing MultiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MultiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-UnaryExpression($input, $state)
  let $state := p:try-MultiplicativeExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 22                                 (: '+' :)
    and $state[$p:l1] != 26) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 22) then                   (: '+' :)
          let $state := p:consume(22, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(26, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MultiplicativeExpression($input, $state)
      return p:parse-AdditiveExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AdditiveExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AdditiveExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 22                                 (: '+' :)
    and $state[$p:l1] != 26) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 22) then                   (: '+' :)
          let $state := p:consumeT(22, $input, $state)      (: '+' :)
          return $state
        else
          let $state := p:consumeT(26, $input, $state)      (: '-' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MultiplicativeExpression($input, $state)
      return p:try-AdditiveExpression-1($input, $state)
};

(:~
 : Parse AdditiveExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpression($input, $state)
  let $state := p:parse-AdditiveExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpression", $count, $begin, $end)
};

(:~
 : Try parsing AdditiveExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AdditiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MultiplicativeExpression($input, $state)
  let $state := p:try-AdditiveExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ShiftExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ShiftExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 41) then                         (: '>' :)
        let $state := p:lookahead2W(144, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '>' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 36                               (: '<<' :)
      and $state[$p:lk] != 5289) then                       (: '>' '>' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 41) then                     (: '>' :)
            let $state := p:lookahead2W(11, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
            let $state :=
              if ($state[$p:lk] eq 5289) then               (: '>' '>' :)
                let $state := p:lookahead3W(144, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                    FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                    STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                    MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                    '--' | '>' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                    'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                    'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                    'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                    'double' | 'false' | 'float' | 'int' | 'long' |
                                                                    'new' | 'null' | 'short' | 'super' | 'this' |
                                                                    'true' | 'void' | '~' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 36) then                 (: '<<' :)
            let $state := p:consume(36, $input, $state)     (: '<<' :)
            return $state
          else if ($state[$p:lk] = 677033) then             (: '>' '>' '>' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-RUNSIGNEDSHIFT($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-RSIGNEDSHIFT($input, $state)
            return $state
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-AdditiveExpression($input, $state)
        return p:parse-ShiftExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ShiftExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ShiftExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 41) then                         (: '>' :)
        let $state := p:lookahead2W(144, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '>' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 36                               (: '<<' :)
      and $state[$p:lk] != 5289) then                       (: '>' '>' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 41) then                     (: '>' :)
            let $state := p:lookahead2W(11, $input, $state) (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '>' :)
            let $state :=
              if ($state[$p:lk] eq 5289) then               (: '>' '>' :)
                let $state := p:lookahead3W(144, $input, $state) (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                                    FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                                    STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                                    MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                                    '--' | '>' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                                    'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                                    'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                                    'TOKEN_MGR_DECLS' | 'boolean' | 'byte' | 'char' |
                                                                    'double' | 'false' | 'float' | 'int' | 'long' |
                                                                    'new' | 'null' | 'short' | 'super' | 'this' |
                                                                    'true' | 'void' | '~' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 36) then                 (: '<<' :)
            let $state := p:consumeT(36, $input, $state)    (: '<<' :)
            return $state
          else if ($state[$p:lk] = 677033) then             (: '>' '>' '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-RUNSIGNEDSHIFT($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-RSIGNEDSHIFT($input, $state)
            return $state
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AdditiveExpression($input, $state)
        return p:try-ShiftExpression-1($input, $state)
};

(:~
 : Parse ShiftExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ShiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpression($input, $state)
  let $state := p:parse-ShiftExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ShiftExpression", $count, $begin, $end)
};

(:~
 : Try parsing ShiftExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ShiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AdditiveExpression($input, $state)
  let $state := p:try-ShiftExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production RelationalExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelationalExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 35                                 (: '<' :)
    and $state[$p:l1] != 38                                 (: '<=' :)
    and $state[$p:l1] != 41                                 (: '>' :)
    and $state[$p:l1] != 42) then                           (: '>=' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: '<' :)
          let $state := p:consume(35, $input, $state)       (: '<' :)
          return $state
        else if ($state[$p:l1] = 41) then                   (: '>' :)
          let $state := p:consume(41, $input, $state)       (: '>' :)
          return $state
        else if ($state[$p:l1] = 38) then                   (: '<=' :)
          let $state := p:consume(38, $input, $state)       (: '<=' :)
          return $state
        else
          let $state := p:consume(42, $input, $state)       (: '>=' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ShiftExpression($input, $state)
      return p:parse-RelationalExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelationalExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RelationalExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 35                                 (: '<' :)
    and $state[$p:l1] != 38                                 (: '<=' :)
    and $state[$p:l1] != 41                                 (: '>' :)
    and $state[$p:l1] != 42) then                           (: '>=' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: '<' :)
          let $state := p:consumeT(35, $input, $state)      (: '<' :)
          return $state
        else if ($state[$p:l1] = 41) then                   (: '>' :)
          let $state := p:consumeT(41, $input, $state)      (: '>' :)
          return $state
        else if ($state[$p:l1] = 38) then                   (: '<=' :)
          let $state := p:consumeT(38, $input, $state)      (: '<=' :)
          return $state
        else
          let $state := p:consumeT(42, $input, $state)      (: '>=' :)
          return $state
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ShiftExpression($input, $state)
      return p:try-RelationalExpression-1($input, $state)
};

(:~
 : Parse RelationalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ShiftExpression($input, $state)
  let $state := p:parse-RelationalExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelationalExpression", $count, $begin, $end)
};

(:~
 : Try parsing RelationalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RelationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ShiftExpression($input, $state)
  let $state := p:try-RelationalExpression-1($input, $state)
  return $state
};

(:~
 : Parse InstanceOfExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceOfExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RelationalExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 86) then                       (: 'instanceof' :)
      let $state := p:consume(86, $input, $state)           (: 'instanceof' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Type($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceOfExpression", $count, $begin, $end)
};

(:~
 : Try parsing InstanceOfExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InstanceOfExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-RelationalExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 86) then                       (: 'instanceof' :)
      let $state := p:consumeT(86, $input, $state)          (: 'instanceof' :)
      let $state := p:lookahead1W(91, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'boolean' | 'byte' | 'char' |
                                                               'double' | 'float' | 'int' | 'long' | 'short' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Type($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production EqualityExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EqualityExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(123, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%=' | '&' | '&&' | '&=' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '/=' | ':' | ';' | '<<=' | '=' | '==' | '>>=' |
                                                               '>>>=' | '?' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 11                               (: '!=' :)
      and $state[$p:l1] != 40) then                         (: '==' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 40) then                 (: '==' :)
            let $state := p:consume(40, $input, $state)     (: '==' :)
            return $state
          else
            let $state := p:consume(11, $input, $state)     (: '!=' :)
            return $state
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceOfExpression($input, $state)
        return p:parse-EqualityExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production EqualityExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EqualityExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(123, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '!=' |
                                                               '%=' | '&' | '&&' | '&=' | ')' | '*=' | '+=' | ',' |
                                                               '-=' | '/=' | ':' | ';' | '<<=' | '=' | '==' | '>>=' |
                                                               '>>>=' | '?' | ']' | '^' | '^=' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 11                               (: '!=' :)
      and $state[$p:l1] != 40) then                         (: '==' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 40) then                 (: '==' :)
            let $state := p:consumeT(40, $input, $state)    (: '==' :)
            return $state
          else
            let $state := p:consumeT(11, $input, $state)    (: '!=' :)
            return $state
        let $state := p:lookahead1W(139, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-InstanceOfExpression($input, $state)
        return p:try-EqualityExpression-1($input, $state)
};

(:~
 : Parse EqualityExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EqualityExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceOfExpression($input, $state)
  let $state := p:parse-EqualityExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EqualityExpression", $count, $begin, $end)
};

(:~
 : Try parsing EqualityExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EqualityExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InstanceOfExpression($input, $state)
  let $state := p:try-EqualityExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AndExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 15) then                           (: '&' :)
      $state
    else
      let $state := p:consume(15, $input, $state)           (: '&' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EqualityExpression($input, $state)
      return p:parse-AndExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AndExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AndExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 15) then                           (: '&' :)
      $state
    else
      let $state := p:consumeT(15, $input, $state)          (: '&' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EqualityExpression($input, $state)
      return p:try-AndExpression-1($input, $state)
};

(:~
 : Parse AndExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EqualityExpression($input, $state)
  let $state := p:parse-AndExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpression", $count, $begin, $end)
};

(:~
 : Try parsing AndExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AndExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EqualityExpression($input, $state)
  let $state := p:try-AndExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ExclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 60) then                           (: '^' :)
      $state
    else
      let $state := p:consume(60, $input, $state)           (: '^' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AndExpression($input, $state)
      return p:parse-ExclusiveOrExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 60) then                           (: '^' :)
      $state
    else
      let $state := p:consumeT(60, $input, $state)          (: '^' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AndExpression($input, $state)
      return p:try-ExclusiveOrExpression-1($input, $state)
};

(:~
 : Parse ExclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpression($input, $state)
  let $state := p:parse-ExclusiveOrExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExclusiveOrExpression", $count, $begin, $end)
};

(:~
 : Try parsing ExclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AndExpression($input, $state)
  let $state := p:try-ExclusiveOrExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production InclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 115) then                          (: '|' :)
      $state
    else
      let $state := p:consume(115, $input, $state)          (: '|' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExclusiveOrExpression($input, $state)
      return p:parse-InclusiveOrExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production InclusiveOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InclusiveOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 115) then                          (: '|' :)
      $state
    else
      let $state := p:consumeT(115, $input, $state)         (: '|' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExclusiveOrExpression($input, $state)
      return p:try-InclusiveOrExpression-1($input, $state)
};

(:~
 : Parse InclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExclusiveOrExpression($input, $state)
  let $state := p:parse-InclusiveOrExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InclusiveOrExpression", $count, $begin, $end)
};

(:~
 : Try parsing InclusiveOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InclusiveOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExclusiveOrExpression($input, $state)
  let $state := p:try-InclusiveOrExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ConditionalAndExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConditionalAndExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 16) then                           (: '&&' :)
      $state
    else
      let $state := p:consume(16, $input, $state)           (: '&&' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InclusiveOrExpression($input, $state)
      return p:parse-ConditionalAndExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ConditionalAndExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ConditionalAndExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 16) then                           (: '&&' :)
      $state
    else
      let $state := p:consumeT(16, $input, $state)          (: '&&' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-InclusiveOrExpression($input, $state)
      return p:try-ConditionalAndExpression-1($input, $state)
};

(:~
 : Parse ConditionalAndExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConditionalAndExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InclusiveOrExpression($input, $state)
  let $state := p:parse-ConditionalAndExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ConditionalAndExpression", $count, $begin, $end)
};

(:~
 : Try parsing ConditionalAndExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ConditionalAndExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InclusiveOrExpression($input, $state)
  let $state := p:try-ConditionalAndExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ConditionalOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConditionalOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 117) then                          (: '||' :)
      $state
    else
      let $state := p:consume(117, $input, $state)          (: '||' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConditionalAndExpression($input, $state)
      return p:parse-ConditionalOrExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ConditionalOrExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ConditionalOrExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 117) then                          (: '||' :)
      $state
    else
      let $state := p:consumeT(117, $input, $state)         (: '||' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ConditionalAndExpression($input, $state)
      return p:try-ConditionalOrExpression-1($input, $state)
};

(:~
 : Parse ConditionalOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConditionalOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ConditionalAndExpression($input, $state)
  let $state := p:parse-ConditionalOrExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ConditionalOrExpression", $count, $begin, $end)
};

(:~
 : Try parsing ConditionalOrExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ConditionalOrExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ConditionalAndExpression($input, $state)
  let $state := p:try-ConditionalOrExpression-1($input, $state)
  return $state
};

(:~
 : Parse ConditionalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ConditionalOrExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '?' :)
      let $state := p:consume(45, $input, $state)           (: '?' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      let $state := p:consume(33, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expression($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConditionalExpression", $count, $begin, $end)
};

(:~
 : Try parsing ConditionalExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ConditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ConditionalOrExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '?' :)
      let $state := p:consumeT(45, $input, $state)          (: '?' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      let $state := p:consumeT(33, $input, $state)          (: ':' :)
      let $state := p:lookahead1W(139, $input, $state)      (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' | 'LOOKAHEAD' |
                                                               'MORE' | 'PARSER_BEGIN' | 'PARSER_END' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expression($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production MemberValueArrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MemberValueArrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '}' :)
    let $state :=
      if ($state[$p:l1] eq 25) then                         (: ',' :)
        let $state := p:lookahead2W(155, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 118                               (: '}' :)
       or $state[$p:lk] = 15129) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(150, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-MemberValue($input, $state)
        return p:parse-MemberValueArrayInitializer-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MemberValueArrayInitializer (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MemberValueArrayInitializer-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ',' |
                                                               '}' :)
    let $state :=
      if ($state[$p:l1] eq 25) then                         (: ',' :)
        let $state := p:lookahead2W(155, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '}' | '~' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 118                               (: '}' :)
       or $state[$p:lk] = 15129) then                       (: ',' '}' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(150, $input, $state)    (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-MemberValue($input, $state)
        return p:try-MemberValueArrayInitializer-1($input, $state)
};

(:~
 : Parse MemberValueArrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MemberValueArrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(114, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MemberValue($input, $state)
  let $state := p:parse-MemberValueArrayInitializer-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consume(25, $input, $state)           (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '}' :)
  let $state := p:consume(118, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "MemberValueArrayInitializer", $count, $begin, $end)
};

(:~
 : Try parsing MemberValueArrayInitializer.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MemberValueArrayInitializer($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(114, $input, $state)             (: '{' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MemberValue($input, $state)
  let $state := p:try-MemberValueArrayInitializer-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: ',' :)
      let $state := p:consumeT(25, $input, $state)          (: ',' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '}' :)
  let $state := p:consumeT(118, $input, $state)             (: '}' :)
  return $state
};

(:~
 : Parse MemberValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MemberValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MemberValueArrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConditionalExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "MemberValue", $count, $begin, $end)
};

(:~
 : Try parsing MemberValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MemberValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: '@' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Annotation($input, $state)
      return $state
    else if ($state[$p:l1] = 114) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MemberValueArrayInitializer($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ConditionalExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse MemberValuePair.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MemberValuePair($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $state := p:lookahead1W(10, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '=' :)
  let $state := p:consume(39, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MemberValue($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MemberValuePair", $count, $begin, $end)
};

(:~
 : Try parsing MemberValuePair.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MemberValuePair($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  let $state := p:lookahead1W(10, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '=' :)
  let $state := p:consumeT(39, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(150, $input, $state)          (: IDENTIFIER | SKIP | INTEGER_LITERAL |
                                                               FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
                                                               STRING_LITERAL | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!' | '(' | '+' | '++' | '-' |
                                                               '--' | '@' | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'false' |
                                                               'float' | 'int' | 'long' | 'new' | 'null' | 'short' |
                                                               'super' | 'this' | 'true' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MemberValue($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MemberValuePairs (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MemberValuePairs-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               ',' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consume(25, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-MemberValuePair($input, $state)
        return p:parse-MemberValuePairs-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MemberValuePairs (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MemberValuePairs-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' |
                                                               ',' :)
    return
      if ($state[$p:l1] != 25) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(25, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-MemberValuePair($input, $state)
        return p:try-MemberValuePairs-1($input, $state)
};

(:~
 : Parse MemberValuePairs.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MemberValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MemberValuePair($input, $state)
  let $state := p:parse-MemberValuePairs-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MemberValuePairs", $count, $begin, $end)
};

(:~
 : Try parsing MemberValuePairs.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MemberValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MemberValuePair($input, $state)
  let $state := p:try-MemberValuePairs-1($input, $state)
  return $state
};

(:~
 : Parse JavaIdentifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-JavaIdentifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'LOOKAHEAD' :)
      let $state := p:consume(50, $input, $state)           (: 'LOOKAHEAD' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: 'IGNORE_CASE' :)
      let $state := p:consume(48, $input, $state)           (: 'IGNORE_CASE' :)
      return $state
    else if ($state[$p:l1] = 52) then                       (: 'PARSER_BEGIN' :)
      let $state := p:consume(52, $input, $state)           (: 'PARSER_BEGIN' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: 'PARSER_END' :)
      let $state := p:consume(53, $input, $state)           (: 'PARSER_END' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: 'JAVACODE' :)
      let $state := p:consume(49, $input, $state)           (: 'JAVACODE' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'TOKEN' :)
      let $state := p:consume(56, $input, $state)           (: 'TOKEN' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'SPECIAL_TOKEN' :)
      let $state := p:consume(55, $input, $state)           (: 'SPECIAL_TOKEN' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: 'MORE' :)
      let $state := p:consume(51, $input, $state)           (: 'MORE' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'SKIP' :)
      let $state := p:consume(54, $input, $state)           (: 'SKIP' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'TOKEN_MGR_DECLS' :)
      let $state := p:consume(57, $input, $state)           (: 'TOKEN_MGR_DECLS' :)
      return $state
    else
      let $state := p:consume(47, $input, $state)           (: 'EOF' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "JavaIdentifier", $count, $begin, $end)
};

(:~
 : Try parsing JavaIdentifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-JavaIdentifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:consumeT(1, $input, $state)           (: IDENTIFIER :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'LOOKAHEAD' :)
      let $state := p:consumeT(50, $input, $state)          (: 'LOOKAHEAD' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: 'IGNORE_CASE' :)
      let $state := p:consumeT(48, $input, $state)          (: 'IGNORE_CASE' :)
      return $state
    else if ($state[$p:l1] = 52) then                       (: 'PARSER_BEGIN' :)
      let $state := p:consumeT(52, $input, $state)          (: 'PARSER_BEGIN' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: 'PARSER_END' :)
      let $state := p:consumeT(53, $input, $state)          (: 'PARSER_END' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: 'JAVACODE' :)
      let $state := p:consumeT(49, $input, $state)          (: 'JAVACODE' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'TOKEN' :)
      let $state := p:consumeT(56, $input, $state)          (: 'TOKEN' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'SPECIAL_TOKEN' :)
      let $state := p:consumeT(55, $input, $state)          (: 'SPECIAL_TOKEN' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: 'MORE' :)
      let $state := p:consumeT(51, $input, $state)          (: 'MORE' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'SKIP' :)
      let $state := p:consumeT(54, $input, $state)          (: 'SKIP' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'TOKEN_MGR_DECLS' :)
      let $state := p:consumeT(57, $input, $state)          (: 'TOKEN_MGR_DECLS' :)
      return $state
    else
      let $state := p:consumeT(47, $input, $state)          (: 'EOF' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Name (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Name-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(173, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' |
                                                               '>>>=' | '?' | '@' | '[' | ']' | '^' | '^=' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                               'double' | 'enum' | 'final' | 'float' | 'instanceof' |
                                                               'int' | 'interface' | 'long' | 'native' | 'package' |
                                                               'private' | 'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 29) then                         (: '.' :)
        let $state := p:lookahead2W(106, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '*' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'new' | 'super' | 'this' :)
        let $state :=
          if ($state[$p:lk] eq 157) then                    (: '.' IDENTIFIER :)
            let $state := p:lookahead3W(173, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                                '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                                ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                                '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                                '>>=' | '>>>=' | '?' | '@' | '[' | ']' | '^' | '^=' |
                                                                'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                                'double' | 'enum' | 'final' | 'float' | 'instanceof' |
                                                                'int' | 'interface' | 'long' | 'native' | 'package' |
                                                                'private' | 'protected' | 'public' | 'short' |
                                                                'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                                'void' | 'volatile' | '{' | '|' | '|=' | '||' | '}' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 180381                       (: '.' IDENTIFIER '!=' :)
            or $state[$p:lk] = 213149                       (: '.' IDENTIFIER '%' :)
            or $state[$p:lk] = 229533                       (: '.' IDENTIFIER '%=' :)
            or $state[$p:lk] = 245917                       (: '.' IDENTIFIER '&' :)
            or $state[$p:lk] = 262301                       (: '.' IDENTIFIER '&&' :)
            or $state[$p:lk] = 278685                       (: '.' IDENTIFIER '&=' :)
            or $state[$p:lk] = 295069                       (: '.' IDENTIFIER '(' :)
            or $state[$p:lk] = 311453                       (: '.' IDENTIFIER ')' :)
            or $state[$p:lk] = 327837                       (: '.' IDENTIFIER '*' :)
            or $state[$p:lk] = 344221                       (: '.' IDENTIFIER '*=' :)
            or $state[$p:lk] = 360605                       (: '.' IDENTIFIER '+' :)
            or $state[$p:lk] = 376989                       (: '.' IDENTIFIER '++' :)
            or $state[$p:lk] = 393373                       (: '.' IDENTIFIER '+=' :)
            or $state[$p:lk] = 409757                       (: '.' IDENTIFIER ',' :)
            or $state[$p:lk] = 426141                       (: '.' IDENTIFIER '-' :)
            or $state[$p:lk] = 442525                       (: '.' IDENTIFIER '--' :)
            or $state[$p:lk] = 458909                       (: '.' IDENTIFIER '-=' :)
            or $state[$p:lk] = 475293                       (: '.' IDENTIFIER '.' :)
            or $state[$p:lk] = 508061                       (: '.' IDENTIFIER '/' :)
            or $state[$p:lk] = 524445                       (: '.' IDENTIFIER '/=' :)
            or $state[$p:lk] = 540829                       (: '.' IDENTIFIER ':' :)
            or $state[$p:lk] = 557213                       (: '.' IDENTIFIER ';' :)
            or $state[$p:lk] = 573597                       (: '.' IDENTIFIER '<' :)
            or $state[$p:lk] = 589981                       (: '.' IDENTIFIER '<<' :)
            or $state[$p:lk] = 606365                       (: '.' IDENTIFIER '<<=' :)
            or $state[$p:lk] = 622749                       (: '.' IDENTIFIER '<=' :)
            or $state[$p:lk] = 639133                       (: '.' IDENTIFIER '=' :)
            or $state[$p:lk] = 655517                       (: '.' IDENTIFIER '==' :)
            or $state[$p:lk] = 671901                       (: '.' IDENTIFIER '>' :)
            or $state[$p:lk] = 688285                       (: '.' IDENTIFIER '>=' :)
            or $state[$p:lk] = 704669                       (: '.' IDENTIFIER '>>=' :)
            or $state[$p:lk] = 721053                       (: '.' IDENTIFIER '>>>=' :)
            or $state[$p:lk] = 737437                       (: '.' IDENTIFIER '?' :)
            or $state[$p:lk] = 950429                       (: '.' IDENTIFIER '[' :)
            or $state[$p:lk] = 966813                       (: '.' IDENTIFIER ']' :)
            or $state[$p:lk] = 983197                       (: '.' IDENTIFIER '^' :)
            or $state[$p:lk] = 999581                       (: '.' IDENTIFIER '^=' :)
            or $state[$p:lk] = 1409181                      (: '.' IDENTIFIER 'instanceof' :)
            or $state[$p:lk] = 1884317                      (: '.' IDENTIFIER '|' :)
            or $state[$p:lk] = 1900701                      (: '.' IDENTIFIER '|=' :)
            or $state[$p:lk] = 1917085                      (: '.' IDENTIFIER '||' :)
            or $state[$p:lk] = 1933469) then                (: '.' IDENTIFIER '}' :)
        let $state := p:memoized($state, 13)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(29, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(94, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-JavaIdentifier($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 6045                             (: '.' 'EOF' :)
      and $state[$p:lk] != 6173                             (: '.' 'IGNORE_CASE' :)
      and $state[$p:lk] != 6301                             (: '.' 'JAVACODE' :)
      and $state[$p:lk] != 6429                             (: '.' 'LOOKAHEAD' :)
      and $state[$p:lk] != 6557                             (: '.' 'MORE' :)
      and $state[$p:lk] != 6685                             (: '.' 'PARSER_BEGIN' :)
      and $state[$p:lk] != 6813                             (: '.' 'PARSER_END' :)
      and $state[$p:lk] != 6941                             (: '.' 'SKIP' :)
      and $state[$p:lk] != 7069                             (: '.' 'SPECIAL_TOKEN' :)
      and $state[$p:lk] != 7197                             (: '.' 'TOKEN' :)
      and $state[$p:lk] != 7325                             (: '.' 'TOKEN_MGR_DECLS' :)
      and $state[$p:lk] != 16541                            (: '.' IDENTIFIER IDENTIFIER :)
      and $state[$p:lk] != 753821                           (: '.' IDENTIFIER '@' :)
      and $state[$p:lk] != 1015965                          (: '.' IDENTIFIER 'abstract' :)
      and $state[$p:lk] != 1048733                          (: '.' IDENTIFIER 'boolean' :)
      and $state[$p:lk] != 1081501                          (: '.' IDENTIFIER 'byte' :)
      and $state[$p:lk] != 1130653                          (: '.' IDENTIFIER 'char' :)
      and $state[$p:lk] != 1147037                          (: '.' IDENTIFIER 'class' :)
      and $state[$p:lk] != 1212573                          (: '.' IDENTIFIER 'double' :)
      and $state[$p:lk] != 1245341                          (: '.' IDENTIFIER 'enum' :)
      and $state[$p:lk] != 1294493                          (: '.' IDENTIFIER 'final' :)
      and $state[$p:lk] != 1327261                          (: '.' IDENTIFIER 'float' :)
      and $state[$p:lk] != 1425565                          (: '.' IDENTIFIER 'int' :)
      and $state[$p:lk] != 1441949                          (: '.' IDENTIFIER 'interface' :)
      and $state[$p:lk] != 1458333                          (: '.' IDENTIFIER 'long' :)
      and $state[$p:lk] != 1474717                          (: '.' IDENTIFIER 'native' :)
      and $state[$p:lk] != 1540253                          (: '.' IDENTIFIER 'package' :)
      and $state[$p:lk] != 1556637                          (: '.' IDENTIFIER 'private' :)
      and $state[$p:lk] != 1573021                          (: '.' IDENTIFIER 'protected' :)
      and $state[$p:lk] != 1589405                          (: '.' IDENTIFIER 'public' :)
      and $state[$p:lk] != 1622173                          (: '.' IDENTIFIER 'short' :)
      and $state[$p:lk] != 1638557                          (: '.' IDENTIFIER 'static' :)
      and $state[$p:lk] != 1654941                          (: '.' IDENTIFIER 'strictfp' :)
      and $state[$p:lk] != 1704093                          (: '.' IDENTIFIER 'synchronized' :)
      and $state[$p:lk] != 1769629                          (: '.' IDENTIFIER 'transient' :)
      and $state[$p:lk] != 1818781                          (: '.' IDENTIFIER 'void' :)
      and $state[$p:lk] != 1835165                          (: '.' IDENTIFIER 'volatile' :)
      and $state[$p:lk] != 1867933) then                    (: '.' IDENTIFIER '{' :)
        $state
      else
        let $state := p:consume(29, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(94, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-JavaIdentifier($input, $state)
        return p:parse-Name-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Name (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Name-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(173, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>=' |
                                                               '>>>=' | '?' | '@' | '[' | ']' | '^' | '^=' |
                                                               'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                               'double' | 'enum' | 'final' | 'float' | 'instanceof' |
                                                               'int' | 'interface' | 'long' | 'native' | 'package' |
                                                               'private' | 'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '{' | '|' | '|=' | '||' | '}' :)
    let $state :=
      if ($state[$p:l1] eq 29) then                         (: '.' :)
        let $state := p:lookahead2W(106, $input, $state)    (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '*' | '<' | 'EOF' | 'IGNORE_CASE' |
                                                               'JAVACODE' | 'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' |
                                                               'PARSER_END' | 'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' |
                                                               'TOKEN_MGR_DECLS' | 'new' | 'super' | 'this' :)
        let $state :=
          if ($state[$p:lk] eq 157) then                    (: '.' IDENTIFIER :)
            let $state := p:lookahead3W(173, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                                MULTI_LINE_COMMENT | '!=' | '%' | '%=' | '&' | '&&' |
                                                                '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' |
                                                                ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' |
                                                                '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' |
                                                                '>>=' | '>>>=' | '?' | '@' | '[' | ']' | '^' | '^=' |
                                                                'abstract' | 'boolean' | 'byte' | 'char' | 'class' |
                                                                'double' | 'enum' | 'final' | 'float' | 'instanceof' |
                                                                'int' | 'interface' | 'long' | 'native' | 'package' |
                                                                'private' | 'protected' | 'public' | 'short' |
                                                                'static' | 'strictfp' | 'synchronized' | 'transient' |
                                                                'void' | 'volatile' | '{' | '|' | '|=' | '||' | '}' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 180381                       (: '.' IDENTIFIER '!=' :)
            or $state[$p:lk] = 213149                       (: '.' IDENTIFIER '%' :)
            or $state[$p:lk] = 229533                       (: '.' IDENTIFIER '%=' :)
            or $state[$p:lk] = 245917                       (: '.' IDENTIFIER '&' :)
            or $state[$p:lk] = 262301                       (: '.' IDENTIFIER '&&' :)
            or $state[$p:lk] = 278685                       (: '.' IDENTIFIER '&=' :)
            or $state[$p:lk] = 295069                       (: '.' IDENTIFIER '(' :)
            or $state[$p:lk] = 311453                       (: '.' IDENTIFIER ')' :)
            or $state[$p:lk] = 327837                       (: '.' IDENTIFIER '*' :)
            or $state[$p:lk] = 344221                       (: '.' IDENTIFIER '*=' :)
            or $state[$p:lk] = 360605                       (: '.' IDENTIFIER '+' :)
            or $state[$p:lk] = 376989                       (: '.' IDENTIFIER '++' :)
            or $state[$p:lk] = 393373                       (: '.' IDENTIFIER '+=' :)
            or $state[$p:lk] = 409757                       (: '.' IDENTIFIER ',' :)
            or $state[$p:lk] = 426141                       (: '.' IDENTIFIER '-' :)
            or $state[$p:lk] = 442525                       (: '.' IDENTIFIER '--' :)
            or $state[$p:lk] = 458909                       (: '.' IDENTIFIER '-=' :)
            or $state[$p:lk] = 475293                       (: '.' IDENTIFIER '.' :)
            or $state[$p:lk] = 508061                       (: '.' IDENTIFIER '/' :)
            or $state[$p:lk] = 524445                       (: '.' IDENTIFIER '/=' :)
            or $state[$p:lk] = 540829                       (: '.' IDENTIFIER ':' :)
            or $state[$p:lk] = 557213                       (: '.' IDENTIFIER ';' :)
            or $state[$p:lk] = 573597                       (: '.' IDENTIFIER '<' :)
            or $state[$p:lk] = 589981                       (: '.' IDENTIFIER '<<' :)
            or $state[$p:lk] = 606365                       (: '.' IDENTIFIER '<<=' :)
            or $state[$p:lk] = 622749                       (: '.' IDENTIFIER '<=' :)
            or $state[$p:lk] = 639133                       (: '.' IDENTIFIER '=' :)
            or $state[$p:lk] = 655517                       (: '.' IDENTIFIER '==' :)
            or $state[$p:lk] = 671901                       (: '.' IDENTIFIER '>' :)
            or $state[$p:lk] = 688285                       (: '.' IDENTIFIER '>=' :)
            or $state[$p:lk] = 704669                       (: '.' IDENTIFIER '>>=' :)
            or $state[$p:lk] = 721053                       (: '.' IDENTIFIER '>>>=' :)
            or $state[$p:lk] = 737437                       (: '.' IDENTIFIER '?' :)
            or $state[$p:lk] = 950429                       (: '.' IDENTIFIER '[' :)
            or $state[$p:lk] = 966813                       (: '.' IDENTIFIER ']' :)
            or $state[$p:lk] = 983197                       (: '.' IDENTIFIER '^' :)
            or $state[$p:lk] = 999581                       (: '.' IDENTIFIER '^=' :)
            or $state[$p:lk] = 1409181                      (: '.' IDENTIFIER 'instanceof' :)
            or $state[$p:lk] = 1884317                      (: '.' IDENTIFIER '|' :)
            or $state[$p:lk] = 1900701                      (: '.' IDENTIFIER '|=' :)
            or $state[$p:lk] = 1917085                      (: '.' IDENTIFIER '||' :)
            or $state[$p:lk] = 1933469) then                (: '.' IDENTIFIER '}' :)
        let $state := p:memoized($state, 13)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(29, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(94, $input, $state) (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-JavaIdentifier($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 13, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-Name-1($input, $state)
      else if ($state[$p:lk] != -1
           and $state[$p:lk] != 6045                        (: '.' 'EOF' :)
           and $state[$p:lk] != 6173                        (: '.' 'IGNORE_CASE' :)
           and $state[$p:lk] != 6301                        (: '.' 'JAVACODE' :)
           and $state[$p:lk] != 6429                        (: '.' 'LOOKAHEAD' :)
           and $state[$p:lk] != 6557                        (: '.' 'MORE' :)
           and $state[$p:lk] != 6685                        (: '.' 'PARSER_BEGIN' :)
           and $state[$p:lk] != 6813                        (: '.' 'PARSER_END' :)
           and $state[$p:lk] != 6941                        (: '.' 'SKIP' :)
           and $state[$p:lk] != 7069                        (: '.' 'SPECIAL_TOKEN' :)
           and $state[$p:lk] != 7197                        (: '.' 'TOKEN' :)
           and $state[$p:lk] != 7325                        (: '.' 'TOKEN_MGR_DECLS' :)
           and $state[$p:lk] != 16541                       (: '.' IDENTIFIER IDENTIFIER :)
           and $state[$p:lk] != 753821                      (: '.' IDENTIFIER '@' :)
           and $state[$p:lk] != 1015965                     (: '.' IDENTIFIER 'abstract' :)
           and $state[$p:lk] != 1048733                     (: '.' IDENTIFIER 'boolean' :)
           and $state[$p:lk] != 1081501                     (: '.' IDENTIFIER 'byte' :)
           and $state[$p:lk] != 1130653                     (: '.' IDENTIFIER 'char' :)
           and $state[$p:lk] != 1147037                     (: '.' IDENTIFIER 'class' :)
           and $state[$p:lk] != 1212573                     (: '.' IDENTIFIER 'double' :)
           and $state[$p:lk] != 1245341                     (: '.' IDENTIFIER 'enum' :)
           and $state[$p:lk] != 1294493                     (: '.' IDENTIFIER 'final' :)
           and $state[$p:lk] != 1327261                     (: '.' IDENTIFIER 'float' :)
           and $state[$p:lk] != 1425565                     (: '.' IDENTIFIER 'int' :)
           and $state[$p:lk] != 1441949                     (: '.' IDENTIFIER 'interface' :)
           and $state[$p:lk] != 1458333                     (: '.' IDENTIFIER 'long' :)
           and $state[$p:lk] != 1474717                     (: '.' IDENTIFIER 'native' :)
           and $state[$p:lk] != 1540253                     (: '.' IDENTIFIER 'package' :)
           and $state[$p:lk] != 1556637                     (: '.' IDENTIFIER 'private' :)
           and $state[$p:lk] != 1573021                     (: '.' IDENTIFIER 'protected' :)
           and $state[$p:lk] != 1589405                     (: '.' IDENTIFIER 'public' :)
           and $state[$p:lk] != 1622173                     (: '.' IDENTIFIER 'short' :)
           and $state[$p:lk] != 1638557                     (: '.' IDENTIFIER 'static' :)
           and $state[$p:lk] != 1654941                     (: '.' IDENTIFIER 'strictfp' :)
           and $state[$p:lk] != 1704093                     (: '.' IDENTIFIER 'synchronized' :)
           and $state[$p:lk] != 1769629                     (: '.' IDENTIFIER 'transient' :)
           and $state[$p:lk] != 1818781                     (: '.' IDENTIFIER 'void' :)
           and $state[$p:lk] != 1835165                     (: '.' IDENTIFIER 'volatile' :)
           and $state[$p:lk] != 1867933) then               (: '.' IDENTIFIER '{' :)
        $state
      else
        let $state := p:consumeT(29, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(94, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-JavaIdentifier($input, $state)
        return p:try-Name-1($input, $state)
};

(:~
 : Parse Name.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Name($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-JavaIdentifier($input, $state)
  let $state := p:parse-Name-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Name", $count, $begin, $end)
};

(:~
 : Try parsing Name.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Name($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-JavaIdentifier($input, $state)
  let $state := p:try-Name-1($input, $state)
  return $state
};

(:~
 : Parse NormalAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NormalAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(46, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MemberValuePairs($input, $state)
      return $state
    else
      $state
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NormalAnnotation", $count, $begin, $end)
};

(:~
 : Try parsing NormalAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NormalAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(46, $input, $state)              (: '@' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Name($input, $state)
  let $state := p:consumeT(18, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MemberValuePairs($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(19, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 46) then                           (: '@' :)
      let $state := p:lookahead2W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:lk] = (174,                           (: '@' IDENTIFIER :)
                             6062,                          (: '@' 'EOF' :)
                             6190,                          (: '@' 'IGNORE_CASE' :)
                             6318,                          (: '@' 'JAVACODE' :)
                             6446,                          (: '@' 'LOOKAHEAD' :)
                             6574,                          (: '@' 'MORE' :)
                             6702,                          (: '@' 'PARSER_BEGIN' :)
                             6830,                          (: '@' 'PARSER_END' :)
                             6958,                          (: '@' 'SKIP' :)
                             7086,                          (: '@' 'SPECIAL_TOKEN' :)
                             7214,                          (: '@' 'TOKEN' :)
                             7342)) then                    (: '@' 'TOKEN_MGR_DECLS' :)
          let $state := p:lookahead3W(130, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | ';' | '<' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'enum' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'package' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 295086                         (: '@' IDENTIFIER '(' :)
          or $state[$p:lk] = 300974                         (: '@' 'EOF' '(' :)
          or $state[$p:lk] = 301102                         (: '@' 'IGNORE_CASE' '(' :)
          or $state[$p:lk] = 301230                         (: '@' 'JAVACODE' '(' :)
          or $state[$p:lk] = 301358                         (: '@' 'LOOKAHEAD' '(' :)
          or $state[$p:lk] = 301486                         (: '@' 'MORE' '(' :)
          or $state[$p:lk] = 301614                         (: '@' 'PARSER_BEGIN' '(' :)
          or $state[$p:lk] = 301742                         (: '@' 'PARSER_END' '(' :)
          or $state[$p:lk] = 301870                         (: '@' 'SKIP' '(' :)
          or $state[$p:lk] = 301998                         (: '@' 'SPECIAL_TOKEN' '(' :)
          or $state[$p:lk] = 302126                         (: '@' 'TOKEN' '(' :)
          or $state[$p:lk] = 302254                         (: '@' 'TOKEN_MGR_DECLS' '(' :)
          or $state[$p:lk] = 475310                         (: '@' IDENTIFIER '.' :)
          or $state[$p:lk] = 481198                         (: '@' 'EOF' '.' :)
          or $state[$p:lk] = 481326                         (: '@' 'IGNORE_CASE' '.' :)
          or $state[$p:lk] = 481454                         (: '@' 'JAVACODE' '.' :)
          or $state[$p:lk] = 481582                         (: '@' 'LOOKAHEAD' '.' :)
          or $state[$p:lk] = 481710                         (: '@' 'MORE' '.' :)
          or $state[$p:lk] = 481838                         (: '@' 'PARSER_BEGIN' '.' :)
          or $state[$p:lk] = 481966                         (: '@' 'PARSER_END' '.' :)
          or $state[$p:lk] = 482094                         (: '@' 'SKIP' '.' :)
          or $state[$p:lk] = 482222                         (: '@' 'SPECIAL_TOKEN' '.' :)
          or $state[$p:lk] = 482350                         (: '@' 'TOKEN' '.' :)
          or $state[$p:lk] = 482478) then                   (: '@' 'TOKEN_MGR_DECLS' '.' :)
      let $state := p:memoized($state, 23)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-NormalAnnotation($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -1, -1)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-SingleMemberAnnotation($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -2, -2)
                else
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -3, -3)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NormalAnnotation($input, $state)
      return $state
    else if ($state[$p:lk] = -2) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleMemberAnnotation($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MarkerAnnotation($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Annotation", $count, $begin, $end)
};

(:~
 : Try parsing Annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 46) then                           (: '@' :)
      let $state := p:lookahead2W(94, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
      let $state :=
        if ($state[$p:lk] = (174,                           (: '@' IDENTIFIER :)
                             6062,                          (: '@' 'EOF' :)
                             6190,                          (: '@' 'IGNORE_CASE' :)
                             6318,                          (: '@' 'JAVACODE' :)
                             6446,                          (: '@' 'LOOKAHEAD' :)
                             6574,                          (: '@' 'MORE' :)
                             6702,                          (: '@' 'PARSER_BEGIN' :)
                             6830,                          (: '@' 'PARSER_END' :)
                             6958,                          (: '@' 'SKIP' :)
                             7086,                          (: '@' 'SPECIAL_TOKEN' :)
                             7214,                          (: '@' 'TOKEN' :)
                             7342)) then                    (: '@' 'TOKEN_MGR_DECLS' :)
          let $state := p:lookahead3W(130, $input, $state)  (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '(' | ')' | ',' | '.' | ';' | '<' |
                                                               '@' | 'abstract' | 'boolean' | 'byte' | 'char' |
                                                               'class' | 'double' | 'enum' | 'final' | 'float' | 'int' |
                                                               'interface' | 'long' | 'native' | 'package' | 'private' |
                                                               'protected' | 'public' | 'short' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'void' |
                                                               'volatile' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 295086                         (: '@' IDENTIFIER '(' :)
          or $state[$p:lk] = 300974                         (: '@' 'EOF' '(' :)
          or $state[$p:lk] = 301102                         (: '@' 'IGNORE_CASE' '(' :)
          or $state[$p:lk] = 301230                         (: '@' 'JAVACODE' '(' :)
          or $state[$p:lk] = 301358                         (: '@' 'LOOKAHEAD' '(' :)
          or $state[$p:lk] = 301486                         (: '@' 'MORE' '(' :)
          or $state[$p:lk] = 301614                         (: '@' 'PARSER_BEGIN' '(' :)
          or $state[$p:lk] = 301742                         (: '@' 'PARSER_END' '(' :)
          or $state[$p:lk] = 301870                         (: '@' 'SKIP' '(' :)
          or $state[$p:lk] = 301998                         (: '@' 'SPECIAL_TOKEN' '(' :)
          or $state[$p:lk] = 302126                         (: '@' 'TOKEN' '(' :)
          or $state[$p:lk] = 302254                         (: '@' 'TOKEN_MGR_DECLS' '(' :)
          or $state[$p:lk] = 475310                         (: '@' IDENTIFIER '.' :)
          or $state[$p:lk] = 481198                         (: '@' 'EOF' '.' :)
          or $state[$p:lk] = 481326                         (: '@' 'IGNORE_CASE' '.' :)
          or $state[$p:lk] = 481454                         (: '@' 'JAVACODE' '.' :)
          or $state[$p:lk] = 481582                         (: '@' 'LOOKAHEAD' '.' :)
          or $state[$p:lk] = 481710                         (: '@' 'MORE' '.' :)
          or $state[$p:lk] = 481838                         (: '@' 'PARSER_BEGIN' '.' :)
          or $state[$p:lk] = 481966                         (: '@' 'PARSER_END' '.' :)
          or $state[$p:lk] = 482094                         (: '@' 'SKIP' '.' :)
          or $state[$p:lk] = 482222                         (: '@' 'SPECIAL_TOKEN' '.' :)
          or $state[$p:lk] = 482350                         (: '@' 'TOKEN' '.' :)
          or $state[$p:lk] = 482478) then                   (: '@' 'TOKEN_MGR_DECLS' '.' :)
      let $state := p:memoized($state, 23)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-NormalAnnotation($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -1, -1)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-SingleMemberAnnotation($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -2, -2)
                else
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -3, -3)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NormalAnnotation($input, $state)
      return $state
    else if ($state[$p:lk] = -2) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SingleMemberAnnotation($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MarkerAnnotation($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Modifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Modifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(124, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'class' | 'double' | 'enum' | 'final' |
                                                               'float' | 'int' | 'interface' | 'long' | 'native' |
                                                               'package' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'void' | 'volatile' :)
    let $state :=
      if ($state[$p:l1] eq 46) then                         (: '@' :)
        let $state := p:lookahead2W(98, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 1                                 (: IDENTIFIER :)
       or $state[$p:lk] = 35                                (: '<' :)
       or $state[$p:lk] = 64                                (: 'boolean' :)
       or $state[$p:lk] = 66                                (: 'byte' :)
       or $state[$p:lk] = 69                                (: 'char' :)
       or $state[$p:lk] = 70                                (: 'class' :)
       or $state[$p:lk] = 74                                (: 'double' :)
       or $state[$p:lk] = 76                                (: 'enum' :)
       or $state[$p:lk] = 81                                (: 'float' :)
       or $state[$p:lk] = 87                                (: 'int' :)
       or $state[$p:lk] = 88                                (: 'interface' :)
       or $state[$p:lk] = 89                                (: 'long' :)
       or $state[$p:lk] = 94                                (: 'package' :)
       or $state[$p:lk] = 99                                (: 'short' :)
       or $state[$p:lk] = 111                               (: 'void' :)
       or $state[$p:lk] = 11310) then                       (: '@' 'interface' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 97) then                 (: 'public' :)
            let $state := p:consume(97, $input, $state)     (: 'public' :)
            return $state
          else if ($state[$p:l1] = 100) then                (: 'static' :)
            let $state := p:consume(100, $input, $state)    (: 'static' :)
            return $state
          else if ($state[$p:l1] = 96) then                 (: 'protected' :)
            let $state := p:consume(96, $input, $state)     (: 'protected' :)
            return $state
          else if ($state[$p:l1] = 95) then                 (: 'private' :)
            let $state := p:consume(95, $input, $state)     (: 'private' :)
            return $state
          else if ($state[$p:l1] = 79) then                 (: 'final' :)
            let $state := p:consume(79, $input, $state)     (: 'final' :)
            return $state
          else if ($state[$p:l1] = 62) then                 (: 'abstract' :)
            let $state := p:consume(62, $input, $state)     (: 'abstract' :)
            return $state
          else if ($state[$p:l1] = 104) then                (: 'synchronized' :)
            let $state := p:consume(104, $input, $state)    (: 'synchronized' :)
            return $state
          else if ($state[$p:l1] = 90) then                 (: 'native' :)
            let $state := p:consume(90, $input, $state)     (: 'native' :)
            return $state
          else if ($state[$p:l1] = 108) then                (: 'transient' :)
            let $state := p:consume(108, $input, $state)    (: 'transient' :)
            return $state
          else if ($state[$p:l1] = 112) then                (: 'volatile' :)
            let $state := p:consume(112, $input, $state)    (: 'volatile' :)
            return $state
          else if ($state[$p:l1] = 101) then                (: 'strictfp' :)
            let $state := p:consume(101, $input, $state)    (: 'strictfp' :)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Annotation($input, $state)
            return $state
        return p:parse-Modifiers-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Modifiers (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Modifiers-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(124, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | '@' | 'abstract' | 'boolean' |
                                                               'byte' | 'char' | 'class' | 'double' | 'enum' | 'final' |
                                                               'float' | 'int' | 'interface' | 'long' | 'native' |
                                                               'package' | 'private' | 'protected' | 'public' |
                                                               'short' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'void' | 'volatile' :)
    let $state :=
      if ($state[$p:l1] eq 46) then                         (: '@' :)
        let $state := p:lookahead2W(98, $input, $state)     (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'interface' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 1                                 (: IDENTIFIER :)
       or $state[$p:lk] = 35                                (: '<' :)
       or $state[$p:lk] = 64                                (: 'boolean' :)
       or $state[$p:lk] = 66                                (: 'byte' :)
       or $state[$p:lk] = 69                                (: 'char' :)
       or $state[$p:lk] = 70                                (: 'class' :)
       or $state[$p:lk] = 74                                (: 'double' :)
       or $state[$p:lk] = 76                                (: 'enum' :)
       or $state[$p:lk] = 81                                (: 'float' :)
       or $state[$p:lk] = 87                                (: 'int' :)
       or $state[$p:lk] = 88                                (: 'interface' :)
       or $state[$p:lk] = 89                                (: 'long' :)
       or $state[$p:lk] = 94                                (: 'package' :)
       or $state[$p:lk] = 99                                (: 'short' :)
       or $state[$p:lk] = 111                               (: 'void' :)
       or $state[$p:lk] = 11310) then                       (: '@' 'interface' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 97) then                 (: 'public' :)
            let $state := p:consumeT(97, $input, $state)    (: 'public' :)
            return $state
          else if ($state[$p:l1] = 100) then                (: 'static' :)
            let $state := p:consumeT(100, $input, $state)   (: 'static' :)
            return $state
          else if ($state[$p:l1] = 96) then                 (: 'protected' :)
            let $state := p:consumeT(96, $input, $state)    (: 'protected' :)
            return $state
          else if ($state[$p:l1] = 95) then                 (: 'private' :)
            let $state := p:consumeT(95, $input, $state)    (: 'private' :)
            return $state
          else if ($state[$p:l1] = 79) then                 (: 'final' :)
            let $state := p:consumeT(79, $input, $state)    (: 'final' :)
            return $state
          else if ($state[$p:l1] = 62) then                 (: 'abstract' :)
            let $state := p:consumeT(62, $input, $state)    (: 'abstract' :)
            return $state
          else if ($state[$p:l1] = 104) then                (: 'synchronized' :)
            let $state := p:consumeT(104, $input, $state)   (: 'synchronized' :)
            return $state
          else if ($state[$p:l1] = 90) then                 (: 'native' :)
            let $state := p:consumeT(90, $input, $state)    (: 'native' :)
            return $state
          else if ($state[$p:l1] = 108) then                (: 'transient' :)
            let $state := p:consumeT(108, $input, $state)   (: 'transient' :)
            return $state
          else if ($state[$p:l1] = 112) then                (: 'volatile' :)
            let $state := p:consumeT(112, $input, $state)   (: 'volatile' :)
            return $state
          else if ($state[$p:l1] = 101) then                (: 'strictfp' :)
            let $state := p:consumeT(101, $input, $state)   (: 'strictfp' :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Annotation($input, $state)
            return $state
        return p:try-Modifiers-1($input, $state)
};

(:~
 : Parse Modifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Modifiers($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Modifiers-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Modifiers", $count, $begin, $end)
};

(:~
 : Try parsing Modifiers.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Modifiers($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Modifiers-1($input, $state)
  return $state
};

(:~
 : Parse PackageDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PackageDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Modifiers($input, $state)
  let $state := p:consume(94, $input, $state)               (: 'package' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PackageDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing PackageDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PackageDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Modifiers($input, $state)
  let $state := p:consumeT(94, $input, $state)              (: 'package' :)
  let $state := p:lookahead1W(94, $input, $state)           (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Name($input, $state)
  let $state := p:consumeT(34, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse the 1st loop of production CompilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompilationUnit-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(111, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               '@' | 'PARSER_END' | 'abstract' | 'class' | 'enum' |
                                                               'final' | 'import' | 'interface' | 'native' | 'private' |
                                                               'protected' | 'public' | 'static' | 'strictfp' |
                                                               'synchronized' | 'transient' | 'volatile' :)
    return
      if ($state[$p:l1] != 85) then                         (: 'import' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ImportDeclaration($input, $state)
        return p:parse-CompilationUnit-1($input, $state)
};

(:~
 : Parse the 2nd loop of production CompilationUnit (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompilationUnit-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(108, $input, $state)        (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               '@' | 'PARSER_END' | 'abstract' | 'class' | 'enum' |
                                                               'final' | 'interface' | 'native' | 'private' |
                                                               'protected' | 'public' | 'static' | 'strictfp' |
                                                               'synchronized' | 'transient' | 'volatile' :)
    return
      if ($state[$p:l1] = 53) then                          (: 'PARSER_END' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-TypeDeclaration($input, $state)
        return p:parse-CompilationUnit-2($input, $state)
};

(:~
 : Parse CompilationUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompilationUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 46) then                           (: '@' :)
      let $state := p:lookahead2W(98, $input, $state)       (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'interface' :)
      let $state :=
        if ($state[$p:lk] = (174,                           (: '@' IDENTIFIER :)
                             6062,                          (: '@' 'EOF' :)
                             6190,                          (: '@' 'IGNORE_CASE' :)
                             6318,                          (: '@' 'JAVACODE' :)
                             6446,                          (: '@' 'LOOKAHEAD' :)
                             6574,                          (: '@' 'MORE' :)
                             6702,                          (: '@' 'PARSER_BEGIN' :)
                             6830,                          (: '@' 'PARSER_END' :)
                             6958,                          (: '@' 'SKIP' :)
                             7086,                          (: '@' 'SPECIAL_TOKEN' :)
                             7214,                          (: '@' 'TOKEN' :)
                             7342)) then                    (: '@' 'TOKEN_MGR_DECLS' :)
          let $state := p:lookahead3W(110, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' |
                                                               '.' | '@' | 'abstract' | 'class' | 'enum' | 'final' |
                                                               'interface' | 'native' | 'package' | 'private' |
                                                               'protected' | 'public' | 'static' | 'strictfp' |
                                                               'synchronized' | 'transient' | 'volatile' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (62,                           (: 'abstract' :)
                              79,                           (: 'final' :)
                              90,                           (: 'native' :)
                              95,                           (: 'private' :)
                              96,                           (: 'protected' :)
                              97,                           (: 'public' :)
                              100,                          (: 'static' :)
                              101,                          (: 'strictfp' :)
                              104,                          (: 'synchronized' :)
                              108,                          (: 'transient' :)
                              112)) then                    (: 'volatile' :)
      let $state := p:lookahead2W(105, $input, $state)      (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '@' |
                                                               'abstract' | 'class' | 'enum' | 'final' | 'interface' |
                                                               'native' | 'package' | 'private' | 'protected' |
                                                               'public' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
      let $state :=
        if ($state[$p:lk] = (5950,                          (: 'abstract' '@' :)
                             5967,                          (: 'final' '@' :)
                             5978,                          (: 'native' '@' :)
                             5983,                          (: 'private' '@' :)
                             5984,                          (: 'protected' '@' :)
                             5985,                          (: 'public' '@' :)
                             5988,                          (: 'static' '@' :)
                             5989,                          (: 'strictfp' '@' :)
                             5992,                          (: 'synchronized' '@' :)
                             5996,                          (: 'transient' '@' :)
                             6000)) then                    (: 'volatile' '@' :)
          let $state := p:lookahead3W(98, $input, $state)   (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'EOF' | 'IGNORE_CASE' | 'JAVACODE' |
                                                               'LOOKAHEAD' | 'MORE' | 'PARSER_BEGIN' | 'PARSER_END' |
                                                               'SKIP' | 'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'interface' :)
          return $state
        else if ($state[$p:lk] = (7998,                     (: 'abstract' 'abstract' :)
                                  10174,                    (: 'abstract' 'final' :)
                                  11582,                    (: 'abstract' 'native' :)
                                  12222,                    (: 'abstract' 'private' :)
                                  12350,                    (: 'abstract' 'protected' :)
                                  12478,                    (: 'abstract' 'public' :)
                                  12862,                    (: 'abstract' 'static' :)
                                  12990,                    (: 'abstract' 'strictfp' :)
                                  13374,                    (: 'abstract' 'synchronized' :)
                                  13886,                    (: 'abstract' 'transient' :)
                                  14398,                    (: 'abstract' 'volatile' :)
                                  8015,                     (: 'final' 'abstract' :)
                                  10191,                    (: 'final' 'final' :)
                                  11599,                    (: 'final' 'native' :)
                                  12239,                    (: 'final' 'private' :)
                                  12367,                    (: 'final' 'protected' :)
                                  12495,                    (: 'final' 'public' :)
                                  12879,                    (: 'final' 'static' :)
                                  13007,                    (: 'final' 'strictfp' :)
                                  13391,                    (: 'final' 'synchronized' :)
                                  13903,                    (: 'final' 'transient' :)
                                  14415,                    (: 'final' 'volatile' :)
                                  8026,                     (: 'native' 'abstract' :)
                                  10202,                    (: 'native' 'final' :)
                                  11610,                    (: 'native' 'native' :)
                                  12250,                    (: 'native' 'private' :)
                                  12378,                    (: 'native' 'protected' :)
                                  12506,                    (: 'native' 'public' :)
                                  12890,                    (: 'native' 'static' :)
                                  13018,                    (: 'native' 'strictfp' :)
                                  13402,                    (: 'native' 'synchronized' :)
                                  13914,                    (: 'native' 'transient' :)
                                  14426,                    (: 'native' 'volatile' :)
                                  8031,                     (: 'private' 'abstract' :)
                                  10207,                    (: 'private' 'final' :)
                                  11615,                    (: 'private' 'native' :)
                                  12255,                    (: 'private' 'private' :)
                                  12383,                    (: 'private' 'protected' :)
                                  12511,                    (: 'private' 'public' :)
                                  12895,                    (: 'private' 'static' :)
                                  13023,                    (: 'private' 'strictfp' :)
                                  13407,                    (: 'private' 'synchronized' :)
                                  13919,                    (: 'private' 'transient' :)
                                  14431,                    (: 'private' 'volatile' :)
                                  8032,                     (: 'protected' 'abstract' :)
                                  10208,                    (: 'protected' 'final' :)
                                  11616,                    (: 'protected' 'native' :)
                                  12256,                    (: 'protected' 'private' :)
                                  12384,                    (: 'protected' 'protected' :)
                                  12512,                    (: 'protected' 'public' :)
                                  12896,                    (: 'protected' 'static' :)
                                  13024,                    (: 'protected' 'strictfp' :)
                                  13408,                    (: 'protected' 'synchronized' :)
                                  13920,                    (: 'protected' 'transient' :)
                                  14432,                    (: 'protected' 'volatile' :)
                                  8033,                     (: 'public' 'abstract' :)
                                  10209,                    (: 'public' 'final' :)
                                  11617,                    (: 'public' 'native' :)
                                  12257,                    (: 'public' 'private' :)
                                  12385,                    (: 'public' 'protected' :)
                                  12513,                    (: 'public' 'public' :)
                                  12897,                    (: 'public' 'static' :)
                                  13025,                    (: 'public' 'strictfp' :)
                                  13409,                    (: 'public' 'synchronized' :)
                                  13921,                    (: 'public' 'transient' :)
                                  14433,                    (: 'public' 'volatile' :)
                                  8036,                     (: 'static' 'abstract' :)
                                  10212,                    (: 'static' 'final' :)
                                  11620,                    (: 'static' 'native' :)
                                  12260,                    (: 'static' 'private' :)
                                  12388,                    (: 'static' 'protected' :)
                                  12516,                    (: 'static' 'public' :)
                                  12900,                    (: 'static' 'static' :)
                                  13028,                    (: 'static' 'strictfp' :)
                                  13412,                    (: 'static' 'synchronized' :)
                                  13924,                    (: 'static' 'transient' :)
                                  14436,                    (: 'static' 'volatile' :)
                                  8037,                     (: 'strictfp' 'abstract' :)
                                  10213,                    (: 'strictfp' 'final' :)
                                  11621,                    (: 'strictfp' 'native' :)
                                  12261,                    (: 'strictfp' 'private' :)
                                  12389,                    (: 'strictfp' 'protected' :)
                                  12517,                    (: 'strictfp' 'public' :)
                                  12901,                    (: 'strictfp' 'static' :)
                                  13029,                    (: 'strictfp' 'strictfp' :)
                                  13413,                    (: 'strictfp' 'synchronized' :)
                                  13925,                    (: 'strictfp' 'transient' :)
                                  14437,                    (: 'strictfp' 'volatile' :)
                                  8040,                     (: 'synchronized' 'abstract' :)
                                  10216,                    (: 'synchronized' 'final' :)
                                  11624,                    (: 'synchronized' 'native' :)
                                  12264,                    (: 'synchronized' 'private' :)
                                  12392,                    (: 'synchronized' 'protected' :)
                                  12520,                    (: 'synchronized' 'public' :)
                                  12904,                    (: 'synchronized' 'static' :)
                                  13032,                    (: 'synchronized' 'strictfp' :)
                                  13416,                    (: 'synchronized' 'synchronized' :)
                                  13928,                    (: 'synchronized' 'transient' :)
                                  14440,                    (: 'synchronized' 'volatile' :)
                                  8044,                     (: 'transient' 'abstract' :)
                                  10220,                    (: 'transient' 'final' :)
                                  11628,                    (: 'transient' 'native' :)
                                  12268,                    (: 'transient' 'private' :)
                                  12396,                    (: 'transient' 'protected' :)
                                  12524,                    (: 'transient' 'public' :)
                                  12908,                    (: 'transient' 'static' :)
                                  13036,                    (: 'transient' 'strictfp' :)
                                  13420,                    (: 'transient' 'synchronized' :)
                                  13932,                    (: 'transient' 'transient' :)
                                  14444,                    (: 'transient' 'volatile' :)
                                  8048,                     (: 'volatile' 'abstract' :)
                                  10224,                    (: 'volatile' 'final' :)
                                  11632,                    (: 'volatile' 'native' :)
                                  12272,                    (: 'volatile' 'private' :)
                                  12400,                    (: 'volatile' 'protected' :)
                                  12528,                    (: 'volatile' 'public' :)
                                  12912,                    (: 'volatile' 'static' :)
                                  13040,                    (: 'volatile' 'strictfp' :)
                                  13424,                    (: 'volatile' 'synchronized' :)
                                  13936,                    (: 'volatile' 'transient' :)
                                  14448)) then              (: 'volatile' 'volatile' :)
          let $state := p:lookahead3W(105, $input, $state)  (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '@' |
                                                               'abstract' | 'class' | 'enum' | 'final' | 'interface' |
                                                               'native' | 'package' | 'private' | 'protected' |
                                                               'public' | 'static' | 'strictfp' | 'synchronized' |
                                                               'transient' | 'volatile' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 34                            (: ';' :)
         and $state[$p:lk] != 53                            (: 'PARSER_END' :)
         and $state[$p:lk] != 70                            (: 'class' :)
         and $state[$p:lk] != 76                            (: 'enum' :)
         and $state[$p:lk] != 85                            (: 'import' :)
         and $state[$p:lk] != 88                            (: 'interface' :)
         and $state[$p:lk] != 94                            (: 'package' :)
         and $state[$p:lk] != 9022                          (: 'abstract' 'class' :)
         and $state[$p:lk] != 9039                          (: 'final' 'class' :)
         and $state[$p:lk] != 9050                          (: 'native' 'class' :)
         and $state[$p:lk] != 9055                          (: 'private' 'class' :)
         and $state[$p:lk] != 9056                          (: 'protected' 'class' :)
         and $state[$p:lk] != 9057                          (: 'public' 'class' :)
         and $state[$p:lk] != 9060                          (: 'static' 'class' :)
         and $state[$p:lk] != 9061                          (: 'strictfp' 'class' :)
         and $state[$p:lk] != 9064                          (: 'synchronized' 'class' :)
         and $state[$p:lk] != 9068                          (: 'transient' 'class' :)
         and $state[$p:lk] != 9072                          (: 'volatile' 'class' :)
         and $state[$p:lk] != 9790                          (: 'abstract' 'enum' :)
         and $state[$p:lk] != 9807                          (: 'final' 'enum' :)
         and $state[$p:lk] != 9818                          (: 'native' 'enum' :)
         and $state[$p:lk] != 9823                          (: 'private' 'enum' :)
         and $state[$p:lk] != 9824                          (: 'protected' 'enum' :)
         and $state[$p:lk] != 9825                          (: 'public' 'enum' :)
         and $state[$p:lk] != 9828                          (: 'static' 'enum' :)
         and $state[$p:lk] != 9829                          (: 'strictfp' 'enum' :)
         and $state[$p:lk] != 9832                          (: 'synchronized' 'enum' :)
         and $state[$p:lk] != 9836                          (: 'transient' 'enum' :)
         and $state[$p:lk] != 9840                          (: 'volatile' 'enum' :)
         and $state[$p:lk] != 11310                         (: '@' 'interface' :)
         and $state[$p:lk] != 11326                         (: 'abstract' 'interface' :)
         and $state[$p:lk] != 11343                         (: 'final' 'interface' :)
         and $state[$p:lk] != 11354                         (: 'native' 'interface' :)
         and $state[$p:lk] != 11359                         (: 'private' 'interface' :)
         and $state[$p:lk] != 11360                         (: 'protected' 'interface' :)
         and $state[$p:lk] != 11361                         (: 'public' 'interface' :)
         and $state[$p:lk] != 11364                         (: 'static' 'interface' :)
         and $state[$p:lk] != 11365                         (: 'strictfp' 'interface' :)
         and $state[$p:lk] != 11368                         (: 'synchronized' 'interface' :)
         and $state[$p:lk] != 11372                         (: 'transient' 'interface' :)
         and $state[$p:lk] != 11376                         (: 'volatile' 'interface' :)
         and $state[$p:lk] != 12094                         (: 'abstract' 'package' :)
         and $state[$p:lk] != 12111                         (: 'final' 'package' :)
         and $state[$p:lk] != 12122                         (: 'native' 'package' :)
         and $state[$p:lk] != 12127                         (: 'private' 'package' :)
         and $state[$p:lk] != 12128                         (: 'protected' 'package' :)
         and $state[$p:lk] != 12129                         (: 'public' 'package' :)
         and $state[$p:lk] != 12132                         (: 'static' 'package' :)
         and $state[$p:lk] != 12133                         (: 'strictfp' 'package' :)
         and $state[$p:lk] != 12136                         (: 'synchronized' 'package' :)
         and $state[$p:lk] != 12140                         (: 'transient' 'package' :)
         and $state[$p:lk] != 12144                         (: 'volatile' 'package' :)
         and $state[$p:lk] != 1147054                       (: '@' IDENTIFIER 'class' :)
         and $state[$p:lk] != 1152942                       (: '@' 'EOF' 'class' :)
         and $state[$p:lk] != 1153070                       (: '@' 'IGNORE_CASE' 'class' :)
         and $state[$p:lk] != 1153198                       (: '@' 'JAVACODE' 'class' :)
         and $state[$p:lk] != 1153326                       (: '@' 'LOOKAHEAD' 'class' :)
         and $state[$p:lk] != 1153454                       (: '@' 'MORE' 'class' :)
         and $state[$p:lk] != 1153582                       (: '@' 'PARSER_BEGIN' 'class' :)
         and $state[$p:lk] != 1153710                       (: '@' 'PARSER_END' 'class' :)
         and $state[$p:lk] != 1153838                       (: '@' 'SKIP' 'class' :)
         and $state[$p:lk] != 1153966                       (: '@' 'SPECIAL_TOKEN' 'class' :)
         and $state[$p:lk] != 1154094                       (: '@' 'TOKEN' 'class' :)
         and $state[$p:lk] != 1154222                       (: '@' 'TOKEN_MGR_DECLS' 'class' :)
         and $state[$p:lk] != 1154878                       (: 'abstract' 'abstract' 'class' :)
         and $state[$p:lk] != 1154895                       (: 'final' 'abstract' 'class' :)
         and $state[$p:lk] != 1154906                       (: 'native' 'abstract' 'class' :)
         and $state[$p:lk] != 1154911                       (: 'private' 'abstract' 'class' :)
         and $state[$p:lk] != 1154912                       (: 'protected' 'abstract' 'class' :)
         and $state[$p:lk] != 1154913                       (: 'public' 'abstract' 'class' :)
         and $state[$p:lk] != 1154916                       (: 'static' 'abstract' 'class' :)
         and $state[$p:lk] != 1154917                       (: 'strictfp' 'abstract' 'class' :)
         and $state[$p:lk] != 1154920                       (: 'synchronized' 'abstract' 'class' :)
         and $state[$p:lk] != 1154924                       (: 'transient' 'abstract' 'class' :)
         and $state[$p:lk] != 1154928                       (: 'volatile' 'abstract' 'class' :)
         and $state[$p:lk] != 1157054                       (: 'abstract' 'final' 'class' :)
         and $state[$p:lk] != 1157071                       (: 'final' 'final' 'class' :)
         and $state[$p:lk] != 1157082                       (: 'native' 'final' 'class' :)
         and $state[$p:lk] != 1157087                       (: 'private' 'final' 'class' :)
         and $state[$p:lk] != 1157088                       (: 'protected' 'final' 'class' :)
         and $state[$p:lk] != 1157089                       (: 'public' 'final' 'class' :)
         and $state[$p:lk] != 1157092                       (: 'static' 'final' 'class' :)
         and $state[$p:lk] != 1157093                       (: 'strictfp' 'final' 'class' :)
         and $state[$p:lk] != 1157096                       (: 'synchronized' 'final' 'class' :)
         and $state[$p:lk] != 1157100                       (: 'transient' 'final' 'class' :)
         and $state[$p:lk] != 1157104                       (: 'volatile' 'final' 'class' :)
         and $state[$p:lk] != 1158462                       (: 'abstract' 'native' 'class' :)
         and $state[$p:lk] != 1158479                       (: 'final' 'native' 'class' :)
         and $state[$p:lk] != 1158490                       (: 'native' 'native' 'class' :)
         and $state[$p:lk] != 1158495                       (: 'private' 'native' 'class' :)
         and $state[$p:lk] != 1158496                       (: 'protected' 'native' 'class' :)
         and $state[$p:lk] != 1158497                       (: 'public' 'native' 'class' :)
         and $state[$p:lk] != 1158500                       (: 'static' 'native' 'class' :)
         and $state[$p:lk] != 1158501                       (: 'strictfp' 'native' 'class' :)
         and $state[$p:lk] != 1158504                       (: 'synchronized' 'native' 'class' :)
         and $state[$p:lk] != 1158508                       (: 'transient' 'native' 'class' :)
         and $state[$p:lk] != 1158512                       (: 'volatile' 'native' 'class' :)
         and $state[$p:lk] != 1159102                       (: 'abstract' 'private' 'class' :)
         and $state[$p:lk] != 1159119                       (: 'final' 'private' 'class' :)
         and $state[$p:lk] != 1159130                       (: 'native' 'private' 'class' :)
         and $state[$p:lk] != 1159135                       (: 'private' 'private' 'class' :)
         and $state[$p:lk] != 1159136                       (: 'protected' 'private' 'class' :)
         and $state[$p:lk] != 1159137                       (: 'public' 'private' 'class' :)
         and $state[$p:lk] != 1159140                       (: 'static' 'private' 'class' :)
         and $state[$p:lk] != 1159141                       (: 'strictfp' 'private' 'class' :)
         and $state[$p:lk] != 1159144                       (: 'synchronized' 'private' 'class' :)
         and $state[$p:lk] != 1159148                       (: 'transient' 'private' 'class' :)
         and $state[$p:lk] != 1159152                       (: 'volatile' 'private' 'class' :)
         and $state[$p:lk] != 1159230                       (: 'abstract' 'protected' 'class' :)
         and $state[$p:lk] != 1159247                       (: 'final' 'protected' 'class' :)
         and $state[$p:lk] != 1159258                       (: 'native' 'protected' 'class' :)
         and $state[$p:lk] != 1159263                       (: 'private' 'protected' 'class' :)
         and $state[$p:lk] != 1159264                       (: 'protected' 'protected' 'class' :)
         and $state[$p:lk] != 1159265                       (: 'public' 'protected' 'class' :)
         and $state[$p:lk] != 1159268                       (: 'static' 'protected' 'class' :)
         and $state[$p:lk] != 1159269                       (: 'strictfp' 'protected' 'class' :)
         and $state[$p:lk] != 1159272                       (: 'synchronized' 'protected' 'class' :)
         and $state[$p:lk] != 1159276                       (: 'transient' 'protected' 'class' :)
         and $state[$p:lk] != 1159280                       (: 'volatile' 'protected' 'class' :)
         and $state[$p:lk] != 1159358                       (: 'abstract' 'public' 'class' :)
         and $state[$p:lk] != 1159375                       (: 'final' 'public' 'class' :)
         and $state[$p:lk] != 1159386                       (: 'native' 'public' 'class' :)
         and $state[$p:lk] != 1159391                       (: 'private' 'public' 'class' :)
         and $state[$p:lk] != 1159392                       (: 'protected' 'public' 'class' :)
         and $state[$p:lk] != 1159393                       (: 'public' 'public' 'class' :)
         and $state[$p:lk] != 1159396                       (: 'static' 'public' 'class' :)
         and $state[$p:lk] != 1159397                       (: 'strictfp' 'public' 'class' :)
         and $state[$p:lk] != 1159400                       (: 'synchronized' 'public' 'class' :)
         and $state[$p:lk] != 1159404                       (: 'transient' 'public' 'class' :)
         and $state[$p:lk] != 1159408                       (: 'volatile' 'public' 'class' :)
         and $state[$p:lk] != 1159742                       (: 'abstract' 'static' 'class' :)
         and $state[$p:lk] != 1159759                       (: 'final' 'static' 'class' :)
         and $state[$p:lk] != 1159770                       (: 'native' 'static' 'class' :)
         and $state[$p:lk] != 1159775                       (: 'private' 'static' 'class' :)
         and $state[$p:lk] != 1159776                       (: 'protected' 'static' 'class' :)
         and $state[$p:lk] != 1159777                       (: 'public' 'static' 'class' :)
         and $state[$p:lk] != 1159780                       (: 'static' 'static' 'class' :)
         and $state[$p:lk] != 1159781                       (: 'strictfp' 'static' 'class' :)
         and $state[$p:lk] != 1159784                       (: 'synchronized' 'static' 'class' :)
         and $state[$p:lk] != 1159788                       (: 'transient' 'static' 'class' :)
         and $state[$p:lk] != 1159792                       (: 'volatile' 'static' 'class' :)
         and $state[$p:lk] != 1159870                       (: 'abstract' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159887                       (: 'final' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159898                       (: 'native' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159903                       (: 'private' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159904                       (: 'protected' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159905                       (: 'public' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159908                       (: 'static' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159909                       (: 'strictfp' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159912                       (: 'synchronized' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159916                       (: 'transient' 'strictfp' 'class' :)
         and $state[$p:lk] != 1159920                       (: 'volatile' 'strictfp' 'class' :)
         and $state[$p:lk] != 1160254                       (: 'abstract' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160271                       (: 'final' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160282                       (: 'native' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160287                       (: 'private' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160288                       (: 'protected' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160289                       (: 'public' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160292                       (: 'static' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160293                       (: 'strictfp' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160296                       (: 'synchronized' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160300                       (: 'transient' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160304                       (: 'volatile' 'synchronized' 'class' :)
         and $state[$p:lk] != 1160766                       (: 'abstract' 'transient' 'class' :)
         and $state[$p:lk] != 1160783                       (: 'final' 'transient' 'class' :)
         and $state[$p:lk] != 1160794                       (: 'native' 'transient' 'class' :)
         and $state[$p:lk] != 1160799                       (: 'private' 'transient' 'class' :)
         and $state[$p:lk] != 1160800                       (: 'protected' 'transient' 'class' :)
         and $state[$p:lk] != 1160801                       (: 'public' 'transient' 'class' :)
         and $state[$p:lk] != 1160804                       (: 'static' 'transient' 'class' :)
         and $state[$p:lk] != 1160805                       (: 'strictfp' 'transient' 'class' :)
         and $state[$p:lk] != 1160808                       (: 'synchronized' 'transient' 'class' :)
         and $state[$p:lk] != 1160812                       (: 'transient' 'transient' 'class' :)
         and $state[$p:lk] != 1160816                       (: 'volatile' 'transient' 'class' :)
         and $state[$p:lk] != 1161278                       (: 'abstract' 'volatile' 'class' :)
         and $state[$p:lk] != 1161295                       (: 'final' 'volatile' 'class' :)
         and $state[$p:lk] != 1161306                       (: 'native' 'volatile' 'class' :)
         and $state[$p:lk] != 1161311                       (: 'private' 'volatile' 'class' :)
         and $state[$p:lk] != 1161312                       (: 'protected' 'volatile' 'class' :)
         and $state[$p:lk] != 1161313                       (: 'public' 'volatile' 'class' :)
         and $state[$p:lk] != 1161316                       (: 'static' 'volatile' 'class' :)
         and $state[$p:lk] != 1161317                       (: 'strictfp' 'volatile' 'class' :)
         and $state[$p:lk] != 1161320                       (: 'synchronized' 'volatile' 'class' :)
         and $state[$p:lk] != 1161324                       (: 'transient' 'volatile' 'class' :)
         and $state[$p:lk] != 1161328                       (: 'volatile' 'volatile' 'class' :)
         and $state[$p:lk] != 1245358                       (: '@' IDENTIFIER 'enum' :)
         and $state[$p:lk] != 1251246                       (: '@' 'EOF' 'enum' :)
         and $state[$p:lk] != 1251374                       (: '@' 'IGNORE_CASE' 'enum' :)
         and $state[$p:lk] != 1251502                       (: '@' 'JAVACODE' 'enum' :)
         and $state[$p:lk] != 1251630                       (: '@' 'LOOKAHEAD' 'enum' :)
         and $state[$p:lk] != 1251758                       (: '@' 'MORE' 'enum' :)
         and $state[$p:lk] != 1251886                       (: '@' 'PARSER_BEGIN' 'enum' :)
         and $state[$p:lk] != 1252014                       (: '@' 'PARSER_END' 'enum' :)
         and $state[$p:lk] != 1252142                       (: '@' 'SKIP' 'enum' :)
         and $state[$p:lk] != 1252270                       (: '@' 'SPECIAL_TOKEN' 'enum' :)
         and $state[$p:lk] != 1252398                       (: '@' 'TOKEN' 'enum' :)
         and $state[$p:lk] != 1252526                       (: '@' 'TOKEN_MGR_DECLS' 'enum' :)
         and $state[$p:lk] != 1253182                       (: 'abstract' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253199                       (: 'final' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253210                       (: 'native' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253215                       (: 'private' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253216                       (: 'protected' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253217                       (: 'public' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253220                       (: 'static' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253221                       (: 'strictfp' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253224                       (: 'synchronized' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253228                       (: 'transient' 'abstract' 'enum' :)
         and $state[$p:lk] != 1253232                       (: 'volatile' 'abstract' 'enum' :)
         and $state[$p:lk] != 1255358                       (: 'abstract' 'final' 'enum' :)
         and $state[$p:lk] != 1255375                       (: 'final' 'final' 'enum' :)
         and $state[$p:lk] != 1255386                       (: 'native' 'final' 'enum' :)
         and $state[$p:lk] != 1255391                       (: 'private' 'final' 'enum' :)
         and $state[$p:lk] != 1255392                       (: 'protected' 'final' 'enum' :)
         and $state[$p:lk] != 1255393                       (: 'public' 'final' 'enum' :)
         and $state[$p:lk] != 1255396                       (: 'static' 'final' 'enum' :)
         and $state[$p:lk] != 1255397                       (: 'strictfp' 'final' 'enum' :)
         and $state[$p:lk] != 1255400                       (: 'synchronized' 'final' 'enum' :)
         and $state[$p:lk] != 1255404                       (: 'transient' 'final' 'enum' :)
         and $state[$p:lk] != 1255408                       (: 'volatile' 'final' 'enum' :)
         and $state[$p:lk] != 1256766                       (: 'abstract' 'native' 'enum' :)
         and $state[$p:lk] != 1256783                       (: 'final' 'native' 'enum' :)
         and $state[$p:lk] != 1256794                       (: 'native' 'native' 'enum' :)
         and $state[$p:lk] != 1256799                       (: 'private' 'native' 'enum' :)
         and $state[$p:lk] != 1256800                       (: 'protected' 'native' 'enum' :)
         and $state[$p:lk] != 1256801                       (: 'public' 'native' 'enum' :)
         and $state[$p:lk] != 1256804                       (: 'static' 'native' 'enum' :)
         and $state[$p:lk] != 1256805                       (: 'strictfp' 'native' 'enum' :)
         and $state[$p:lk] != 1256808                       (: 'synchronized' 'native' 'enum' :)
         and $state[$p:lk] != 1256812                       (: 'transient' 'native' 'enum' :)
         and $state[$p:lk] != 1256816                       (: 'volatile' 'native' 'enum' :)
         and $state[$p:lk] != 1257406                       (: 'abstract' 'private' 'enum' :)
         and $state[$p:lk] != 1257423                       (: 'final' 'private' 'enum' :)
         and $state[$p:lk] != 1257434                       (: 'native' 'private' 'enum' :)
         and $state[$p:lk] != 1257439                       (: 'private' 'private' 'enum' :)
         and $state[$p:lk] != 1257440                       (: 'protected' 'private' 'enum' :)
         and $state[$p:lk] != 1257441                       (: 'public' 'private' 'enum' :)
         and $state[$p:lk] != 1257444                       (: 'static' 'private' 'enum' :)
         and $state[$p:lk] != 1257445                       (: 'strictfp' 'private' 'enum' :)
         and $state[$p:lk] != 1257448                       (: 'synchronized' 'private' 'enum' :)
         and $state[$p:lk] != 1257452                       (: 'transient' 'private' 'enum' :)
         and $state[$p:lk] != 1257456                       (: 'volatile' 'private' 'enum' :)
         and $state[$p:lk] != 1257534                       (: 'abstract' 'protected' 'enum' :)
         and $state[$p:lk] != 1257551                       (: 'final' 'protected' 'enum' :)
         and $state[$p:lk] != 1257562                       (: 'native' 'protected' 'enum' :)
         and $state[$p:lk] != 1257567                       (: 'private' 'protected' 'enum' :)
         and $state[$p:lk] != 1257568                       (: 'protected' 'protected' 'enum' :)
         and $state[$p:lk] != 1257569                       (: 'public' 'protected' 'enum' :)
         and $state[$p:lk] != 1257572                       (: 'static' 'protected' 'enum' :)
         and $state[$p:lk] != 1257573                       (: 'strictfp' 'protected' 'enum' :)
         and $state[$p:lk] != 1257576                       (: 'synchronized' 'protected' 'enum' :)
         and $state[$p:lk] != 1257580                       (: 'transient' 'protected' 'enum' :)
         and $state[$p:lk] != 1257584                       (: 'volatile' 'protected' 'enum' :)
         and $state[$p:lk] != 1257662                       (: 'abstract' 'public' 'enum' :)
         and $state[$p:lk] != 1257679                       (: 'final' 'public' 'enum' :)
         and $state[$p:lk] != 1257690                       (: 'native' 'public' 'enum' :)
         and $state[$p:lk] != 1257695                       (: 'private' 'public' 'enum' :)
         and $state[$p:lk] != 1257696                       (: 'protected' 'public' 'enum' :)
         and $state[$p:lk] != 1257697                       (: 'public' 'public' 'enum' :)
         and $state[$p:lk] != 1257700                       (: 'static' 'public' 'enum' :)
         and $state[$p:lk] != 1257701                       (: 'strictfp' 'public' 'enum' :)
         and $state[$p:lk] != 1257704                       (: 'synchronized' 'public' 'enum' :)
         and $state[$p:lk] != 1257708                       (: 'transient' 'public' 'enum' :)
         and $state[$p:lk] != 1257712                       (: 'volatile' 'public' 'enum' :)
         and $state[$p:lk] != 1258046                       (: 'abstract' 'static' 'enum' :)
         and $state[$p:lk] != 1258063                       (: 'final' 'static' 'enum' :)
         and $state[$p:lk] != 1258074                       (: 'native' 'static' 'enum' :)
         and $state[$p:lk] != 1258079                       (: 'private' 'static' 'enum' :)
         and $state[$p:lk] != 1258080                       (: 'protected' 'static' 'enum' :)
         and $state[$p:lk] != 1258081                       (: 'public' 'static' 'enum' :)
         and $state[$p:lk] != 1258084                       (: 'static' 'static' 'enum' :)
         and $state[$p:lk] != 1258085                       (: 'strictfp' 'static' 'enum' :)
         and $state[$p:lk] != 1258088                       (: 'synchronized' 'static' 'enum' :)
         and $state[$p:lk] != 1258092                       (: 'transient' 'static' 'enum' :)
         and $state[$p:lk] != 1258096                       (: 'volatile' 'static' 'enum' :)
         and $state[$p:lk] != 1258174                       (: 'abstract' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258191                       (: 'final' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258202                       (: 'native' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258207                       (: 'private' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258208                       (: 'protected' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258209                       (: 'public' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258212                       (: 'static' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258213                       (: 'strictfp' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258216                       (: 'synchronized' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258220                       (: 'transient' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258224                       (: 'volatile' 'strictfp' 'enum' :)
         and $state[$p:lk] != 1258558                       (: 'abstract' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258575                       (: 'final' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258586                       (: 'native' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258591                       (: 'private' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258592                       (: 'protected' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258593                       (: 'public' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258596                       (: 'static' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258597                       (: 'strictfp' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258600                       (: 'synchronized' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258604                       (: 'transient' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1258608                       (: 'volatile' 'synchronized' 'enum' :)
         and $state[$p:lk] != 1259070                       (: 'abstract' 'transient' 'enum' :)
         and $state[$p:lk] != 1259087                       (: 'final' 'transient' 'enum' :)
         and $state[$p:lk] != 1259098                       (: 'native' 'transient' 'enum' :)
         and $state[$p:lk] != 1259103                       (: 'private' 'transient' 'enum' :)
         and $state[$p:lk] != 1259104                       (: 'protected' 'transient' 'enum' :)
         and $state[$p:lk] != 1259105                       (: 'public' 'transient' 'enum' :)
         and $state[$p:lk] != 1259108                       (: 'static' 'transient' 'enum' :)
         and $state[$p:lk] != 1259109                       (: 'strictfp' 'transient' 'enum' :)
         and $state[$p:lk] != 1259112                       (: 'synchronized' 'transient' 'enum' :)
         and $state[$p:lk] != 1259116                       (: 'transient' 'transient' 'enum' :)
         and $state[$p:lk] != 1259120                       (: 'volatile' 'transient' 'enum' :)
         and $state[$p:lk] != 1259582                       (: 'abstract' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259599                       (: 'final' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259610                       (: 'native' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259615                       (: 'private' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259616                       (: 'protected' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259617                       (: 'public' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259620                       (: 'static' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259621                       (: 'strictfp' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259624                       (: 'synchronized' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259628                       (: 'transient' 'volatile' 'enum' :)
         and $state[$p:lk] != 1259632                       (: 'volatile' 'volatile' 'enum' :)
         and $state[$p:lk] != 1441966                       (: '@' IDENTIFIER 'interface' :)
         and $state[$p:lk] != 1447742                       (: 'abstract' '@' 'interface' :)
         and $state[$p:lk] != 1447759                       (: 'final' '@' 'interface' :)
         and $state[$p:lk] != 1447770                       (: 'native' '@' 'interface' :)
         and $state[$p:lk] != 1447775                       (: 'private' '@' 'interface' :)
         and $state[$p:lk] != 1447776                       (: 'protected' '@' 'interface' :)
         and $state[$p:lk] != 1447777                       (: 'public' '@' 'interface' :)
         and $state[$p:lk] != 1447780                       (: 'static' '@' 'interface' :)
         and $state[$p:lk] != 1447781                       (: 'strictfp' '@' 'interface' :)
         and $state[$p:lk] != 1447784                       (: 'synchronized' '@' 'interface' :)
         and $state[$p:lk] != 1447788                       (: 'transient' '@' 'interface' :)
         and $state[$p:lk] != 1447792                       (: 'volatile' '@' 'interface' :)
         and $state[$p:lk] != 1447854                       (: '@' 'EOF' 'interface' :)
         and $state[$p:lk] != 1447982                       (: '@' 'IGNORE_CASE' 'interface' :)
         and $state[$p:lk] != 1448110                       (: '@' 'JAVACODE' 'interface' :)
         and $state[$p:lk] != 1448238                       (: '@' 'LOOKAHEAD' 'interface' :)
         and $state[$p:lk] != 1448366                       (: '@' 'MORE' 'interface' :)
         and $state[$p:lk] != 1448494                       (: '@' 'PARSER_BEGIN' 'interface' :)
         and $state[$p:lk] != 1448622                       (: '@' 'PARSER_END' 'interface' :)
         and $state[$p:lk] != 1448750                       (: '@' 'SKIP' 'interface' :)
         and $state[$p:lk] != 1448878                       (: '@' 'SPECIAL_TOKEN' 'interface' :)
         and $state[$p:lk] != 1449006                       (: '@' 'TOKEN' 'interface' :)
         and $state[$p:lk] != 1449134                       (: '@' 'TOKEN_MGR_DECLS' 'interface' :)
         and $state[$p:lk] != 1449790                       (: 'abstract' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449807                       (: 'final' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449818                       (: 'native' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449823                       (: 'private' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449824                       (: 'protected' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449825                       (: 'public' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449828                       (: 'static' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449829                       (: 'strictfp' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449832                       (: 'synchronized' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449836                       (: 'transient' 'abstract' 'interface' :)
         and $state[$p:lk] != 1449840                       (: 'volatile' 'abstract' 'interface' :)
         and $state[$p:lk] != 1451966                       (: 'abstract' 'final' 'interface' :)
         and $state[$p:lk] != 1451983                       (: 'final' 'final' 'interface' :)
         and $state[$p:lk] != 1451994                       (: 'native' 'final' 'interface' :)
         and $state[$p:lk] != 1451999                       (: 'private' 'final' 'interface' :)
         and $state[$p:lk] != 1452000                       (: 'protected' 'final' 'interface' :)
         and $state[$p:lk] != 1452001                       (: 'public' 'final' 'interface' :)
         and $state[$p:lk] != 1452004                       (: 'static' 'final' 'interface' :)
         and $state[$p:lk] != 1452005                       (: 'strictfp' 'final' 'interface' :)
         and $state[$p:lk] != 1452008                       (: 'synchronized' 'final' 'interface' :)
         and $state[$p:lk] != 1452012                       (: 'transient' 'final' 'interface' :)
         and $state[$p:lk] != 1452016                       (: 'volatile' 'final' 'interface' :)
         and $state[$p:lk] != 1453374                       (: 'abstract' 'native' 'interface' :)
         and $state[$p:lk] != 1453391                       (: 'final' 'native' 'interface' :)
         and $state[$p:lk] != 1453402                       (: 'native' 'native' 'interface' :)
         and $state[$p:lk] != 1453407                       (: 'private' 'native' 'interface' :)
         and $state[$p:lk] != 1453408                       (: 'protected' 'native' 'interface' :)
         and $state[$p:lk] != 1453409                       (: 'public' 'native' 'interface' :)
         and $state[$p:lk] != 1453412                       (: 'static' 'native' 'interface' :)
         and $state[$p:lk] != 1453413                       (: 'strictfp' 'native' 'interface' :)
         and $state[$p:lk] != 1453416                       (: 'synchronized' 'native' 'interface' :)
         and $state[$p:lk] != 1453420                       (: 'transient' 'native' 'interface' :)
         and $state[$p:lk] != 1453424                       (: 'volatile' 'native' 'interface' :)
         and $state[$p:lk] != 1454014                       (: 'abstract' 'private' 'interface' :)
         and $state[$p:lk] != 1454031                       (: 'final' 'private' 'interface' :)
         and $state[$p:lk] != 1454042                       (: 'native' 'private' 'interface' :)
         and $state[$p:lk] != 1454047                       (: 'private' 'private' 'interface' :)
         and $state[$p:lk] != 1454048                       (: 'protected' 'private' 'interface' :)
         and $state[$p:lk] != 1454049                       (: 'public' 'private' 'interface' :)
         and $state[$p:lk] != 1454052                       (: 'static' 'private' 'interface' :)
         and $state[$p:lk] != 1454053                       (: 'strictfp' 'private' 'interface' :)
         and $state[$p:lk] != 1454056                       (: 'synchronized' 'private' 'interface' :)
         and $state[$p:lk] != 1454060                       (: 'transient' 'private' 'interface' :)
         and $state[$p:lk] != 1454064                       (: 'volatile' 'private' 'interface' :)
         and $state[$p:lk] != 1454142                       (: 'abstract' 'protected' 'interface' :)
         and $state[$p:lk] != 1454159                       (: 'final' 'protected' 'interface' :)
         and $state[$p:lk] != 1454170                       (: 'native' 'protected' 'interface' :)
         and $state[$p:lk] != 1454175                       (: 'private' 'protected' 'interface' :)
         and $state[$p:lk] != 1454176                       (: 'protected' 'protected' 'interface' :)
         and $state[$p:lk] != 1454177                       (: 'public' 'protected' 'interface' :)
         and $state[$p:lk] != 1454180                       (: 'static' 'protected' 'interface' :)
         and $state[$p:lk] != 1454181                       (: 'strictfp' 'protected' 'interface' :)
         and $state[$p:lk] != 1454184                       (: 'synchronized' 'protected' 'interface' :)
         and $state[$p:lk] != 1454188                       (: 'transient' 'protected' 'interface' :)
         and $state[$p:lk] != 1454192                       (: 'volatile' 'protected' 'interface' :)
         and $state[$p:lk] != 1454270                       (: 'abstract' 'public' 'interface' :)
         and $state[$p:lk] != 1454287                       (: 'final' 'public' 'interface' :)
         and $state[$p:lk] != 1454298                       (: 'native' 'public' 'interface' :)
         and $state[$p:lk] != 1454303                       (: 'private' 'public' 'interface' :)
         and $state[$p:lk] != 1454304                       (: 'protected' 'public' 'interface' :)
         and $state[$p:lk] != 1454305                       (: 'public' 'public' 'interface' :)
         and $state[$p:lk] != 1454308                       (: 'static' 'public' 'interface' :)
         and $state[$p:lk] != 1454309                       (: 'strictfp' 'public' 'interface' :)
         and $state[$p:lk] != 1454312                       (: 'synchronized' 'public' 'interface' :)
         and $state[$p:lk] != 1454316                       (: 'transient' 'public' 'interface' :)
         and $state[$p:lk] != 1454320                       (: 'volatile' 'public' 'interface' :)
         and $state[$p:lk] != 1454654                       (: 'abstract' 'static' 'interface' :)
         and $state[$p:lk] != 1454671                       (: 'final' 'static' 'interface' :)
         and $state[$p:lk] != 1454682                       (: 'native' 'static' 'interface' :)
         and $state[$p:lk] != 1454687                       (: 'private' 'static' 'interface' :)
         and $state[$p:lk] != 1454688                       (: 'protected' 'static' 'interface' :)
         and $state[$p:lk] != 1454689                       (: 'public' 'static' 'interface' :)
         and $state[$p:lk] != 1454692                       (: 'static' 'static' 'interface' :)
         and $state[$p:lk] != 1454693                       (: 'strictfp' 'static' 'interface' :)
         and $state[$p:lk] != 1454696                       (: 'synchronized' 'static' 'interface' :)
         and $state[$p:lk] != 1454700                       (: 'transient' 'static' 'interface' :)
         and $state[$p:lk] != 1454704                       (: 'volatile' 'static' 'interface' :)
         and $state[$p:lk] != 1454782                       (: 'abstract' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454799                       (: 'final' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454810                       (: 'native' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454815                       (: 'private' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454816                       (: 'protected' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454817                       (: 'public' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454820                       (: 'static' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454821                       (: 'strictfp' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454824                       (: 'synchronized' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454828                       (: 'transient' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1454832                       (: 'volatile' 'strictfp' 'interface' :)
         and $state[$p:lk] != 1455166                       (: 'abstract' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455183                       (: 'final' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455194                       (: 'native' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455199                       (: 'private' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455200                       (: 'protected' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455201                       (: 'public' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455204                       (: 'static' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455205                       (: 'strictfp' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455208                       (: 'synchronized' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455212                       (: 'transient' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455216                       (: 'volatile' 'synchronized' 'interface' :)
         and $state[$p:lk] != 1455678                       (: 'abstract' 'transient' 'interface' :)
         and $state[$p:lk] != 1455695                       (: 'final' 'transient' 'interface' :)
         and $state[$p:lk] != 1455706                       (: 'native' 'transient' 'interface' :)
         and $state[$p:lk] != 1455711                       (: 'private' 'transient' 'interface' :)
         and $state[$p:lk] != 1455712                       (: 'protected' 'transient' 'interface' :)
         and $state[$p:lk] != 1455713                       (: 'public' 'transient' 'interface' :)
         and $state[$p:lk] != 1455716                       (: 'static' 'transient' 'interface' :)
         and $state[$p:lk] != 1455717                       (: 'strictfp' 'transient' 'interface' :)
         and $state[$p:lk] != 1455720                       (: 'synchronized' 'transient' 'interface' :)
         and $state[$p:lk] != 1455724                       (: 'transient' 'transient' 'interface' :)
         and $state[$p:lk] != 1455728                       (: 'volatile' 'transient' 'interface' :)
         and $state[$p:lk] != 1456190                       (: 'abstract' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456207                       (: 'final' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456218                       (: 'native' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456223                       (: 'private' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456224                       (: 'protected' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456225                       (: 'public' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456228                       (: 'static' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456229                       (: 'strictfp' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456232                       (: 'synchronized' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456236                       (: 'transient' 'volatile' 'interface' :)
         and $state[$p:lk] != 1456240                       (: 'volatile' 'volatile' 'interface' :)
         and $state[$p:lk] != 1540270                       (: '@' IDENTIFIER 'package' :)
         and $state[$p:lk] != 1546158                       (: '@' 'EOF' 'package' :)
         and $state[$p:lk] != 1546286                       (: '@' 'IGNORE_CASE' 'package' :)
         and $state[$p:lk] != 1546414                       (: '@' 'JAVACODE' 'package' :)
         and $state[$p:lk] != 1546542                       (: '@' 'LOOKAHEAD' 'package' :)
         and $state[$p:lk] != 1546670                       (: '@' 'MORE' 'package' :)
         and $state[$p:lk] != 1546798                       (: '@' 'PARSER_BEGIN' 'package' :)
         and $state[$p:lk] != 1546926                       (: '@' 'PARSER_END' 'package' :)
         and $state[$p:lk] != 1547054                       (: '@' 'SKIP' 'package' :)
         and $state[$p:lk] != 1547182                       (: '@' 'SPECIAL_TOKEN' 'package' :)
         and $state[$p:lk] != 1547310                       (: '@' 'TOKEN' 'package' :)
         and $state[$p:lk] != 1547438                       (: '@' 'TOKEN_MGR_DECLS' 'package' :)
         and $state[$p:lk] != 1548094                       (: 'abstract' 'abstract' 'package' :)
         and $state[$p:lk] != 1548111                       (: 'final' 'abstract' 'package' :)
         and $state[$p:lk] != 1548122                       (: 'native' 'abstract' 'package' :)
         and $state[$p:lk] != 1548127                       (: 'private' 'abstract' 'package' :)
         and $state[$p:lk] != 1548128                       (: 'protected' 'abstract' 'package' :)
         and $state[$p:lk] != 1548129                       (: 'public' 'abstract' 'package' :)
         and $state[$p:lk] != 1548132                       (: 'static' 'abstract' 'package' :)
         and $state[$p:lk] != 1548133                       (: 'strictfp' 'abstract' 'package' :)
         and $state[$p:lk] != 1548136                       (: 'synchronized' 'abstract' 'package' :)
         and $state[$p:lk] != 1548140                       (: 'transient' 'abstract' 'package' :)
         and $state[$p:lk] != 1548144                       (: 'volatile' 'abstract' 'package' :)
         and $state[$p:lk] != 1550270                       (: 'abstract' 'final' 'package' :)
         and $state[$p:lk] != 1550287                       (: 'final' 'final' 'package' :)
         and $state[$p:lk] != 1550298                       (: 'native' 'final' 'package' :)
         and $state[$p:lk] != 1550303                       (: 'private' 'final' 'package' :)
         and $state[$p:lk] != 1550304                       (: 'protected' 'final' 'package' :)
         and $state[$p:lk] != 1550305                       (: 'public' 'final' 'package' :)
         and $state[$p:lk] != 1550308                       (: 'static' 'final' 'package' :)
         and $state[$p:lk] != 1550309                       (: 'strictfp' 'final' 'package' :)
         and $state[$p:lk] != 1550312                       (: 'synchronized' 'final' 'package' :)
         and $state[$p:lk] != 1550316                       (: 'transient' 'final' 'package' :)
         and $state[$p:lk] != 1550320                       (: 'volatile' 'final' 'package' :)
         and $state[$p:lk] != 1551678                       (: 'abstract' 'native' 'package' :)
         and $state[$p:lk] != 1551695                       (: 'final' 'native' 'package' :)
         and $state[$p:lk] != 1551706                       (: 'native' 'native' 'package' :)
         and $state[$p:lk] != 1551711                       (: 'private' 'native' 'package' :)
         and $state[$p:lk] != 1551712                       (: 'protected' 'native' 'package' :)
         and $state[$p:lk] != 1551713                       (: 'public' 'native' 'package' :)
         and $state[$p:lk] != 1551716                       (: 'static' 'native' 'package' :)
         and $state[$p:lk] != 1551717                       (: 'strictfp' 'native' 'package' :)
         and $state[$p:lk] != 1551720                       (: 'synchronized' 'native' 'package' :)
         and $state[$p:lk] != 1551724                       (: 'transient' 'native' 'package' :)
         and $state[$p:lk] != 1551728                       (: 'volatile' 'native' 'package' :)
         and $state[$p:lk] != 1552318                       (: 'abstract' 'private' 'package' :)
         and $state[$p:lk] != 1552335                       (: 'final' 'private' 'package' :)
         and $state[$p:lk] != 1552346                       (: 'native' 'private' 'package' :)
         and $state[$p:lk] != 1552351                       (: 'private' 'private' 'package' :)
         and $state[$p:lk] != 1552352                       (: 'protected' 'private' 'package' :)
         and $state[$p:lk] != 1552353                       (: 'public' 'private' 'package' :)
         and $state[$p:lk] != 1552356                       (: 'static' 'private' 'package' :)
         and $state[$p:lk] != 1552357                       (: 'strictfp' 'private' 'package' :)
         and $state[$p:lk] != 1552360                       (: 'synchronized' 'private' 'package' :)
         and $state[$p:lk] != 1552364                       (: 'transient' 'private' 'package' :)
         and $state[$p:lk] != 1552368                       (: 'volatile' 'private' 'package' :)
         and $state[$p:lk] != 1552446                       (: 'abstract' 'protected' 'package' :)
         and $state[$p:lk] != 1552463                       (: 'final' 'protected' 'package' :)
         and $state[$p:lk] != 1552474                       (: 'native' 'protected' 'package' :)
         and $state[$p:lk] != 1552479                       (: 'private' 'protected' 'package' :)
         and $state[$p:lk] != 1552480                       (: 'protected' 'protected' 'package' :)
         and $state[$p:lk] != 1552481                       (: 'public' 'protected' 'package' :)
         and $state[$p:lk] != 1552484                       (: 'static' 'protected' 'package' :)
         and $state[$p:lk] != 1552485                       (: 'strictfp' 'protected' 'package' :)
         and $state[$p:lk] != 1552488                       (: 'synchronized' 'protected' 'package' :)
         and $state[$p:lk] != 1552492                       (: 'transient' 'protected' 'package' :)
         and $state[$p:lk] != 1552496                       (: 'volatile' 'protected' 'package' :)
         and $state[$p:lk] != 1552574                       (: 'abstract' 'public' 'package' :)
         and $state[$p:lk] != 1552591                       (: 'final' 'public' 'package' :)
         and $state[$p:lk] != 1552602                       (: 'native' 'public' 'package' :)
         and $state[$p:lk] != 1552607                       (: 'private' 'public' 'package' :)
         and $state[$p:lk] != 1552608                       (: 'protected' 'public' 'package' :)
         and $state[$p:lk] != 1552609                       (: 'public' 'public' 'package' :)
         and $state[$p:lk] != 1552612                       (: 'static' 'public' 'package' :)
         and $state[$p:lk] != 1552613                       (: 'strictfp' 'public' 'package' :)
         and $state[$p:lk] != 1552616                       (: 'synchronized' 'public' 'package' :)
         and $state[$p:lk] != 1552620                       (: 'transient' 'public' 'package' :)
         and $state[$p:lk] != 1552624                       (: 'volatile' 'public' 'package' :)
         and $state[$p:lk] != 1552958                       (: 'abstract' 'static' 'package' :)
         and $state[$p:lk] != 1552975                       (: 'final' 'static' 'package' :)
         and $state[$p:lk] != 1552986                       (: 'native' 'static' 'package' :)
         and $state[$p:lk] != 1552991                       (: 'private' 'static' 'package' :)
         and $state[$p:lk] != 1552992                       (: 'protected' 'static' 'package' :)
         and $state[$p:lk] != 1552993                       (: 'public' 'static' 'package' :)
         and $state[$p:lk] != 1552996                       (: 'static' 'static' 'package' :)
         and $state[$p:lk] != 1552997                       (: 'strictfp' 'static' 'package' :)
         and $state[$p:lk] != 1553000                       (: 'synchronized' 'static' 'package' :)
         and $state[$p:lk] != 1553004                       (: 'transient' 'static' 'package' :)
         and $state[$p:lk] != 1553008                       (: 'volatile' 'static' 'package' :)
         and $state[$p:lk] != 1553086                       (: 'abstract' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553103                       (: 'final' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553114                       (: 'native' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553119                       (: 'private' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553120                       (: 'protected' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553121                       (: 'public' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553124                       (: 'static' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553125                       (: 'strictfp' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553128                       (: 'synchronized' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553132                       (: 'transient' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553136                       (: 'volatile' 'strictfp' 'package' :)
         and $state[$p:lk] != 1553470                       (: 'abstract' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553487                       (: 'final' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553498                       (: 'native' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553503                       (: 'private' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553504                       (: 'protected' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553505                       (: 'public' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553508                       (: 'static' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553509                       (: 'strictfp' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553512                       (: 'synchronized' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553516                       (: 'transient' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553520                       (: 'volatile' 'synchronized' 'package' :)
         and $state[$p:lk] != 1553982                       (: 'abstract' 'transient' 'package' :)
         and $state[$p:lk] != 1553999                       (: 'final' 'transient' 'package' :)
         and $state[$p:lk] != 1554010                       (: 'native' 'transient' 'package' :)
         and $state[$p:lk] != 1554015                       (: 'private' 'transient' 'package' :)
         and $state[$p:lk] != 1554016                       (: 'protected' 'transient' 'package' :)
         and $state[$p:lk] != 1554017                       (: 'public' 'transient' 'package' :)
         and $state[$p:lk] != 1554020                       (: 'static' 'transient' 'package' :)
         and $state[$p:lk] != 1554021                       (: 'strictfp' 'transient' 'package' :)
         and $state[$p:lk] != 1554024                       (: 'synchronized' 'transient' 'package' :)
         and $state[$p:lk] != 1554028                       (: 'transient' 'transient' 'package' :)
         and $state[$p:lk] != 1554032                       (: 'volatile' 'transient' 'package' :)
         and $state[$p:lk] != 1554494                       (: 'abstract' 'volatile' 'package' :)
         and $state[$p:lk] != 1554511                       (: 'final' 'volatile' 'package' :)
         and $state[$p:lk] != 1554522                       (: 'native' 'volatile' 'package' :)
         and $state[$p:lk] != 1554527                       (: 'private' 'volatile' 'package' :)
         and $state[$p:lk] != 1554528                       (: 'protected' 'volatile' 'package' :)
         and $state[$p:lk] != 1554529                       (: 'public' 'volatile' 'package' :)
         and $state[$p:lk] != 1554532                       (: 'static' 'volatile' 'package' :)
         and $state[$p:lk] != 1554533                       (: 'strictfp' 'volatile' 'package' :)
         and $state[$p:lk] != 1554536                       (: 'synchronized' 'volatile' 'package' :)
         and $state[$p:lk] != 1554540                       (: 'transient' 'volatile' 'package' :)
         and $state[$p:lk] != 1554544) then                 (: 'volatile' 'volatile' 'package' :)
      let $state := p:memoized($state, 7)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-PackageDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 94                             (: 'package' :)
          or $state[$p:lk] = 12094                          (: 'abstract' 'package' :)
          or $state[$p:lk] = 12111                          (: 'final' 'package' :)
          or $state[$p:lk] = 12122                          (: 'native' 'package' :)
          or $state[$p:lk] = 12127                          (: 'private' 'package' :)
          or $state[$p:lk] = 12128                          (: 'protected' 'package' :)
          or $state[$p:lk] = 12129                          (: 'public' 'package' :)
          or $state[$p:lk] = 12132                          (: 'static' 'package' :)
          or $state[$p:lk] = 12133                          (: 'strictfp' 'package' :)
          or $state[$p:lk] = 12136                          (: 'synchronized' 'package' :)
          or $state[$p:lk] = 12140                          (: 'transient' 'package' :)
          or $state[$p:lk] = 12144                          (: 'volatile' 'package' :)
          or $state[$p:lk] = 1540270                        (: '@' IDENTIFIER 'package' :)
          or $state[$p:lk] = 1546158                        (: '@' 'EOF' 'package' :)
          or $state[$p:lk] = 1546286                        (: '@' 'IGNORE_CASE' 'package' :)
          or $state[$p:lk] = 1546414                        (: '@' 'JAVACODE' 'package' :)
          or $state[$p:lk] = 1546542                        (: '@' 'LOOKAHEAD' 'package' :)
          or $state[$p:lk] = 1546670                        (: '@' 'MORE' 'package' :)
          or $state[$p:lk] = 1546798                        (: '@' 'PARSER_BEGIN' 'package' :)
          or $state[$p:lk] = 1546926                        (: '@' 'PARSER_END' 'package' :)
          or $state[$p:lk] = 1547054                        (: '@' 'SKIP' 'package' :)
          or $state[$p:lk] = 1547182                        (: '@' 'SPECIAL_TOKEN' 'package' :)
          or $state[$p:lk] = 1547310                        (: '@' 'TOKEN' 'package' :)
          or $state[$p:lk] = 1547438                        (: '@' 'TOKEN_MGR_DECLS' 'package' :)
          or $state[$p:lk] = 1548094                        (: 'abstract' 'abstract' 'package' :)
          or $state[$p:lk] = 1548111                        (: 'final' 'abstract' 'package' :)
          or $state[$p:lk] = 1548122                        (: 'native' 'abstract' 'package' :)
          or $state[$p:lk] = 1548127                        (: 'private' 'abstract' 'package' :)
          or $state[$p:lk] = 1548128                        (: 'protected' 'abstract' 'package' :)
          or $state[$p:lk] = 1548129                        (: 'public' 'abstract' 'package' :)
          or $state[$p:lk] = 1548132                        (: 'static' 'abstract' 'package' :)
          or $state[$p:lk] = 1548133                        (: 'strictfp' 'abstract' 'package' :)
          or $state[$p:lk] = 1548136                        (: 'synchronized' 'abstract' 'package' :)
          or $state[$p:lk] = 1548140                        (: 'transient' 'abstract' 'package' :)
          or $state[$p:lk] = 1548144                        (: 'volatile' 'abstract' 'package' :)
          or $state[$p:lk] = 1550270                        (: 'abstract' 'final' 'package' :)
          or $state[$p:lk] = 1550287                        (: 'final' 'final' 'package' :)
          or $state[$p:lk] = 1550298                        (: 'native' 'final' 'package' :)
          or $state[$p:lk] = 1550303                        (: 'private' 'final' 'package' :)
          or $state[$p:lk] = 1550304                        (: 'protected' 'final' 'package' :)
          or $state[$p:lk] = 1550305                        (: 'public' 'final' 'package' :)
          or $state[$p:lk] = 1550308                        (: 'static' 'final' 'package' :)
          or $state[$p:lk] = 1550309                        (: 'strictfp' 'final' 'package' :)
          or $state[$p:lk] = 1550312                        (: 'synchronized' 'final' 'package' :)
          or $state[$p:lk] = 1550316                        (: 'transient' 'final' 'package' :)
          or $state[$p:lk] = 1550320                        (: 'volatile' 'final' 'package' :)
          or $state[$p:lk] = 1551678                        (: 'abstract' 'native' 'package' :)
          or $state[$p:lk] = 1551695                        (: 'final' 'native' 'package' :)
          or $state[$p:lk] = 1551706                        (: 'native' 'native' 'package' :)
          or $state[$p:lk] = 1551711                        (: 'private' 'native' 'package' :)
          or $state[$p:lk] = 1551712                        (: 'protected' 'native' 'package' :)
          or $state[$p:lk] = 1551713                        (: 'public' 'native' 'package' :)
          or $state[$p:lk] = 1551716                        (: 'static' 'native' 'package' :)
          or $state[$p:lk] = 1551717                        (: 'strictfp' 'native' 'package' :)
          or $state[$p:lk] = 1551720                        (: 'synchronized' 'native' 'package' :)
          or $state[$p:lk] = 1551724                        (: 'transient' 'native' 'package' :)
          or $state[$p:lk] = 1551728                        (: 'volatile' 'native' 'package' :)
          or $state[$p:lk] = 1552318                        (: 'abstract' 'private' 'package' :)
          or $state[$p:lk] = 1552335                        (: 'final' 'private' 'package' :)
          or $state[$p:lk] = 1552346                        (: 'native' 'private' 'package' :)
          or $state[$p:lk] = 1552351                        (: 'private' 'private' 'package' :)
          or $state[$p:lk] = 1552352                        (: 'protected' 'private' 'package' :)
          or $state[$p:lk] = 1552353                        (: 'public' 'private' 'package' :)
          or $state[$p:lk] = 1552356                        (: 'static' 'private' 'package' :)
          or $state[$p:lk] = 1552357                        (: 'strictfp' 'private' 'package' :)
          or $state[$p:lk] = 1552360                        (: 'synchronized' 'private' 'package' :)
          or $state[$p:lk] = 1552364                        (: 'transient' 'private' 'package' :)
          or $state[$p:lk] = 1552368                        (: 'volatile' 'private' 'package' :)
          or $state[$p:lk] = 1552446                        (: 'abstract' 'protected' 'package' :)
          or $state[$p:lk] = 1552463                        (: 'final' 'protected' 'package' :)
          or $state[$p:lk] = 1552474                        (: 'native' 'protected' 'package' :)
          or $state[$p:lk] = 1552479                        (: 'private' 'protected' 'package' :)
          or $state[$p:lk] = 1552480                        (: 'protected' 'protected' 'package' :)
          or $state[$p:lk] = 1552481                        (: 'public' 'protected' 'package' :)
          or $state[$p:lk] = 1552484                        (: 'static' 'protected' 'package' :)
          or $state[$p:lk] = 1552485                        (: 'strictfp' 'protected' 'package' :)
          or $state[$p:lk] = 1552488                        (: 'synchronized' 'protected' 'package' :)
          or $state[$p:lk] = 1552492                        (: 'transient' 'protected' 'package' :)
          or $state[$p:lk] = 1552496                        (: 'volatile' 'protected' 'package' :)
          or $state[$p:lk] = 1552574                        (: 'abstract' 'public' 'package' :)
          or $state[$p:lk] = 1552591                        (: 'final' 'public' 'package' :)
          or $state[$p:lk] = 1552602                        (: 'native' 'public' 'package' :)
          or $state[$p:lk] = 1552607                        (: 'private' 'public' 'package' :)
          or $state[$p:lk] = 1552608                        (: 'protected' 'public' 'package' :)
          or $state[$p:lk] = 1552609                        (: 'public' 'public' 'package' :)
          or $state[$p:lk] = 1552612                        (: 'static' 'public' 'package' :)
          or $state[$p:lk] = 1552613                        (: 'strictfp' 'public' 'package' :)
          or $state[$p:lk] = 1552616                        (: 'synchronized' 'public' 'package' :)
          or $state[$p:lk] = 1552620                        (: 'transient' 'public' 'package' :)
          or $state[$p:lk] = 1552624                        (: 'volatile' 'public' 'package' :)
          or $state[$p:lk] = 1552958                        (: 'abstract' 'static' 'package' :)
          or $state[$p:lk] = 1552975                        (: 'final' 'static' 'package' :)
          or $state[$p:lk] = 1552986                        (: 'native' 'static' 'package' :)
          or $state[$p:lk] = 1552991                        (: 'private' 'static' 'package' :)
          or $state[$p:lk] = 1552992                        (: 'protected' 'static' 'package' :)
          or $state[$p:lk] = 1552993                        (: 'public' 'static' 'package' :)
          or $state[$p:lk] = 1552996                        (: 'static' 'static' 'package' :)
          or $state[$p:lk] = 1552997                        (: 'strictfp' 'static' 'package' :)
          or $state[$p:lk] = 1553000                        (: 'synchronized' 'static' 'package' :)
          or $state[$p:lk] = 1553004                        (: 'transient' 'static' 'package' :)
          or $state[$p:lk] = 1553008                        (: 'volatile' 'static' 'package' :)
          or $state[$p:lk] = 1553086                        (: 'abstract' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553103                        (: 'final' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553114                        (: 'native' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553119                        (: 'private' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553120                        (: 'protected' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553121                        (: 'public' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553124                        (: 'static' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553125                        (: 'strictfp' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553128                        (: 'synchronized' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553132                        (: 'transient' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553136                        (: 'volatile' 'strictfp' 'package' :)
          or $state[$p:lk] = 1553470                        (: 'abstract' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553487                        (: 'final' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553498                        (: 'native' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553503                        (: 'private' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553504                        (: 'protected' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553505                        (: 'public' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553508                        (: 'static' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553509                        (: 'strictfp' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553512                        (: 'synchronized' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553516                        (: 'transient' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553520                        (: 'volatile' 'synchronized' 'package' :)
          or $state[$p:lk] = 1553982                        (: 'abstract' 'transient' 'package' :)
          or $state[$p:lk] = 1553999                        (: 'final' 'transient' 'package' :)
          or $state[$p:lk] = 1554010                        (: 'native' 'transient' 'package' :)
          or $state[$p:lk] = 1554015                        (: 'private' 'transient' 'package' :)
          or $state[$p:lk] = 1554016                        (: 'protected' 'transient' 'package' :)
          or $state[$p:lk] = 1554017                        (: 'public' 'transient' 'package' :)
          or $state[$p:lk] = 1554020                        (: 'static' 'transient' 'package' :)
          or $state[$p:lk] = 1554021                        (: 'strictfp' 'transient' 'package' :)
          or $state[$p:lk] = 1554024                        (: 'synchronized' 'transient' 'package' :)
          or $state[$p:lk] = 1554028                        (: 'transient' 'transient' 'package' :)
          or $state[$p:lk] = 1554032                        (: 'volatile' 'transient' 'package' :)
          or $state[$p:lk] = 1554494                        (: 'abstract' 'volatile' 'package' :)
          or $state[$p:lk] = 1554511                        (: 'final' 'volatile' 'package' :)
          or $state[$p:lk] = 1554522                        (: 'native' 'volatile' 'package' :)
          or $state[$p:lk] = 1554527                        (: 'private' 'volatile' 'package' :)
          or $state[$p:lk] = 1554528                        (: 'protected' 'volatile' 'package' :)
          or $state[$p:lk] = 1554529                        (: 'public' 'volatile' 'package' :)
          or $state[$p:lk] = 1554532                        (: 'static' 'volatile' 'package' :)
          or $state[$p:lk] = 1554533                        (: 'strictfp' 'volatile' 'package' :)
          or $state[$p:lk] = 1554536                        (: 'synchronized' 'volatile' 'package' :)
          or $state[$p:lk] = 1554540                        (: 'transient' 'volatile' 'package' :)
          or $state[$p:lk] = 1554544) then                  (: 'volatile' 'volatile' 'package' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PackageDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:parse-CompilationUnit-1($input, $state)
  let $state := p:parse-CompilationUnit-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompilationUnit", $count, $begin, $end)
};

(:~
 : Parse identifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-identifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(1, $input, $state)                (: IDENTIFIER :)
  let $end := $state[$p:e0]
  return p:reduce($state, "identifier", $count, $begin, $end)
};

(:~
 : Try parsing identifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-identifier($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(1, $input, $state)               (: IDENTIFIER :)
  return $state
};

(:~
 : Parse StringLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(7, $input, $state)                (: STRING_LITERAL :)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringLiteral", $count, $begin, $end)
};

(:~
 : Try parsing StringLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(7, $input, $state)               (: STRING_LITERAL :)
  return $state
};

(:~
 : Parse BooleanLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BooleanLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 109) then                      (: 'true' :)
      let $state := p:consume(109, $input, $state)          (: 'true' :)
      return $state
    else
      let $state := p:consume(78, $input, $state)           (: 'false' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BooleanLiteral", $count, $begin, $end)
};

(:~
 : Try parsing BooleanLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BooleanLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 109) then                      (: 'true' :)
      let $state := p:consumeT(109, $input, $state)         (: 'true' :)
      return $state
    else
      let $state := p:consumeT(78, $input, $state)          (: 'false' :)
      return $state
  return $state
};

(:~
 : Parse IntegerLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntegerLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: INTEGER_LITERAL :)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntegerLiteral", $count, $begin, $end)
};

(:~
 : Try parsing IntegerLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IntegerLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(4, $input, $state)               (: INTEGER_LITERAL :)
  return $state
};

(:~
 : Parse option_binding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-option_binding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IDENTIFIER :)
      let $state := p:consume(1, $input, $state)            (: IDENTIFIER :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'LOOKAHEAD' :)
      let $state := p:consume(50, $input, $state)           (: 'LOOKAHEAD' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: 'IGNORE_CASE' :)
      let $state := p:consume(48, $input, $state)           (: 'IGNORE_CASE' :)
      return $state
    else
      let $state := p:consume(100, $input, $state)          (: 'static' :)
      return $state
  let $state := p:lookahead1W(10, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '=' :)
  let $state := p:consume(39, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(67, $input, $state)           (: SKIP | INTEGER_LITERAL | STRING_LITERAL |
                                                               SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | 'false' |
                                                               'true' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: INTEGER_LITERAL :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IntegerLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 7) then                        (: STRING_LITERAL :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StringLiteral($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BooleanLiteral($input, $state)
      return $state
  let $state := p:lookahead1W(8, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' :)
  let $state := p:consume(34, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "option_binding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production javacc_options (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-javacc_options-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | 'IGNORE_CASE' | 'LOOKAHEAD' |
                                                               'static' | '}' :)
    return
      if ($state[$p:l1] = 118) then                         (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-option_binding($input, $state)
        return p:parse-javacc_options-1($input, $state)
};

(:~
 : Parse javacc_options.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-javacc_options($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 93) then                       (: 'options' :)
      let $state := p:consume(93, $input, $state)           (: 'options' :)
      let $state := p:lookahead1W(23, $input, $state)       (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '{' :)
      let $state := p:consume(114, $input, $state)          (: '{' :)
      let $state := p:parse-javacc_options-1($input, $state)
      let $state := p:consume(118, $input, $state)          (: '}' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "javacc_options", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production javacc_input (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-javacc_input-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'JAVACODE' | 'MORE' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'private' | 'protected' | 'public' |
                                                               'short' | 'void' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-production($input, $state)
    let $state := p:lookahead1W(115, $input, $state)        (: IDENTIFIER | SKIP | EOF | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT | '<' | 'JAVACODE' | 'MORE' | 'SKIP' |
                                                               'SPECIAL_TOKEN' | 'TOKEN' | 'TOKEN_MGR_DECLS' |
                                                               'boolean' | 'byte' | 'char' | 'double' | 'float' |
                                                               'int' | 'long' | 'private' | 'protected' | 'public' |
                                                               'short' | 'void' :)
    return
      if ($state[$p:l1] = 3) then                           (: EOF :)
        $state
      else
        p:parse-javacc_input-1($input, $state)
};

(:~
 : Parse javacc_input.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-javacc_input($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(49, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'PARSER_BEGIN' | 'options' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-javacc_options($input, $state)
  let $state := p:lookahead1W(14, $input, $state)           (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT |
                                                               'PARSER_BEGIN' :)
  let $state := p:consume(52, $input, $state)               (: 'PARSER_BEGIN' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-identifier($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(112, $input, $state)          (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ';' |
                                                               '@' | 'PARSER_END' | 'abstract' | 'class' | 'enum' |
                                                               'final' | 'import' | 'interface' | 'native' | 'package' |
                                                               'private' | 'protected' | 'public' | 'static' |
                                                               'strictfp' | 'synchronized' | 'transient' | 'volatile' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CompilationUnit($input, $state)
  let $state := p:consume(53, $input, $state)               (: 'PARSER_END' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | '(' :)
  let $state := p:consume(18, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IDENTIFIER | SKIP | SINGLE_LINE_COMMENT |
                                                               MULTI_LINE_COMMENT :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-identifier($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: SKIP | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT | ')' :)
  let $state := p:consume(19, $input, $state)               (: ')' :)
  let $state := p:parse-javacc_input-1($input, $state)
  let $state := p:consume(3, $input, $state)                (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "javacc_input", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 2                                       (: SKIP :)
     or $match[1] = 8                                       (: SINGLE_LINE_COMMENT :)
     or $match[1] = 9) then                                 (: MULTI_LINE_COMMENT :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 128 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 16384 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from lexer state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore lexer state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the lexer state before backtracking started.
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value
  }
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $dpi for input position $e0. Reconstruct state from the parameters.
 :
 : @param $state the lexer state to be restored.
 : @param $update the lexer state containing updates.
 : @param $dpi the decision point id.
 : @param $e0 the input position.
 : @param $v the id of the successful alternative.
 : @param $lk the new lookahead code.
 : @return the reconstructed state.
 :)
declare function p:memoize($state as item()+,
                           $update as item()+,
                           $dpi as xs:integer,
                           $e0 as xs:integer,
                           $v as xs:integer,
                           $lk as xs:integer) as item()+
{
  $lk,
  subsequence($state, $p:b0, $p:memo - $p:b0),
  let $memo := $update[$p:memo]
  let $errors := ($memo, $update[$p:error])[.]
  return
    element memo
    {
      $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
      $memo/value,
      <value key='{$e0 * 32 + $dpi}'>{$v}</value>
    },
  subsequence($state, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $dpi
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $dpi the decision point id.
 : @return the updated state.
 :)
declare function p:memoized($state as item()+, $dpi as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 32 + $dpi])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol javacc_input from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-javacc_input($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>)
  let $state := p:parse-javacc_input($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
