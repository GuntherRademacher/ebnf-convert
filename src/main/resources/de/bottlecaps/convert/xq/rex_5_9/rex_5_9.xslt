<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Thu Jan 30, 2025 13:23 (UTC+01) by REx v6.1 which is Copyright (c) 1979-2025 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: -q -tree -a none -xslt -name de/bottlecaps/convert/xq/rex_5_9/rex_5_9.xslt ../../../../../../../main/java/de/bottlecaps/convert/rex_5_9/rex_5_9.ebnf -->

<xsl:stylesheet version="2.0"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:p="de/bottlecaps/convert/xq/rex_5_9/rex_5_9.xslt">
  <!--~
   ! The index of the lexer state for accessing the combined
   ! (i.e. level > 1) lookahead code.
  -->
  <xsl:variable name="p:lk" as="xs:integer" select="1"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the token that has been consumed.
  -->
  <xsl:variable name="p:b0" as="xs:integer" select="2"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the token that has been consumed.
  -->
  <xsl:variable name="p:e0" as="xs:integer" select="3"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-1-lookahead token.
  -->
  <xsl:variable name="p:l1" as="xs:integer" select="4"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-1-lookahead token.
  -->
  <xsl:variable name="p:b1" as="xs:integer" select="5"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-1-lookahead token.
  -->
  <xsl:variable name="p:e1" as="xs:integer" select="6"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-2-lookahead token.
  -->
  <xsl:variable name="p:l2" as="xs:integer" select="7"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-2-lookahead token.
  -->
  <xsl:variable name="p:b2" as="xs:integer" select="8"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-2-lookahead token.
  -->
  <xsl:variable name="p:e2" as="xs:integer" select="9"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-3-lookahead token.
  -->
  <xsl:variable name="p:l3" as="xs:integer" select="10"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-3-lookahead token.
  -->
  <xsl:variable name="p:b3" as="xs:integer" select="11"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-3-lookahead token.
  -->
  <xsl:variable name="p:e3" as="xs:integer" select="12"/>

  <!--~
   ! The index of the lexer state for accessing the token code that
   ! was expected when an error was found.
  -->
  <xsl:variable name="p:error" as="xs:integer" select="13"/>

  <!--~
   ! The index of the lexer state that points to the first entry
   ! used for collecting action results.
  -->
  <xsl:variable name="p:result" as="xs:integer" select="14"/>

  <!--~
   ! The codepoint to charclass mapping for 7 bit codepoints.
  -->
  <xsl:variable name="p:MAP0" as="xs:integer+" select="
    72, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 8, 15, 16, 17, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 20, 21, 22, 23, 24, 8, 25, 26, 27, 26, 28, 29, 30, 30, 31, 30, 32, 33, 34, 35, 36, 30, 30, 37, 38, 39, 30, 40, 41,
    30, 30, 30, 42, 43, 44, 45, 46, 8, 47, 48, 49, 50, 51, 52, 53, 54, 55, 54, 54, 56, 57, 58, 59, 60, 54, 61, 62, 63, 64, 54, 65, 66, 67, 54, 68, 69, 70, 8, 8
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints below the surrogate block.
  -->
  <xsl:variable name="p:MAP1" as="xs:integer+" select="
    216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 713,
    745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
    815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
    247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
    247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
    247, 247, 247, 247, 259, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
    247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 853, 940,
    949, 941, 941, 957, 965, 973, 979, 987, 1010, 1018, 1026, 1034, 1042, 1050, 1058, 1267, 1267, 1267, 1267, 1267, 1267, 1437, 1267, 1259, 1259, 1260, 1259,
    1259, 1259, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
    1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1261, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259,
    1259, 1359, 1260, 1258, 1257, 1259, 1259, 1259, 1259, 1259, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1072, 1259, 1259, 1259, 1259, 1188,
    1075, 1259, 1259, 1259, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1266, 1267, 1074, 1265,
    1267, 1405, 1267, 1267, 1267, 1267, 1267, 1258, 1259, 1259, 1264, 1125, 1325, 1404, 1267, 1399, 1405, 1125, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
    1361, 1259, 1260, 1136, 1399, 1314, 1201, 1399, 1405, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1401, 1267, 1267, 1267, 1405, 1267, 1267, 1267, 1384,
    1236, 1259, 1259, 1256, 1259, 1259, 1259, 1259, 1260, 1260, 1424, 1257, 1259, 1263, 1267, 1258, 1083, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1258,
    1083, 1259, 1259, 1259, 1259, 1092, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1105, 1114, 1259, 1259, 1259, 1106, 1261, 1265, 1450, 1259, 1259, 1259, 1259,
    1259, 1259, 1154, 1399, 1401, 1202, 1259, 1172, 1399, 1267, 1267, 1450, 1105, 1360, 1259, 1259, 1257, 1186, 1197, 1163, 1175, 1437, 1212, 1172, 1399, 1265,
    1267, 1223, 1246, 1360, 1259, 1259, 1257, 1414, 1197, 1178, 1175, 1267, 1234, 1438, 1399, 1244, 1267, 1450, 1235, 1256, 1259, 1259, 1257, 1254, 1154, 1277,
    1097, 1267, 1267, 994, 1399, 1267, 1267, 1450, 1105, 1360, 1259, 1259, 1257, 1357, 1154, 1203, 1175, 1438, 1212, 1117, 1399, 1267, 1267, 1002, 1286, 1302,
    1298, 1189, 1286, 1127, 1117, 1204, 1201, 1437, 1267, 1437, 1399, 1267, 1267, 1450, 1083, 1257, 1259, 1259, 1257, 1084, 1117, 1278, 1201, 1439, 1267, 1117,
    1399, 1267, 1267, 1002, 1083, 1257, 1259, 1259, 1257, 1084, 1117, 1278, 1201, 1439, 1269, 1117, 1399, 1267, 1267, 1002, 1083, 1257, 1259, 1259, 1257, 1259,
    1117, 1164, 1201, 1437, 1267, 1117, 1399, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
    1267, 1259, 1259, 1259, 1259, 1261, 1267, 1259, 1259, 1259, 1259, 1260, 1267, 1258, 1259, 1259, 1259, 1259, 1260, 1310, 1404, 1322, 1400, 1399, 1405, 1267,
    1267, 1267, 1267, 1215, 1334, 1073, 1258, 1344, 1354, 1310, 1146, 1369, 1401, 1399, 1405, 1267, 1267, 1267, 1267, 1269, 1290, 1267, 1267, 1267, 1267, 1267,
    1267, 1267, 1267, 1267, 1267, 1264, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1254, 1413, 1264, 1267, 1267,
    1267, 1267, 1422, 1266, 1422, 1188, 1070, 1346, 1187, 1214, 1267, 1267, 1267, 1267, 1269, 1267, 1336, 1268, 1300, 1264, 1267, 1267, 1267, 1267, 1433, 1266,
    1435, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1259, 1259, 1259, 1259, 1259,
    1259, 1259, 1259, 1259, 1259, 1259, 1265, 1259, 1259, 1261, 1261, 1259, 1259, 1259, 1259, 1261, 1261, 1259, 1425, 1259, 1259, 1259, 1261, 1259, 1259, 1259,
    1259, 1259, 1259, 1083, 1128, 1226, 1262, 1106, 1263, 1259, 1262, 1226, 1262, 1064, 1267, 1267, 1267, 1258, 1326, 1162, 1267, 1258, 1259, 1259, 1259, 1259,
    1259, 1259, 1259, 1259, 1259, 1262, 999, 1258, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1447, 1072, 1259, 1259, 1259, 1259, 1262, 1267,
    1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
    1267, 1267, 1267, 1267, 1267, 1399, 1402, 1382, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
    1259, 1259, 1259, 1259, 1259, 1263, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1405, 1399, 1405, 1392, 1374, 1259, 1258, 1259, 1259,
    1259, 1265, 1398, 1399, 1278, 1403, 1277, 1398, 1399, 1401, 1398, 1382, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1258, 1259, 1259, 1259, 1260, 1435,
    1258, 1259, 1259, 1259, 1260, 1267, 1398, 1399, 1160, 1399, 1399, 1142, 1379, 1267, 1259, 1259, 1259, 1264, 1264, 1267, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
    0, 0, 1, 0, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 8, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 20, 21, 22, 23, 24, 8, 25, 26, 27, 26, 28, 29,
    30, 8, 8, 8, 8, 8, 71, 71, 8, 8, 71, 71, 8, 30, 30, 30, 30, 31, 30, 32, 33, 34, 35, 36, 30, 30, 37, 38, 39, 30, 40, 41, 30, 30, 30, 42, 43, 44, 45, 46, 8,
    47, 48, 49, 50, 51, 52, 53, 54, 55, 54, 54, 56, 57, 58, 59, 60, 54, 61, 62, 63, 64, 54, 65, 66, 67, 54, 68, 69, 70, 8, 8, 8, 8, 8, 71, 8, 30, 8, 8, 8, 8, 8,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 8, 30, 30, 30, 30, 30, 8, 71, 71, 71, 71, 8, 71, 71, 71, 8, 8, 30, 30, 30, 30, 30, 8, 8, 30, 30, 30, 8, 8, 30,
    30, 8, 8, 8, 8, 71, 71, 71, 30, 30, 30, 30, 30, 30, 30, 8, 30, 8, 30, 30, 30, 30, 8, 30, 71, 71, 8, 71, 71, 71, 8, 71, 71, 30, 8, 8, 30, 30, 8, 8, 71, 30,
    71, 71, 8, 71, 71, 71, 71, 71, 8, 8, 71, 71, 30, 30, 71, 71, 8, 8, 71, 71, 71, 8, 8, 8, 8, 71, 30, 8, 30, 8, 8, 8, 30, 30, 8, 8, 8, 30, 30, 8, 8, 71, 8, 71,
    71, 71, 71, 8, 8, 8, 71, 71, 8, 8, 8, 8, 30, 30, 8, 30, 8, 8, 30, 8, 8, 71, 8, 8, 30, 30, 30, 8, 30, 30, 8, 30, 30, 30, 30, 8, 30, 8, 30, 30, 71, 71, 30,
    30, 30, 8, 8, 8, 8, 30, 30, 8, 30, 30, 8, 30, 30, 30, 30, 30, 30, 30, 30, 8, 8, 8, 8, 8, 8, 8, 8, 30, 8, 71, 71, 71, 71, 71, 71, 8, 71, 71, 30, 30, 30, 8,
    8, 8, 30, 30, 8, 8, 30, 8, 8, 30, 30, 8, 30, 8, 30, 30, 30, 30, 8, 8, 30, 71, 30, 30, 71, 71, 71, 71, 71, 30, 30, 71, 30, 30, 30, 30, 30, 30, 71, 71, 71,
    71, 71, 71, 30, 8, 30, 8, 8, 30, 8, 8, 30, 30, 8, 30, 30, 30, 8, 30, 8, 30, 8, 30, 8, 8, 30, 30, 8, 30, 30, 8, 8, 30, 30, 30, 30, 30, 8, 30, 30, 30, 30, 30,
    8, 71, 8, 8, 8, 8, 71, 71, 8, 71, 8, 8, 8, 8, 8, 8, 30, 71, 8, 8, 8, 8, 8, 71, 8, 71, 71, 71, 71, 71, 71, 71, 71, 8, 8, 8, 8, 8, 8, 8, 30, 8, 30, 30, 8, 30,
    30, 8, 8, 8, 8, 8, 30, 8, 30, 8, 30, 8, 30, 8, 8, 8, 30, 8, 8, 8, 8, 8, 8, 8, 71, 71, 8, 30, 30, 30, 8, 71, 71, 71, 8, 30, 30, 30
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints above the surrogate block.
  -->
  <xsl:variable name="p:MAP2" as="xs:integer+" select="
    57344, 65536, 65533, 1114111, 8, 8
  "/>

  <!--~
   ! The token-set-id to DFA-initial-state mapping.
  -->
  <xsl:variable name="p:INITIAL" as="xs:integer+" select="
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
    81, 82, 83, 84
  "/>

  <!--~
   ! The DFA transition table.
  -->
  <xsl:variable name="p:TRANSITION" as="xs:integer+" select="
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4672, 4679, 4684, 4908, 4692, 4906, 4906, 4906, 4906, 4906, 4696, 4708, 5698, 5271,
    5723, 6855, 6855, 4962, 5700, 4737, 6855, 7450, 4748, 5035, 5210, 4756, 6854, 7487, 5650, 6851, 4764, 5574, 5571, 4766, 5577, 4774, 4782, 4787, 4792, 4797,
    4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4813, 4820,
    4825, 4842, 4833, 4850, 4839, 4876, 4879, 4878, 4857, 4887, 5698, 5271, 5723, 6855, 6855, 4962, 5700, 4737, 6855, 7450, 4748, 5035, 5210, 4756, 6854, 7487,
    5650, 6851, 4764, 5574, 5571, 4766, 5577, 4774, 4782, 4787, 4792, 4797, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4700, 4901, 4684, 4908, 4692, 4906, 4906, 4906, 4906, 4906, 4696, 4708, 5698, 5271, 5723, 6855,
    6855, 4962, 5700, 4737, 6855, 7450, 4748, 5035, 5210, 4756, 6854, 7487, 5650, 6851, 4764, 5574, 5571, 4766, 5577, 4774, 4782, 4787, 4792, 4797, 4802, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6881, 4937, 4946,
    4954, 4944, 4944, 4944, 4944, 4944, 4958, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851,
    5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4996, 4719, 5158, 5287, 5004, 5010, 5011, 5011, 5011, 5011, 5019, 4970, 5698, 6783, 6855, 6855, 6855, 6351,
    5700, 4737, 6855, 7450, 4994, 6361, 7455, 6699, 6854, 7280, 4740, 5250, 5592, 5574, 5371, 5594, 6745, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 6278, 5031, 6231,
    6855, 4861, 4868, 4865, 5043, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 5055, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574,
    5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 5311, 6855, 5076, 5083, 5080, 5072, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737,
    6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 6855, 6855,
    6855, 6855, 6855, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766,
    5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 5091, 6953, 5105, 5102, 5113, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450,
    4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5505, 5125, 5131, 5132, 5132, 5132, 5132,
    6685, 4970, 5698, 5297, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 5047, 7455, 7108, 6173, 6971, 4740, 6170, 5547, 6309, 6306, 5549, 6312, 6741,
    6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 4916, 6855, 5158, 7178, 5646, 5337, 5142, 5140, 5150, 5150, 5154, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174,
    7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5168, 5646, 6448, 5166, 6450, 5176, 5178, 5186, 4970,
    5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239,
    7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    5198, 5218, 5190, 7178, 5646, 6855, 5606, 6855, 6855, 5227, 5231, 5243, 6253, 5271, 6855, 5261, 5269, 6351, 6255, 4737, 6855, 5205, 4994, 5219, 7455, 6083,
    6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 7408, 6855, 6855, 5279, 5283, 4970, 5698, 5271,
    6855, 4986, 5295, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156,
    4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855,
    5158, 7178, 5646, 6855, 6855, 6855, 4729, 5305, 5319, 5331, 5698, 5271, 4714, 6082, 6082, 5919, 5700, 5345, 5353, 6003, 5364, 5917, 7455, 6042, 6854, 6187,
    4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5382, 5400, 5405, 5418, 5419, 5416, 5427, 5331, 5698, 5271, 6855, 6082,
    6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 6042, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 6780, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6982, 5451, 5485,
    5447, 5459, 5482, 5493, 5470, 5465, 5474, 4970, 5836, 5271, 6855, 6855, 6855, 6351, 7192, 4737, 6855, 7450, 4994, 6323, 7455, 6083, 6854, 6084, 4740, 6851,
    5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 6855, 6855, 6855, 6855, 7201, 5331, 5698, 5271, 4724, 5501, 6082, 5919,
    5700, 5513, 5521, 6003, 5533, 5557, 5713, 6042, 5253, 5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5585, 6856, 5158, 5784, 5780, 7200,
    7199, 7197, 7374, 7377, 5602, 4970, 5614, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 6855, 6083, 6854, 6084, 4740, 6851, 5547, 5574,
    5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 6855, 5624, 6855, 5625, 6855, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737,
    6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5641, 5634, 5658, 5666, 5671,
    5679, 5687, 5694, 4970, 5698, 5392, 6855, 5387, 6855, 5708, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766,
    5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 4916, 5721, 5158, 7178, 5646, 6855, 6855, 6855, 5794, 6508, 6512, 4970, 5698, 5271, 6855, 6855, 6855, 5023, 5700, 4737, 6855, 7450,
    4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5775, 7401, 5731, 7406, 5732, 6855, 7456,
    5740, 4970, 6392, 5117, 6855, 6855, 5757, 5765, 7053, 4737, 6855, 7450, 5792, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 6497, 5577, 6741,
    5802, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 5813, 6855, 5235, 5851, 7171, 7177, 7176, 5850, 6855, 5828, 5832, 4970, 6935, 7065, 6855, 5844, 6794, 5859, 4923, 4737, 6855, 7450, 5872, 6174,
    7455, 6083, 6854, 6084, 4740, 6851, 5547, 5374, 5882, 4766, 5577, 6736, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331,
    5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6003, 5533, 5917, 7455, 5968, 6854, 5567, 4805, 6851, 5747, 5885, 5981, 5749, 6593, 7321, 6026, 7239,
    7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6003, 5533, 5917, 7455, 5968,
    6854, 5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271,
    5626, 6082, 6082, 5919, 5700, 5948, 5992, 6003, 5533, 5998, 7455, 6016, 6854, 5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156,
    4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855,
    5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 6037, 6003, 5533, 6665, 7455, 5968, 6854, 6055,
    4805, 6851, 6221, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082,
    6082, 5919, 5700, 5948, 6075, 6003, 5533, 5917, 7455, 5968, 6854, 5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356,
    5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851,
    5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919,
    5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6092, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927,
    5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 6103, 6854, 6187, 4805, 6851, 5747, 5885,
    5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439,
    5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 6111, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928,
    5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 7229, 4805, 6851, 5747, 5885, 5571, 5749,
    6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003,
    4994, 6128, 7455, 5968, 6854, 6187, 4805, 6141, 6206, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928,
    5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 6152, 7455, 5968, 6854, 7123, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321,
    6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917,
    7455, 6165, 6854, 6187, 5094, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331,
    5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5903, 5885, 5571, 5749, 6608, 7321, 6026, 7239,
    7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 6182, 6003, 4994, 5917, 7455, 5968,
    6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271,
    5626, 6199, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156,
    4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855,
    5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6214, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187,
    4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 4929, 6239, 6244, 6266, 6263, 6249, 4970, 5698, 5271, 5874, 6855,
    6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6541, 5158, 7178,
    5646, 6277, 6855, 6543, 6855, 6855, 6274, 6286, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851,
    5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6294, 6855, 5158, 6855, 6320, 6855, 6855, 6320, 6855, 6322, 6855, 6331, 5698, 5271, 6855, 6855, 6855, 6351,
    5700, 6855, 6855, 7450, 4994, 6349, 7455, 6359, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 6369, 4985,
    4984, 4982, 6855, 7499, 6388, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574,
    5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439,
    5353, 6670, 4994, 5917, 7455, 5968, 6854, 6187, 6400, 6851, 5747, 5885, 5571, 5749, 7138, 7321, 6417, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928,
    5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6439, 6458, 6478, 6950, 5968, 6854, 5567, 4805, 6851, 5747, 5885, 7127, 5749,
    6593, 6491, 6026, 6524, 6523, 6532, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6003,
    5533, 6478, 7455, 5968, 6854, 5567, 5408, 6851, 6407, 6117, 5571, 6409, 6120, 6551, 6559, 6643, 6642, 6562, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928,
    5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6003, 5533, 6478, 7455, 5968, 6144, 5567, 4805, 6851, 5888, 5885, 5571, 5749, 6593, 7321,
    6026, 7239, 7238, 6774, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 5896, 6445, 5960, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5559, 5700, 6570, 6578, 6003, 5533, 6478,
    7455, 5968, 6854, 5567, 4805, 6851, 5820, 6590, 5571, 5749, 6601, 7321, 6026, 7094, 7238, 5805, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 6651, 5356, 6659, 5927, 5928, 5928, 5928, 5928, 5936, 5331,
    5698, 6678, 5626, 6082, 6697, 5919, 5700, 5948, 5956, 6707, 5533, 6478, 7455, 5968, 6854, 6715, 4805, 6851, 6301, 6820, 6817, 6067, 6723, 6731, 6753, 6767,
    6757, 6759, 6791, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 7031, 5948, 5956, 6003, 5533, 6478, 7455, 5968,
    6802, 6813, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6828, 7239, 6832, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 7341, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271,
    7294, 6082, 6082, 5323, 5700, 5439, 5353, 6133, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 6840, 5984, 5571, 6848, 6593, 7321, 6026, 6907, 7238, 7156,
    4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855,
    5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 6478, 7455, 5968, 6854, 6187,
    4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 6864, 5698, 5271, 5626, 6082,
    6082, 5919, 5700, 5439, 5353, 6003, 6878, 6478, 5770, 5968, 6503, 6187, 4893, 6191, 5747, 5885, 5571, 6889, 6622, 7321, 6026, 7239, 7238, 6900, 4802, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356,
    5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 4976, 6917, 5439, 5353, 6003, 6931, 6943, 7455, 6961, 6969, 6187, 4805, 6851,
    5747, 5885, 6021, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 6979, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 6990, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919,
    5700, 6998, 7006, 6003, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6629, 7014, 6026, 6431, 6636, 7080, 4802, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927,
    5928, 5928, 5928, 5928, 5936, 5331, 7029, 5271, 7039, 6082, 6082, 5919, 7047, 5439, 5353, 6483, 4994, 6478, 5864, 5968, 6854, 6187, 4805, 6376, 5747, 5885,
    5973, 5749, 6615, 7073, 6026, 7088, 6427, 7156, 6538, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 7106, 6082, 5919, 5700, 5439,
    5353, 6003, 4994, 6478, 7309, 5968, 6854, 6187, 7116, 6851, 5747, 7135, 5571, 5749, 6593, 7146, 6026, 7239, 7154, 7098, 4802, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928,
    5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5616, 5439, 5353, 6003, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749,
    6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 7164, 6855, 7186, 6341, 7209, 7215, 7216, 7216, 7216, 7216, 7224, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003,
    4994, 6478, 7455, 5968, 6854, 6187, 4805, 6047, 5747, 6062, 5571, 5749, 6593, 7321, 7237, 6422, 7238, 7021, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 6870, 5356, 5911, 5927, 7247, 7252, 5928, 7254,
    5936, 5331, 5698, 5271, 7262, 6082, 6082, 6582, 5700, 7270, 5353, 6157, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 6465, 5749, 6593, 7321,
    6470, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 7278, 6478,
    7455, 5968, 6095, 6187, 5540, 6892, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 6909, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 7288,
    6923, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 7302, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 7317, 5571, 5749, 6593, 7321, 6026, 7239,
    7238, 6029, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    5896, 6855, 5940, 7353, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5431, 5700, 5439, 5353, 6003, 4994, 6478, 7455, 5968,
    6854, 6187, 4805, 6226, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 7436, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 7329,
    6380, 7337, 6082, 5525, 5700, 5439, 5353, 6003, 4994, 6478, 6008, 5968, 7349, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156,
    4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855,
    5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 7469, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 6478, 7455, 5968, 6854, 6187,
    4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 7361, 7366, 7388, 7385, 7371, 4970, 5698, 5271, 6855, 6855,
    6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7396,
    5646, 6805, 7422, 7416, 7424, 7424, 7432, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851,
    5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6337, 5158, 7178, 5646, 6855, 6855, 6855, 6855, 6855, 6855, 4970, 5698, 5271, 6855, 6855, 7059, 7444,
    5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855,
    6855, 6855, 6855, 6855, 7201, 5331, 5698, 5271, 6855, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 6042, 6854, 6187, 4805, 6851, 5747, 5885,
    5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6515, 6855, 7485, 7464, 7477, 7483, 5061, 5064, 5063, 7495, 6689, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
    6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 1621, 4610, 0, 0, 0, 0, 1626, 1621, 1621, 1621,
    1621, 0, 7773, 7773, 7773, 7773, 1621, 1621, 1621, 7773, 7773, 7773, 5748, 5748, 7773, 7773, 7773, 7773, 1621, 0, 0, 0, 0, 0, 1626, 1621, 0, 1626, 91, 0,
    7773, 94, 0, 0, 0, 155, 155, 0, 0, 0, 0, 12800, 0, 0, 0, 0, 4252, 0, 0, 0, 0, 18944, 0, 0, 18944, 0, 0, 6144, 0, 0, 0, 0, 0, 0, 243, 0, 0, 147, 0, 0, 0, 0,
    0, 200, 201, 0, 0, 0, 0, 0, 207, 208, 0, 242, 243, 243, 0, 0, 0, 208, 209, 0, 0, 243, 288, 0, 252, 0, 288, 288, 0, 252, 0, 243, 252, 294, 298, 252, 294,
    243, 252, 306, 243, 252, 294, 243, 252, 315, 243, 252, 294, 294, 294, 0, 0, 0, 0, 0, 0, 1255, 0, 1536, 4610, 0, 0, 0, 0, 1627, 1536, 1536, 1536, 1536, 0,
    7680, 7680, 7680, 7680, 1536, 1536, 1536, 7680, 7680, 7680, 5748, 5748, 7680, 7799, 7680, 7799, 7799, 7680, 7680, 7680, 7680, 7680, 7680, 1536, 5748, 7680,
    7799, 7799, 7680, 7799, 7799, 7680, 7799, 7799, 7799, 7799, 0, 0, 0, 0, 0, 124, 124, 0, 0, 124, 0, 124, 124, 0, 124, 7680, 7680, 7680, 7799, 7799, 7799,
    7799, 7799, 7799, 7799, 7799, 0, 91, 91, 0, 0, 73216, 0, 0, 0, 240, 241, 0, 1255, 0, 1621, 1621, 1621, 1621, 5120, 7773, 7773, 7773, 7773, 7773, 7773, 7773,
    7773, 1621, 5748, 0, 4610, 0, 0, 0, 0, 91, 0, 0, 178, 148, 103, 103, 0, 0, 0, 28672, 0, 0, 28672, 127, 94, 94, 94, 94, 101, 103, 0, 94, 94, 94, 94, 94, 94,
    94, 94, 0, 5748, 94, 94, 5748, 5748, 94, 94, 94, 94, 0, 0, 0, 0, 0, 142, 0, 0, 0, 91, 91, 0, 0, 94, 0, 0, 0, 1193, 0, 171, 0, 0, 0, 3704, 0, 0, 0, 0, 0, 0,
    0, 23040, 0, 147, 0, 0, 0, 0, 0, 0, 91, 12800, 0, 111, 5748, 5748, 0, 111, 0, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 0, 0, 0, 0, 0,
    171, 21504, 0, 0, 0, 5749, 5749, 0, 0, 0, 0, 0, 207, 0, 171, 124, 124, 0, 124, 0, 0, 0, 0, 0, 209, 0, 171, 0, 147, 0, 0, 0, 199, 0, 0, 0, 12288, 12288,
    12288, 12288, 12288, 12288, 12288, 12288, 13312, 13312, 0, 13312, 0, 0, 0, 0, 0, 13312, 13312, 0, 0, 13312, 0, 13312, 13312, 0, 13312, 0, 0, 13824, 0, 0, 0,
    0, 0, 0, 1255, 245, 0, 13824, 13824, 0, 0, 13824, 0, 13824, 13824, 0, 13824, 13824, 13824, 0, 13824, 0, 0, 0, 0, 0, 27136, 111, 112, 0, 112, 5748, 5748, 0,
    112, 0, 112, 112, 112, 112, 112, 112, 112, 112, 14336, 14336, 14336, 0, 0, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336,
    14336, 14336, 0, 0, 0, 0, 101, 103, 0, 0, 14848, 0, 0, 14848, 0, 0, 0, 0, 0, 5748, 14848, 0, 14848, 14848, 14848, 14848, 14848, 14848, 14848, 14848, 14848,
    14848, 14848, 14848, 0, 0, 0, 0, 101, 104, 0, 0, 0, 4610, 86, 0, 0, 0, 91, 0, 0, 192, 171, 171, 171, 0, 0, 0, 0, 0, 0, 200, 86, 0, 0, 0, 0, 0, 0, 0, 192,
    137, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 0, 0, 0, 0, 102, 103, 0, 0, 0, 91, 91, 0, 0, 94, 142, 0, 0, 223, 209, 0, 0, 0, 0, 0, 0, 6872, 0, 0,
    20622, 0, 0, 0, 0, 22528, 0, 35328, 0, 0, 0, 0, 0, 0, 111, 112, 138, 17408, 17408, 17408, 17408, 17408, 17408, 17408, 0, 0, 0, 0, 111, 0, 0, 5748, 0, 35840,
    0, 0, 0, 0, 0, 0, 111, 3072, 0, 18944, 0, 0, 0, 18944, 0, 0, 0, 13312, 0, 0, 13312, 0, 0, 18944, 0, 18944, 0, 0, 0, 1112, 0, 172, 0, 0, 1112, 91, 91, 0, 0,
    94, 0, 0, 0, 14336, 0, 0, 14336, 0, 0, 0, 6144, 182, 0, 0, 0, 3744, 1112, 0, 0, 0, 0, 0, 0, 1112, 1112, 0, 5748, 0, 147, 0, 0, 0, 0, 182, 0, 0, 223, 209, 0,
    0, 252, 0, 243, 243, 267, 0, 19456, 5748, 5748, 19456, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 23552, 0, 111, 112, 0, 19456, 19456, 19456, 19456, 0, 19456, 19456, 0,
    0, 0, 0, 0, 0, 1268, 0, 19456, 19456, 19456, 0, 0, 19456, 0, 19456, 19456, 0, 19456, 19456, 19456, 19456, 19456, 0, 0, 0, 1112, 0, 173, 0, 0, 0, 0, 6144, 0,
    0, 0, 0, 3744, 95, 95, 5748, 5748, 95, 95, 95, 95, 101, 103, 0, 95, 95, 95, 123, 95, 95, 123, 95, 123, 123, 20091, 20091, 123, 20091, 123, 20091, 123, 123,
    20091, 123, 0, 15872, 0, 0, 20063, 95, 123, 95, 95, 95, 95, 95, 95, 0, 5748, 95, 95, 95, 95, 20091, 123, 123, 20091, 1112, 0, 0, 4259, 0, 0, 0, 0, 112, 0,
    0, 5748, 0, 0, 6144, 4252, 4279, 0, 185, 3744, 1112, 0, 4259, 4260, 0, 0, 0, 1112, 0, 174, 0, 0, 0, 147, 0, 0, 0, 0, 4279, 0, 0, 239, 0, 0, 0, 1255, 0, 0,
    243, 243, 0, 0, 0, 208, 224, 0, 185, 1112, 0, 0, 0, 1112, 0, 171, 0, 175, 6873, 0, 1112, 0, 0, 0, 208, 209, 0, 0, 252, 0, 243, 243, 0, 208, 209, 252, 0,
    4610, 0, 20992, 0, 0, 91, 0, 0, 243, 243, 0, 0, 0, 223, 209, 0, 97, 97, 0, 97, 0, 0, 0, 0, 131, 132, 0, 0, 143, 0, 0, 0, 147, 147, 103, 103, 0, 180, 0,
    22016, 0, 0, 0, 0, 0, 0, 0, 3744, 0, 0, 5748, 5748, 0, 108, 109, 108, 0, 0, 109, 0, 0, 0, 5748, 5748, 0, 0, 0, 0, 0, 242, 243, 0, 109, 122, 122, 0, 125,
    126, 0, 122, 108, 125, 122, 128, 128, 128, 128, 128, 125, 126, 122, 122, 135, 135, 135, 122, 135, 122, 122, 135, 122, 128, 122, 122, 135, 135, 122, 135,
    125, 125, 139, 125, 0, 0, 0, 0, 147, 147, 103, 103, 0, 0, 0, 0, 23552, 0, 0, 171, 0, 0, 0, 0, 0, 6872, 0, 0, 26112, 0, 0, 0, 0, 0, 0, 119, 0, 110, 0, 0, 0,
    110, 0, 0, 0, 0, 110, 110, 110, 110, 0, 0, 28160, 0, 0, 243, 1255, 0, 0, 0, 208, 209, 0, 0, 0, 16384, 0, 17920, 0, 0, 26624, 16384, 17920, 0, 0, 0, 171, 0,
    0, 0, 214, 0, 0, 0, 110, 0, 0, 0, 5748, 5748, 0, 0, 97, 0, 0, 97, 0, 5748, 0, 133120, 0, 0, 0, 0, 0, 0, 136, 0, 25088, 252, 0, 243, 252, 294, 243, 252, 294,
    320, 294, 0, 4610, 0, 0, 87, 0, 91, 0, 0, 243, 1255, 0, 0, 0, 259, 0, 27648, 27648, 27648, 27648, 27648, 27648, 27648, 0, 0, 0, 0, 147, 147, 103, 15872, 0,
    162, 0, 0, 162, 165, 0, 0, 0, 27648, 0, 0, 0, 0, 5748, 0, 0, 24229, 0, 0, 171, 0, 0, 213, 0, 215, 0, 0, 0, 178, 0, 0, 0, 0, 0, 0, 159, 0, 0, 269, 208, 209,
    0, 0, 252, 0, 243, 1255, 0, 0, 0, 208, 0, 4610, 0, 0, 0, 1112, 91, 0, 0, 243, 1255, 0, 0, 258, 208, 0, 1112, 5748, 5748, 0, 1112, 0, 1112, 0, 0, 0, 1112, 0,
    171, 0, 0, 0, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 0, 0, 0, 1112, 101, 103, 0, 0, 0, 0, 6144, 0, 4279, 0, 0, 3744, 1112,
    0, 0, 4260, 0, 0, 0, 1112, 101, 103, 105, 0, 68096, 0, 1112, 0, 0, 0, 0, 208, 209, 0, 30208, 273, 0, 268, 0, 208, 209, 0, 0, 252, 0, 243, 1290, 0, 1112, 0,
    0, 4260, 0, 8704, 0, 1112, 0, 0, 9216, 1112, 0, 171, 171, 171, 171, 0, 0, 0, 0, 0, 217, 0, 68096, 0, 1112, 220, 0, 0, 0, 208, 209, 272, 0, 252, 0, 243, 252,
    294, 243, 252, 294, 294, 321, 1112, 187, 0, 4260, 187, 0, 0, 1112, 0, 0, 0, 0, 208, 209, 0, 250, 0, 0, 6873, 0, 1112, 0, 0, 234, 208, 209, 0, 0, 252, 264,
    243, 1255, 0, 0, 0, 278, 279, 31232, 1112, 0, 0, 4260, 0, 0, 189, 1112, 0, 0, 0, 0, 0, 0, 0, 208, 209, 246, 0, 208, 209, 0, 0, 0, 0, 0, 229, 0, 68096, 0,
    1112, 0, 0, 222, 0, 208, 243, 1255, 0, 277, 0, 208, 209, 0, 0, 252, 0, 254, 1268, 0, 208, 209, 252, 0, 1112, 204, 0, 0, 1112, 0, 171, 171, 171, 173, 0, 0,
    0, 247, 208, 209, 0, 0, 0, 0, 228, 0, 0, 0, 1112, 0, 206, 0, 1112, 0, 171, 171, 193, 171, 0, 0, 68096, 0, 1112, 0, 221, 0, 0, 208, 224, 0, 0, 0, 0, 0, 0, 0,
    171, 1112, 0, 0, 0, 188, 0, 0, 1112, 0, 0, 0, 208, 209, 0, 0, 251, 0, 1112, 0, 0, 0, 0, 0, 166, 0, 0, 243, 1255, 0, 257, 0, 208, 1112, 0, 0, 0, 0, 0, 167,
    0, 0, 243, 1255, 256, 0, 0, 208, 209, 30720, 0, 0, 0, 124, 0, 0, 124, 0, 127, 0, 127, 28672, 28672, 28672, 28672, 28672, 0, 127, 28799, 28799, 127, 28799,
    0, 0, 0, 0, 147, 147, 149, 150, 0, 0, 28672, 28799, 28799, 127, 127, 28799, 127, 28799, 28799, 127, 28799, 96, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 5749, 0, 91,
    91, 0, 0, 94, 0, 8192, 0, 4610, 0, 0, 0, 0, 9728, 0, 0, 243, 1279, 0, 0, 0, 208, 224, 0, 0, 252, 0, 243, 243, 0, 208, 224, 252, 0, 0, 29184, 0, 0, 0, 0, 0,
    0, 0, 7680, 0, 9728, 9728, 0, 0, 94, 0, 0, 0, 36864, 0, 0, 0, 0, 1113, 1113, 0, 5748, 201, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 201, 0, 0, 0, 0, 0, 208, 0, 171,
    0, 0, 5748, 29812, 0, 0, 3704, 0, 0, 248, 249, 0, 0, 0, 0, 157, 0, 0, 3744, 3704, 3704, 3704, 3704, 0, 0, 0, 0, 147, 28307, 103, 103, 0, 238, 0, 0, 0, 0,
    1255, 0, 0, 254, 1268, 0, 0, 0, 208, 209, 0, 0, 252, 0, 243, 296, 294, 243, 252, 294, 304, 252, 294, 243, 311, 294, 243, 252, 294, 243, 305, 294, 243, 1112,
    191, 171, 171, 171, 171, 0, 0, 92, 0, 0, 0, 0, 0, 0, 14848, 0, 0, 14848, 0, 147, 0, 0, 198, 0, 4279, 0, 0, 270, 271, 0, 0, 252, 0, 243, 252, 294, 243, 299,
    202, 1112, 0, 0, 0, 1112, 0, 171, 193, 171, 171, 0, 0, 0, 243, 1255, 0, 252, 291, 243, 243, 24576, 0, 25600, 208, 209, 0, 0, 0, 227, 0, 0, 0, 136, 0, 0,
    136, 0, 0, 0, 0, 0, 0, 12288, 0, 308, 294, 243, 252, 294, 243, 252, 294, 307, 316, 252, 294, 243, 252, 294, 294, 294, 300, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0,
    254, 1268, 0, 252, 0, 254, 254, 0, 252, 0, 254, 252, 294, 254, 252, 294, 294, 294, 0, 0, 6144, 0, 4279, 184, 0, 3744, 1210, 0, 0, 4260, 0, 0, 0, 1112, 170,
    171, 0, 0, 260, 0, 0, 252, 0, 243, 1255, 0, 208, 209, 252, 280, 0, 243, 1255, 0, 208, 209, 252, 0, 243, 1255, 284, 208, 209, 252, 0, 243, 1307, 0, 208, 209,
    252, 0, 282, 1255, 0, 208, 209, 252, 281, 243, 1255, 0, 10752, 10752, 252, 294, 310, 252, 294, 313, 252, 294, 254, 252, 294, 254, 252, 294, 254, 98, 0, 0,
    1112, 101, 103, 106, 98, 118, 1112, 5748, 5748, 118, 1112, 0, 1112, 0, 205, 0, 1112, 0, 171, 171, 171, 171, 194, 0, 151, 0, 153, 0, 0, 0, 111, 112, 112,
    112, 112, 0, 0, 0, 0, 0, 73216, 0, 0, 1192, 0, 0, 0, 0, 0, 0, 0, 208, 223, 32856, 0, 171, 171, 171, 171, 0, 32768, 6873, 0, 1255, 0, 0, 0, 235, 236, 263, 0,
    243, 1255, 0, 208, 209, 263, 0, 243, 1255, 0, 263, 0, 243, 243, 289, 252, 0, 243, 243, 0, 252, 0, 243, 243, 0, 223, 209, 252, 0, 263, 0, 243, 263, 297, 243,
    263, 297, 243, 263, 297, 297, 297, 297, 243, 302, 297, 243, 263, 297, 243, 252, 294, 243, 11264, 294, 294, 294, 12070, 0, 0, 0, 0, 0, 0, 3072, 112, 297,
    323, 297, 0, 0, 0, 0, 0, 0, 24229, 0, 209, 0, 226, 0, 0, 0, 0, 0, 0, 36352, 36352, 6873, 230, 1112, 0, 0, 0, 208, 209, 0, 0, 263, 0, 265, 1255, 0, 0, 293,
    0, 295, 252, 294, 243, 252, 312, 243, 252, 294, 0, 253, 243, 1255, 0, 0, 0, 208, 275, 1255, 0, 0, 0, 208, 209, 0, 0, 0, 0, 0, 0, 0, 0, 97, 1112, 91, 91,
    141, 0, 94, 0, 0, 100, 1112, 101, 103, 0, 107, 0, 147, 196, 0, 0, 0, 0, 0, 94, 94, 94, 243, 1300, 0, 0, 0, 208, 209, 0, 0, 0, 31744, 243, 317, 294, 243,
    252, 294, 294, 294, 301, 252, 294, 243, 252, 294, 243, 314, 294, 176, 0, 147, 147, 103, 103, 0, 0, 145, 0, 147, 147, 103, 103, 0, 147, 0, 197, 0, 0, 0, 0,
    148, 148, 103, 103, 202, 1112, 0, 0, 0, 1112, 210, 171, 0, 212, 0, 0, 0, 0, 0, 0, 13824, 0, 68096, 0, 1243, 0, 0, 0, 0, 208, 209, 225, 0, 0, 0, 0, 0, 0,
    208, 224, 322, 294, 294, 0, 0, 0, 0, 0, 95, 95, 95, 0, 1112, 5748, 5748, 0, 1112, 0, 1145, 181, 0, 6144, 0, 0, 0, 0, 3744, 1112, 0, 0, 0, 0, 0, 0, 1214,
    286, 243, 1255, 0, 252, 0, 243, 243, 252, 294, 10240, 252, 294, 294, 294, 0, 144, 0, 0, 147, 147, 103, 103, 179, 0, 32256, 0, 0, 0, 0, 158, 0, 3744, 0, 177,
    147, 147, 103, 103, 0, 0, 147, 0, 103, 103, 0, 0, 0, 16896, 0, 18432, 0, 0, 0, 24064, 0, 0, 111, 112, 0, 287, 1255, 0, 252, 0, 243, 243, 252, 318, 243, 252,
    294, 294, 294, 300, 243, 252, 294, 243, 273, 294, 243, 252, 303, 243, 252, 294, 243, 252, 319, 294, 294, 1185, 0, 0, 0, 0, 0, 0, 0, 209, 208, 237, 0, 0, 0,
    0, 0, 1255, 0, 0, 1112, 232, 0, 0, 208, 209, 0, 0, 252, 274, 209, 0, 262, 252, 0, 243, 1255, 0, 208, 209, 285, 0, 243, 1255, 0, 290, 0, 243, 292, 252, 309,
    243, 252, 294, 243, 252, 294, 294, 294, 0, 4610, 0, 0, 0, 1113, 91, 0, 0, 5748, 5748, 0, 0, 27648, 0, 0, 0, 0, 0, 0, 0, 5748, 0, 99, 0, 1113, 101, 103, 0,
    0, 147, 147, 138240, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 1112, 99, 1113, 5748, 5748, 99, 1113, 0, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113,
    1113, 1113, 0, 0, 0, 1112, 0, 233, 0, 208, 209, 0, 252, 294, 243, 252, 294, 243, 252, 294, 243, 1112, 1112, 1112, 1153, 1153, 1153, 1153, 1153, 1112, 1112,
    1112, 1112, 1112, 1112, 1112, 0, 33792, 0, 0, 0, 0, 0, 3744, 0, 34304, 6144, 0, 0, 0, 0, 3744, 195, 147, 0, 0, 0, 0, 0, 0, 223, 209, 1164, 91, 91, 0, 0, 94,
    0, 0, 154, 0, 0, 0, 0, 3744, 202, 1227, 0, 0, 0, 1112, 0, 171, 211, 0, 0, 0, 0, 0, 218, 209, 261, 0, 252, 0, 243, 1255, 0, 252, 0, 243, 243, 0, 152, 0, 0,
    0, 0, 111, 112, 1112, 0, 0, 164, 0, 0, 0, 0, 1112, 1112, 113, 5748, 209, 0, 0, 33280, 0, 0, 0, 0, 1112, 1112, 114, 5748, 34816, 0, 0, 130, 130, 130, 130,
    130, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 97, 0, 97, 97, 97, 97, 130, 0, 0, 34816, 34816, 0, 34816, 0, 0, 34816, 0, 0, 36352, 0, 0, 0, 0, 0, 5748, 5748, 0, 0,
    110, 0, 0, 0, 0, 0, 0, 133, 134, 36352, 36352, 36352, 0, 36352, 36352, 36352, 0, 36352, 36352, 36352, 36352, 36352, 36352, 36352, 36352, 36352, 36352,
    36352, 36352, 0, 0, 0, 0, 1112, 1112, 115, 5748, 16896, 18432, 0, 0, 0, 171, 0, 0, 171, 171, 171, 171, 0, 0, 0, 0, 0, 0, 0, 110, 12288, 0, 0, 0, 12288, 0,
    0, 0, 146, 147, 147, 103, 103, 0, 12288, 12288, 0, 12288, 12288, 0, 12288, 12288, 0, 0, 0, 0, 0, 0, 0, 223, 224, 12288, 12288, 12288, 12288, 0, 0, 0, 0,
    3704, 0, 3704, 3704
  "/>

  <!--~
   ! The DFA-state to expected-token-set mapping.
  -->
  <xsl:variable name="p:EXPECTED" as="xs:integer+" select="
    31, 39, 47, 204, 55, 63, 71, 86, 78, 94, 102, 110, 118, 126, 134, 141, 149, 164, 156, 172, 181, 189, 197, 230, 212, 220, 226, 173, 173, 173, 238, 241, 347,
    252, 261, 458, 279, 283, 293, 297, 301, 305, 309, 313, 317, 318, 322, 325, 329, 333, 337, 341, 345, 351, 264, 376, 577, 453, 575, 356, 534, 422, 384, 404,
    571, 456, 285, 354, 382, 389, 573, 576, 248, 388, 288, 393, 247, 402, 288, 273, 431, 289, 429, 419, 430, 275, 577, 408, 288, 577, 429, 287, 414, 430, 274,
    426, 427, 428, 426, 427, 428, 435, 436, 636, 563, 440, 592, 378, 446, 450, 462, 466, 470, 474, 478, 482, 486, 490, 494, 498, 502, 506, 510, 514, 523, 583,
    591, 562, 527, 531, 540, 577, 577, 544, 270, 536, 548, 552, 593, 577, 557, 577, 267, 578, 441, 561, 557, 577, 568, 584, 556, 577, 616, 598, 555, 590, 616,
    609, 604, 617, 610, 256, 577, 257, 582, 588, 616, 582, 588, 615, 597, 603, 256, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 517, 577, 397,
    599, 577, 614, 577, 577, 577, 628, 621, 622, 626, 365, 371, 368, 632, 372, 634, 577, 358, 415, 519, 605, 362, 410, 244, 577, 442, 577, 577, 577, 394, 577,
    564, 577, 577, 577, 577, 577, 395, 577, 577, 397, 577, 577, 577, 396, 577, 577, 398, 255, 577, 577, 577, 578, 4, 256, 1073741824, 0, 0, 196608, 0, 0,
    2097152, 4096, 4194304, 1073741828, 4, 4, 4, 0, 0, 0, 65536, 0, 16777728, 49152, 8404992, 16384, 16384, 16384, 32768, 0, 0, 229376, 0, 6144, 0, 0, 2097152,
    4194304, 524288, 524288, 12, 1073750020, 4, 2113536, 8404992, 268451840, 16384, 16384, 0, 0, 0, 1048576, 1048576, 0, 16418, 16386, 4, 7296, 12599296, 16418,
    7296, 7296, 12599296, 16434, 16448, 540722, 49216, 8405042, 8405042, 167788706, 8405042, 8405042, 436224162, 8601650, 402866210, 8405106, 75710514,
    403718178, -2012200926, 135282722, 135282722, 135282722, 8437874, 277037106, 176373938, 243482802, 411254834, 142819378, 511918258, 411254834, 511918258,
    511918258, 411254834, 511918258, -1743765470, 1048789170, 1048789170, 948125746, 948125810, 1048789170, 948125810, 1048789234, 1048822002, 1048789234,
    948125810, 1048822002, 4, 1073741824, 0, 2, 262148, 16777220, 2, 262148, 262144, 0, 8, 0, 0, 8, 8, 8192, 1073750016, 6272, 4194304, 16, 64, 8, 72, 72, 64,
    112, 64, 72, 64, 64, 64, 1048578, 0, -2147483648, 0, -2147483648, 4194304, 2097152, 4096, 4224, 4194304, 16, 64, 16, 16, 524290, 0, 0, 1048576, 0, 0, 0, 1,
    0, 0, 0, 2, 4096, 4194304, 524290, 0, 128, 128, 2097152, 4194304, 524290, 0, 16384, 128, 1048576, 0, 0, 2097152, 0, 0, 1048576, 1048576, 2097152, 0, 2048,
    4224, 2097152, 4194304, 524288, 2097152, 4194304, 524288, 524290, 0, 0, 2097152, 4194304, 4194304, 4194304, 0, 262144, 134217728, 0, 0, 0, 48, 0, 603979776,
    268435456, 16384, 0, 2097664, 1056768, -2147483648, 0, 0, 2, 0, 16384, 16384, 16384, 16386, -2147483136, 1073741824, 0, -2147483648, -2147483616, 16777216,
    33554432, -2147483616, -2147467264, 3154432, -2147467264, 3154432, -2147450848, -2147450720, -2139095008, -2146394080, -2147254144, -2139095008,
    -2147450720, -2147467200, -2144296416, -2147450720, -2139088896, -2139088896, -2139088895, -2139088892, -2139088888, -2139088864, -2139087872, -2122311680,
    -2144296416, -2147254080, -2139062112, -2139062112, -2147237696, -2147237760, -2147237696, -2139062112, -2147237696, -2139062096, -2139061600, -2146713408,
    -2139061584, -2122310611, -2136964942, -2136964446, -2144616254, -2145140030, -2136964430, -2144615742, -2135907678, -2135907678, -2135907662, -2143559454,
    -2135907662, 0, 128, 0, 0, 32, 32, 0, 4194304, 0, -2147483648, 4194304, 0, 0, 67108864, 536870912, 0, 16384, 8192, 8192, 0, 0, 1, 4, 1048576, 0, 0,
    1073741824, 32768, 128, 0, 40960, 8, 245760, 524288, 1, 12, 253952, -2147483648, 134217728, 268435456, 0, 67108864, 536870912, 0, 0, 268435456, -2147483648,
    0, 0, 0, 4, 0, 32768, 196608, 0, 65536, 131072, 1048578, 0, 16384, 0, 0, 0, 0, -2147483648, 131072, 0, 0, 134217728, 0, 0, 268435456, 67108864, 536870912,
    0, 0, 0, 512, 268435456, -2147483648, 65536, 131072, 0, 0, 0, 64, 268435456, 67108864, 0, 0, 0, 2048, 131072, 0, 0, 268435456, 0, 6, 0, 0, 0, 32768, 65536,
    131072, 64, 112, 112, 112, 112, 112, 0, 64, 64, 72, 0, 64, 72, 72, 64, 0, 0, 256, 4194304
  "/>

  <!--~
   ! The token-string table.
  -->
  <xsl:variable name="p:TOKEN" as="xs:string+" select="
    '%ERROR',
    'Name',
    'Space',
    'DirPIContents',
    'Number',
    'StringLiteral',
    'CaretName',
    'CharCode',
    'TokenIdentifier',
    'Blank',
    'Char',
    'CharRange',
    'CharCodeRange',
    'PragmaContents',
    'S',
    &quot;'\\'&quot;,
    &quot;'[VC'&quot;,
    &quot;'[WFC'&quot;,
    'NonRBrackedContents',
    'BeginOfGrammar',
    'Sem',
    'Semantic',
    'EndOfGrammar',
    'EOF',
    &quot;'&quot;&quot;'&quot;,
    &quot;'$'&quot;,
    &quot;'&amp;'&quot;,
    &quot;'('&quot;,
    &quot;')'&quot;,
    &quot;'*'&quot;,
    &quot;'*/'&quot;,
    &quot;'*&gt;'&quot;,
    &quot;'*}'&quot;,
    &quot;'+'&quot;,
    &quot;'+&gt;'&quot;,
    &quot;'+}'&quot;,
    &quot;'-'&quot;,
    &quot;'.'&quot;,
    &quot;'/'&quot;,
    &quot;'/*'&quot;,
    &quot;':'&quot;,
    &quot;'::='&quot;,
    &quot;';'&quot;,
    &quot;'&lt;*'&quot;,
    &quot;'&lt;+'&quot;,
    &quot;'&lt;&lt;'&quot;,
    &quot;'&lt;?'&quot;,
    &quot;'&lt;?ENCORE?&gt;'&quot;,
    &quot;'&lt;?TERMINALS?&gt;'&quot;,
    &quot;'&lt;?TOKENS?&gt;'&quot;,
    &quot;'='&quot;,
    &quot;'=&gt;'&quot;,
    &quot;'&gt;&gt;'&quot;,
    &quot;'?'&quot;,
    &quot;'?&gt;'&quot;,
    &quot;'['&quot;,
    &quot;']'&quot;,
    &quot;'^'&quot;,
    &quot;'definition'&quot;,
    &quot;'disallow'&quot;,
    &quot;'end_of_rule'&quot;,
    &quot;'explicit'&quot;,
    &quot;'gn'&quot;,
    &quot;'rule'&quot;,
    &quot;'syntax'&quot;,
    &quot;'ws'&quot;,
    &quot;'xgs'&quot;,
    &quot;'{'&quot;,
    &quot;'{*'&quot;,
    &quot;'{+'&quot;,
    &quot;'|'&quot;,
    &quot;'}'&quot;
  "/>

  <!--~
   ! Match next token in input string, starting at given index, using
   ! the DFA entry state for the set of tokens that are expected in
   ! the current context.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start in input string.
   ! @param $token-set the expected token set id.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:match" as="xs:integer+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="result" select="$p:INITIAL[1 + $token-set]"/>
    <xsl:sequence select="p:transition($input, $begin, $begin, $begin, $result, $result mod 512, 0)"/>
  </xsl:function>

  <!--~
   ! The DFA state transition function. If we are in a valid DFA state, save
   ! it's result annotation, consume one input codepoint, calculate the next
   ! state, and use tail recursion to do the same again. Otherwise, return
   ! any valid result or a negative DFA state id in case of an error.
   !
   ! @param $input the input string.
   ! @param $begin the begin index of the current token in the input string.
   ! @param $current the index of the current position in the input string.
   ! @param $end the end index of the result in the input string.
   ! @param $result the result code.
   ! @param $current-state the current DFA state.
   ! @param $previous-state the  previous DFA state.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:transition">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="current" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>
    <xsl:param name="result" as="xs:integer"/>
    <xsl:param name="current-state" as="xs:integer"/>
    <xsl:param name="previous-state" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$current-state eq 0">
        <xsl:variable name="result" select="$result idiv 512"/>
        <xsl:variable name="end" select="$end - $result idiv 128"/>
        <xsl:variable name="end" select="if ($end gt string-length($input)) then string-length($input) + 1 else $end"/>
        <xsl:sequence select="
          if ($result ne 0) then
          (
            $result mod 128 - 1,
            $begin,
            $end
          )
          else
          (
            - $previous-state,
            $begin,
            $current - 1
          )
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="c0" select="(string-to-codepoints(substring($input, $current, 1)), 0)[1]"/>
        <xsl:variable name="c1" as="xs:integer">
          <xsl:choose>
            <xsl:when test="$c0 &lt; 128">
              <xsl:sequence select="$p:MAP0[1 + $c0]"/>
            </xsl:when>
            <xsl:when test="$c0 &lt; 55296">
              <xsl:variable name="c1" select="$c0 idiv 8"/>
              <xsl:variable name="c2" select="$c1 idiv 32"/>
              <xsl:sequence select="$p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="p:map2($c0, 1, 2)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="current" select="$current + 1"/>
        <xsl:variable name="i0" select="512 * $c1 + $current-state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 8"/>
        <xsl:variable name="next-state" select="$p:TRANSITION[$i0 mod 8 + $p:TRANSITION[$i1 + 1] + 1]"/>
        <xsl:sequence select="
          if ($next-state &gt; 511) then
            p:transition($input, $begin, $current, $current, $next-state, $next-state mod 512, $current-state)
          else
            p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Recursively translate one 32-bit chunk of an expected token bitset
   ! to the corresponding sequence of token strings.
   !
   ! @param $result the result of previous recursion levels.
   ! @param $chunk the 32-bit chunk of the expected token bitset.
   ! @param $base-token-code the token code of bit 0 in the current chunk.
   ! @return the set of token strings.
  -->
  <xsl:function name="p:token">
    <xsl:param name="result" as="xs:string*"/>
    <xsl:param name="chunk" as="xs:integer"/>
    <xsl:param name="base-token-code" as="xs:integer"/>

    <xsl:sequence select="
      if ($chunk = 0) then
        $result
      else
        p:token
        (
          ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
          if ($chunk &lt; 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
          $base-token-code + 1
        )
    "/>
  </xsl:function>

  <!--~
   ! Calculate expected token set for a given DFA state as a sequence
   ! of strings.
   !
   ! @param $state the DFA state.
   ! @return the set of token strings
  -->
  <xsl:function name="p:expected-token-set" as="xs:string*">
    <xsl:param name="state" as="xs:integer"/>

    <xsl:if test="$state > 0">
      <xsl:for-each select="0 to 2">
        <xsl:variable name="i0" select=". * 323 + $state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 4"/>
        <xsl:variable name="i2" select="$i1 idiv 8"/>
        <xsl:sequence select="p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 8 + $p:EXPECTED[$i2 + 1] + 1] + 1], . * 32 + 1)"/>
      </xsl:for-each>
    </xsl:if>
  </xsl:function>

  <!--~
   ! Classify codepoint by doing a tail recursive binary search for a
   ! matching codepoint range entry in MAP2, the codepoint to charclass
   ! map for codepoints above the surrogate block.
   !
   ! @param $c the codepoint.
   ! @param $lo the binary search lower bound map index.
   ! @param $hi the binary search upper bound map index.
   ! @return the character class.
  -->
  <xsl:function name="p:map2" as="xs:integer">
    <xsl:param name="c" as="xs:integer"/>
    <xsl:param name="lo" as="xs:integer"/>
    <xsl:param name="hi" as="xs:integer"/>

    <xsl:variable name="m" select="($hi + $lo) idiv 2"/>
    <xsl:choose>
      <xsl:when test="$lo &gt; $hi">
        <xsl:sequence select="0"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[$m] &gt; $c">
        <xsl:sequence select="p:map2($c, $lo, $m - 1)"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[2 + $m] &lt; $c">
        <xsl:sequence select="p:map2($c, $m + 1, $hi)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$p:MAP2[4 + $m]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PhythiaItem.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaItem" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 43">                                        <!-- '<*' -->
          <xsl:variable name="state" select="p:consume(43, $input, $state)"/>       <!-- '<*' -->
          <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | ';' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(42, $input, $state)"/>       <!-- ';' -->
          <xsl:variable name="state" select="p:lookahead1W(52, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | '*>' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(31, $input, $state)"/>       <!-- '*>' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- '<+' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- '<+' -->
          <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | ';' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(42, $input, $state)"/>       <!-- ';' -->
          <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | '+>' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(34, $input, $state)"/>       <!-- '+>' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 68">                                        <!-- '{*' -->
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- '{*' -->
          <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | '*}' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(32, $input, $state)"/>       <!-- '*}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- '{+' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- '{+' -->
          <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | '+}' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(35, $input, $state)"/>       <!-- '+}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- '[' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- '[' -->
          <xsl:variable name="state" select="p:lookahead1W(58, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | '<*' | '<+' | '[' | ']' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(56, $input, $state)"/>       <!-- ']' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 27">                                        <!-- '(' -->
          <xsl:variable name="state" select="p:consume(27, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(51, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | Sem | '(' | ')' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(28, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- Sem -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- Sem -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Name($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PhythiaItem', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PhythiaSequence (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaSequence-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(72, $input, $state)"/>     <!-- Name^Token | StringLiteral | S | Sem | '(' | ')' | '*>' | '*}' | '+>' |
                                                                                         '+}' | '.' | ';' | '<*' | '<+' | '[' | ']' | 'rule' | '{*' | '{+' |
                                                                                         '|' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 28                                          (: ')' :)
                       or $state[$p:l1] = 31                                          (: '*>' :)
                       or $state[$p:l1] = 32                                          (: '*}' :)
                       or $state[$p:l1] = 34                                          (: '+>' :)
                       or $state[$p:l1] = 35                                          (: '+}' :)
                       or $state[$p:l1] = 37                                          (: '.' :)
                       or $state[$p:l1] = 42                                          (: ';' :)
                       or $state[$p:l1] = 56                                          (: ']' :)
                       or $state[$p:l1] = 70">                                      <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-PhythiaItem($input, $state)
            "/>
            <xsl:sequence select="p:parse-PhythiaSequence-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PhythiaSequence.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaSequence" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-PhythiaSequence-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PhythiaSequence', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PhythiaChoice (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaChoice-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 70">                                     <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(70, $input, $state)"/>     <!-- '|' -->
            <xsl:variable name="state" select="p:lookahead1W(72, $input, $state)"/> <!-- Name^Token | StringLiteral | S | Sem | '(' | ')' | '*>' | '*}' | '+>' |
                                                                                         '+}' | '.' | ';' | '<*' | '<+' | '[' | ']' | 'rule' | '{*' | '{+' |
                                                                                         '|' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-PhythiaSequence($input, $state)
            "/>
            <xsl:sequence select="p:parse-PhythiaChoice-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PhythiaChoice.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaChoice" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PhythiaSequence($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-PhythiaChoice-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PhythiaChoice', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PhythiaProduction.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaProduction" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(63, $input, $state)"/>             <!-- 'rule' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- Name^Token | S | 'rule' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Name($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(18, $input, $state)"/>         <!-- S | 'syntax' -->
    <xsl:variable name="state" select="p:consume(64, $input, $state)"/>             <!-- 'syntax' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- Name^Token | S | 'rule' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Name($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(15, $input, $state)"/>         <!-- S | '::=' -->
    <xsl:variable name="state" select="p:consume(41, $input, $state)"/>             <!-- '::=' -->
    <xsl:variable name="state" select="p:lookahead1W(56, $input, $state)"/>         <!-- Name^Token | StringLiteral | S | Sem | '(' | '.' | '<*' | '<+' | '[' |
                                                                                         'rule' | '{*' | '{+' | '|' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PhythiaChoice($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(37, $input, $state)"/>             <!-- '.' -->
    <xsl:variable name="state" select="p:lookahead1W(23, $input, $state)"/>         <!-- S | Semantic | 'end_of_rule' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 21">                                        <!-- Semantic -->
          <xsl:variable name="state" select="p:consume(21, $input, $state)"/>       <!-- Semantic -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/>         <!-- S | 'end_of_rule' -->
    <xsl:variable name="state" select="p:consume(60, $input, $state)"/>             <!-- 'end_of_rule' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- Name^Token | S | 'rule' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Name($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(36, $input, $state)"/>         <!-- S | EndOfGrammar | EOF | '.' | 'rule' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 37">                                        <!-- '.' -->
          <xsl:variable name="state" select="p:consume(37, $input, $state)"/>       <!-- '.' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PhythiaProduction', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PhythiaGrammar (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaGrammar-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S | 'rule' -->
        <xsl:variable name="state" select="p:whitespace($input, $state)"/>
        <xsl:variable name="state" select="
          if ($state[$p:error]) then
            $state
          else
            p:parse-PhythiaProduction($input, $state)
        "/>
        <xsl:variable name="state" select="p:lookahead1W(32, $input, $state)"/>     <!-- S | EndOfGrammar | EOF | 'rule' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 63">                                     <!-- 'rule' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-PhythiaGrammar-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PhythiaGrammar.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PhythiaGrammar" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 19">                                        <!-- BeginOfGrammar -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- BeginOfGrammar -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:parse-PhythiaGrammar-1($input, $state)"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 22">                                        <!-- EndOfGrammar -->
          <xsl:variable name="state" select="p:consume(22, $input, $state)"/>       <!-- EndOfGrammar -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PhythiaGrammar', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Delimiter (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Delimiter-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>     <!-- Name^Token | StringLiteral | S | 'rule' -->
        <xsl:variable name="state" select="p:whitespace($input, $state)"/>
        <xsl:variable name="state" select="
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameOrString($input, $state)
        "/>
        <xsl:variable name="state" select="p:lookahead1W(41, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<?ENCORE?>' |
                                                                                         'rule' -->
        <xsl:variable name="state" as="item()+">
          <xsl:choose>
            <xsl:when test="$state[$p:l1] eq 5">                                    <!-- StringLiteral -->
              <xsl:variable name="state" select="p:lookahead2W(49, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | S | EOF | '.' |
                                                                                           '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' | 'rule' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] eq 773">                            <!-- StringLiteral CaretName -->
                    <xsl:variable name="state" select="p:lookahead3W(44, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<<' |
                                                                                                 '<?ENCORE?>' | '>>' | 'rule' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = (1,                                       (: Name^Token :)
                                             63)">                                  <!-- 'rule' -->
              <xsl:variable name="state" select="p:lookahead2W(59, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | S |
                                                                                           DoubleBackslash | EOF | '.' | '::=' | '<<' | '<?ENCORE?>' | '>>' |
                                                                                           '?' | 'rule' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] = (769,                               (: Name^Token CaretName :)
                                                   831)">                           <!-- 'rule' CaretName -->
                    <xsl:variable name="state" select="p:lookahead3W(44, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<<' |
                                                                                                 '<?ENCORE?>' | '>>' | 'rule' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$state[$p:lk] = 4                                           (: Number :)
                       or $state[$p:lk] = 23                                          (: EOF :)
                       or $state[$p:lk] = 37                                          (: '.' :)
                       or $state[$p:lk] = 47                                          (: '&lt;?ENCORE?>' :)
                       or $state[$p:lk] = 1921                                        (: Name^Token DoubleBackslash :)
                       or $state[$p:lk] = 1983                                        (: 'rule' DoubleBackslash :)
                       or $state[$p:lk] = 5249                                        (: Name^Token '::=' :)
                       or $state[$p:lk] = 5253                                        (: StringLiteral '::=' :)
                       or $state[$p:lk] = 5311                                        (: 'rule' '::=' :)
                       or $state[$p:lk] = 5761                                        (: Name^Token '&lt;&lt;' :)
                       or $state[$p:lk] = 5765                                        (: StringLiteral '&lt;&lt;' :)
                       or $state[$p:lk] = 5823                                        (: 'rule' '&lt;&lt;' :)
                       or $state[$p:lk] = 6657                                        (: Name^Token '>>' :)
                       or $state[$p:lk] = 6661                                        (: StringLiteral '>>' :)
                       or $state[$p:lk] = 6719                                        (: 'rule' '>>' :)
                       or $state[$p:lk] = 6785                                        (: Name^Token '?' :)
                       or $state[$p:lk] = 6789                                        (: StringLiteral '?' :)
                       or $state[$p:lk] = 6847                                        (: 'rule' '?' :)
                       or $state[$p:lk] = 738049                                      (: Name^Token CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 738053                                      (: StringLiteral CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 738111                                      (: 'rule' CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 852737                                      (: Name^Token CaretName '>>' :)
                       or $state[$p:lk] = 852741                                      (: StringLiteral CaretName '>>' :)
                       or $state[$p:lk] = 852799">                                  <!-- 'rule' CaretName '>>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-Delimiter-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Delimiter.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Delimiter" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Name($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S | DoubleBackslash -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- DoubleBackslash -->
    <xsl:variable name="state" select="p:parse-Delimiter-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Delimiter', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Preference (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Preference-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>     <!-- Name^Token | StringLiteral | S | 'rule' -->
        <xsl:variable name="state" select="p:whitespace($input, $state)"/>
        <xsl:variable name="state" select="
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameOrString($input, $state)
        "/>
        <xsl:variable name="state" select="p:lookahead1W(41, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<?ENCORE?>' |
                                                                                         'rule' -->
        <xsl:variable name="state" as="item()+">
          <xsl:choose>
            <xsl:when test="$state[$p:l1] eq 5">                                    <!-- StringLiteral -->
              <xsl:variable name="state" select="p:lookahead2W(49, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | S | EOF | '.' |
                                                                                           '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' | 'rule' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] eq 773">                            <!-- StringLiteral CaretName -->
                    <xsl:variable name="state" select="p:lookahead3W(44, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<<' |
                                                                                                 '<?ENCORE?>' | '>>' | 'rule' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = (1,                                       (: Name^Token :)
                                             63)">                                  <!-- 'rule' -->
              <xsl:variable name="state" select="p:lookahead2W(59, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | S |
                                                                                           DoubleBackslash | EOF | '.' | '::=' | '<<' | '<?ENCORE?>' | '>>' |
                                                                                           '?' | 'rule' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] = (769,                               (: Name^Token CaretName :)
                                                   831)">                           <!-- 'rule' CaretName -->
                    <xsl:variable name="state" select="p:lookahead3W(44, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<<' |
                                                                                                 '<?ENCORE?>' | '>>' | 'rule' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$state[$p:lk] = 4                                           (: Number :)
                       or $state[$p:lk] = 23                                          (: EOF :)
                       or $state[$p:lk] = 37                                          (: '.' :)
                       or $state[$p:lk] = 47                                          (: '&lt;?ENCORE?>' :)
                       or $state[$p:lk] = 1921                                        (: Name^Token DoubleBackslash :)
                       or $state[$p:lk] = 1983                                        (: 'rule' DoubleBackslash :)
                       or $state[$p:lk] = 5249                                        (: Name^Token '::=' :)
                       or $state[$p:lk] = 5253                                        (: StringLiteral '::=' :)
                       or $state[$p:lk] = 5311                                        (: 'rule' '::=' :)
                       or $state[$p:lk] = 5761                                        (: Name^Token '&lt;&lt;' :)
                       or $state[$p:lk] = 5765                                        (: StringLiteral '&lt;&lt;' :)
                       or $state[$p:lk] = 5823                                        (: 'rule' '&lt;&lt;' :)
                       or $state[$p:lk] = 6657                                        (: Name^Token '>>' :)
                       or $state[$p:lk] = 6661                                        (: StringLiteral '>>' :)
                       or $state[$p:lk] = 6719                                        (: 'rule' '>>' :)
                       or $state[$p:lk] = 6785                                        (: Name^Token '?' :)
                       or $state[$p:lk] = 6789                                        (: StringLiteral '?' :)
                       or $state[$p:lk] = 6847                                        (: 'rule' '?' :)
                       or $state[$p:lk] = 738049                                      (: Name^Token CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 738053                                      (: StringLiteral CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 738111                                      (: 'rule' CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 852737                                      (: Name^Token CaretName '>>' :)
                       or $state[$p:lk] = 852741                                      (: StringLiteral CaretName '>>' :)
                       or $state[$p:lk] = 852799">                                  <!-- 'rule' CaretName '>>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-Preference-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 2nd loop of production Preference (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Preference-2">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>     <!-- Name^Token | StringLiteral | S | 'rule' -->
        <xsl:variable name="state" select="p:whitespace($input, $state)"/>
        <xsl:variable name="state" select="
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameOrString($input, $state)
        "/>
        <xsl:variable name="state" select="p:lookahead1W(41, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<?ENCORE?>' |
                                                                                         'rule' -->
        <xsl:variable name="state" as="item()+">
          <xsl:choose>
            <xsl:when test="$state[$p:l1] eq 5">                                    <!-- StringLiteral -->
              <xsl:variable name="state" select="p:lookahead2W(49, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | S | EOF | '.' |
                                                                                           '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' | 'rule' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] eq 773">                            <!-- StringLiteral CaretName -->
                    <xsl:variable name="state" select="p:lookahead3W(44, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<<' |
                                                                                                 '<?ENCORE?>' | '>>' | 'rule' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = (1,                                       (: Name^Token :)
                                             63)">                                  <!-- 'rule' -->
              <xsl:variable name="state" select="p:lookahead2W(59, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | S |
                                                                                           DoubleBackslash | EOF | '.' | '::=' | '<<' | '<?ENCORE?>' | '>>' |
                                                                                           '?' | 'rule' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] = (769,                               (: Name^Token CaretName :)
                                                   831)">                           <!-- 'rule' CaretName -->
                    <xsl:variable name="state" select="p:lookahead3W(44, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<<' |
                                                                                                 '<?ENCORE?>' | '>>' | 'rule' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$state[$p:lk] = 4                                           (: Number :)
                       or $state[$p:lk] = 23                                          (: EOF :)
                       or $state[$p:lk] = 37                                          (: '.' :)
                       or $state[$p:lk] = 47                                          (: '&lt;?ENCORE?>' :)
                       or $state[$p:lk] = 1921                                        (: Name^Token DoubleBackslash :)
                       or $state[$p:lk] = 1983                                        (: 'rule' DoubleBackslash :)
                       or $state[$p:lk] = 5249                                        (: Name^Token '::=' :)
                       or $state[$p:lk] = 5253                                        (: StringLiteral '::=' :)
                       or $state[$p:lk] = 5311                                        (: 'rule' '::=' :)
                       or $state[$p:lk] = 5761                                        (: Name^Token '&lt;&lt;' :)
                       or $state[$p:lk] = 5765                                        (: StringLiteral '&lt;&lt;' :)
                       or $state[$p:lk] = 5823                                        (: 'rule' '&lt;&lt;' :)
                       or $state[$p:lk] = 6657                                        (: Name^Token '>>' :)
                       or $state[$p:lk] = 6661                                        (: StringLiteral '>>' :)
                       or $state[$p:lk] = 6719                                        (: 'rule' '>>' :)
                       or $state[$p:lk] = 6785                                        (: Name^Token '?' :)
                       or $state[$p:lk] = 6789                                        (: StringLiteral '?' :)
                       or $state[$p:lk] = 6847                                        (: 'rule' '?' :)
                       or $state[$p:lk] = 738049                                      (: Name^Token CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 738053                                      (: StringLiteral CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 738111                                      (: 'rule' CaretName '&lt;&lt;' :)
                       or $state[$p:lk] = 852737                                      (: Name^Token CaretName '>>' :)
                       or $state[$p:lk] = 852741                                      (: StringLiteral CaretName '>>' :)
                       or $state[$p:lk] = 852799">                                  <!-- 'rule' CaretName '>>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-Preference-2($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Preference.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Preference" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-NameOrString($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(27, $input, $state)"/>         <!-- S | '<<' | '>>' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- '>>' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- '>>' -->
          <xsl:variable name="state" select="p:parse-Preference-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- '<<' -->
          <xsl:variable name="state" select="p:parse-Preference-2($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Preference', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production CharClass (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CharClass-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(31, $input, $state)"/>      <!-- CharCode | Char | CharRange | CharCodeRange -->
        <xsl:variable name="state" as="item()+">
          <xsl:choose>
            <xsl:when test="$state[$p:error]">
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = 10">                                    <!-- Char -->
              <xsl:variable name="state" select="p:consume(10, $input, $state)"/>   <!-- Char -->
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = 7">                                     <!-- CharCode -->
              <xsl:variable name="state" select="p:consume(7, $input, $state)"/>    <!-- CharCode -->
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = 11">                                    <!-- CharRange -->
              <xsl:variable name="state" select="p:consume(11, $input, $state)"/>   <!-- CharRange -->
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:variable name="state" select="p:consume(12, $input, $state)"/>   <!-- CharCodeRange -->
              <xsl:sequence select="$state"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="state" select="p:lookahead1(34, $input, $state)"/>      <!-- CharCode | Char | CharRange | CharCodeRange | ']' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 56">                                      <!-- ']' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-CharClass-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse CharClass.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CharClass" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(55, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1(35, $input, $state)"/>          <!-- CharCode | Char | CharRange | CharCodeRange | '^' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- '^' -->
          <xsl:variable name="state" select="p:consume(57, $input, $state)"/>       <!-- '^' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:parse-CharClass-1($input, $state)"/>
    <xsl:variable name="state" select="p:consume(56, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CharClass', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production LexicalChoice (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalChoice-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(25, $input, $state)"/>     <!-- S | ')' | '|' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 70">                                     <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(70, $input, $state)"/>     <!-- '|' -->
            <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/> <!-- Name^Token | StringLiteral | CharCode | S | '$' | '(' | ')' | '.' |
                                                                                         '[' | 'rule' | '|' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-LexicalSequence($input, $state)
            "/>
            <xsl:sequence select="p:parse-LexicalChoice-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse LexicalChoice.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalChoice" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-LexicalSequence($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-LexicalChoice-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LexicalChoice', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse LexicalPrimary.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalPrimary" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 27">                                        <!-- '(' -->
          <xsl:variable name="state" select="p:consume(27, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>   <!-- Name^Token | StringLiteral | CharCode | S | '$' | '(' | ')' | '.' |
                                                                                         '[' | 'rule' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-LexicalChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(28, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 25">                                        <!-- '$' -->
          <xsl:variable name="state" select="p:consume(25, $input, $state)"/>       <!-- '$' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 7">                                         <!-- CharCode -->
          <xsl:variable name="state" select="p:consume(7, $input, $state)"/>        <!-- CharCode -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- '[' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CharClass($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 37">                                  <!-- '.' -->
                <xsl:variable name="state" select="p:consume(37, $input, $state)"/> <!-- '.' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-Name($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LexicalPrimary', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse LexicalItem.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalItem" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-LexicalPrimary($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(73, $input, $state)"/>         <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                         '$' | '&' | '(' | ')' | '*' | '+' | '-' | '.' | '/*' | '<?ENCORE?>' |
                                                                                         '?' | '[' | 'rule' | '|' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 29                                            (: '*' :)
                     or $state[$p:l1] = 33                                            (: '+' :)
                     or $state[$p:l1] = 53">                                        <!-- '?' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 53">                                  <!-- '?' -->
                <xsl:variable name="state" select="p:consume(53, $input, $state)"/> <!-- '?' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 29">                                  <!-- '*' -->
                <xsl:variable name="state" select="p:consume(29, $input, $state)"/> <!-- '*' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(33, $input, $state)"/> <!-- '+' -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LexicalItem', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production LexicalSequence (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalSequence-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(66, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                         '$' | '&' | '(' | ')' | '.' | '/*' | '<?ENCORE?>' | '[' | 'rule' |
                                                                                         '|' -->
        <xsl:variable name="state" as="item()+">
          <xsl:choose>
            <xsl:when test="$state[$p:l1] eq 5">                                    <!-- StringLiteral -->
              <xsl:variable name="state" select="p:lookahead2W(79, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | CharCode | S | VC |
                                                                                           WFC | EOF | '$' | '&' | '(' | ')' | '*' | '+' | '.' | '/*' | '::=' |
                                                                                           '<<' | '<?ENCORE?>' | '>>' | '?' | '[' | 'rule' | '|' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] eq 6789">                           <!-- StringLiteral '?' -->
                    <xsl:variable name="state" select="p:lookahead3W(69, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC |
                                                                                                 EOF | '$' | '&' | '(' | ')' | '.' | '/*' | '::=' |
                                                                                                 '<?ENCORE?>' | '[' | 'rule' | '|' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] eq 37">                                   <!-- '.' -->
              <xsl:variable name="state" select="p:lookahead2W(74, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                           '$' | '&' | '(' | ')' | '*' | '+' | '.' | '/*' | '::=' |
                                                                                           '<?ENCORE?>' | '?' | '[' | 'rule' | '|' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] eq 6821">                           <!-- '.' '?' -->
                    <xsl:variable name="state" select="p:lookahead3W(69, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC |
                                                                                                 EOF | '$' | '&' | '(' | ')' | '.' | '/*' | '::=' |
                                                                                                 '<?ENCORE?>' | '[' | 'rule' | '|' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:when test="$state[$p:l1] = (1,                                       (: Name^Token :)
                                             63)">                                  <!-- 'rule' -->
              <xsl:variable name="state" select="p:lookahead2W(80, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | CharCode | S |
                                                                                           DoubleBackslash | VC | WFC | EOF | '$' | '&' | '(' | ')' | '*' |
                                                                                           '+' | '.' | '/*' | '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' | '[' |
                                                                                           'rule' | '|' -->
              <xsl:variable name="state" as="item()+">
                <xsl:choose>
                  <xsl:when test="$state[$p:lk] = (6785,                              (: Name^Token '?' :)
                                                   6847)">                          <!-- 'rule' '?' -->
                    <xsl:variable name="state" select="p:lookahead3W(69, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC |
                                                                                                 EOF | '$' | '&' | '(' | ')' | '.' | '/*' | '::=' |
                                                                                                 '<?ENCORE?>' | '[' | 'rule' | '|' -->
                    <xsl:sequence select="$state"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence select="$state"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$state[$p:lk] = 4                                           (: Number :)
                       or $state[$p:lk] = 16                                          (: VC :)
                       or $state[$p:lk] = 17                                          (: WFC :)
                       or $state[$p:lk] = 23                                          (: EOF :)
                       or $state[$p:lk] = 26                                          (: '&amp;' :)
                       or $state[$p:lk] = 28                                          (: ')' :)
                       or $state[$p:lk] = 39                                          (: '/*' :)
                       or $state[$p:lk] = 47                                          (: '&lt;?ENCORE?>' :)
                       or $state[$p:lk] = 70                                          (: '|' :)
                       or $state[$p:lk] = 769                                         (: Name^Token CaretName :)
                       or $state[$p:lk] = 773                                         (: StringLiteral CaretName :)
                       or $state[$p:lk] = 831                                         (: 'rule' CaretName :)
                       or $state[$p:lk] = 1921                                        (: Name^Token DoubleBackslash :)
                       or $state[$p:lk] = 1983                                        (: 'rule' DoubleBackslash :)
                       or $state[$p:lk] = 5249                                        (: Name^Token '::=' :)
                       or $state[$p:lk] = 5253                                        (: StringLiteral '::=' :)
                       or $state[$p:lk] = 5285                                        (: '.' '::=' :)
                       or $state[$p:lk] = 5311                                        (: 'rule' '::=' :)
                       or $state[$p:lk] = 5761                                        (: Name^Token '&lt;&lt;' :)
                       or $state[$p:lk] = 5765                                        (: StringLiteral '&lt;&lt;' :)
                       or $state[$p:lk] = 5823                                        (: 'rule' '&lt;&lt;' :)
                       or $state[$p:lk] = 6657                                        (: Name^Token '>>' :)
                       or $state[$p:lk] = 6661                                        (: StringLiteral '>>' :)
                       or $state[$p:lk] = 6719                                        (: 'rule' '>>' :)
                       or $state[$p:lk] = 678529                                      (: Name^Token '?' '::=' :)
                       or $state[$p:lk] = 678533                                      (: StringLiteral '?' '::=' :)
                       or $state[$p:lk] = 678565                                      (: '.' '?' '::=' :)
                       or $state[$p:lk] = 678591">                                  <!-- 'rule' '?' '::=' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-LexicalItem($input, $state)
            "/>
            <xsl:sequence select="p:parse-LexicalSequence-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse LexicalSequence.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalSequence" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 5">                                        <!-- StringLiteral -->
          <xsl:variable name="state" select="p:lookahead2W(81, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CaretName | CharCode | S | VC |
                                                                                         WFC | EOF | '$' | '&' | '(' | ')' | '*' | '+' | '-' | '.' | '/*' |
                                                                                         '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' | '[' | 'rule' | '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 6789">                               <!-- StringLiteral '?' -->
                <xsl:variable name="state" select="p:lookahead3W(71, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC |
                                                                                             EOF | '$' | '&' | '(' | ')' | '-' | '.' | '/*' | '::=' |
                                                                                             '<?ENCORE?>' | '[' | 'rule' | '|' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] eq 37">                                       <!-- '.' -->
          <xsl:variable name="state" select="p:lookahead2W(77, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                         '$' | '&' | '(' | ')' | '*' | '+' | '-' | '.' | '/*' | '::=' |
                                                                                         '<?ENCORE?>' | '?' | '[' | 'rule' | '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 6821">                               <!-- '.' '?' -->
                <xsl:variable name="state" select="p:lookahead3W(71, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC |
                                                                                             EOF | '$' | '&' | '(' | ')' | '-' | '.' | '/*' | '::=' |
                                                                                             '<?ENCORE?>' | '[' | 'rule' | '|' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (1,                                           (: Name^Token :)
                                         63)">                                      <!-- 'rule' -->
          <xsl:variable name="state" select="p:lookahead2W(83, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CaretName | CharCode | S |
                                                                                         DoubleBackslash | VC | WFC | EOF | '$' | '&' | '(' | ')' | '*' | '+' |
                                                                                         '-' | '.' | '/*' | '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' | '[' |
                                                                                         'rule' | '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] = (6785,                                  (: Name^Token '?' :)
                                               6847)">                              <!-- 'rule' '?' -->
                <xsl:variable name="state" select="p:lookahead3W(71, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC |
                                                                                             EOF | '$' | '&' | '(' | ')' | '-' | '.' | '/*' | '::=' |
                                                                                             '<?ENCORE?>' | '[' | 'rule' | '|' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 4                                             (: Number :)
                     or $state[$p:lk] = 16                                            (: VC :)
                     or $state[$p:lk] = 17                                            (: WFC :)
                     or $state[$p:lk] = 23                                            (: EOF :)
                     or $state[$p:lk] = 26                                            (: '&amp;' :)
                     or $state[$p:lk] = 28                                            (: ')' :)
                     or $state[$p:lk] = 39                                            (: '/*' :)
                     or $state[$p:lk] = 47                                            (: '&lt;?ENCORE?>' :)
                     or $state[$p:lk] = 70                                            (: '|' :)
                     or $state[$p:lk] = 769                                           (: Name^Token CaretName :)
                     or $state[$p:lk] = 773                                           (: StringLiteral CaretName :)
                     or $state[$p:lk] = 831                                           (: 'rule' CaretName :)
                     or $state[$p:lk] = 1921                                          (: Name^Token DoubleBackslash :)
                     or $state[$p:lk] = 1983                                          (: 'rule' DoubleBackslash :)
                     or $state[$p:lk] = 5249                                          (: Name^Token '::=' :)
                     or $state[$p:lk] = 5253                                          (: StringLiteral '::=' :)
                     or $state[$p:lk] = 5285                                          (: '.' '::=' :)
                     or $state[$p:lk] = 5311                                          (: 'rule' '::=' :)
                     or $state[$p:lk] = 5761                                          (: Name^Token '&lt;&lt;' :)
                     or $state[$p:lk] = 5765                                          (: StringLiteral '&lt;&lt;' :)
                     or $state[$p:lk] = 5823                                          (: 'rule' '&lt;&lt;' :)
                     or $state[$p:lk] = 6657                                          (: Name^Token '>>' :)
                     or $state[$p:lk] = 6661                                          (: StringLiteral '>>' :)
                     or $state[$p:lk] = 6719                                          (: 'rule' '>>' :)
                     or $state[$p:lk] = 678529                                        (: Name^Token '?' '::=' :)
                     or $state[$p:lk] = 678533                                        (: StringLiteral '?' '::=' :)
                     or $state[$p:lk] = 678565                                        (: '.' '?' '::=' :)
                     or $state[$p:lk] = 678591">                                    <!-- 'rule' '?' '::=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-LexicalItem($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(68, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                         '$' | '&' | '(' | ')' | '-' | '.' | '/*' | '<?ENCORE?>' | '[' |
                                                                                         'rule' | '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 36">                                  <!-- '-' -->
                <xsl:variable name="state" select="p:consume(36, $input, $state)"/> <!-- '-' -->
                <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/> <!-- Name^Token | StringLiteral | CharCode | S | '$' | '(' | '.' | '[' |
                                                                                             'rule' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-LexicalItem($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:parse-LexicalSequence-1($input, $state)"/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LexicalSequence', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ContextExpression (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextExpression-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(47, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '.' | '/*' |
                                                                                         '<?ENCORE?>' | 'rule' | '|' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 16                                         (: VC :)
                      and $state[$p:l1] != 17">                                     <!-- WFC -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Constraint($input, $state)
            "/>
            <xsl:sequence select="p:parse-ContextExpression-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ContextExpression.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextExpression" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-LexicalSequence($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(50, $input, $state)"/>         <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '&' | '.' |
                                                                                         '/*' | '<?ENCORE?>' | 'rule' | '|' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 26">                                        <!-- '&' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '&' -->
          <xsl:variable name="state" select="p:lookahead1W(61, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                         '$' | '(' | '.' | '/*' | '<?ENCORE?>' | '[' | 'rule' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-LexicalSequence($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:parse-ContextExpression-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ContextExpression', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ContextChoice (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextChoice-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 70">                                     <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(70, $input, $state)"/>     <!-- '|' -->
            <xsl:variable name="state" select="p:lookahead1W(62, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                         '$' | '&' | '(' | '.' | '/*' | '<?ENCORE?>' | '[' | 'rule' | '|' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ContextExpression($input, $state)
            "/>
            <xsl:sequence select="p:parse-ContextChoice-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ContextChoice.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextChoice" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ContextExpression($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ContextChoice-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ContextChoice', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production LexicalProduction (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalProduction-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '/*' |
                                                                                         '<?ENCORE?>' | 'rule' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 39">                                     <!-- '/*' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Option($input, $state)
            "/>
            <xsl:sequence select="p:parse-LexicalProduction-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse LexicalProduction.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LexicalProduction" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 4">                                         <!-- Number -->
          <xsl:variable name="state" select="p:consume(4, $input, $state)"/>        <!-- Number -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(33, $input, $state)"/>         <!-- Name^Token | StringLiteral | S | '.' | 'rule' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 37">                                        <!-- '.' -->
          <xsl:variable name="state" select="p:consume(37, $input, $state)"/>       <!-- '.' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Name($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(26, $input, $state)"/>         <!-- S | '::=' | '?' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(53, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(15, $input, $state)"/>         <!-- S | '::=' -->
    <xsl:variable name="state" select="p:consume(41, $input, $state)"/>             <!-- '::=' -->
    <xsl:variable name="state" select="p:lookahead1W(62, $input, $state)"/>         <!-- Name^Token | Number | StringLiteral | CharCode | S | VC | WFC | EOF |
                                                                                         '$' | '&' | '(' | '.' | '/*' | '<?ENCORE?>' | '[' | 'rule' | '|' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ContextChoice($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-LexicalProduction-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LexicalProduction', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Option (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Option-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(30, $input, $state)"/>      <!-- Space | 'gn' | 'ws' | 'xgs' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-Option-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 2nd loop of production Option (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Option-2">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(22, $input, $state)"/>      <!-- Space | 'definition' | 'explicit' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-Option-2($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 3rd loop of production Option (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Option-3">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(8, $input, $state)"/>       <!-- Space | '*/' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-Option-3($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 4th loop of production Option (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Option-4">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(21, $input, $state)"/>      <!-- Space | PragmaContents | '*/' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-Option-4($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 5th loop of production Option (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Option-5">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(21, $input, $state)"/>      <!-- Space | PragmaContents | '*/' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-Option-5($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Option.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Option" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(39, $input, $state)"/>             <!-- '/*' -->
    <xsl:variable name="state" select="p:parse-Option-1($input, $state)"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'ws' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'ws' -->
          <xsl:variable name="state" select="p:lookahead1(3, $input, $state)"/>     <!-- ':' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- ':' -->
          <xsl:variable name="state" select="p:parse-Option-2($input, $state)"/>
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 61">                                  <!-- 'explicit' -->
                <xsl:variable name="state" select="p:consume(61, $input, $state)"/> <!-- 'explicit' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(58, $input, $state)"/> <!-- 'definition' -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:variable name="state" select="p:parse-Option-3($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 62">                                        <!-- 'gn' -->
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'gn' -->
          <xsl:variable name="state" select="p:lookahead1(3, $input, $state)"/>     <!-- ':' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- ':' -->
          <xsl:variable name="state" select="p:parse-Option-4($input, $state)"/>
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 13">                                  <!-- PragmaContents -->
                <xsl:variable name="state" select="p:consume(13, $input, $state)"/> <!-- PragmaContents -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(66, $input, $state)"/>       <!-- 'xgs' -->
          <xsl:variable name="state" select="p:lookahead1(3, $input, $state)"/>     <!-- ':' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- ':' -->
          <xsl:variable name="state" select="p:parse-Option-5($input, $state)"/>
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 13">                                  <!-- PragmaContents -->
                <xsl:variable name="state" select="p:consume(13, $input, $state)"/> <!-- PragmaContents -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1(2, $input, $state)"/>           <!-- '*/' -->
    <xsl:variable name="state" select="p:consume(30, $input, $state)"/>             <!-- '*/' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Option', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Constraint (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Constraint-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(6, $input, $state)"/>       <!-- Space | NonRBrackedContents -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-Constraint-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 2nd loop of production Constraint (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Constraint-2">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(6, $input, $state)"/>       <!-- Space | NonRBrackedContents -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-Constraint-2($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Constraint.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Constraint" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- VC -->
          <xsl:variable name="state" select="p:consume(16, $input, $state)"/>       <!-- VC -->
          <xsl:variable name="state" select="p:lookahead1(3, $input, $state)"/>     <!-- ':' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- ':' -->
          <xsl:variable name="state" select="p:parse-Constraint-1($input, $state)"/>
          <xsl:variable name="state" select="p:consume(18, $input, $state)"/>       <!-- NonRBrackedContents -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- WFC -->
          <xsl:variable name="state" select="p:lookahead1(3, $input, $state)"/>     <!-- ':' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- ':' -->
          <xsl:variable name="state" select="p:parse-Constraint-2($input, $state)"/>
          <xsl:variable name="state" select="p:consume(18, $input, $state)"/>       <!-- NonRBrackedContents -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Constraint', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production DisAllow (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DisAllow-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(10, $input, $state)"/>      <!-- Space | 'disallow' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-DisAllow-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 2nd loop of production DisAllow (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DisAllow-2">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(9, $input, $state)"/>       <!-- Space | '=' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-DisAllow-2($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 3rd loop of production DisAllow (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DisAllow-3">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(7, $input, $state)"/>       <!-- Space | '"' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-DisAllow-3($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 4th loop of production DisAllow (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DisAllow-4">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(12, $input, $state)"/>      <!-- Blank | '"' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 9">                                      <!-- Blank -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(9, $input, $state)"/>      <!-- Blank -->
            <xsl:variable name="state" select="p:lookahead1(1, $input, $state)"/>   <!-- TokenIdentifier -->
            <xsl:variable name="state" select="p:consume(8, $input, $state)"/>      <!-- TokenIdentifier -->
            <xsl:sequence select="p:parse-DisAllow-4($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 5th loop of production DisAllow (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DisAllow-5">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(11, $input, $state)"/>      <!-- Space | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(2, $input, $state)"/>      <!-- Space -->
            <xsl:sequence select="p:parse-DisAllow-5($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse DisAllow.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DisAllow" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- '{' -->
    <xsl:variable name="state" select="p:parse-DisAllow-1($input, $state)"/>
    <xsl:variable name="state" select="p:consume(59, $input, $state)"/>             <!-- 'disallow' -->
    <xsl:variable name="state" select="p:parse-DisAllow-2($input, $state)"/>
    <xsl:variable name="state" select="p:consume(50, $input, $state)"/>             <!-- '=' -->
    <xsl:variable name="state" select="p:parse-DisAllow-3($input, $state)"/>
    <xsl:variable name="state" select="p:consume(24, $input, $state)"/>             <!-- '"' -->
    <xsl:variable name="state" select="p:lookahead1(1, $input, $state)"/>           <!-- TokenIdentifier -->
    <xsl:variable name="state" select="p:consume(8, $input, $state)"/>              <!-- TokenIdentifier -->
    <xsl:variable name="state" select="p:parse-DisAllow-4($input, $state)"/>
    <xsl:variable name="state" select="p:consume(24, $input, $state)"/>             <!-- '"' -->
    <xsl:variable name="state" select="p:parse-DisAllow-5($input, $state)"/>
    <xsl:variable name="state" select="p:consume(71, $input, $state)"/>             <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'DisAllow', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Context.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Context" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(6, $input, $state)"/>              <!-- CaretName -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Context', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NameOrString.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NameOrString" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:variable name="state" select="p:lookahead1W(82, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CaretName | S | VC | WFC | EOF |
                                                                                         '(' | ')' | '*' | '+' | '.' | '/' | '/*' | '<<' | '<?' | '<?ENCORE?>' |
                                                                                         '<?TERMINALS?>' | '<?TOKENS?>' | '=>' | '>>' | '?' | 'rule' | '{' |
                                                                                         '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 6">                                   <!-- CaretName -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-Context($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Name($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(82, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CaretName | S | VC | WFC | EOF |
                                                                                         '(' | ')' | '*' | '+' | '.' | '/' | '/*' | '<<' | '<?' | '<?ENCORE?>' |
                                                                                         '<?TERMINALS?>' | '<?TOKENS?>' | '=>' | '>>' | '?' | 'rule' | '{' |
                                                                                         '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 6">                                   <!-- CaretName -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-Context($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NameOrString', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SyntaxPrimary.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxPrimary" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 27">                                        <!-- '(' -->
          <xsl:variable name="state" select="p:consume(27, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(48, $input, $state)"/>   <!-- Name^Token | StringLiteral | S | VC | WFC | '(' | ')' | '/' | '<?' |
                                                                                         'rule' | '{' | '|' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SyntaxChoice($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(28, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 46">                                        <!-- '<?' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ProcessingInstruction($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- '{' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-DisAllow($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NameOrString($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SyntaxPrimary', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SyntaxItem.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxItem" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SyntaxPrimary($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(75, $input, $state)"/>         <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '(' | ')' |
                                                                                         '*' | '+' | '/' | '/*' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' |
                                                                                         '<?TOKENS?>' | '=>' | '?' | 'rule' | '{' | '|' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 29                                            (: '*' :)
                     or $state[$p:l1] = 33                                            (: '+' :)
                     or $state[$p:l1] = 53">                                        <!-- '?' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 53">                                  <!-- '?' -->
                <xsl:variable name="state" select="p:consume(53, $input, $state)"/> <!-- '?' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 29">                                  <!-- '*' -->
                <xsl:variable name="state" select="p:consume(29, $input, $state)"/> <!-- '*' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(33, $input, $state)"/> <!-- '+' -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SyntaxItem', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SyntaxSequence (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxSequence-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(67, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '(' | ')' |
                                                                                         '/' | '/*' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' |
                                                                                         'rule' | '{' | '|' -->
        <xsl:variable name="state" as="item()+">
          <xsl:choose>
            <xsl:when test="$state[$p:l1] = (1,                                       (: Name^Token :)
                                             5,                                       (: StringLiteral :)
                                             63)">                                  <!-- 'rule' -->
              <xsl:variable name="state" select="p:lookahead2W(76, $input, $state)"/> <!-- Name^Token | Number | StringLiteral | CaretName | S | VC | WFC |
                                                                                           EOF | '(' | ')' | '*' | '+' | '/' | '/*' | '::=' | '<?' |
                                                                                           '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' | '?' | 'rule' | '{' |
                                                                                           '|' -->
              <xsl:sequence select="$state"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$state[$p:lk] = 4                                           (: Number :)
                       or $state[$p:lk] = 16                                          (: VC :)
                       or $state[$p:lk] = 17                                          (: WFC :)
                       or $state[$p:lk] = 23                                          (: EOF :)
                       or $state[$p:lk] = 28                                          (: ')' :)
                       or $state[$p:lk] = 38                                          (: '/' :)
                       or $state[$p:lk] = 39                                          (: '/*' :)
                       or $state[$p:lk] = 47                                          (: '&lt;?ENCORE?>' :)
                       or $state[$p:lk] = 48                                          (: '&lt;?TERMINALS?>' :)
                       or $state[$p:lk] = 49                                          (: '&lt;?TOKENS?>' :)
                       or $state[$p:lk] = 70                                          (: '|' :)
                       or $state[$p:lk] = 5249                                        (: Name^Token '::=' :)
                       or $state[$p:lk] = 5253                                        (: StringLiteral '::=' :)
                       or $state[$p:lk] = 5311">                                    <!-- 'rule' '::=' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SyntaxItem($input, $state)
            "/>
            <xsl:sequence select="p:parse-SyntaxSequence-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 2nd loop of production SyntaxSequence (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxSequence-2">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(60, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | ')' | '/' |
                                                                                         '/*' | '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' | '|' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 16                                         (: VC :)
                      and $state[$p:l1] != 17">                                     <!-- WFC -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Constraint($input, $state)
            "/>
            <xsl:sequence select="p:parse-SyntaxSequence-2($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SyntaxSequence.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxSequence" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (1,                                           (: Name^Token :)
                                         5,                                           (: StringLiteral :)
                                         63)">                                      <!-- 'rule' -->
          <xsl:variable name="state" select="p:lookahead2W(78, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | CaretName | S | VC | WFC | EOF |
                                                                                         '(' | ')' | '*' | '+' | '/' | '/*' | '::=' | '<?' | '<?ENCORE?>' |
                                                                                         '<?TERMINALS?>' | '<?TOKENS?>' | '=>' | '?' | 'rule' | '{' | '|' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] != 4                                            (: Number :)
                    and $state[$p:lk] != 16                                           (: VC :)
                    and $state[$p:lk] != 17                                           (: WFC :)
                    and $state[$p:lk] != 23                                           (: EOF :)
                    and $state[$p:lk] != 28                                           (: ')' :)
                    and $state[$p:lk] != 38                                           (: '/' :)
                    and $state[$p:lk] != 39                                           (: '/*' :)
                    and $state[$p:lk] != 47                                           (: '&lt;?ENCORE?>' :)
                    and $state[$p:lk] != 48                                           (: '&lt;?TERMINALS?>' :)
                    and $state[$p:lk] != 49                                           (: '&lt;?TOKENS?>' :)
                    and $state[$p:lk] != 70                                           (: '|' :)
                    and $state[$p:lk] != 5249                                         (: Name^Token '::=' :)
                    and $state[$p:lk] != 5253                                         (: StringLiteral '::=' :)
                    and $state[$p:lk] != 5311">                                     <!-- 'rule' '::=' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SyntaxItem($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(70, $input, $state)"/>   <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '(' | ')' |
                                                                                         '/' | '/*' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' |
                                                                                         '=>' | 'rule' | '{' | '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 51">                                  <!-- '=>' -->
                <xsl:variable name="state" select="p:consume(51, $input, $state)"/> <!-- '=>' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:variable name="state" select="p:parse-SyntaxSequence-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:parse-SyntaxSequence-2($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SyntaxSequence', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SyntaxChoice (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxChoice-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:consume(70, $input, $state)"/>         <!-- '|' -->
        <xsl:variable name="state" select="p:lookahead1W(64, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '(' | ')' |
                                                                                         '/*' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' |
                                                                                         '{' | '|' -->
        <xsl:variable name="state" select="p:whitespace($input, $state)"/>
        <xsl:variable name="state" select="
          if ($state[$p:error]) then
            $state
          else
            p:parse-SyntaxSequence($input, $state)
        "/>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 70">                                     <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-SyntaxChoice-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 2nd loop of production SyntaxChoice (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxChoice-2">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:consume(38, $input, $state)"/>         <!-- '/' -->
        <xsl:variable name="state" select="p:lookahead1W(63, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '(' | ')' |
                                                                                         '/' | '/*' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' |
                                                                                         'rule' | '{' -->
        <xsl:variable name="state" select="p:whitespace($input, $state)"/>
        <xsl:variable name="state" select="
          if ($state[$p:error]) then
            $state
          else
            p:parse-SyntaxSequence($input, $state)
        "/>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 38">                                     <!-- '/' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-SyntaxChoice-2($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SyntaxChoice.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxChoice" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SyntaxSequence($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 38                                            (: '/' :)
                     or $state[$p:l1] = 70">                                        <!-- '|' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 70">                                  <!-- '|' -->
                <xsl:variable name="state" select="p:parse-SyntaxChoice-1($input, $state)"/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:parse-SyntaxChoice-2($input, $state)"/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SyntaxChoice', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SyntaxProduction (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxProduction-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | EOF | '/*' | '<?ENCORE?>' |
                                                                                         '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 39">                                     <!-- '/*' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Option($input, $state)
            "/>
            <xsl:sequence select="p:parse-SyntaxProduction-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SyntaxProduction.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SyntaxProduction" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 4">                                         <!-- Number -->
          <xsl:variable name="state" select="p:consume(4, $input, $state)"/>        <!-- Number -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>         <!-- Name^Token | StringLiteral | S | 'rule' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Name($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(15, $input, $state)"/>         <!-- S | '::=' -->
    <xsl:variable name="state" select="p:consume(41, $input, $state)"/>             <!-- '::=' -->
    <xsl:variable name="state" select="p:lookahead1W(65, $input, $state)"/>         <!-- Name^Token | Number | StringLiteral | S | VC | WFC | EOF | '(' | '/' |
                                                                                         '/*' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' |
                                                                                         '{' | '|' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SyntaxChoice($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SyntaxProduction-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SyntaxProduction', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Name.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Name" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1(5, $input, $state)"/>           <!-- Name^Token | 'rule' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 63">                                        <!-- 'rule' -->
          <xsl:variable name="state" select="p:consume(63, $input, $state)"/>       <!-- 'rule' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(1, $input, $state)"/>        <!-- Name^Token -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Name', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ProcessingInstruction (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ProcessingInstruction-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(0, $input, $state)"/>       <!-- Space -->
        <xsl:variable name="state" select="p:consume(2, $input, $state)"/>          <!-- Space -->
        <xsl:variable name="state" select="p:lookahead1(20, $input, $state)"/>      <!-- Space | DirPIContents | '?>' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 2">                                      <!-- Space -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-ProcessingInstruction-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ProcessingInstruction.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ProcessingInstruction" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(46, $input, $state)"/>             <!-- '<?' -->
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Name($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ProcessingInstruction-1($input, $state)"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 3">                                         <!-- DirPIContents -->
          <xsl:variable name="state" select="p:consume(3, $input, $state)"/>        <!-- DirPIContents -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1(4, $input, $state)"/>           <!-- '?>' -->
    <xsl:variable name="state" select="p:consume(54, $input, $state)"/>             <!-- '?>' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ProcessingInstruction', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production W3CGrammar (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-W3CGrammar-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(37, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | '<?' | 'rule' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 46">                                     <!-- '<?' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ProcessingInstruction($input, $state)
            "/>
            <xsl:sequence select="p:parse-W3CGrammar-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 2nd loop of production W3CGrammar (one or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-W3CGrammar-2">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:whitespace($input, $state)"/>
        <xsl:variable name="state" select="
          if ($state[$p:error]) then
            $state
          else
            p:parse-SyntaxProduction($input, $state)
        "/>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 1                                          (: Name^Token :)
                      and $state[$p:l1] != 4                                          (: Number :)
                      and $state[$p:l1] != 5                                          (: StringLiteral :)
                      and $state[$p:l1] != 63">                                     <!-- 'rule' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="p:parse-W3CGrammar-2($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 3rd loop of production W3CGrammar (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-W3CGrammar-3">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(41, $input, $state)"/>     <!-- Name^Token | Number | StringLiteral | S | EOF | '.' | '<?ENCORE?>' |
                                                                                         'rule' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 23                                          (: EOF :)
                       or $state[$p:l1] = 47">                                      <!-- '<?ENCORE?>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:l1] eq 5">                                <!-- StringLiteral -->
                  <xsl:variable name="state" select="p:lookahead2W(38, $input, $state)"/> <!-- CaretName | S | '::=' | '<<' | '>>' | '?' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = (1,                                   (: Name^Token :)
                                                 63)">                              <!-- 'rule' -->
                  <xsl:variable name="state" select="p:lookahead2W(40, $input, $state)"/> <!-- CaretName | S | DoubleBackslash | '::=' | '<<' | '>>' | '?' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:lk] = 4                                     (: Number :)
                             or $state[$p:lk] = 37                                    (: '.' :)
                             or $state[$p:lk] = 5249                                  (: Name^Token '::=' :)
                             or $state[$p:lk] = 5253                                  (: StringLiteral '::=' :)
                             or $state[$p:lk] = 5311                                  (: 'rule' '::=' :)
                             or $state[$p:lk] = 6785                                  (: Name^Token '?' :)
                             or $state[$p:lk] = 6789                                  (: StringLiteral '?' :)
                             or $state[$p:lk] = 6847">                              <!-- 'rule' '?' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-LexicalProduction($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:lk] = 1921                                  (: Name^Token DoubleBackslash :)
                             or $state[$p:lk] = 1983">                              <!-- 'rule' DoubleBackslash -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Delimiter($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Preference($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-W3CGrammar-3($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse the 4th loop of production W3CGrammar (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-W3CGrammar-4">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(24, $input, $state)"/>     <!-- S | EOF | '<?' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 46">                                     <!-- '<?' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ProcessingInstruction($input, $state)
            "/>
            <xsl:sequence select="p:parse-W3CGrammar-4($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse W3CGrammar.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-W3CGrammar" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-W3CGrammar-1($input, $state)"/>
    <xsl:variable name="state" select="p:parse-W3CGrammar-2($input, $state)"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48                                            (: '&lt;?TERMINALS?>' :)
                     or $state[$p:l1] = 49">                                        <!-- '<?TOKENS?>' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 48">                                  <!-- '<?TERMINALS?>' -->
                <xsl:variable name="state" select="p:consume(48, $input, $state)"/> <!-- '<?TERMINALS?>' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(49, $input, $state)"/> <!-- '<?TOKENS?>' -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:variable name="state" select="p:parse-W3CGrammar-3($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 47">                                        <!-- '<?ENCORE?>' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- '<?ENCORE?>' -->
          <xsl:variable name="state" select="p:parse-W3CGrammar-4($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'W3CGrammar', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Grammar.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Grammar" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1W(39, $input, $state)"/>         <!-- Name^Token | Number | StringLiteral | S | BeginOfGrammar | '<?' |
                                                                                         'rule' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 63">                                       <!-- 'rule' -->
          <xsl:variable name="state" select="p:lookahead2W(29, $input, $state)"/>   <!-- Name^Token | S | '::=' | 'rule' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 19                                            (: BeginOfGrammar :)
                     or $state[$p:lk] = 191                                           (: 'rule' Name^Token :)
                     or $state[$p:lk] = 8127">                                      <!-- 'rule' 'rule' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PhythiaGrammar($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(14, $input, $state)"/>   <!-- S | EOF -->
          <xsl:variable name="state" select="p:consume(23, $input, $state)"/>       <!-- EOF -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-W3CGrammar($input, $state)
          "/>
          <xsl:variable name="state" select="p:consume(23, $input, $state)"/>       <!-- EOF -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Grammar', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Create a textual error message from a parsing error.
   !
   ! @param $input the input string.
   ! @param $error the parsing error descriptor.
   ! @return the error message.
  -->
  <xsl:function name="p:error-message" as="xs:string">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="error" as="element(error)"/>

    <xsl:variable name="begin" select="xs:integer($error/@b)"/>
    <xsl:variable name="context" select="string-to-codepoints(substring($input, 1, $begin - 1))"/>
    <xsl:variable name="linefeeds" select="index-of($context, 10)"/>
    <xsl:variable name="line" select="count($linefeeds) + 1"/>
    <xsl:variable name="column" select="($begin - $linefeeds[last()], $begin)[1]"/>
    <xsl:variable name="expected" select="if ($error/@x or $error/@ambiguous-input) then () else p:expected-token-set($error/@s)"/>
    <xsl:sequence select="
      string-join
      (
        (
          if ($error/@o) then
            ('syntax error, found ', $p:TOKEN[$error/@o + 1])
          else
            'lexical analysis failed',
          '&#10;',
          'while expecting ',
          if ($error/@x) then
            $p:TOKEN[$error/@x + 1]
          else
          (
            '['[exists($expected[2])],
            string-join($expected, ', '),
            ']'[exists($expected[2])]
          ),
          '&#10;',
          if ($error/@o or $error/@e = $begin) then
            ()
          else
            ('after successfully scanning ', string($error/@e - $begin), ' characters beginning '),
          'at line ', string($line), ', column ', string($column), ':&#10;',
          '...', substring($input, $begin, 64), '...'
        ),
        ''
      )
    "/>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consume" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:variable name="begin" select="$state[$p:e0]"/>
        <xsl:variable name="end" select="$state[$p:b1]"/>
        <xsl:variable name="whitespace">
          <xsl:if test="$begin ne $end">
            <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="token" select="$p:TOKEN[1 + $state[$p:l1]]"/>
        <xsl:variable name="name" select="if (starts-with($token, &quot;'&quot;)) then 'TOKEN' else $token"/>
        <xsl:variable name="begin" select="$state[$p:b1]"/>
        <xsl:variable name="end" select="$state[$p:e1]"/>
        <xsl:variable name="node">
          <xsl:element name="{$name}">
            <xsl:sequence select="substring($input, $begin, $end - $begin)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13),
          $whitespace/node(),
          $node/node()
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="end" select="$state[$p:b1]"/>
    <xsl:choose>
      <xsl:when test="$begin eq $end">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="whitespace">
          <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
        </xsl:variable>
        <xsl:sequence select="
          0,
          $state[$p:b0],
          $end,
          subsequence($state, $p:e0 + 1),
          $whitespace/node()
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Use p:match to fetch the next token, but skip any leading
   ! whitespace.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start.
   ! @param $token-set the valid token set id.
   ! @return a sequence of three values: the token code of the result
   ! token, with input string positions of token begin and end.
  -->
  <xsl:function name="p:matchW">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="match" select="p:match($input, $begin, $token-set)"/>
    <xsl:choose>
      <xsl:when test="$match[1] = 14">                                              <!-- S -->
        <xsl:sequence select="p:matchW($input, $match[3], $token-set)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$match"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:matchW($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 2 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead2W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l2] ne 0) then
        subsequence($state, $p:l2, 6)
      else
      (
        p:matchW($input, $state[$p:e1], $set),
        0, 0, 0
      )
    "/>
    <xsl:sequence select="
      $match[1] * 128 + $state[$p:l1],
      subsequence($state, $p:b0, 5),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 3 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead3W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l3] ne 0) then
        subsequence($state, $p:l3, 3)
      else
        p:matchW($input, $state[$p:e2], $set)
    "/>
    <xsl:sequence select="
      $match[1] * 16384 + $state[$p:lk],
      subsequence($state, $p:b0, 8),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:match($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Reduce the result stack, creating a nonterminal element. Pop
   ! $count elements off the stack, wrap them in a new element
   ! named $name, and push the new element.
   !
   ! @param $state lexer state, error indicator, and result.
   ! @param $name the name of the result node.
   ! @param $count the number of child nodes.
   ! @param $begin the input index where the nonterminal begins.
   ! @param $end the input index where the nonterminal ends.
   ! @return the updated state.
  -->
  <xsl:function name="p:reduce" as="item()+">
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="name" as="xs:string"/>
    <xsl:param name="count" as="xs:integer"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>

    <xsl:variable name="node">
      <xsl:element name="{$name}">
        <xsl:sequence select="subsequence($state, $count + 1)"/>
      </xsl:element>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $count), $node/node()"/>
  </xsl:function>

  <!--~
   ! Parse start symbol Grammar from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-Grammar" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-Grammar($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</xsl:stylesheet>