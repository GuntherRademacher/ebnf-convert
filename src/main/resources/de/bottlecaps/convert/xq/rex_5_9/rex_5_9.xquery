xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Mar 9, 2023 13:03 (UTC+01) by REx v5.57 which is Copyright (c) 1979-2023 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -q -tree -a none -xquery -name de/bottlecaps/convert/xq/rex_5_9/rex_5_9.xquery ../../../../../../../main/java/de/bottlecaps/convert/rex_5_9/rex_5_9.ebnf :)

(:~
 : The parser that was generated for the de/bottlecaps/convert/xq/rex_5_9/rex_5_9.xquery grammar.
 :)
module namespace p="de/bottlecaps/convert/xq/rex_5_9/rex_5_9.xquery";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  72, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 7, 8, 9,
  10, 11, 12, 13, 14, 8, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 20, 21, 22, 23, 24, 8, 25, 26, 27, 26,
  28, 29, 30, 30, 31, 30, 32, 33, 34, 35, 36, 30, 30, 37, 38, 39, 30, 40, 41, 30, 30, 30, 42, 43, 44, 45, 46, 8, 47, 48,
  49, 50, 51, 52, 53, 54, 55, 54, 54, 56, 57, 58, 59, 60, 54, 61, 62, 63, 64, 54, 65, 66, 67, 54, 68, 69, 70, 8, 8
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1010, 1018, 1026, 1034,
  1042, 1050, 1058, 1267, 1267, 1267, 1267, 1267, 1267, 1437, 1267, 1259, 1259, 1260, 1259, 1259, 1259, 1260, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1261, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1359, 1260, 1258, 1257, 1259, 1259, 1259, 1259,
  1259, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1072, 1259, 1259, 1259, 1259, 1188, 1075, 1259,
  1259, 1259, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1266, 1267, 1074, 1265, 1267, 1405, 1267, 1267, 1267, 1267, 1267, 1258, 1259, 1259, 1264, 1125, 1325, 1404,
  1267, 1399, 1405, 1125, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1361, 1259, 1260, 1136, 1399, 1314, 1201,
  1399, 1405, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1401, 1267, 1267, 1267, 1405, 1267, 1267, 1267, 1384,
  1236, 1259, 1259, 1256, 1259, 1259, 1259, 1259, 1260, 1260, 1424, 1257, 1259, 1263, 1267, 1258, 1083, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1258, 1083, 1259, 1259, 1259, 1259, 1092, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1105, 1114, 1259, 1259, 1259, 1106, 1261, 1265, 1450, 1259, 1259, 1259, 1259, 1259, 1259, 1154, 1399, 1401,
  1202, 1259, 1172, 1399, 1267, 1267, 1450, 1105, 1360, 1259, 1259, 1257, 1186, 1197, 1163, 1175, 1437, 1212, 1172,
  1399, 1265, 1267, 1223, 1246, 1360, 1259, 1259, 1257, 1414, 1197, 1178, 1175, 1267, 1234, 1438, 1399, 1244, 1267,
  1450, 1235, 1256, 1259, 1259, 1257, 1254, 1154, 1277, 1097, 1267, 1267, 994, 1399, 1267, 1267, 1450, 1105, 1360, 1259,
  1259, 1257, 1357, 1154, 1203, 1175, 1438, 1212, 1117, 1399, 1267, 1267, 1002, 1286, 1302, 1298, 1189, 1286, 1127,
  1117, 1204, 1201, 1437, 1267, 1437, 1399, 1267, 1267, 1450, 1083, 1257, 1259, 1259, 1257, 1084, 1117, 1278, 1201,
  1439, 1267, 1117, 1399, 1267, 1267, 1002, 1083, 1257, 1259, 1259, 1257, 1084, 1117, 1278, 1201, 1439, 1269, 1117,
  1399, 1267, 1267, 1002, 1083, 1257, 1259, 1259, 1257, 1259, 1117, 1164, 1201, 1437, 1267, 1117, 1399, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259,
  1259, 1259, 1259, 1261, 1267, 1259, 1259, 1259, 1259, 1260, 1267, 1258, 1259, 1259, 1259, 1259, 1260, 1310, 1404,
  1322, 1400, 1399, 1405, 1267, 1267, 1267, 1267, 1215, 1334, 1073, 1258, 1344, 1354, 1310, 1146, 1369, 1401, 1399,
  1405, 1267, 1267, 1267, 1267, 1269, 1290, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1264, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1254, 1413, 1264, 1267, 1267,
  1267, 1267, 1422, 1266, 1422, 1188, 1070, 1346, 1187, 1214, 1267, 1267, 1267, 1267, 1269, 1267, 1336, 1268, 1300,
  1264, 1267, 1267, 1267, 1267, 1433, 1266, 1435, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1265, 1259, 1259, 1261, 1261, 1259, 1259, 1259, 1259, 1261, 1261, 1259, 1425, 1259, 1259, 1259, 1261, 1259,
  1259, 1259, 1259, 1259, 1259, 1083, 1128, 1226, 1262, 1106, 1263, 1259, 1262, 1226, 1262, 1064, 1267, 1267, 1267,
  1258, 1326, 1162, 1267, 1258, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1262, 999, 1258, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1447, 1072, 1259, 1259, 1259, 1259, 1262, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1399, 1402, 1382, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1405, 1399, 1405, 1392, 1374, 1259, 1258, 1259, 1259, 1259, 1265,
  1398, 1399, 1278, 1403, 1277, 1398, 1399, 1401, 1398, 1382, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1258,
  1259, 1259, 1259, 1260, 1435, 1258, 1259, 1259, 1259, 1260, 1267, 1398, 1399, 1160, 1399, 1399, 1142, 1379, 1267,
  1259, 1259, 1259, 1264, 1264, 1267, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 1, 0, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11,
  12, 13, 14, 8, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 20, 21, 22, 23, 24, 8, 25, 26, 27, 26, 28, 29, 30, 8,
  8, 8, 8, 8, 71, 71, 8, 8, 71, 71, 8, 30, 30, 30, 30, 31, 30, 32, 33, 34, 35, 36, 30, 30, 37, 38, 39, 30, 40, 41, 30,
  30, 30, 42, 43, 44, 45, 46, 8, 47, 48, 49, 50, 51, 52, 53, 54, 55, 54, 54, 56, 57, 58, 59, 60, 54, 61, 62, 63, 64, 54,
  65, 66, 67, 54, 68, 69, 70, 8, 8, 8, 8, 8, 71, 8, 30, 8, 8, 8, 8, 8, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 8,
  30, 30, 30, 30, 30, 8, 71, 71, 71, 71, 8, 71, 71, 71, 8, 8, 30, 30, 30, 30, 30, 8, 8, 30, 30, 30, 8, 8, 30, 30, 8, 8,
  8, 8, 71, 71, 71, 30, 30, 30, 30, 30, 30, 30, 8, 30, 8, 30, 30, 30, 30, 8, 30, 71, 71, 8, 71, 71, 71, 8, 71, 71, 30,
  8, 8, 30, 30, 8, 8, 71, 30, 71, 71, 8, 71, 71, 71, 71, 71, 8, 8, 71, 71, 30, 30, 71, 71, 8, 8, 71, 71, 71, 8, 8, 8, 8,
  71, 30, 8, 30, 8, 8, 8, 30, 30, 8, 8, 8, 30, 30, 8, 8, 71, 8, 71, 71, 71, 71, 8, 8, 8, 71, 71, 8, 8, 8, 8, 30, 30, 8,
  30, 8, 8, 30, 8, 8, 71, 8, 8, 30, 30, 30, 8, 30, 30, 8, 30, 30, 30, 30, 8, 30, 8, 30, 30, 71, 71, 30, 30, 30, 8, 8, 8,
  8, 30, 30, 8, 30, 30, 8, 30, 30, 30, 30, 30, 30, 30, 30, 8, 8, 8, 8, 8, 8, 8, 8, 30, 8, 71, 71, 71, 71, 71, 71, 8, 71,
  71, 30, 30, 30, 8, 8, 8, 30, 30, 8, 8, 30, 8, 8, 30, 30, 8, 30, 8, 30, 30, 30, 30, 8, 8, 30, 71, 30, 30, 71, 71, 71,
  71, 71, 30, 30, 71, 30, 30, 30, 30, 30, 30, 71, 71, 71, 71, 71, 71, 30, 8, 30, 8, 8, 30, 8, 8, 30, 30, 8, 30, 30, 30,
  8, 30, 8, 30, 8, 30, 8, 8, 30, 30, 8, 30, 30, 8, 8, 30, 30, 30, 30, 30, 8, 30, 30, 30, 30, 30, 8, 71, 8, 8, 8, 8, 71,
  71, 8, 71, 8, 8, 8, 8, 8, 8, 30, 71, 8, 8, 8, 8, 8, 71, 8, 71, 71, 71, 71, 71, 71, 71, 71, 8, 8, 8, 8, 8, 8, 8, 30, 8,
  30, 30, 8, 30, 30, 8, 8, 8, 8, 8, 30, 8, 30, 8, 30, 8, 30, 8, 8, 8, 30, 8, 8, 8, 8, 8, 8, 8, 71, 71, 8, 30, 30, 30, 8,
  71, 71, 71, 8, 30, 30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 8, 8
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
  62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 4672, 4679, 4684, 4908, 4692, 4906, 4906, 4906, 4906, 4906, 4696, 4708,
  5698, 5271, 5723, 6855, 6855, 4962, 5700, 4737, 6855, 7450, 4748, 5035, 5210, 4756, 6854, 7487, 5650, 6851, 4764,
  5574, 5571, 4766, 5577, 4774, 4782, 4787, 4792, 4797, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4813, 4820, 4825, 4842, 4833,
  4850, 4839, 4876, 4879, 4878, 4857, 4887, 5698, 5271, 5723, 6855, 6855, 4962, 5700, 4737, 6855, 7450, 4748, 5035,
  5210, 4756, 6854, 7487, 5650, 6851, 4764, 5574, 5571, 4766, 5577, 4774, 4782, 4787, 4792, 4797, 4802, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 4700, 4901, 4684, 4908, 4692, 4906, 4906, 4906, 4906, 4906, 4696, 4708, 5698, 5271, 5723, 6855, 6855,
  4962, 5700, 4737, 6855, 7450, 4748, 5035, 5210, 4756, 6854, 7487, 5650, 6851, 4764, 5574, 5571, 4766, 5577, 4774,
  4782, 4787, 4792, 4797, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6881, 4937, 4946, 4954, 4944, 4944, 4944, 4944, 4944,
  4958, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740,
  6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4996, 4719, 5158,
  5287, 5004, 5010, 5011, 5011, 5011, 5011, 5019, 4970, 5698, 6783, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450,
  4994, 6361, 7455, 6699, 6854, 7280, 4740, 5250, 5592, 5574, 5371, 5594, 6745, 6741, 6026, 7239, 7238, 7156, 4802,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 4916, 6855, 5158, 6278, 5031, 6231, 6855, 4861, 4868, 4865, 5043, 4970, 5698, 5271, 6855,
  6855, 6855, 6351, 5700, 4737, 6855, 7450, 5055, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766,
  5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 5311, 6855, 5076,
  5083, 5080, 5072, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854,
  6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916,
  6855, 5158, 7178, 5646, 6855, 6855, 6855, 6855, 6855, 6855, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737,
  6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238,
  7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 5091, 6953, 5105, 5102, 5113, 4970, 5698,
  5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574,
  5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5505, 5125, 5131,
  5132, 5132, 5132, 5132, 6685, 4970, 5698, 5297, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 5047, 7455,
  7108, 6173, 6971, 4740, 6170, 5547, 6309, 6306, 5549, 6312, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 4916, 6855, 5158, 7178, 5646, 5337, 5142, 5140, 5150, 5150, 5154, 4970, 5698, 5271, 6855, 6855, 6855, 6351,
  5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026,
  7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5168, 5646, 6448, 5166, 6450, 5176, 5178, 5186,
  4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851,
  5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5198, 5218, 5190, 7178,
  5646, 6855, 5606, 6855, 6855, 5227, 5231, 5243, 6253, 5271, 6855, 5261, 5269, 6351, 6255, 4737, 6855, 5205, 4994,
  5219, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 7408, 6855, 6855, 5279, 5283, 4970, 5698, 5271, 6855, 4986,
  5295, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577,
  6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 6855, 6855, 4729,
  5305, 5319, 5331, 5698, 5271, 4714, 6082, 6082, 5919, 5700, 5345, 5353, 6003, 5364, 5917, 7455, 6042, 6854, 6187,
  4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855,
  5158, 7178, 5382, 5400, 5405, 5418, 5419, 5416, 5427, 5331, 5698, 5271, 6855, 6082, 6082, 5919, 5700, 5439, 5353,
  6003, 4994, 5917, 7455, 6042, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156,
  6780, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 4916, 6982, 5451, 5485, 5447, 5459, 5482, 5493, 5470, 5465, 5474, 4970, 5836, 5271,
  6855, 6855, 6855, 6351, 7192, 4737, 6855, 7450, 4994, 6323, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571,
  4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 6855,
  6855, 6855, 6855, 7201, 5331, 5698, 5271, 4724, 5501, 6082, 5919, 5700, 5513, 5521, 6003, 5533, 5557, 5713, 6042,
  5253, 5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  5585, 6856, 5158, 5784, 5780, 7200, 7199, 7197, 7374, 7377, 5602, 4970, 5614, 5271, 6855, 6855, 6855, 6351, 5700,
  4737, 6855, 7450, 4994, 6174, 6855, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239,
  7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 6855, 5624, 6855, 5625, 6855, 4970,
  5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547,
  5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5641, 5634,
  5658, 5666, 5671, 5679, 5687, 5694, 4970, 5698, 5392, 6855, 5387, 6855, 5708, 5700, 4737, 6855, 7450, 4994, 6174,
  7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 4916, 5721, 5158, 7178, 5646, 6855, 6855, 6855, 5794, 6508, 6512, 4970, 5698, 5271, 6855, 6855, 6855,
  5023, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741,
  6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 5775, 7401, 5731, 7406, 5732, 6855, 7456,
  5740, 4970, 6392, 5117, 6855, 6855, 5757, 5765, 7053, 4737, 6855, 7450, 5792, 6174, 7455, 6083, 6854, 6084, 4740,
  6851, 5547, 5574, 5571, 6497, 5577, 6741, 5802, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5813, 6855, 5235,
  5851, 7171, 7177, 7176, 5850, 6855, 5828, 5832, 4970, 6935, 7065, 6855, 5844, 6794, 5859, 4923, 4737, 6855, 7450,
  5872, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5374, 5882, 4766, 5577, 6736, 6026, 7239, 7238, 7156, 4802,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626,
  6082, 6082, 5919, 5700, 5948, 5956, 6003, 5533, 5917, 7455, 5968, 6854, 5567, 4805, 6851, 5747, 5885, 5981, 5749,
  6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928,
  5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6003, 5533, 5917, 7455, 5968, 6854,
  5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896,
  6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948,
  5992, 6003, 5533, 5998, 7455, 6016, 6854, 5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238,
  7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698,
  5271, 5626, 6082, 6082, 5919, 5700, 5948, 6037, 6003, 5533, 6665, 7455, 5968, 6854, 6055, 4805, 6851, 6221, 5885,
  5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927,
  5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 6075, 6003, 5533, 5917, 7455,
  5968, 6854, 5567, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919,
  5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026,
  7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936,
  5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6092,
  5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356,
  5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994,
  5917, 7455, 6103, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082,
  6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 6111, 6593,
  7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928,
  5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 7229,
  4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855,
  5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353,
  6003, 4994, 6128, 7455, 5968, 6854, 6187, 4805, 6141, 6206, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156,
  4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271,
  5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 6152, 7455, 5968, 6854, 7123, 4805, 6851, 5747, 5885, 5571,
  5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928,
  5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 6165,
  6854, 6187, 5094, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700,
  5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5903, 5885, 5571, 5749, 6608, 7321, 6026, 7239,
  7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331,
  5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 6182, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5747,
  5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911,
  5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6199, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917,
  7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6214, 6082,
  5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321,
  6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 4929, 6239, 6244, 6266, 6263,
  6249, 4970, 5698, 5271, 5874, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740,
  6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6541, 5158,
  7178, 5646, 6277, 6855, 6543, 6855, 6855, 6274, 6286, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450,
  4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6294, 6855, 5158, 6855, 6320, 6855, 6855, 6320, 6855, 6322, 6855, 6331, 5698, 5271, 6855,
  6855, 6855, 6351, 5700, 6855, 6855, 7450, 4994, 6349, 7455, 6359, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766,
  5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7178, 6369, 4985, 4984, 4982,
  6855, 7499, 6388, 4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854,
  6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896,
  6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439,
  5353, 6670, 4994, 5917, 7455, 5968, 6854, 6187, 6400, 6851, 5747, 5885, 5571, 5749, 7138, 7321, 6417, 7239, 7238,
  7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698,
  5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6439, 6458, 6478, 6950, 5968, 6854, 5567, 4805, 6851, 5747, 5885,
  7127, 5749, 6593, 6491, 6026, 6524, 6523, 6532, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927,
  5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5948, 5956, 6003, 5533, 6478, 7455,
  5968, 6854, 5567, 5408, 6851, 6407, 6117, 5571, 6409, 6120, 6551, 6559, 6643, 6642, 6562, 4802, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919,
  5700, 5948, 5956, 6003, 5533, 6478, 7455, 5968, 6144, 5567, 4805, 6851, 5888, 5885, 5571, 5749, 6593, 7321, 6026,
  7239, 7238, 6774, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6445, 5960, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936,
  5331, 5698, 5271, 5626, 6082, 6082, 5559, 5700, 6570, 6578, 6003, 5533, 6478, 7455, 5968, 6854, 5567, 4805, 6851,
  5820, 6590, 5571, 5749, 6601, 7321, 6026, 7094, 7238, 5805, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 6651, 5356,
  6659, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 6678, 5626, 6082, 6697, 5919, 5700, 5948, 5956, 6707, 5533,
  6478, 7455, 5968, 6854, 6715, 4805, 6851, 6301, 6820, 6817, 6067, 6723, 6731, 6753, 6767, 6757, 6759, 6791, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082,
  6082, 5919, 7031, 5948, 5956, 6003, 5533, 6478, 7455, 5968, 6802, 6813, 4805, 6851, 5747, 5885, 5571, 5749, 6593,
  7321, 6828, 7239, 6832, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 7341, 5911, 5927, 5928, 5928, 5928,
  5928, 5936, 5331, 5698, 5271, 7294, 6082, 6082, 5323, 5700, 5439, 5353, 6133, 4994, 6478, 7455, 5968, 6854, 6187,
  4805, 6851, 6840, 5984, 5571, 6848, 6593, 7321, 6026, 6907, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855,
  5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353,
  6003, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156,
  4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 6864, 5698, 5271,
  5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 6878, 6478, 5770, 5968, 6503, 6187, 4893, 6191, 5747, 5885, 5571,
  6889, 6622, 7321, 6026, 7239, 7238, 6900, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928,
  5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 4976, 6917, 5439, 5353, 6003, 6931, 6943, 7455, 6961,
  6969, 6187, 4805, 6851, 5747, 5885, 6021, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 6979, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  5896, 6855, 5940, 5356, 6990, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700,
  6998, 7006, 6003, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6629, 7014, 6026, 6431,
  6636, 7080, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331,
  7029, 5271, 7039, 6082, 6082, 5919, 7047, 5439, 5353, 6483, 4994, 6478, 5864, 5968, 6854, 6187, 4805, 6376, 5747,
  5885, 5973, 5749, 6615, 7073, 6026, 7088, 6427, 7156, 6538, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911,
  5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 7106, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 6478,
  7309, 5968, 6854, 6187, 7116, 6851, 5747, 7135, 5571, 5749, 6593, 7146, 6026, 7239, 7154, 7098, 4802, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082,
  5919, 5616, 5439, 5353, 6003, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321,
  6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 7164, 6855, 7186, 6341, 7209, 7215, 7216, 7216, 7216, 7216,
  7224, 5331, 5698, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 6478, 7455, 5968, 6854, 6187, 4805,
  6047, 5747, 6062, 5571, 5749, 6593, 7321, 7237, 6422, 7238, 7021, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 6870,
  5356, 5911, 5927, 7247, 7252, 5928, 7254, 5936, 5331, 5698, 5271, 7262, 6082, 6082, 6582, 5700, 7270, 5353, 6157,
  4994, 6478, 7455, 5968, 6854, 6187, 4805, 6851, 5747, 5885, 6465, 5749, 6593, 7321, 6470, 7239, 7238, 7156, 4802,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626,
  6082, 6082, 5919, 5700, 5439, 5353, 6003, 7278, 6478, 7455, 5968, 6095, 6187, 5540, 6892, 5747, 5885, 5571, 5749,
  6593, 7321, 6026, 7239, 6909, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927, 5928, 5928,
  5928, 5928, 5936, 7288, 6923, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 7302, 7455, 5968, 6854,
  6187, 4805, 6851, 5747, 7317, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 6029, 4802, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896,
  6855, 5940, 7353, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698, 5271, 5626, 6082, 6082, 5431, 5700, 5439,
  5353, 6003, 4994, 6478, 7455, 5968, 6854, 6187, 4805, 6226, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238,
  7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 7436, 5911, 5927, 5928, 5928, 5928, 5928, 5936, 5331, 5698,
  7329, 6380, 7337, 6082, 5525, 5700, 5439, 5353, 6003, 4994, 6478, 6008, 5968, 7349, 6187, 4805, 6851, 5747, 5885,
  5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 5896, 6855, 5940, 5356, 5911, 5927,
  5928, 5928, 5928, 5928, 5936, 5331, 7469, 5271, 5626, 6082, 6082, 5919, 5700, 5439, 5353, 6003, 4994, 6478, 7455,
  5968, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593, 7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 4916, 6855, 5158, 7178, 5646, 6855, 7361, 7366, 7388, 7385, 7371, 4970, 5698, 5271, 6855, 6855, 6855, 6351,
  5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026,
  7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6855, 5158, 7396, 5646, 6805, 7422, 7416, 7424, 7424, 7432,
  4970, 5698, 5271, 6855, 6855, 6855, 6351, 5700, 4737, 6855, 7450, 4994, 6174, 7455, 6083, 6854, 6084, 4740, 6851,
  5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 4916, 6337, 5158, 7178,
  5646, 6855, 6855, 6855, 6855, 6855, 6855, 4970, 5698, 5271, 6855, 6855, 7059, 7444, 5700, 4737, 6855, 7450, 4994,
  6174, 7455, 6083, 6854, 6084, 4740, 6851, 5547, 5574, 5571, 4766, 5577, 6741, 6026, 7239, 7238, 7156, 4802, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 4916, 6855, 5158, 7178, 5646, 6855, 6855, 6855, 6855, 6855, 7201, 5331, 5698, 5271, 6855, 6082,
  6082, 5919, 5700, 5439, 5353, 6003, 4994, 5917, 7455, 6042, 6854, 6187, 4805, 6851, 5747, 5885, 5571, 5749, 6593,
  7321, 6026, 7239, 7238, 7156, 4802, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6515, 6855, 7485, 7464, 7477, 7483, 5061, 5064,
  5063, 7495, 6689, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855,
  6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 6855, 1621, 4610, 0,
  0, 0, 0, 1626, 1621, 1621, 1621, 1621, 0, 7773, 7773, 7773, 7773, 1621, 1621, 1621, 7773, 7773, 7773, 5748, 5748,
  7773, 7773, 7773, 7773, 1621, 0, 0, 0, 0, 0, 1626, 1621, 0, 1626, 91, 0, 7773, 94, 0, 0, 0, 155, 155, 0, 0, 0, 0,
  12800, 0, 0, 0, 0, 4252, 0, 0, 0, 0, 18944, 0, 0, 18944, 0, 0, 6144, 0, 0, 0, 0, 0, 0, 243, 0, 0, 147, 0, 0, 0, 0, 0,
  200, 201, 0, 0, 0, 0, 0, 207, 208, 0, 242, 243, 243, 0, 0, 0, 208, 209, 0, 0, 243, 288, 0, 252, 0, 288, 288, 0, 252,
  0, 243, 252, 294, 298, 252, 294, 243, 252, 306, 243, 252, 294, 243, 252, 315, 243, 252, 294, 294, 294, 0, 0, 0, 0, 0,
  0, 1255, 0, 1536, 4610, 0, 0, 0, 0, 1627, 1536, 1536, 1536, 1536, 0, 7680, 7680, 7680, 7680, 1536, 1536, 1536, 7680,
  7680, 7680, 5748, 5748, 7680, 7799, 7680, 7799, 7799, 7680, 7680, 7680, 7680, 7680, 7680, 1536, 5748, 7680, 7799,
  7799, 7680, 7799, 7799, 7680, 7799, 7799, 7799, 7799, 0, 0, 0, 0, 0, 124, 124, 0, 0, 124, 0, 124, 124, 0, 124, 7680,
  7680, 7680, 7799, 7799, 7799, 7799, 7799, 7799, 7799, 7799, 0, 91, 91, 0, 0, 73216, 0, 0, 0, 240, 241, 0, 1255, 0,
  1621, 1621, 1621, 1621, 5120, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 7773, 1621, 5748, 0, 4610, 0, 0, 0, 0, 91, 0,
  0, 178, 148, 103, 103, 0, 0, 0, 28672, 0, 0, 28672, 127, 94, 94, 94, 94, 101, 103, 0, 94, 94, 94, 94, 94, 94, 94, 94,
  0, 5748, 94, 94, 5748, 5748, 94, 94, 94, 94, 0, 0, 0, 0, 0, 142, 0, 0, 0, 91, 91, 0, 0, 94, 0, 0, 0, 1193, 0, 171, 0,
  0, 0, 3704, 0, 0, 0, 0, 0, 0, 0, 23040, 0, 147, 0, 0, 0, 0, 0, 0, 91, 12800, 0, 111, 5748, 5748, 0, 111, 0, 111, 111,
  111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 0, 0, 0, 0, 0, 171, 21504, 0, 0, 0, 5749, 5749, 0, 0, 0, 0, 0, 207,
  0, 171, 124, 124, 0, 124, 0, 0, 0, 0, 0, 209, 0, 171, 0, 147, 0, 0, 0, 199, 0, 0, 0, 12288, 12288, 12288, 12288,
  12288, 12288, 12288, 12288, 13312, 13312, 0, 13312, 0, 0, 0, 0, 0, 13312, 13312, 0, 0, 13312, 0, 13312, 13312, 0,
  13312, 0, 0, 13824, 0, 0, 0, 0, 0, 0, 1255, 245, 0, 13824, 13824, 0, 0, 13824, 0, 13824, 13824, 0, 13824, 13824,
  13824, 0, 13824, 0, 0, 0, 0, 0, 27136, 111, 112, 0, 112, 5748, 5748, 0, 112, 0, 112, 112, 112, 112, 112, 112, 112,
  112, 14336, 14336, 14336, 0, 0, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336, 14336,
  14336, 0, 0, 0, 0, 101, 103, 0, 0, 14848, 0, 0, 14848, 0, 0, 0, 0, 0, 5748, 14848, 0, 14848, 14848, 14848, 14848,
  14848, 14848, 14848, 14848, 14848, 14848, 14848, 14848, 0, 0, 0, 0, 101, 104, 0, 0, 0, 4610, 86, 0, 0, 0, 91, 0, 0,
  192, 171, 171, 171, 0, 0, 0, 0, 0, 0, 200, 86, 0, 0, 0, 0, 0, 0, 0, 192, 137, 15360, 15360, 15360, 15360, 15360,
  15360, 15360, 0, 0, 0, 0, 102, 103, 0, 0, 0, 91, 91, 0, 0, 94, 142, 0, 0, 223, 209, 0, 0, 0, 0, 0, 0, 6872, 0, 0,
  20622, 0, 0, 0, 0, 22528, 0, 35328, 0, 0, 0, 0, 0, 0, 111, 112, 138, 17408, 17408, 17408, 17408, 17408, 17408, 17408,
  0, 0, 0, 0, 111, 0, 0, 5748, 0, 35840, 0, 0, 0, 0, 0, 0, 111, 3072, 0, 18944, 0, 0, 0, 18944, 0, 0, 0, 13312, 0, 0,
  13312, 0, 0, 18944, 0, 18944, 0, 0, 0, 1112, 0, 172, 0, 0, 1112, 91, 91, 0, 0, 94, 0, 0, 0, 14336, 0, 0, 14336, 0, 0,
  0, 6144, 182, 0, 0, 0, 3744, 1112, 0, 0, 0, 0, 0, 0, 1112, 1112, 0, 5748, 0, 147, 0, 0, 0, 0, 182, 0, 0, 223, 209, 0,
  0, 252, 0, 243, 243, 267, 0, 19456, 5748, 5748, 19456, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 23552, 0, 111, 112, 0, 19456,
  19456, 19456, 19456, 0, 19456, 19456, 0, 0, 0, 0, 0, 0, 1268, 0, 19456, 19456, 19456, 0, 0, 19456, 0, 19456, 19456, 0,
  19456, 19456, 19456, 19456, 19456, 0, 0, 0, 1112, 0, 173, 0, 0, 0, 0, 6144, 0, 0, 0, 0, 3744, 95, 95, 5748, 5748, 95,
  95, 95, 95, 101, 103, 0, 95, 95, 95, 123, 95, 95, 123, 95, 123, 123, 20091, 20091, 123, 20091, 123, 20091, 123, 123,
  20091, 123, 0, 15872, 0, 0, 20063, 95, 123, 95, 95, 95, 95, 95, 95, 0, 5748, 95, 95, 95, 95, 20091, 123, 123, 20091,
  1112, 0, 0, 4259, 0, 0, 0, 0, 112, 0, 0, 5748, 0, 0, 6144, 4252, 4279, 0, 185, 3744, 1112, 0, 4259, 4260, 0, 0, 0,
  1112, 0, 174, 0, 0, 0, 147, 0, 0, 0, 0, 4279, 0, 0, 239, 0, 0, 0, 1255, 0, 0, 243, 243, 0, 0, 0, 208, 224, 0, 185,
  1112, 0, 0, 0, 1112, 0, 171, 0, 175, 6873, 0, 1112, 0, 0, 0, 208, 209, 0, 0, 252, 0, 243, 243, 0, 208, 209, 252, 0,
  4610, 0, 20992, 0, 0, 91, 0, 0, 243, 243, 0, 0, 0, 223, 209, 0, 97, 97, 0, 97, 0, 0, 0, 0, 131, 132, 0, 0, 143, 0, 0,
  0, 147, 147, 103, 103, 0, 180, 0, 22016, 0, 0, 0, 0, 0, 0, 0, 3744, 0, 0, 5748, 5748, 0, 108, 109, 108, 0, 0, 109, 0,
  0, 0, 5748, 5748, 0, 0, 0, 0, 0, 242, 243, 0, 109, 122, 122, 0, 125, 126, 0, 122, 108, 125, 122, 128, 128, 128, 128,
  128, 125, 126, 122, 122, 135, 135, 135, 122, 135, 122, 122, 135, 122, 128, 122, 122, 135, 135, 122, 135, 125, 125,
  139, 125, 0, 0, 0, 0, 147, 147, 103, 103, 0, 0, 0, 0, 23552, 0, 0, 171, 0, 0, 0, 0, 0, 6872, 0, 0, 26112, 0, 0, 0, 0,
  0, 0, 119, 0, 110, 0, 0, 0, 110, 0, 0, 0, 0, 110, 110, 110, 110, 0, 0, 28160, 0, 0, 243, 1255, 0, 0, 0, 208, 209, 0,
  0, 0, 16384, 0, 17920, 0, 0, 26624, 16384, 17920, 0, 0, 0, 171, 0, 0, 0, 214, 0, 0, 0, 110, 0, 0, 0, 5748, 5748, 0, 0,
  97, 0, 0, 97, 0, 5748, 0, 133120, 0, 0, 0, 0, 0, 0, 136, 0, 25088, 252, 0, 243, 252, 294, 243, 252, 294, 320, 294, 0,
  4610, 0, 0, 87, 0, 91, 0, 0, 243, 1255, 0, 0, 0, 259, 0, 27648, 27648, 27648, 27648, 27648, 27648, 27648, 0, 0, 0, 0,
  147, 147, 103, 15872, 0, 162, 0, 0, 162, 165, 0, 0, 0, 27648, 0, 0, 0, 0, 5748, 0, 0, 24229, 0, 0, 171, 0, 0, 213, 0,
  215, 0, 0, 0, 178, 0, 0, 0, 0, 0, 0, 159, 0, 0, 269, 208, 209, 0, 0, 252, 0, 243, 1255, 0, 0, 0, 208, 0, 4610, 0, 0,
  0, 1112, 91, 0, 0, 243, 1255, 0, 0, 258, 208, 0, 1112, 5748, 5748, 0, 1112, 0, 1112, 0, 0, 0, 1112, 0, 171, 0, 0, 0,
  1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 0, 0, 0, 1112, 101, 103, 0, 0, 0, 0, 6144, 0,
  4279, 0, 0, 3744, 1112, 0, 0, 4260, 0, 0, 0, 1112, 101, 103, 105, 0, 68096, 0, 1112, 0, 0, 0, 0, 208, 209, 0, 30208,
  273, 0, 268, 0, 208, 209, 0, 0, 252, 0, 243, 1290, 0, 1112, 0, 0, 4260, 0, 8704, 0, 1112, 0, 0, 9216, 1112, 0, 171,
  171, 171, 171, 0, 0, 0, 0, 0, 217, 0, 68096, 0, 1112, 220, 0, 0, 0, 208, 209, 272, 0, 252, 0, 243, 252, 294, 243, 252,
  294, 294, 321, 1112, 187, 0, 4260, 187, 0, 0, 1112, 0, 0, 0, 0, 208, 209, 0, 250, 0, 0, 6873, 0, 1112, 0, 0, 234, 208,
  209, 0, 0, 252, 264, 243, 1255, 0, 0, 0, 278, 279, 31232, 1112, 0, 0, 4260, 0, 0, 189, 1112, 0, 0, 0, 0, 0, 0, 0, 208,
  209, 246, 0, 208, 209, 0, 0, 0, 0, 0, 229, 0, 68096, 0, 1112, 0, 0, 222, 0, 208, 243, 1255, 0, 277, 0, 208, 209, 0, 0,
  252, 0, 254, 1268, 0, 208, 209, 252, 0, 1112, 204, 0, 0, 1112, 0, 171, 171, 171, 173, 0, 0, 0, 247, 208, 209, 0, 0, 0,
  0, 228, 0, 0, 0, 1112, 0, 206, 0, 1112, 0, 171, 171, 193, 171, 0, 0, 68096, 0, 1112, 0, 221, 0, 0, 208, 224, 0, 0, 0,
  0, 0, 0, 0, 171, 1112, 0, 0, 0, 188, 0, 0, 1112, 0, 0, 0, 208, 209, 0, 0, 251, 0, 1112, 0, 0, 0, 0, 0, 166, 0, 0, 243,
  1255, 0, 257, 0, 208, 1112, 0, 0, 0, 0, 0, 167, 0, 0, 243, 1255, 256, 0, 0, 208, 209, 30720, 0, 0, 0, 124, 0, 0, 124,
  0, 127, 0, 127, 28672, 28672, 28672, 28672, 28672, 0, 127, 28799, 28799, 127, 28799, 0, 0, 0, 0, 147, 147, 149, 150,
  0, 0, 28672, 28799, 28799, 127, 127, 28799, 127, 28799, 28799, 127, 28799, 96, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 5749, 0,
  91, 91, 0, 0, 94, 0, 8192, 0, 4610, 0, 0, 0, 0, 9728, 0, 0, 243, 1279, 0, 0, 0, 208, 224, 0, 0, 252, 0, 243, 243, 0,
  208, 224, 252, 0, 0, 29184, 0, 0, 0, 0, 0, 0, 0, 7680, 0, 9728, 9728, 0, 0, 94, 0, 0, 0, 36864, 0, 0, 0, 0, 1113,
  1113, 0, 5748, 201, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 201, 0, 0, 0, 0, 0, 208, 0, 171, 0, 0, 5748, 29812, 0, 0, 3704, 0,
  0, 248, 249, 0, 0, 0, 0, 157, 0, 0, 3744, 3704, 3704, 3704, 3704, 0, 0, 0, 0, 147, 28307, 103, 103, 0, 238, 0, 0, 0,
  0, 1255, 0, 0, 254, 1268, 0, 0, 0, 208, 209, 0, 0, 252, 0, 243, 296, 294, 243, 252, 294, 304, 252, 294, 243, 311, 294,
  243, 252, 294, 243, 305, 294, 243, 1112, 191, 171, 171, 171, 171, 0, 0, 92, 0, 0, 0, 0, 0, 0, 14848, 0, 0, 14848, 0,
  147, 0, 0, 198, 0, 4279, 0, 0, 270, 271, 0, 0, 252, 0, 243, 252, 294, 243, 299, 202, 1112, 0, 0, 0, 1112, 0, 171, 193,
  171, 171, 0, 0, 0, 243, 1255, 0, 252, 291, 243, 243, 24576, 0, 25600, 208, 209, 0, 0, 0, 227, 0, 0, 0, 136, 0, 0, 136,
  0, 0, 0, 0, 0, 0, 12288, 0, 308, 294, 243, 252, 294, 243, 252, 294, 307, 316, 252, 294, 243, 252, 294, 294, 294, 300,
  0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 254, 1268, 0, 252, 0, 254, 254, 0, 252, 0, 254, 252, 294, 254, 252, 294, 294, 294,
  0, 0, 6144, 0, 4279, 184, 0, 3744, 1210, 0, 0, 4260, 0, 0, 0, 1112, 170, 171, 0, 0, 260, 0, 0, 252, 0, 243, 1255, 0,
  208, 209, 252, 280, 0, 243, 1255, 0, 208, 209, 252, 0, 243, 1255, 284, 208, 209, 252, 0, 243, 1307, 0, 208, 209, 252,
  0, 282, 1255, 0, 208, 209, 252, 281, 243, 1255, 0, 10752, 10752, 252, 294, 310, 252, 294, 313, 252, 294, 254, 252,
  294, 254, 252, 294, 254, 98, 0, 0, 1112, 101, 103, 106, 98, 118, 1112, 5748, 5748, 118, 1112, 0, 1112, 0, 205, 0,
  1112, 0, 171, 171, 171, 171, 194, 0, 151, 0, 153, 0, 0, 0, 111, 112, 112, 112, 112, 0, 0, 0, 0, 0, 73216, 0, 0, 1192,
  0, 0, 0, 0, 0, 0, 0, 208, 223, 32856, 0, 171, 171, 171, 171, 0, 32768, 6873, 0, 1255, 0, 0, 0, 235, 236, 263, 0, 243,
  1255, 0, 208, 209, 263, 0, 243, 1255, 0, 263, 0, 243, 243, 289, 252, 0, 243, 243, 0, 252, 0, 243, 243, 0, 223, 209,
  252, 0, 263, 0, 243, 263, 297, 243, 263, 297, 243, 263, 297, 297, 297, 297, 243, 302, 297, 243, 263, 297, 243, 252,
  294, 243, 11264, 294, 294, 294, 12070, 0, 0, 0, 0, 0, 0, 3072, 112, 297, 323, 297, 0, 0, 0, 0, 0, 0, 24229, 0, 209, 0,
  226, 0, 0, 0, 0, 0, 0, 36352, 36352, 6873, 230, 1112, 0, 0, 0, 208, 209, 0, 0, 263, 0, 265, 1255, 0, 0, 293, 0, 295,
  252, 294, 243, 252, 312, 243, 252, 294, 0, 253, 243, 1255, 0, 0, 0, 208, 275, 1255, 0, 0, 0, 208, 209, 0, 0, 0, 0, 0,
  0, 0, 0, 97, 1112, 91, 91, 141, 0, 94, 0, 0, 100, 1112, 101, 103, 0, 107, 0, 147, 196, 0, 0, 0, 0, 0, 94, 94, 94, 243,
  1300, 0, 0, 0, 208, 209, 0, 0, 0, 31744, 243, 317, 294, 243, 252, 294, 294, 294, 301, 252, 294, 243, 252, 294, 243,
  314, 294, 176, 0, 147, 147, 103, 103, 0, 0, 145, 0, 147, 147, 103, 103, 0, 147, 0, 197, 0, 0, 0, 0, 148, 148, 103,
  103, 202, 1112, 0, 0, 0, 1112, 210, 171, 0, 212, 0, 0, 0, 0, 0, 0, 13824, 0, 68096, 0, 1243, 0, 0, 0, 0, 208, 209,
  225, 0, 0, 0, 0, 0, 0, 208, 224, 322, 294, 294, 0, 0, 0, 0, 0, 95, 95, 95, 0, 1112, 5748, 5748, 0, 1112, 0, 1145, 181,
  0, 6144, 0, 0, 0, 0, 3744, 1112, 0, 0, 0, 0, 0, 0, 1214, 286, 243, 1255, 0, 252, 0, 243, 243, 252, 294, 10240, 252,
  294, 294, 294, 0, 144, 0, 0, 147, 147, 103, 103, 179, 0, 32256, 0, 0, 0, 0, 158, 0, 3744, 0, 177, 147, 147, 103, 103,
  0, 0, 147, 0, 103, 103, 0, 0, 0, 16896, 0, 18432, 0, 0, 0, 24064, 0, 0, 111, 112, 0, 287, 1255, 0, 252, 0, 243, 243,
  252, 318, 243, 252, 294, 294, 294, 300, 243, 252, 294, 243, 273, 294, 243, 252, 303, 243, 252, 294, 243, 252, 319,
  294, 294, 1185, 0, 0, 0, 0, 0, 0, 0, 209, 208, 237, 0, 0, 0, 0, 0, 1255, 0, 0, 1112, 232, 0, 0, 208, 209, 0, 0, 252,
  274, 209, 0, 262, 252, 0, 243, 1255, 0, 208, 209, 285, 0, 243, 1255, 0, 290, 0, 243, 292, 252, 309, 243, 252, 294,
  243, 252, 294, 294, 294, 0, 4610, 0, 0, 0, 1113, 91, 0, 0, 5748, 5748, 0, 0, 27648, 0, 0, 0, 0, 0, 0, 0, 5748, 0, 99,
  0, 1113, 101, 103, 0, 0, 147, 147, 138240, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 1112, 99, 1113, 5748, 5748, 99, 1113, 0,
  1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 0, 0, 0, 1112, 0, 233, 0, 208, 209, 0, 252,
  294, 243, 252, 294, 243, 252, 294, 243, 1112, 1112, 1112, 1153, 1153, 1153, 1153, 1153, 1112, 1112, 1112, 1112, 1112,
  1112, 1112, 0, 33792, 0, 0, 0, 0, 0, 3744, 0, 34304, 6144, 0, 0, 0, 0, 3744, 195, 147, 0, 0, 0, 0, 0, 0, 223, 209,
  1164, 91, 91, 0, 0, 94, 0, 0, 154, 0, 0, 0, 0, 3744, 202, 1227, 0, 0, 0, 1112, 0, 171, 211, 0, 0, 0, 0, 0, 218, 209,
  261, 0, 252, 0, 243, 1255, 0, 252, 0, 243, 243, 0, 152, 0, 0, 0, 0, 111, 112, 1112, 0, 0, 164, 0, 0, 0, 0, 1112, 1112,
  113, 5748, 209, 0, 0, 33280, 0, 0, 0, 0, 1112, 1112, 114, 5748, 34816, 0, 0, 130, 130, 130, 130, 130, 0, 0, 0, 0,
  34816, 0, 0, 0, 0, 0, 97, 0, 97, 97, 97, 97, 130, 0, 0, 34816, 34816, 0, 34816, 0, 0, 34816, 0, 0, 36352, 0, 0, 0, 0,
  0, 5748, 5748, 0, 0, 110, 0, 0, 0, 0, 0, 0, 133, 134, 36352, 36352, 36352, 0, 36352, 36352, 36352, 0, 36352, 36352,
  36352, 36352, 36352, 36352, 36352, 36352, 36352, 36352, 36352, 36352, 0, 0, 0, 0, 1112, 1112, 115, 5748, 16896, 18432,
  0, 0, 0, 171, 0, 0, 171, 171, 171, 171, 0, 0, 0, 0, 0, 0, 0, 110, 12288, 0, 0, 0, 12288, 0, 0, 0, 146, 147, 147, 103,
  103, 0, 12288, 12288, 0, 12288, 12288, 0, 12288, 12288, 0, 0, 0, 0, 0, 0, 0, 223, 224, 12288, 12288, 12288, 12288, 0,
  0, 0, 0, 3704, 0, 3704, 3704
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  31, 39, 47, 204, 55, 63, 71, 86, 78, 94, 102, 110, 118, 126, 134, 141, 149, 164, 156, 172, 181, 189, 197, 230, 212,
  220, 226, 173, 173, 173, 238, 241, 347, 252, 261, 458, 279, 283, 293, 297, 301, 305, 309, 313, 317, 318, 322, 325,
  329, 333, 337, 341, 345, 351, 264, 376, 577, 453, 575, 356, 534, 422, 384, 404, 571, 456, 285, 354, 382, 389, 573,
  576, 248, 388, 288, 393, 247, 402, 288, 273, 431, 289, 429, 419, 430, 275, 577, 408, 288, 577, 429, 287, 414, 430,
  274, 426, 427, 428, 426, 427, 428, 435, 436, 636, 563, 440, 592, 378, 446, 450, 462, 466, 470, 474, 478, 482, 486,
  490, 494, 498, 502, 506, 510, 514, 523, 583, 591, 562, 527, 531, 540, 577, 577, 544, 270, 536, 548, 552, 593, 577,
  557, 577, 267, 578, 441, 561, 557, 577, 568, 584, 556, 577, 616, 598, 555, 590, 616, 609, 604, 617, 610, 256, 577,
  257, 582, 588, 616, 582, 588, 615, 597, 603, 256, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 517,
  577, 397, 599, 577, 614, 577, 577, 577, 628, 621, 622, 626, 365, 371, 368, 632, 372, 634, 577, 358, 415, 519, 605,
  362, 410, 244, 577, 442, 577, 577, 577, 394, 577, 564, 577, 577, 577, 577, 577, 395, 577, 577, 397, 577, 577, 577,
  396, 577, 577, 398, 255, 577, 577, 577, 578, 4, 256, 1073741824, 0, 0, 196608, 0, 0, 2097152, 4096, 4194304,
  1073741828, 4, 4, 4, 0, 0, 0, 65536, 0, 16777728, 49152, 8404992, 16384, 16384, 16384, 32768, 0, 0, 229376, 0, 6144,
  0, 0, 2097152, 4194304, 524288, 524288, 12, 1073750020, 4, 2113536, 8404992, 268451840, 16384, 16384, 0, 0, 0,
  1048576, 1048576, 0, 16418, 16386, 4, 7296, 12599296, 16418, 7296, 7296, 12599296, 16434, 16448, 540722, 49216,
  8405042, 8405042, 167788706, 8405042, 8405042, 436224162, 8601650, 402866210, 8405106, 75710514, 403718178,
  -2012200926, 135282722, 135282722, 135282722, 8437874, 277037106, 176373938, 243482802, 411254834, 142819378,
  511918258, 411254834, 511918258, 511918258, 411254834, 511918258, -1743765470, 1048789170, 1048789170, 948125746,
  948125810, 1048789170, 948125810, 1048789234, 1048822002, 1048789234, 948125810, 1048822002, 4, 1073741824, 0, 2,
  262148, 16777220, 2, 262148, 262144, 0, 8, 0, 0, 8, 8, 8192, 1073750016, 6272, 4194304, 16, 64, 8, 72, 72, 64, 112,
  64, 72, 64, 64, 64, 1048578, 0, -2147483648, 0, -2147483648, 4194304, 2097152, 4096, 4224, 4194304, 16, 64, 16, 16,
  524290, 0, 0, 1048576, 0, 0, 0, 1, 0, 0, 0, 2, 4096, 4194304, 524290, 0, 128, 128, 2097152, 4194304, 524290, 0, 16384,
  128, 1048576, 0, 0, 2097152, 0, 0, 1048576, 1048576, 2097152, 0, 2048, 4224, 2097152, 4194304, 524288, 2097152,
  4194304, 524288, 524290, 0, 0, 2097152, 4194304, 4194304, 4194304, 0, 262144, 134217728, 0, 0, 0, 48, 0, 603979776,
  268435456, 16384, 0, 2097664, 1056768, -2147483648, 0, 0, 2, 0, 16384, 16384, 16384, 16386, -2147483136, 1073741824,
  0, -2147483648, -2147483616, 16777216, 33554432, -2147483616, -2147467264, 3154432, -2147467264, 3154432, -2147450848,
  -2147450720, -2139095008, -2146394080, -2147254144, -2139095008, -2147450720, -2147467200, -2144296416, -2147450720,
  -2139088896, -2139088896, -2139088895, -2139088892, -2139088888, -2139088864, -2139087872, -2122311680, -2144296416,
  -2147254080, -2139062112, -2139062112, -2147237696, -2147237760, -2147237696, -2139062112, -2147237696, -2139062096,
  -2139061600, -2146713408, -2139061584, -2122310611, -2136964942, -2136964446, -2144616254, -2145140030, -2136964430,
  -2144615742, -2135907678, -2135907678, -2135907662, -2143559454, -2135907662, 0, 128, 0, 0, 32, 32, 0, 4194304, 0,
  -2147483648, 4194304, 0, 0, 67108864, 536870912, 0, 16384, 8192, 8192, 0, 0, 1, 4, 1048576, 0, 0, 1073741824, 32768,
  128, 0, 40960, 8, 245760, 524288, 1, 12, 253952, -2147483648, 134217728, 268435456, 0, 67108864, 536870912, 0, 0,
  268435456, -2147483648, 0, 0, 0, 4, 0, 32768, 196608, 0, 65536, 131072, 1048578, 0, 16384, 0, 0, 0, 0, -2147483648,
  131072, 0, 0, 134217728, 0, 0, 268435456, 67108864, 536870912, 0, 0, 0, 512, 268435456, -2147483648, 65536, 131072, 0,
  0, 0, 64, 268435456, 67108864, 0, 0, 0, 2048, 131072, 0, 0, 268435456, 0, 6, 0, 0, 0, 32768, 65536, 131072, 64, 112,
  112, 112, 112, 112, 0, 64, 64, 72, 0, 64, 72, 72, 64, 0, 0, 256, 4194304
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "Name",
  "Space",
  "DirPIContents",
  "Number",
  "StringLiteral",
  "CaretName",
  "CharCode",
  "TokenIdentifier",
  "Blank",
  "Char",
  "CharRange",
  "CharCodeRange",
  "PragmaContents",
  "S",
  "'\\'",
  "'[VC'",
  "'[WFC'",
  "NonRBrackedContents",
  "BeginOfGrammar",
  "Sem",
  "Semantic",
  "EndOfGrammar",
  "EOF",
  "'""'",
  "'$'",
  "'&amp;'",
  "'('",
  "')'",
  "'*'",
  "'*/'",
  "'*>'",
  "'*}'",
  "'+'",
  "'+>'",
  "'+}'",
  "'-'",
  "'.'",
  "'/'",
  "'/*'",
  "':'",
  "'::='",
  "';'",
  "'<*'",
  "'<+'",
  "'<<'",
  "'<?'",
  "'<?ENCORE?>'",
  "'<?TERMINALS?>'",
  "'<?TOKENS?>'",
  "'='",
  "'=>'",
  "'>>'",
  "'?'",
  "'?>'",
  "'['",
  "']'",
  "'^'",
  "'definition'",
  "'disallow'",
  "'end_of_rule'",
  "'explicit'",
  "'gn'",
  "'rule'",
  "'syntax'",
  "'ws'",
  "'xgs'",
  "'{'",
  "'{*'",
  "'{+'",
  "'|'",
  "'}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 512,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 512
    let $end := $end - $result idiv 128
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 128 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 512 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 8
    let $next-state := $p:TRANSITION[$i0 mod 8 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 511) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 512, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 2
    let $i0 := $t * 323 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 8
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 8 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : Parse PhythiaItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: StringLiteral :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 43) then                       (: '<*' :)
      let $state := p:consume(43, $input, $state)           (: '<*' :)
      let $state := p:lookahead1W(57, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | ';' | '<*' |
                                                               '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(42, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(52, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | '*>' |
                                                               '<*' | '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(31, $input, $state)           (: '*>' :)
      return $state
    else if ($state[$p:l1] = 44) then                       (: '<+' :)
      let $state := p:consume(44, $input, $state)           (: '<+' :)
      let $state := p:lookahead1W(57, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | ';' | '<*' |
                                                               '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(42, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(54, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | '+>' |
                                                               '<*' | '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(34, $input, $state)           (: '+>' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: '{*' :)
      let $state := p:consume(68, $input, $state)           (: '{*' :)
      let $state := p:lookahead1W(53, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | '*}' |
                                                               '<*' | '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(32, $input, $state)           (: '*}' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: '{+' :)
      let $state := p:consume(69, $input, $state)           (: '{+' :)
      let $state := p:lookahead1W(55, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | '+}' |
                                                               '<*' | '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(35, $input, $state)           (: '+}' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '[' :)
      let $state := p:consume(55, $input, $state)           (: '[' :)
      let $state := p:lookahead1W(58, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | '<*' |
                                                               '<+' | '[' | ']' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(56, $input, $state)           (: ']' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '(' :)
      let $state := p:consume(27, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(51, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | ')' | '<*' |
                                                               '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaChoice($input, $state)
      let $state := p:consume(28, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: Sem :)
      let $state := p:consume(20, $input, $state)           (: Sem :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PhythiaItem", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PhythiaSequence (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaSequence-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(72, $input, $state)         (: Name^Token | StringLiteral | S | Sem | '(' | ')' | '*>' |
                                                               '*}' | '+>' | '+}' | '.' | ';' | '<*' | '<+' | '[' |
                                                               ']' | 'rule' | '{*' | '{+' | '|' :)
    return
      if ($state[$p:l1] = 28                                (: ')' :)
       or $state[$p:l1] = 31                                (: '*>' :)
       or $state[$p:l1] = 32                                (: '*}' :)
       or $state[$p:l1] = 34                                (: '+>' :)
       or $state[$p:l1] = 35                                (: '+}' :)
       or $state[$p:l1] = 37                                (: '.' :)
       or $state[$p:l1] = 42                                (: ';' :)
       or $state[$p:l1] = 56                                (: ']' :)
       or $state[$p:l1] = 70) then                          (: '|' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-PhythiaItem($input, $state)
        return p:parse-PhythiaSequence-1($input, $state)
};

(:~
 : Parse PhythiaSequence.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PhythiaSequence-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PhythiaSequence", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PhythiaChoice (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaChoice-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 70) then                           (: '|' :)
      $state
    else
      let $state := p:consume(70, $input, $state)           (: '|' :)
      let $state := p:lookahead1W(72, $input, $state)       (: Name^Token | StringLiteral | S | Sem | '(' | ')' | '*>' |
                                                               '*}' | '+>' | '+}' | '.' | ';' | '<*' | '<+' | '[' |
                                                               ']' | 'rule' | '{*' | '{+' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaSequence($input, $state)
      return p:parse-PhythiaChoice-1($input, $state)
};

(:~
 : Parse PhythiaChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaChoice($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PhythiaSequence($input, $state)
  let $state := p:parse-PhythiaChoice-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PhythiaChoice", $count, $begin, $end)
};

(:~
 : Parse PhythiaProduction.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaProduction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(63, $input, $state)               (: 'rule' :)
  let $state := p:lookahead1W(19, $input, $state)           (: Name^Token | S | 'rule' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:lookahead1W(18, $input, $state)           (: S | 'syntax' :)
  let $state := p:consume(64, $input, $state)               (: 'syntax' :)
  let $state := p:lookahead1W(19, $input, $state)           (: Name^Token | S | 'rule' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:lookahead1W(15, $input, $state)           (: S | '::=' :)
  let $state := p:consume(41, $input, $state)               (: '::=' :)
  let $state := p:lookahead1W(56, $input, $state)           (: Name^Token | StringLiteral | S | Sem | '(' | '.' | '<*' |
                                                               '<+' | '[' | 'rule' | '{*' | '{+' | '|' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PhythiaChoice($input, $state)
  let $state := p:consume(37, $input, $state)               (: '.' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S | Semantic | 'end_of_rule' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: Semantic :)
      let $state := p:consume(21, $input, $state)           (: Semantic :)
      return $state
    else
      $state
  let $state := p:lookahead1W(16, $input, $state)           (: S | 'end_of_rule' :)
  let $state := p:consume(60, $input, $state)               (: 'end_of_rule' :)
  let $state := p:lookahead1W(19, $input, $state)           (: Name^Token | S | 'rule' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:lookahead1W(36, $input, $state)           (: S | EndOfGrammar | EOF | '.' | 'rule' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '.' :)
      let $state := p:consume(37, $input, $state)           (: '.' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PhythiaProduction", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PhythiaGrammar (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaGrammar-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(17, $input, $state)         (: S | 'rule' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-PhythiaProduction($input, $state)
    let $state := p:lookahead1W(32, $input, $state)         (: S | EndOfGrammar | EOF | 'rule' :)
    return
      if ($state[$p:l1] != 63) then                         (: 'rule' :)
        $state
      else
        p:parse-PhythiaGrammar-1($input, $state)
};

(:~
 : Parse PhythiaGrammar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PhythiaGrammar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: BeginOfGrammar :)
      let $state := p:consume(19, $input, $state)           (: BeginOfGrammar :)
      return $state
    else
      $state
  let $state := p:parse-PhythiaGrammar-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: EndOfGrammar :)
      let $state := p:consume(22, $input, $state)           (: EndOfGrammar :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PhythiaGrammar", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Delimiter (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Delimiter-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: Name^Token | StringLiteral | S | 'rule' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-NameOrString($input, $state)
    let $state := p:lookahead1W(41, $input, $state)         (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<?ENCORE?>' | 'rule' :)
    let $state :=
      if ($state[$p:l1] eq 5) then                          (: StringLiteral :)
        let $state := p:lookahead2W(49, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               EOF | '.' | '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' |
                                                               'rule' :)
        let $state :=
          if ($state[$p:lk] eq 773) then                    (: StringLiteral CaretName :)
            let $state := p:lookahead3W(44, $input, $state) (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<<' | '<?ENCORE?>' | '>>' | 'rule' :)
            return $state
          else
            $state
        return $state
      else if ($state[$p:l1] = (1,                          (: Name^Token :)
                                63)) then                   (: 'rule' :)
        let $state := p:lookahead2W(59, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               DoubleBackslash | EOF | '.' | '::=' | '<<' |
                                                               '<?ENCORE?>' | '>>' | '?' | 'rule' :)
        let $state :=
          if ($state[$p:lk] = (769,                         (: Name^Token CaretName :)
                               831)) then                   (: 'rule' CaretName :)
            let $state := p:lookahead3W(44, $input, $state) (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<<' | '<?ENCORE?>' | '>>' | 'rule' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 4                                 (: Number :)
       or $state[$p:lk] = 23                                (: EOF :)
       or $state[$p:lk] = 37                                (: '.' :)
       or $state[$p:lk] = 47                                (: '<?ENCORE?>' :)
       or $state[$p:lk] = 1921                              (: Name^Token DoubleBackslash :)
       or $state[$p:lk] = 1983                              (: 'rule' DoubleBackslash :)
       or $state[$p:lk] = 5249                              (: Name^Token '::=' :)
       or $state[$p:lk] = 5253                              (: StringLiteral '::=' :)
       or $state[$p:lk] = 5311                              (: 'rule' '::=' :)
       or $state[$p:lk] = 5761                              (: Name^Token '<<' :)
       or $state[$p:lk] = 5765                              (: StringLiteral '<<' :)
       or $state[$p:lk] = 5823                              (: 'rule' '<<' :)
       or $state[$p:lk] = 6657                              (: Name^Token '>>' :)
       or $state[$p:lk] = 6661                              (: StringLiteral '>>' :)
       or $state[$p:lk] = 6719                              (: 'rule' '>>' :)
       or $state[$p:lk] = 6785                              (: Name^Token '?' :)
       or $state[$p:lk] = 6789                              (: StringLiteral '?' :)
       or $state[$p:lk] = 6847                              (: 'rule' '?' :)
       or $state[$p:lk] = 738049                            (: Name^Token CaretName '<<' :)
       or $state[$p:lk] = 738053                            (: StringLiteral CaretName '<<' :)
       or $state[$p:lk] = 738111                            (: 'rule' CaretName '<<' :)
       or $state[$p:lk] = 852737                            (: Name^Token CaretName '>>' :)
       or $state[$p:lk] = 852741                            (: StringLiteral CaretName '>>' :)
       or $state[$p:lk] = 852799) then                      (: 'rule' CaretName '>>' :)
        $state
      else
        p:parse-Delimiter-1($input, $state)
};

(:~
 : Parse Delimiter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Delimiter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:lookahead1W(13, $input, $state)           (: S | DoubleBackslash :)
  let $state := p:consume(15, $input, $state)               (: DoubleBackslash :)
  let $state := p:parse-Delimiter-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Delimiter", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Preference (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Preference-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: Name^Token | StringLiteral | S | 'rule' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-NameOrString($input, $state)
    let $state := p:lookahead1W(41, $input, $state)         (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<?ENCORE?>' | 'rule' :)
    let $state :=
      if ($state[$p:l1] eq 5) then                          (: StringLiteral :)
        let $state := p:lookahead2W(49, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               EOF | '.' | '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' |
                                                               'rule' :)
        let $state :=
          if ($state[$p:lk] eq 773) then                    (: StringLiteral CaretName :)
            let $state := p:lookahead3W(44, $input, $state) (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<<' | '<?ENCORE?>' | '>>' | 'rule' :)
            return $state
          else
            $state
        return $state
      else if ($state[$p:l1] = (1,                          (: Name^Token :)
                                63)) then                   (: 'rule' :)
        let $state := p:lookahead2W(59, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               DoubleBackslash | EOF | '.' | '::=' | '<<' |
                                                               '<?ENCORE?>' | '>>' | '?' | 'rule' :)
        let $state :=
          if ($state[$p:lk] = (769,                         (: Name^Token CaretName :)
                               831)) then                   (: 'rule' CaretName :)
            let $state := p:lookahead3W(44, $input, $state) (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<<' | '<?ENCORE?>' | '>>' | 'rule' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 4                                 (: Number :)
       or $state[$p:lk] = 23                                (: EOF :)
       or $state[$p:lk] = 37                                (: '.' :)
       or $state[$p:lk] = 47                                (: '<?ENCORE?>' :)
       or $state[$p:lk] = 1921                              (: Name^Token DoubleBackslash :)
       or $state[$p:lk] = 1983                              (: 'rule' DoubleBackslash :)
       or $state[$p:lk] = 5249                              (: Name^Token '::=' :)
       or $state[$p:lk] = 5253                              (: StringLiteral '::=' :)
       or $state[$p:lk] = 5311                              (: 'rule' '::=' :)
       or $state[$p:lk] = 5761                              (: Name^Token '<<' :)
       or $state[$p:lk] = 5765                              (: StringLiteral '<<' :)
       or $state[$p:lk] = 5823                              (: 'rule' '<<' :)
       or $state[$p:lk] = 6657                              (: Name^Token '>>' :)
       or $state[$p:lk] = 6661                              (: StringLiteral '>>' :)
       or $state[$p:lk] = 6719                              (: 'rule' '>>' :)
       or $state[$p:lk] = 6785                              (: Name^Token '?' :)
       or $state[$p:lk] = 6789                              (: StringLiteral '?' :)
       or $state[$p:lk] = 6847                              (: 'rule' '?' :)
       or $state[$p:lk] = 738049                            (: Name^Token CaretName '<<' :)
       or $state[$p:lk] = 738053                            (: StringLiteral CaretName '<<' :)
       or $state[$p:lk] = 738111                            (: 'rule' CaretName '<<' :)
       or $state[$p:lk] = 852737                            (: Name^Token CaretName '>>' :)
       or $state[$p:lk] = 852741                            (: StringLiteral CaretName '>>' :)
       or $state[$p:lk] = 852799) then                      (: 'rule' CaretName '>>' :)
        $state
      else
        p:parse-Preference-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Preference (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Preference-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: Name^Token | StringLiteral | S | 'rule' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-NameOrString($input, $state)
    let $state := p:lookahead1W(41, $input, $state)         (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<?ENCORE?>' | 'rule' :)
    let $state :=
      if ($state[$p:l1] eq 5) then                          (: StringLiteral :)
        let $state := p:lookahead2W(49, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               EOF | '.' | '::=' | '<<' | '<?ENCORE?>' | '>>' | '?' |
                                                               'rule' :)
        let $state :=
          if ($state[$p:lk] eq 773) then                    (: StringLiteral CaretName :)
            let $state := p:lookahead3W(44, $input, $state) (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<<' | '<?ENCORE?>' | '>>' | 'rule' :)
            return $state
          else
            $state
        return $state
      else if ($state[$p:l1] = (1,                          (: Name^Token :)
                                63)) then                   (: 'rule' :)
        let $state := p:lookahead2W(59, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               DoubleBackslash | EOF | '.' | '::=' | '<<' |
                                                               '<?ENCORE?>' | '>>' | '?' | 'rule' :)
        let $state :=
          if ($state[$p:lk] = (769,                         (: Name^Token CaretName :)
                               831)) then                   (: 'rule' CaretName :)
            let $state := p:lookahead3W(44, $input, $state) (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<<' | '<?ENCORE?>' | '>>' | 'rule' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 4                                 (: Number :)
       or $state[$p:lk] = 23                                (: EOF :)
       or $state[$p:lk] = 37                                (: '.' :)
       or $state[$p:lk] = 47                                (: '<?ENCORE?>' :)
       or $state[$p:lk] = 1921                              (: Name^Token DoubleBackslash :)
       or $state[$p:lk] = 1983                              (: 'rule' DoubleBackslash :)
       or $state[$p:lk] = 5249                              (: Name^Token '::=' :)
       or $state[$p:lk] = 5253                              (: StringLiteral '::=' :)
       or $state[$p:lk] = 5311                              (: 'rule' '::=' :)
       or $state[$p:lk] = 5761                              (: Name^Token '<<' :)
       or $state[$p:lk] = 5765                              (: StringLiteral '<<' :)
       or $state[$p:lk] = 5823                              (: 'rule' '<<' :)
       or $state[$p:lk] = 6657                              (: Name^Token '>>' :)
       or $state[$p:lk] = 6661                              (: StringLiteral '>>' :)
       or $state[$p:lk] = 6719                              (: 'rule' '>>' :)
       or $state[$p:lk] = 6785                              (: Name^Token '?' :)
       or $state[$p:lk] = 6789                              (: StringLiteral '?' :)
       or $state[$p:lk] = 6847                              (: 'rule' '?' :)
       or $state[$p:lk] = 738049                            (: Name^Token CaretName '<<' :)
       or $state[$p:lk] = 738053                            (: StringLiteral CaretName '<<' :)
       or $state[$p:lk] = 738111                            (: 'rule' CaretName '<<' :)
       or $state[$p:lk] = 852737                            (: Name^Token CaretName '>>' :)
       or $state[$p:lk] = 852741                            (: StringLiteral CaretName '>>' :)
       or $state[$p:lk] = 852799) then                      (: 'rule' CaretName '>>' :)
        $state
      else
        p:parse-Preference-2($input, $state)
};

(:~
 : Parse Preference.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Preference($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NameOrString($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S | '<<' | '>>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: '>>' :)
      let $state := p:consume(52, $input, $state)           (: '>>' :)
      let $state := p:parse-Preference-1($input, $state)
      return $state
    else
      let $state := p:consume(45, $input, $state)           (: '<<' :)
      let $state := p:parse-Preference-2($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Preference", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production CharClass (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CharClass-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(31, $input, $state)          (: CharCode | Char | CharRange | CharCodeRange :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 10) then                     (: Char :)
        let $state := p:consume(10, $input, $state)         (: Char :)
        return $state
      else if ($state[$p:l1] = 7) then                      (: CharCode :)
        let $state := p:consume(7, $input, $state)          (: CharCode :)
        return $state
      else if ($state[$p:l1] = 11) then                     (: CharRange :)
        let $state := p:consume(11, $input, $state)         (: CharRange :)
        return $state
      else
        let $state := p:consume(12, $input, $state)         (: CharCodeRange :)
        return $state
    let $state := p:lookahead1(34, $input, $state)          (: CharCode | Char | CharRange | CharCodeRange | ']' :)
    return
      if ($state[$p:l1] = 56) then                          (: ']' :)
        $state
      else
        p:parse-CharClass-1($input, $state)
};

(:~
 : Parse CharClass.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CharClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(55, $input, $state)               (: '[' :)
  let $state := p:lookahead1(35, $input, $state)            (: CharCode | Char | CharRange | CharCodeRange | '^' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 57) then                       (: '^' :)
      let $state := p:consume(57, $input, $state)           (: '^' :)
      return $state
    else
      $state
  let $state := p:parse-CharClass-1($input, $state)
  let $state := p:consume(56, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CharClass", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LexicalChoice (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalChoice-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(25, $input, $state)         (: S | ')' | '|' :)
    return
      if ($state[$p:l1] != 70) then                         (: '|' :)
        $state
      else
        let $state := p:consume(70, $input, $state)         (: '|' :)
        let $state := p:lookahead1W(46, $input, $state)     (: Name^Token | StringLiteral | CharCode | S | '$' | '(' |
                                                               ')' | '.' | '[' | 'rule' | '|' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-LexicalSequence($input, $state)
        return p:parse-LexicalChoice-1($input, $state)
};

(:~
 : Parse LexicalChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalChoice($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-LexicalSequence($input, $state)
  let $state := p:parse-LexicalChoice-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LexicalChoice", $count, $begin, $end)
};

(:~
 : Parse LexicalPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: StringLiteral :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '(' :)
      let $state := p:consume(27, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(46, $input, $state)       (: Name^Token | StringLiteral | CharCode | S | '$' | '(' |
                                                               ')' | '.' | '[' | 'rule' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LexicalChoice($input, $state)
      let $state := p:consume(28, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '$' :)
      let $state := p:consume(25, $input, $state)           (: '$' :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: CharCode :)
      let $state := p:consume(7, $input, $state)            (: CharCode :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CharClass($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: '.' :)
          let $state := p:consume(37, $input, $state)       (: '.' :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Name($input, $state)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "LexicalPrimary", $count, $begin, $end)
};

(:~
 : Parse LexicalItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-LexicalPrimary($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '*' | '+' | '-' |
                                                               '.' | '/*' | '<?ENCORE?>' | '?' | '[' | 'rule' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29                             (: '*' :)
          or $state[$p:l1] = 33                             (: '+' :)
          or $state[$p:l1] = 53) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 53) then                   (: '?' :)
          let $state := p:consume(53, $input, $state)       (: '?' :)
          return $state
        else if ($state[$p:l1] = 29) then                   (: '*' :)
          let $state := p:consume(29, $input, $state)       (: '*' :)
          return $state
        else
          let $state := p:consume(33, $input, $state)       (: '+' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "LexicalItem", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LexicalSequence (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalSequence-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(66, $input, $state)         (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '.' | '/*' |
                                                               '<?ENCORE?>' | '[' | 'rule' | '|' :)
    let $state :=
      if ($state[$p:l1] eq 5) then                          (: StringLiteral :)
        let $state := p:lookahead2W(79, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName |
                                                               CharCode | S | VC | WFC | EOF | '$' | '&' | '(' | ')' |
                                                               '*' | '+' | '.' | '/*' | '::=' | '<<' | '<?ENCORE?>' |
                                                               '>>' | '?' | '[' | 'rule' | '|' :)
        let $state :=
          if ($state[$p:lk] eq 6789) then                   (: StringLiteral '?' :)
            let $state := p:lookahead3W(69, $input, $state) (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '.' | '/*' | '::=' |
                                                               '<?ENCORE?>' | '[' | 'rule' | '|' :)
            return $state
          else
            $state
        return $state
      else if ($state[$p:l1] eq 37) then                    (: '.' :)
        let $state := p:lookahead2W(74, $input, $state)     (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '*' | '+' | '.' |
                                                               '/*' | '::=' | '<?ENCORE?>' | '?' | '[' | 'rule' | '|' :)
        let $state :=
          if ($state[$p:lk] eq 6821) then                   (: '.' '?' :)
            let $state := p:lookahead3W(69, $input, $state) (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '.' | '/*' | '::=' |
                                                               '<?ENCORE?>' | '[' | 'rule' | '|' :)
            return $state
          else
            $state
        return $state
      else if ($state[$p:l1] = (1,                          (: Name^Token :)
                                63)) then                   (: 'rule' :)
        let $state := p:lookahead2W(80, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName |
                                                               CharCode | S | DoubleBackslash | VC | WFC | EOF | '$' |
                                                               '&' | '(' | ')' | '*' | '+' | '.' | '/*' | '::=' | '<<' |
                                                               '<?ENCORE?>' | '>>' | '?' | '[' | 'rule' | '|' :)
        let $state :=
          if ($state[$p:lk] = (6785,                        (: Name^Token '?' :)
                               6847)) then                  (: 'rule' '?' :)
            let $state := p:lookahead3W(69, $input, $state) (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '.' | '/*' | '::=' |
                                                               '<?ENCORE?>' | '[' | 'rule' | '|' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 4                                 (: Number :)
       or $state[$p:lk] = 16                                (: VC :)
       or $state[$p:lk] = 17                                (: WFC :)
       or $state[$p:lk] = 23                                (: EOF :)
       or $state[$p:lk] = 26                                (: '&' :)
       or $state[$p:lk] = 28                                (: ')' :)
       or $state[$p:lk] = 39                                (: '/*' :)
       or $state[$p:lk] = 47                                (: '<?ENCORE?>' :)
       or $state[$p:lk] = 70                                (: '|' :)
       or $state[$p:lk] = 769                               (: Name^Token CaretName :)
       or $state[$p:lk] = 773                               (: StringLiteral CaretName :)
       or $state[$p:lk] = 831                               (: 'rule' CaretName :)
       or $state[$p:lk] = 1921                              (: Name^Token DoubleBackslash :)
       or $state[$p:lk] = 1983                              (: 'rule' DoubleBackslash :)
       or $state[$p:lk] = 5249                              (: Name^Token '::=' :)
       or $state[$p:lk] = 5253                              (: StringLiteral '::=' :)
       or $state[$p:lk] = 5285                              (: '.' '::=' :)
       or $state[$p:lk] = 5311                              (: 'rule' '::=' :)
       or $state[$p:lk] = 5761                              (: Name^Token '<<' :)
       or $state[$p:lk] = 5765                              (: StringLiteral '<<' :)
       or $state[$p:lk] = 5823                              (: 'rule' '<<' :)
       or $state[$p:lk] = 6657                              (: Name^Token '>>' :)
       or $state[$p:lk] = 6661                              (: StringLiteral '>>' :)
       or $state[$p:lk] = 6719                              (: 'rule' '>>' :)
       or $state[$p:lk] = 678529                            (: Name^Token '?' '::=' :)
       or $state[$p:lk] = 678533                            (: StringLiteral '?' '::=' :)
       or $state[$p:lk] = 678565                            (: '.' '?' '::=' :)
       or $state[$p:lk] = 678591) then                      (: 'rule' '?' '::=' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-LexicalItem($input, $state)
        return p:parse-LexicalSequence-1($input, $state)
};

(:~
 : Parse LexicalSequence.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 5) then                            (: StringLiteral :)
      let $state := p:lookahead2W(81, $input, $state)       (: Name^Token | Number | StringLiteral | CaretName |
                                                               CharCode | S | VC | WFC | EOF | '$' | '&' | '(' | ')' |
                                                               '*' | '+' | '-' | '.' | '/*' | '::=' | '<<' |
                                                               '<?ENCORE?>' | '>>' | '?' | '[' | 'rule' | '|' :)
      let $state :=
        if ($state[$p:lk] eq 6789) then                     (: StringLiteral '?' :)
          let $state := p:lookahead3W(71, $input, $state)   (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '-' | '.' | '/*' |
                                                               '::=' | '<?ENCORE?>' | '[' | 'rule' | '|' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 37) then                      (: '.' :)
      let $state := p:lookahead2W(77, $input, $state)       (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '*' | '+' | '-' |
                                                               '.' | '/*' | '::=' | '<?ENCORE?>' | '?' | '[' | 'rule' |
                                                               '|' :)
      let $state :=
        if ($state[$p:lk] eq 6821) then                     (: '.' '?' :)
          let $state := p:lookahead3W(71, $input, $state)   (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '-' | '.' | '/*' |
                                                               '::=' | '<?ENCORE?>' | '[' | 'rule' | '|' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (1,                            (: Name^Token :)
                              63)) then                     (: 'rule' :)
      let $state := p:lookahead2W(83, $input, $state)       (: Name^Token | Number | StringLiteral | CaretName |
                                                               CharCode | S | DoubleBackslash | VC | WFC | EOF | '$' |
                                                               '&' | '(' | ')' | '*' | '+' | '-' | '.' | '/*' | '::=' |
                                                               '<<' | '<?ENCORE?>' | '>>' | '?' | '[' | 'rule' | '|' :)
      let $state :=
        if ($state[$p:lk] = (6785,                          (: Name^Token '?' :)
                             6847)) then                    (: 'rule' '?' :)
          let $state := p:lookahead3W(71, $input, $state)   (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '-' | '.' | '/*' |
                                                               '::=' | '<?ENCORE?>' | '[' | 'rule' | '|' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 4                              (: Number :)
          or $state[$p:lk] = 16                             (: VC :)
          or $state[$p:lk] = 17                             (: WFC :)
          or $state[$p:lk] = 23                             (: EOF :)
          or $state[$p:lk] = 26                             (: '&' :)
          or $state[$p:lk] = 28                             (: ')' :)
          or $state[$p:lk] = 39                             (: '/*' :)
          or $state[$p:lk] = 47                             (: '<?ENCORE?>' :)
          or $state[$p:lk] = 70                             (: '|' :)
          or $state[$p:lk] = 769                            (: Name^Token CaretName :)
          or $state[$p:lk] = 773                            (: StringLiteral CaretName :)
          or $state[$p:lk] = 831                            (: 'rule' CaretName :)
          or $state[$p:lk] = 1921                           (: Name^Token DoubleBackslash :)
          or $state[$p:lk] = 1983                           (: 'rule' DoubleBackslash :)
          or $state[$p:lk] = 5249                           (: Name^Token '::=' :)
          or $state[$p:lk] = 5253                           (: StringLiteral '::=' :)
          or $state[$p:lk] = 5285                           (: '.' '::=' :)
          or $state[$p:lk] = 5311                           (: 'rule' '::=' :)
          or $state[$p:lk] = 5761                           (: Name^Token '<<' :)
          or $state[$p:lk] = 5765                           (: StringLiteral '<<' :)
          or $state[$p:lk] = 5823                           (: 'rule' '<<' :)
          or $state[$p:lk] = 6657                           (: Name^Token '>>' :)
          or $state[$p:lk] = 6661                           (: StringLiteral '>>' :)
          or $state[$p:lk] = 6719                           (: 'rule' '>>' :)
          or $state[$p:lk] = 678529                         (: Name^Token '?' '::=' :)
          or $state[$p:lk] = 678533                         (: StringLiteral '?' '::=' :)
          or $state[$p:lk] = 678565                         (: '.' '?' '::=' :)
          or $state[$p:lk] = 678591) then                   (: 'rule' '?' '::=' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LexicalItem($input, $state)
      let $state := p:lookahead1W(68, $input, $state)       (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | ')' | '-' | '.' | '/*' |
                                                               '<?ENCORE?>' | '[' | 'rule' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 36) then                   (: '-' :)
          let $state := p:consume(36, $input, $state)       (: '-' :)
          let $state := p:lookahead1W(43, $input, $state)   (: Name^Token | StringLiteral | CharCode | S | '$' | '(' |
                                                               '.' | '[' | 'rule' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-LexicalItem($input, $state)
          return $state
        else
          let $state := p:parse-LexicalSequence-1($input, $state)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "LexicalSequence", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ContextExpression (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(47, $input, $state)         (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '.' | '/*' | '<?ENCORE?>' | 'rule' | '|' :)
    return
      if ($state[$p:l1] != 16                               (: VC :)
      and $state[$p:l1] != 17) then                         (: WFC :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Constraint($input, $state)
        return p:parse-ContextExpression-1($input, $state)
};

(:~
 : Parse ContextExpression.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-LexicalSequence($input, $state)
  let $state := p:lookahead1W(50, $input, $state)           (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '&' | '.' | '/*' | '<?ENCORE?>' | 'rule' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26) then                       (: '&' :)
      let $state := p:consume(26, $input, $state)           (: '&' :)
      let $state := p:lookahead1W(61, $input, $state)       (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '(' | '.' | '/*' | '<?ENCORE?>' | '[' |
                                                               'rule' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LexicalSequence($input, $state)
      return $state
    else
      $state
  let $state := p:parse-ContextExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextExpression", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ContextChoice (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextChoice-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 70) then                           (: '|' :)
      $state
    else
      let $state := p:consume(70, $input, $state)           (: '|' :)
      let $state := p:lookahead1W(62, $input, $state)       (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | '.' | '/*' | '<?ENCORE?>' |
                                                               '[' | 'rule' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextExpression($input, $state)
      return p:parse-ContextChoice-1($input, $state)
};

(:~
 : Parse ContextChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextChoice($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ContextExpression($input, $state)
  let $state := p:parse-ContextChoice-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextChoice", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LexicalProduction (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalProduction-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '/*' | '<?ENCORE?>' | 'rule' :)
    return
      if ($state[$p:l1] != 39) then                         (: '/*' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Option($input, $state)
        return p:parse-LexicalProduction-1($input, $state)
};

(:~
 : Parse LexicalProduction.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LexicalProduction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Number :)
      let $state := p:consume(4, $input, $state)            (: Number :)
      return $state
    else
      $state
  let $state := p:lookahead1W(33, $input, $state)           (: Name^Token | StringLiteral | S | '.' | 'rule' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '.' :)
      let $state := p:consume(37, $input, $state)           (: '.' :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: StringLiteral :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      return $state
  let $state := p:lookahead1W(26, $input, $state)           (: S | '::=' | '?' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '?' :)
      let $state := p:consume(53, $input, $state)           (: '?' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: S | '::=' :)
  let $state := p:consume(41, $input, $state)               (: '::=' :)
  let $state := p:lookahead1W(62, $input, $state)           (: Name^Token | Number | StringLiteral | CharCode | S | VC |
                                                               WFC | EOF | '$' | '&' | '(' | '.' | '/*' | '<?ENCORE?>' |
                                                               '[' | 'rule' | '|' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ContextChoice($input, $state)
  let $state := p:parse-LexicalProduction-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LexicalProduction", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Option (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Option-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(30, $input, $state)          (: Space | 'gn' | 'ws' | 'xgs' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-Option-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Option (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Option-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(22, $input, $state)          (: Space | 'definition' | 'explicit' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-Option-2($input, $state)
};

(:~
 : Parse the 3rd loop of production Option (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Option-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(8, $input, $state)           (: Space | '*/' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-Option-3($input, $state)
};

(:~
 : Parse the 4th loop of production Option (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Option-4($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: Space | PragmaContents | '*/' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-Option-4($input, $state)
};

(:~
 : Parse the 5th loop of production Option (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Option-5($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: Space | PragmaContents | '*/' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-Option-5($input, $state)
};

(:~
 : Parse Option.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Option($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(39, $input, $state)               (: '/*' :)
  let $state := p:parse-Option-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'ws' :)
      let $state := p:consume(65, $input, $state)           (: 'ws' :)
      let $state := p:lookahead1(3, $input, $state)         (: ':' :)
      let $state := p:consume(40, $input, $state)           (: ':' :)
      let $state := p:parse-Option-2($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 61) then                   (: 'explicit' :)
          let $state := p:consume(61, $input, $state)       (: 'explicit' :)
          return $state
        else
          let $state := p:consume(58, $input, $state)       (: 'definition' :)
          return $state
      let $state := p:parse-Option-3($input, $state)
      return $state
    else if ($state[$p:l1] = 62) then                       (: 'gn' :)
      let $state := p:consume(62, $input, $state)           (: 'gn' :)
      let $state := p:lookahead1(3, $input, $state)         (: ':' :)
      let $state := p:consume(40, $input, $state)           (: ':' :)
      let $state := p:parse-Option-4($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 13) then                   (: PragmaContents :)
          let $state := p:consume(13, $input, $state)       (: PragmaContents :)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consume(66, $input, $state)           (: 'xgs' :)
      let $state := p:lookahead1(3, $input, $state)         (: ':' :)
      let $state := p:consume(40, $input, $state)           (: ':' :)
      let $state := p:parse-Option-5($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 13) then                   (: PragmaContents :)
          let $state := p:consume(13, $input, $state)       (: PragmaContents :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1(2, $input, $state)             (: '*/' :)
  let $state := p:consume(30, $input, $state)               (: '*/' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Option", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Constraint (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constraint-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(6, $input, $state)           (: Space | NonRBrackedContents :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-Constraint-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Constraint (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constraint-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(6, $input, $state)           (: Space | NonRBrackedContents :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-Constraint-2($input, $state)
};

(:~
 : Parse Constraint.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constraint($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: VC :)
      let $state := p:consume(16, $input, $state)           (: VC :)
      let $state := p:lookahead1(3, $input, $state)         (: ':' :)
      let $state := p:consume(40, $input, $state)           (: ':' :)
      let $state := p:parse-Constraint-1($input, $state)
      let $state := p:consume(18, $input, $state)           (: NonRBrackedContents :)
      return $state
    else
      let $state := p:consume(17, $input, $state)           (: WFC :)
      let $state := p:lookahead1(3, $input, $state)         (: ':' :)
      let $state := p:consume(40, $input, $state)           (: ':' :)
      let $state := p:parse-Constraint-2($input, $state)
      let $state := p:consume(18, $input, $state)           (: NonRBrackedContents :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Constraint", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DisAllow (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DisAllow-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(10, $input, $state)          (: Space | 'disallow' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-DisAllow-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DisAllow (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DisAllow-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(9, $input, $state)           (: Space | '=' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-DisAllow-2($input, $state)
};

(:~
 : Parse the 3rd loop of production DisAllow (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DisAllow-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(7, $input, $state)           (: Space | '"' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-DisAllow-3($input, $state)
};

(:~
 : Parse the 4th loop of production DisAllow (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DisAllow-4($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(12, $input, $state)          (: Blank | '"' :)
    return
      if ($state[$p:l1] != 9) then                          (: Blank :)
        $state
      else
        let $state := p:consume(9, $input, $state)          (: Blank :)
        let $state := p:lookahead1(1, $input, $state)       (: TokenIdentifier :)
        let $state := p:consume(8, $input, $state)          (: TokenIdentifier :)
        return p:parse-DisAllow-4($input, $state)
};

(:~
 : Parse the 5th loop of production DisAllow (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DisAllow-5($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(11, $input, $state)          (: Space | '}' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        let $state := p:consume(2, $input, $state)          (: Space :)
        return p:parse-DisAllow-5($input, $state)
};

(:~
 : Parse DisAllow.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DisAllow($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(67, $input, $state)               (: '{' :)
  let $state := p:parse-DisAllow-1($input, $state)
  let $state := p:consume(59, $input, $state)               (: 'disallow' :)
  let $state := p:parse-DisAllow-2($input, $state)
  let $state := p:consume(50, $input, $state)               (: '=' :)
  let $state := p:parse-DisAllow-3($input, $state)
  let $state := p:consume(24, $input, $state)               (: '"' :)
  let $state := p:lookahead1(1, $input, $state)             (: TokenIdentifier :)
  let $state := p:consume(8, $input, $state)                (: TokenIdentifier :)
  let $state := p:parse-DisAllow-4($input, $state)
  let $state := p:consume(24, $input, $state)               (: '"' :)
  let $state := p:parse-DisAllow-5($input, $state)
  let $state := p:consume(71, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DisAllow", $count, $begin, $end)
};

(:~
 : Parse Context.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Context($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(6, $input, $state)                (: CaretName :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Context", $count, $begin, $end)
};

(:~
 : Parse NameOrString.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameOrString($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: StringLiteral :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      let $state := p:lookahead1W(82, $input, $state)       (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               VC | WFC | EOF | '(' | ')' | '*' | '+' | '.' | '/' |
                                                               '/*' | '<<' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' |
                                                               '<?TOKENS?>' | '=>' | '>>' | '?' | 'rule' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 6) then                    (: CaretName :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Context($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      let $state := p:lookahead1W(82, $input, $state)       (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               VC | WFC | EOF | '(' | ')' | '*' | '+' | '.' | '/' |
                                                               '/*' | '<<' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' |
                                                               '<?TOKENS?>' | '=>' | '>>' | '?' | 'rule' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 6) then                    (: CaretName :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Context($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameOrString", $count, $begin, $end)
};

(:~
 : Parse SyntaxPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27) then                       (: '(' :)
      let $state := p:consume(27, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(48, $input, $state)       (: Name^Token | StringLiteral | S | VC | WFC | '(' | ')' |
                                                               '/' | '<?' | 'rule' | '{' | '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SyntaxChoice($input, $state)
      let $state := p:consume(28, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 46) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ProcessingInstruction($input, $state)
      return $state
    else if ($state[$p:l1] = 67) then                       (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DisAllow($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameOrString($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SyntaxPrimary", $count, $begin, $end)
};

(:~
 : Parse SyntaxItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SyntaxPrimary($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '(' | ')' | '*' | '+' | '/' | '/*' | '<?' |
                                                               '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' | '=>' |
                                                               '?' | 'rule' | '{' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 29                             (: '*' :)
          or $state[$p:l1] = 33                             (: '+' :)
          or $state[$p:l1] = 53) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 53) then                   (: '?' :)
          let $state := p:consume(53, $input, $state)       (: '?' :)
          return $state
        else if ($state[$p:l1] = 29) then                   (: '*' :)
          let $state := p:consume(29, $input, $state)       (: '*' :)
          return $state
        else
          let $state := p:consume(33, $input, $state)       (: '+' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SyntaxItem", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SyntaxSequence (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxSequence-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(67, $input, $state)         (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '(' | ')' | '/' | '/*' | '<?' | '<?ENCORE?>' |
                                                               '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' | '{' | '|' :)
    let $state :=
      if ($state[$p:l1] = (1,                               (: Name^Token :)
                           5,                               (: StringLiteral :)
                           63)) then                        (: 'rule' :)
        let $state := p:lookahead2W(76, $input, $state)     (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               VC | WFC | EOF | '(' | ')' | '*' | '+' | '/' | '/*' |
                                                               '::=' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' |
                                                               '<?TOKENS?>' | '?' | 'rule' | '{' | '|' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 4                                 (: Number :)
       or $state[$p:lk] = 16                                (: VC :)
       or $state[$p:lk] = 17                                (: WFC :)
       or $state[$p:lk] = 23                                (: EOF :)
       or $state[$p:lk] = 28                                (: ')' :)
       or $state[$p:lk] = 38                                (: '/' :)
       or $state[$p:lk] = 39                                (: '/*' :)
       or $state[$p:lk] = 47                                (: '<?ENCORE?>' :)
       or $state[$p:lk] = 48                                (: '<?TERMINALS?>' :)
       or $state[$p:lk] = 49                                (: '<?TOKENS?>' :)
       or $state[$p:lk] = 70                                (: '|' :)
       or $state[$p:lk] = 5249                              (: Name^Token '::=' :)
       or $state[$p:lk] = 5253                              (: StringLiteral '::=' :)
       or $state[$p:lk] = 5311) then                        (: 'rule' '::=' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SyntaxItem($input, $state)
        return p:parse-SyntaxSequence-1($input, $state)
};

(:~
 : Parse the 2nd loop of production SyntaxSequence (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxSequence-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(60, $input, $state)         (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | ')' | '/' | '/*' | '<?ENCORE?>' | '<?TERMINALS?>' |
                                                               '<?TOKENS?>' | 'rule' | '|' :)
    return
      if ($state[$p:l1] != 16                               (: VC :)
      and $state[$p:l1] != 17) then                         (: WFC :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Constraint($input, $state)
        return p:parse-SyntaxSequence-2($input, $state)
};

(:~
 : Parse SyntaxSequence.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (1,                                 (: Name^Token :)
                         5,                                 (: StringLiteral :)
                         63)) then                          (: 'rule' :)
      let $state := p:lookahead2W(78, $input, $state)       (: Name^Token | Number | StringLiteral | CaretName | S |
                                                               VC | WFC | EOF | '(' | ')' | '*' | '+' | '/' | '/*' |
                                                               '::=' | '<?' | '<?ENCORE?>' | '<?TERMINALS?>' |
                                                               '<?TOKENS?>' | '=>' | '?' | 'rule' | '{' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 4                             (: Number :)
         and $state[$p:lk] != 16                            (: VC :)
         and $state[$p:lk] != 17                            (: WFC :)
         and $state[$p:lk] != 23                            (: EOF :)
         and $state[$p:lk] != 28                            (: ')' :)
         and $state[$p:lk] != 38                            (: '/' :)
         and $state[$p:lk] != 39                            (: '/*' :)
         and $state[$p:lk] != 47                            (: '<?ENCORE?>' :)
         and $state[$p:lk] != 48                            (: '<?TERMINALS?>' :)
         and $state[$p:lk] != 49                            (: '<?TOKENS?>' :)
         and $state[$p:lk] != 70                            (: '|' :)
         and $state[$p:lk] != 5249                          (: Name^Token '::=' :)
         and $state[$p:lk] != 5253                          (: StringLiteral '::=' :)
         and $state[$p:lk] != 5311) then                    (: 'rule' '::=' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SyntaxItem($input, $state)
      let $state := p:lookahead1W(70, $input, $state)       (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '(' | ')' | '/' | '/*' | '<?' | '<?ENCORE?>' |
                                                               '<?TERMINALS?>' | '<?TOKENS?>' | '=>' | 'rule' | '{' |
                                                               '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: '=>' :)
          let $state := p:consume(51, $input, $state)       (: '=>' :)
          return $state
        else
          $state
      let $state := p:parse-SyntaxSequence-1($input, $state)
      return $state
    else
      $state
  let $state := p:parse-SyntaxSequence-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SyntaxSequence", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SyntaxChoice (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxChoice-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(70, $input, $state)             (: '|' :)
    let $state := p:lookahead1W(64, $input, $state)         (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '(' | ')' | '/*' | '<?' | '<?ENCORE?>' |
                                                               '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' | '{' | '|' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SyntaxSequence($input, $state)
    return
      if ($state[$p:l1] != 70) then                         (: '|' :)
        $state
      else
        p:parse-SyntaxChoice-1($input, $state)
};

(:~
 : Parse the 2nd loop of production SyntaxChoice (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxChoice-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(38, $input, $state)             (: '/' :)
    let $state := p:lookahead1W(63, $input, $state)         (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '(' | ')' | '/' | '/*' | '<?' | '<?ENCORE?>' |
                                                               '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' | '{' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SyntaxSequence($input, $state)
    return
      if ($state[$p:l1] != 38) then                         (: '/' :)
        $state
      else
        p:parse-SyntaxChoice-2($input, $state)
};

(:~
 : Parse SyntaxChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxChoice($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SyntaxSequence($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38                             (: '/' :)
          or $state[$p:l1] = 70) then                       (: '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 70) then                   (: '|' :)
          let $state := p:parse-SyntaxChoice-1($input, $state)
          return $state
        else
          let $state := p:parse-SyntaxChoice-2($input, $state)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SyntaxChoice", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SyntaxProduction (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxProduction-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(45, $input, $state)         (: Name^Token | Number | StringLiteral | S | EOF | '/*' |
                                                               '<?ENCORE?>' | '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' :)
    return
      if ($state[$p:l1] != 39) then                         (: '/*' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Option($input, $state)
        return p:parse-SyntaxProduction-1($input, $state)
};

(:~
 : Parse SyntaxProduction.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SyntaxProduction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Number :)
      let $state := p:consume(4, $input, $state)            (: Number :)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: Name^Token | StringLiteral | S | 'rule' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: StringLiteral :)
      let $state := p:consume(5, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Name($input, $state)
      return $state
  let $state := p:lookahead1W(15, $input, $state)           (: S | '::=' :)
  let $state := p:consume(41, $input, $state)               (: '::=' :)
  let $state := p:lookahead1W(65, $input, $state)           (: Name^Token | Number | StringLiteral | S | VC | WFC |
                                                               EOF | '(' | '/' | '/*' | '<?' | '<?ENCORE?>' |
                                                               '<?TERMINALS?>' | '<?TOKENS?>' | 'rule' | '{' | '|' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SyntaxChoice($input, $state)
  let $state := p:parse-SyntaxProduction-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SyntaxProduction", $count, $begin, $end)
};

(:~
 : Parse Name.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Name($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(5, $input, $state)             (: Name^Token | 'rule' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'rule' :)
      let $state := p:consume(63, $input, $state)           (: 'rule' :)
      return $state
    else
      let $state := p:consume(1, $input, $state)            (: Name^Token :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Name", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ProcessingInstruction (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ProcessingInstruction-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(0, $input, $state)           (: Space :)
    let $state := p:consume(2, $input, $state)              (: Space :)
    let $state := p:lookahead1(20, $input, $state)          (: Space | DirPIContents | '?>' :)
    return
      if ($state[$p:l1] != 2) then                          (: Space :)
        $state
      else
        p:parse-ProcessingInstruction-1($input, $state)
};

(:~
 : Parse ProcessingInstruction.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ProcessingInstruction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(46, $input, $state)               (: '<?' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Name($input, $state)
  let $state := p:parse-ProcessingInstruction-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: DirPIContents :)
      let $state := p:consume(3, $input, $state)            (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '?>' :)
  let $state := p:consume(54, $input, $state)               (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ProcessingInstruction", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production W3CGrammar (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-W3CGrammar-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: Name^Token | Number | StringLiteral | S | '<?' | 'rule' :)
    return
      if ($state[$p:l1] != 46) then                         (: '<?' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ProcessingInstruction($input, $state)
        return p:parse-W3CGrammar-1($input, $state)
};

(:~
 : Parse the 2nd loop of production W3CGrammar (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-W3CGrammar-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SyntaxProduction($input, $state)
    return
      if ($state[$p:l1] != 1                                (: Name^Token :)
      and $state[$p:l1] != 4                                (: Number :)
      and $state[$p:l1] != 5                                (: StringLiteral :)
      and $state[$p:l1] != 63) then                         (: 'rule' :)
        $state
      else
        p:parse-W3CGrammar-2($input, $state)
};

(:~
 : Parse the 3rd loop of production W3CGrammar (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-W3CGrammar-3($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(41, $input, $state)         (: Name^Token | Number | StringLiteral | S | EOF | '.' |
                                                               '<?ENCORE?>' | 'rule' :)
    return
      if ($state[$p:l1] = 23                                (: EOF :)
       or $state[$p:l1] = 47) then                          (: '<?ENCORE?>' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 5) then                      (: StringLiteral :)
            let $state := p:lookahead2W(38, $input, $state) (: CaretName | S | '::=' | '<<' | '>>' | '?' :)
            return $state
          else if ($state[$p:l1] = (1,                      (: Name^Token :)
                                    63)) then               (: 'rule' :)
            let $state := p:lookahead2W(40, $input, $state) (: CaretName | S | DoubleBackslash | '::=' | '<<' | '>>' |
                                                               '?' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 4                        (: Number :)
                or $state[$p:lk] = 37                       (: '.' :)
                or $state[$p:lk] = 5249                     (: Name^Token '::=' :)
                or $state[$p:lk] = 5253                     (: StringLiteral '::=' :)
                or $state[$p:lk] = 5311                     (: 'rule' '::=' :)
                or $state[$p:lk] = 6785                     (: Name^Token '?' :)
                or $state[$p:lk] = 6789                     (: StringLiteral '?' :)
                or $state[$p:lk] = 6847) then               (: 'rule' '?' :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-LexicalProduction($input, $state)
            return $state
          else if ($state[$p:lk] = 1921                     (: Name^Token DoubleBackslash :)
                or $state[$p:lk] = 1983) then               (: 'rule' DoubleBackslash :)
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Delimiter($input, $state)
            return $state
          else
            let $state := p:whitespace($input, $state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Preference($input, $state)
            return $state
        return p:parse-W3CGrammar-3($input, $state)
};

(:~
 : Parse the 4th loop of production W3CGrammar (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-W3CGrammar-4($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(24, $input, $state)         (: S | EOF | '<?' :)
    return
      if ($state[$p:l1] != 46) then                         (: '<?' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ProcessingInstruction($input, $state)
        return p:parse-W3CGrammar-4($input, $state)
};

(:~
 : Parse W3CGrammar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-W3CGrammar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-W3CGrammar-1($input, $state)
  let $state := p:parse-W3CGrammar-2($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48                             (: '<?TERMINALS?>' :)
          or $state[$p:l1] = 49) then                       (: '<?TOKENS?>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 48) then                   (: '<?TERMINALS?>' :)
          let $state := p:consume(48, $input, $state)       (: '<?TERMINALS?>' :)
          return $state
        else
          let $state := p:consume(49, $input, $state)       (: '<?TOKENS?>' :)
          return $state
      let $state := p:parse-W3CGrammar-3($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: '<?ENCORE?>' :)
      let $state := p:consume(47, $input, $state)           (: '<?ENCORE?>' :)
      let $state := p:parse-W3CGrammar-4($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "W3CGrammar", $count, $begin, $end)
};

(:~
 : Parse Grammar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Grammar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(39, $input, $state)           (: Name^Token | Number | StringLiteral | S |
                                                               BeginOfGrammar | '<?' | 'rule' :)
  let $state :=
    if ($state[$p:l1] eq 63) then                           (: 'rule' :)
      let $state := p:lookahead2W(29, $input, $state)       (: Name^Token | S | '::=' | 'rule' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 19                             (: BeginOfGrammar :)
          or $state[$p:lk] = 191                            (: 'rule' Name^Token :)
          or $state[$p:lk] = 8127) then                     (: 'rule' 'rule' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PhythiaGrammar($input, $state)
      let $state := p:lookahead1W(14, $input, $state)       (: S | EOF :)
      let $state := p:consume(23, $input, $state)           (: EOF :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-W3CGrammar($input, $state)
      let $state := p:consume(23, $input, $state)           (: EOF :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Grammar", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 14) then                                (: S :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 128 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 16384 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol Grammar from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Grammar($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-Grammar($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
