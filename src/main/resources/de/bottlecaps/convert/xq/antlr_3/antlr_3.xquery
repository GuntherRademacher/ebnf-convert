xquery version "1.0" encoding "UTF-8";

(: This file was generated on Fri Feb 10, 2023 18:43 (UTC+01) by REx v5.57 which is Copyright (c) 1979-2023 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: -backtrack -tree -a none -xquery -name de/bottlecaps/convert/xq/antlr_3/antlr_3.xquery ../../../../../../../main/java/de/bottlecaps/convert/antlr_3/antlr_3.ebnf :)

(:~
 : The parser that was generated for the de/bottlecaps/convert/xq/antlr_3/antlr_3.xquery grammar.
 :)
module namespace p="de/bottlecaps/convert/xq/antlr_3/antlr_3.xquery";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 14;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 15;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  66, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7, 8, 7, 7,
  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 27, 27,
  27, 27, 28, 28, 28, 28, 28, 29, 28, 30, 28, 28, 28, 31, 28, 32, 28, 28, 28, 28, 28, 28, 33, 34, 35, 36, 37, 7, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 47, 54, 55, 56, 57, 58, 59, 60, 61, 47, 62, 63, 64, 65, 7
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  54, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
  58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 90, 122, 154, 186,
  217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217,
  217, 217, 217, 217, 217, 217, 217, 217, 217, 66, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7, 8, 7, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18,
  18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 28, 30, 28, 28, 28, 31, 28, 32, 28,
  28, 28, 28, 28, 28, 33, 34, 35, 36, 37, 7, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 47, 54, 55,
  56, 57, 58, 59, 60, 61, 47, 62, 63, 64, 65, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 7, 7
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
  62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 4337, 4337, 4337, 4288, 4289, 4289, 4289, 4289, 4297, 4289, 4289, 4289, 4289, 4289, 4399,
  4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734,
  6162, 6709, 5759, 4986, 4377, 4442, 4385, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5293, 4464, 5194, 4478,
  4486, 4505, 5208, 4540, 4560, 5238, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4288, 4289, 4289, 4289, 4289,
  4297, 4289, 4289, 4289, 4289, 4289, 4303, 4336, 4806, 4322, 4337, 7463, 4334, 8364, 4568, 4337, 4580, 4365, 7305,
  4337, 7437, 5561, 4337, 7436, 7115, 7434, 5549, 6222, 6169, 4599, 6716, 4628, 4642, 4392, 4607, 4674, 4615, 4622,
  4636, 4668, 4678, 4648, 4654, 5919, 4686, 4694, 4702, 4660, 4710, 4724, 4716, 4732, 4732, 4732, 4732, 4740, 4337,
  4337, 4337, 7911, 7912, 7912, 7912, 7912, 4794, 7912, 7912, 7912, 7912, 7912, 4801, 4336, 4806, 4322, 4337, 7347,
  4334, 8364, 4752, 4337, 4764, 4365, 8369, 4337, 7932, 4369, 4337, 7931, 6043, 7929, 5409, 7175, 5752, 4779, 5416,
  4841, 4855, 4787, 4819, 4875, 4827, 4835, 4849, 4869, 4879, 4861, 4887, 6319, 4901, 4909, 4917, 4893, 4925, 4939,
  4931, 4947, 4947, 4947, 4947, 4955, 4337, 4337, 4337, 4288, 4289, 4289, 4289, 4289, 4297, 4289, 4289, 4289, 4289,
  4289, 4399, 4336, 4806, 4322, 4337, 8690, 4334, 8364, 4967, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736,
  5499, 5734, 6162, 6709, 5759, 4980, 4377, 5379, 4385, 4994, 5002, 7039, 5021, 5029, 5037, 8123, 5045, 5293, 4464,
  5053, 5061, 5069, 5077, 5307, 5085, 5093, 5238, 5105, 5101, 5117, 5129, 5141, 4337, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 5503, 7639, 4337, 7639, 7431, 5154, 5161, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358,
  4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179,
  4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105,
  5338, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 5252, 4337, 4337, 4337, 4337, 4337, 7295, 4336, 6033, 5260,
  4337, 7376, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671,
  4986, 4377, 4442, 5174, 4413, 7489, 5273, 7504, 5281, 4450, 8123, 5289, 7220, 5301, 5315, 5323, 5331, 5350, 5358,
  5824, 5366, 5830, 4493, 4493, 4493, 4497, 5009, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 5503, 4337, 4337,
  4337, 4337, 4337, 7110, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479,
  4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373,
  5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 4756, 4337, 5387, 5390, 5013, 5392, 7110, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346,
  4337, 5402, 4365, 7541, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 5424, 4442, 5174, 4413,
  6519, 6955, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5432, 5224, 5440, 5232, 5459, 5467, 5105, 5105,
  5105, 5105, 5338, 4337, 4337, 4337, 7927, 7633, 4337, 4337, 6815, 5481, 7636, 5486, 6821, 6822, 6822, 5494, 4337,
  4308, 5511, 4337, 5523, 5531, 8301, 4346, 4338, 5542, 5557, 8306, 4337, 5265, 6479, 4337, 5264, 5499, 5734, 5569,
  6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216,
  5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 6667, 4337, 4337, 4337, 6668, 5503,
  6668, 5581, 5604, 5605, 5605, 5587, 4336, 4806, 4322, 5613, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337,
  5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450,
  8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337,
  4337, 4312, 4337, 5623, 4314, 4337, 4572, 4337, 5640, 5633, 5659, 5662, 5646, 4336, 4806, 4322, 4337, 8037, 4334,
  8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442,
  5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546,
  5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 4337, 4337, 5515, 4337, 4959, 4337, 4337, 4337, 5687, 5691,
  5670, 4336, 6176, 5683, 4337, 8729, 4334, 5699, 5712, 4337, 5724, 4587, 5745, 4337, 5737, 4591, 4337, 5736, 5499,
  5734, 5731, 6587, 5797, 5817, 7045, 5888, 5838, 5851, 5866, 5843, 5874, 5882, 5896, 8117, 5904, 5912, 4526, 8278,
  5927, 5935, 5943, 4532, 5951, 5959, 5973, 5967, 5967, 5967, 5967, 5981, 4337, 4337, 4337, 4337, 4337, 5786, 5716,
  4337, 5503, 4337, 4337, 5625, 8775, 8779, 5993, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365,
  8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428,
  4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338,
  4337, 4337, 4337, 4337, 4337, 6010, 6654, 4337, 6028, 4337, 4337, 4337, 4337, 4337, 7110, 4336, 4806, 4322, 4337,
  8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986,
  4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232,
  4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 5789, 4337, 4337, 4337, 4337, 5342, 4337, 5789, 8224,
  8228, 8231, 6055, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337,
  5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187,
  5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 5394, 4337,
  4337, 5534, 5393, 5503, 7630, 6073, 7092, 7096, 6087, 6079, 4336, 4806, 4322, 7883, 8037, 4334, 8364, 4346, 5985,
  4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489,
  5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105,
  5105, 5338, 4337, 4337, 4337, 8052, 8053, 8053, 8053, 6104, 6116, 6095, 6112, 6102, 8053, 8053, 6124, 4336, 6237,
  6137, 4337, 8037, 4334, 8364, 4346, 4337, 6155, 4771, 6194, 4337, 5737, 6442, 4337, 5736, 5499, 5734, 7147, 7320,
  6230, 6250, 6257, 8532, 6265, 6948, 6273, 8526, 6281, 6289, 6297, 6305, 6327, 6312, 6335, 8608, 6349, 6357, 6365,
  6341, 6373, 6381, 6395, 6389, 6389, 6389, 6389, 6403, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 6047, 4337,
  4337, 4337, 4337, 4337, 7110, 6417, 4806, 6428, 7414, 8037, 6450, 8364, 6463, 6002, 4358, 6475, 5704, 8349, 7571,
  6504, 8348, 7736, 5592, 7951, 6487, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 6512,
  6527, 5187, 5202, 5194, 6535, 5216, 6543, 4519, 6551, 6559, 5473, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337,
  4337, 6019, 6014, 4337, 6018, 6567, 6580, 4337, 6020, 6681, 4337, 7110, 4336, 4806, 4322, 4337, 8037, 4334, 8364,
  4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174,
  4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105,
  5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6600, 6741, 6610, 4337, 7119, 4337, 4337, 6614, 6618, 6622, 6630,
  4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734,
  5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478,
  5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337,
  6643, 4337, 4337, 4337, 7654, 7660, 7666, 4336, 7300, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306,
  4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436,
  4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337,
  4337, 4337, 4337, 7880, 7876, 5573, 4337, 5503, 4337, 4337, 5572, 6651, 4350, 6662, 6676, 4806, 4322, 4337, 8037,
  4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377,
  4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560,
  4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 4337, 6146, 6147, 4337, 5503, 4337, 4337, 4337, 4337,
  4337, 7169, 4336, 4806, 4322, 4337, 6694, 4334, 8449, 4346, 4337, 4358, 4365, 6702, 4337, 5737, 6479, 4337, 5736,
  5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202,
  5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 6145, 4337, 4337,
  6141, 4337, 5503, 4337, 4337, 6781, 6724, 6728, 6736, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358,
  4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179,
  4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105,
  5338, 4337, 4337, 4337, 4337, 4337, 6407, 6779, 6777, 6749, 6771, 6409, 6780, 6408, 4337, 7110, 4336, 4806, 4322,
  4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671,
  4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470,
  5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6602, 4337, 5809, 5804, 6803, 6796, 6789,
  6789, 6789, 6789, 6809, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 6002, 4358, 6475, 5704, 8349, 7712, 6836,
  8348, 7736, 5592, 7951, 6487, 6498, 6065, 4986, 4377, 6844, 5174, 4413, 7489, 4420, 6852, 4436, 4450, 8123, 5373,
  5187, 5202, 5194, 4478, 5216, 5224, 4470, 6860, 4560, 5244, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337,
  6602, 4337, 5809, 5804, 6803, 6796, 6789, 6789, 6789, 6789, 6809, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463,
  6002, 4358, 6475, 5704, 8349, 7571, 6504, 8348, 7736, 5592, 7951, 6487, 6498, 6065, 4986, 4377, 4442, 5174, 4413,
  7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105,
  5105, 5105, 5338, 4337, 4337, 4337, 4337, 6602, 4337, 5809, 5804, 6803, 6796, 6789, 6789, 6789, 6789, 6809, 6417,
  4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580, 6504, 8348, 7780, 5592, 7778, 6868,
  6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216,
  5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6602, 4337, 5809, 5804, 6803,
  6796, 6789, 6789, 6789, 6789, 6809, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8349,
  7580, 6504, 8348, 7780, 5592, 7778, 6868, 6891, 6065, 4986, 4377, 4442, 5174, 4413, 6905, 6913, 4428, 4436, 6921,
  8111, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5447, 6929, 5105, 5105, 5338, 4337, 4337,
  4337, 4337, 6602, 4337, 5809, 5804, 6803, 6796, 6789, 6789, 6789, 6789, 6809, 6417, 4806, 6830, 7414, 8037, 6450,
  8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580, 6504, 8348, 6186, 5998, 7778, 6868, 6498, 6065, 4986, 4377, 4442,
  6941, 4413, 7489, 5179, 6963, 6971, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 6979, 4512,
  6987, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6602, 4337, 5809, 5804, 6803, 6796, 6789, 6789, 6789, 6789,
  6809, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580, 6504, 8348, 7780, 5592,
  7778, 6868, 6498, 6208, 4986, 4377, 4442, 5174, 4413, 7489, 5858, 6999, 4436, 4450, 8129, 7007, 5187, 5202, 5194,
  4478, 5216, 5224, 4470, 5232, 4560, 4546, 5109, 6933, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6602, 4337, 5809,
  5804, 6803, 6796, 6789, 6789, 6789, 6789, 6809, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438,
  5704, 8349, 7580, 6504, 8348, 7780, 5592, 8408, 7015, 6498, 6065, 4986, 4377, 4442, 5174, 7032, 7053, 5179, 4428,
  7061, 7069, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4552, 5451, 5105, 5105, 5105, 5338,
  4337, 4337, 4337, 8455, 4337, 4337, 4337, 4337, 5503, 4404, 4337, 5615, 4405, 5773, 5780, 4336, 4806, 4322, 4337,
  8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986,
  4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232,
  4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4326, 4337, 4337, 4337,
  4337, 4337, 8769, 7077, 6038, 7086, 4337, 8479, 7104, 7127, 4346, 4337, 7140, 7155, 8306, 4337, 5146, 6479, 4337,
  5145, 5499, 5734, 7163, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 7183, 7191, 4450, 8123, 5373, 7199,
  7214, 7206, 7228, 7236, 7244, 7252, 7267, 7281, 7273, 7259, 7259, 7259, 7259, 7289, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 5503, 4337, 4337, 4337, 4337, 4337, 7341, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337,
  4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489,
  5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105,
  5105, 5338, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 5503, 4337, 7313, 8430, 8434, 7328, 7335, 4336, 4806,
  4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587,
  7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224,
  4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 5503, 4337,
  4337, 4337, 4337, 4337, 7110, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580,
  6504, 8348, 7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123,
  5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337,
  4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457, 7355, 7370, 6830, 7020, 8037, 7384, 8364,
  7397, 6002, 4358, 6475, 5704, 7822, 7571, 6504, 7411, 7854, 5592, 7951, 6487, 6498, 6065, 4986, 4377, 4442, 5174,
  4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105,
  5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457,
  6417, 4806, 6830, 7414, 8037, 6450, 8364, 7424, 6002, 4358, 6475, 5704, 8349, 7571, 6504, 8348, 7736, 5592, 7951,
  6487, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478,
  5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060,
  6455, 6873, 8344, 7981, 7981, 7981, 7457, 7445, 4806, 6830, 7471, 8037, 6450, 8364, 6463, 6002, 4358, 6475, 5704,
  7416, 7571, 6504, 8348, 7736, 5651, 7951, 6487, 6498, 6065, 4986, 4377, 4442, 7483, 7497, 7489, 5179, 4428, 4436,
  4450, 8135, 5373, 5187, 7512, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5133, 8162, 5338, 4337,
  4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037,
  6450, 8364, 6463, 6002, 4358, 6475, 5704, 8349, 7571, 6504, 8348, 7736, 5592, 7951, 6487, 6498, 8183, 4986, 4377,
  4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560,
  4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981,
  7981, 7457, 7520, 4806, 7528, 7414, 8037, 6450, 7536, 6463, 6002, 4358, 7549, 5704, 6490, 7616, 7557, 7565, 7736,
  6181, 7951, 7588, 7647, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202,
  5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337,
  6420, 6060, 6455, 7973, 7966, 7980, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 6002, 4358,
  6475, 5704, 8349, 7571, 6504, 8348, 7736, 5592, 7951, 6487, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179,
  4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105,
  5338, 4337, 4337, 4337, 4337, 4811, 4337, 6420, 6129, 7389, 6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 6830,
  7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 7132, 8349, 7580, 6504, 8348, 7780, 5592, 7778, 6868, 6498, 6065,
  4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470,
  5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981,
  7981, 7981, 7981, 7457, 6417, 5166, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580, 6504,
  7683, 7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373,
  5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337,
  6763, 4337, 6420, 6060, 6455, 6873, 7982, 7679, 7981, 7981, 7457, 6417, 4806, 6830, 6878, 8037, 6450, 8364, 7691,
  5596, 4358, 6438, 7705, 8349, 7744, 6504, 7947, 7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413,
  7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105,
  5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457, 6417,
  4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580, 6504, 8348, 7780, 5592, 7778, 6868,
  6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216,
  5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455,
  6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 7757, 4358, 6438, 5704, 8349,
  7580, 6504, 8348, 7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450,
  8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337,
  4337, 4337, 6763, 4337, 6420, 6572, 7896, 6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037, 6450,
  8364, 6463, 5596, 4358, 6438, 5704, 7775, 7580, 6504, 8348, 7788, 5592, 7577, 6868, 6498, 6065, 4986, 4377, 4442,
  5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546,
  5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981,
  7457, 6417, 4806, 6830, 7475, 8037, 6450, 8364, 6463, 5596, 7806, 6438, 5704, 8349, 6433, 6504, 7821, 7780, 5592,
  7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194,
  4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420,
  6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 7869, 4358, 6438,
  5704, 8349, 7580, 6504, 7834, 7780, 7830, 7842, 7862, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428,
  4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338,
  4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 7623, 7595, 7981, 7798, 7795, 7981, 7457, 6417, 4806, 6830, 7763,
  8037, 7891, 8364, 7904, 7920, 4358, 6438, 7940, 8349, 7959, 7403, 8348, 7990, 5592, 7778, 6868, 6498, 6065, 4986,
  4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232,
  4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6635, 8397, 8004, 7997, 8011,
  7981, 7981, 7457, 6417, 6592, 6830, 7024, 8037, 6450, 8364, 6463, 8015, 4358, 8023, 5704, 6467, 7580, 6504, 8348,
  7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187,
  5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763,
  4337, 6420, 6060, 6455, 7609, 7981, 7981, 7981, 7981, 7697, 6417, 8031, 8045, 7767, 8037, 8061, 8384, 6463, 5596,
  4358, 6438, 5704, 8349, 8194, 8069, 8089, 8077, 8085, 8317, 6868, 6498, 6065, 4986, 4377, 4456, 5174, 4413, 7489,
  5179, 4428, 4436, 8097, 8105, 5373, 8143, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 8158,
  8170, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 8178, 6215, 7719, 8209, 7726, 7981, 7981, 7457, 6417, 4806,
  6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 7749, 5704, 8349, 7580, 6504, 8348, 7780, 7849, 8191, 8202, 8217,
  6065, 4986, 8239, 4442, 5174, 4413, 7489, 5179, 4428, 8247, 8255, 8123, 8263, 8271, 5202, 5194, 4478, 5216, 5224,
  4470, 5232, 4560, 4546, 5105, 5121, 6991, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6242, 7451, 7602,
  8332, 8339, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037, 6450, 8423, 8286, 8294, 4358, 6438, 5704, 8314, 7580,
  6504, 8348, 7780, 5675, 6883, 8325, 8357, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123,
  5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337,
  4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 8377, 7414, 5766, 8392, 8364,
  6463, 5596, 4358, 6438, 5704, 7731, 7580, 6504, 8348, 7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174,
  4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105,
  5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457,
  6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8405, 7580, 6504, 8348, 7780, 5592, 7778,
  6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478,
  5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060,
  6455, 6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704,
  8349, 7580, 6897, 8348, 7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436,
  4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337,
  4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981, 7981, 7457, 6417, 4806, 6830, 7414, 8037,
  8416, 8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580, 6504, 8348, 7780, 5592, 7778, 6868, 6498, 6065, 4986, 4377,
  4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560,
  4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 6763, 4337, 6420, 6060, 6455, 6873, 7981, 7981, 7981,
  7981, 7457, 6417, 4806, 6830, 7414, 8037, 6450, 8364, 6463, 5596, 4358, 6438, 5704, 8349, 7580, 6504, 8348, 7780,
  5592, 7778, 6868, 8442, 6065, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202,
  5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 8459, 8458,
  6761, 6759, 6754, 4337, 8467, 8487, 8488, 8488, 8473, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358,
  4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 7813, 7362, 6201, 8496, 8511, 8546, 8503, 8519, 8585, 8540,
  8554, 8562, 8570, 8578, 8593, 8601, 8616, 8150, 8630, 8638, 8646, 8622, 8654, 8668, 8660, 8676, 8676, 8676, 8676,
  8684, 4337, 4337, 4337, 4337, 4337, 8698, 8699, 4337, 4744, 4337, 4337, 8715, 8713, 8707, 8723, 4336, 4806, 4322,
  4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671,
  4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470,
  5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337, 7078, 4337, 6686, 4337, 6685, 4337, 4337,
  4337, 4337, 4337, 7110, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346, 4337, 4358, 4365, 8306, 4337, 5737, 6479,
  4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413, 7489, 5179, 4428, 4436, 4450, 8123, 5373,
  5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105, 5105, 5105, 5338, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 5503, 8741, 8737, 8753, 8749, 8755, 8763, 4336, 4806, 4322, 4337, 8037, 4334, 8364, 4346,
  4337, 4358, 4365, 8306, 4337, 5737, 6479, 4337, 5736, 5499, 5734, 5731, 6587, 7671, 4986, 4377, 4442, 5174, 4413,
  7489, 5179, 4428, 4436, 4450, 8123, 5373, 5187, 5202, 5194, 4478, 5216, 5224, 4470, 5232, 4560, 4546, 5105, 5105,
  5105, 5105, 5338, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4971, 4972, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337,
  4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 4337, 0, 9728, 9728, 9728, 9728, 9728, 9728,
  9728, 9728, 9728, 9728, 9728, 9728, 5120, 9728, 9728, 9728, 130, 0, 93, 0, 0, 0, 108, 0, 0, 0, 0, 11776, 0, 0, 0, 0,
  0, 113, 114, 0, 6656, 0, 0, 0, 0, 116, 0, 0, 0, 0, 175, 138, 0, 0, 0, 0, 0, 0, 0, 0, 2048, 113, 114, 155, 1725, 0, 0,
  0, 0, 129, 0, 0, 17920, 132, 9898, 9898, 134, 135, 0, 175, 175, 0, 0, 0, 0, 0, 0, 212, 212, 0, 0, 190, 280, 280, 9898,
  276, 285, 285, 285, 1725, 280, 298, 273, 290, 290, 9898, 285, 304, 304, 304, 1536, 264, 273, 298, 9728, 0, 130, 0, 93,
  0, 0, 0, 93, 0, 0, 93, 0, 0, 276, 294, 294, 1725, 280, 273, 290, 9898, 285, 276, 294, 294, 1725, 280, 334, 10057, 285,
  294, 1868, 280, 290, 335, 335, 10057, 285, 294, 340, 340, 1868, 280, 290, 280, 9898, 285, 294, 285, 1725, 0, 335, 285,
  294, 0, 340, 280, 290, 280, 10030, 285, 294, 285, 1844, 371, 371, 290, 380, 392, 373, 373, 294, 0, 273, 400, 400, 400,
  389, 0, 392, 392, 396, 373, 294, 0, 400, 371, 402, 400, 389, 389, 389, 371, 290, 280, 294, 285, 290, 280, 294, 285,
  290, 371, 294, 373, 0, 410, 373, 412, 410, 396, 396, 396, 448, 273, 389, 371, 276, 396, 373, 294, 419, 273, 400, 400,
  400, 389, 371, 300, 392, 392, 396, 373, 306, 0, 279, 421, 421, 434, 389, 371, 260, 276, 410, 410, 410, 396, 373, 273,
  389, 371, 276, 396, 373, 273, 389, 450, 276, 396, 452, 273, 400, 389, 389, 371, 276, 410, 396, 113, 114, 155, 1536, 0,
  0, 0, 0, 5120, 0, 0, 11776, 132, 9728, 9728, 134, 135, 0, 175, 175, 0, 0, 0, 0, 0, 0, 213, 213, 0, 0, 1725, 273, 264,
  9728, 276, 260, 1536, 273, 264, 260, 276, 304, 1536, 264, 273, 298, 298, 10063, 260, 304, 1876, 264, 298, 335, 10063,
  260, 304, 340, 1876, 1876, 264, 298, 264, 9728, 260, 304, 260, 1536, 0, 335, 260, 304, 0, 340, 264, 298, 298, 298,
  298, 9728, 260, 304, 375, 298, 380, 304, 375, 375, 298, 380, 380, 380, 380, 304, 264, 273, 400, 400, 400, 402, 0, 260,
  304, 0, 264, 298, 9728, 260, 276, 304, 304, 1536, 264, 298, 260, 304, 264, 298, 0, 392, 392, 412, 380, 304, 0, 400,
  375, 402, 402, 402, 402, 402, 375, 298, 0, 410, 380, 412, 412, 412, 412, 412, 375, 260, 276, 410, 410, 410, 412, 380,
  298, 402, 375, 304, 412, 380, 273, 400, 402, 402, 375, 276, 410, 412, 402, 375, 412, 380, 402, 375, 412, 380, 402,
  412, 402, 412, 0, 0, 0, 0, 5120, 0, 0, 29184, 113, 114, 155, 190, 0, 0, 0, 0, 5120, 0, 10752, 0, 132, 90, 90, 134,
  135, 0, 175, 175, 0, 0, 0, 0, 0, 0, 9940, 273, 265, 90, 276, 269, 190, 273, 265, 276, 305, 305, 190, 265, 273, 299,
  90, 90, 90, 90, 5120, 90, 90, 90, 0, 130, 0, 93, 0, 0, 0, 108, 148, 0, 0, 0, 96, 0, 0, 8803, 0, 269, 276, 305, 190,
  265, 273, 299, 299, 336, 269, 305, 341, 265, 299, 335, 335, 336, 269, 305, 340, 340, 341, 265, 299, 265, 90, 269, 305,
  269, 190, 0, 335, 269, 305, 0, 340, 265, 299, 273, 299, 299, 90, 269, 305, 376, 299, 381, 305, 376, 385, 0, 269, 305,
  0, 265, 299, 90, 269, 276, 305, 305, 190, 265, 299, 269, 305, 265, 299, 376, 376, 299, 381, 392, 381, 381, 305, 265,
  273, 400, 400, 400, 403, 0, 392, 392, 413, 381, 305, 0, 400, 376, 403, 400, 403, 403, 403, 376, 299, 0, 410, 381, 413,
  410, 413, 413, 413, 376, 269, 276, 410, 410, 410, 413, 381, 299, 403, 376, 305, 413, 381, 273, 400, 403, 403, 376,
  276, 410, 413, 403, 376, 413, 381, 403, 376, 413, 381, 403, 413, 403, 413, 0, 0, 0, 0, 5120, 12288, 0, 0, 113, 114,
  155, 1727, 0, 0, 0, 0, 9216, 0, 0, 0, 0, 273, 281, 10011, 276, 286, 1824, 273, 280, 9898, 276, 285, 1725, 273, 280,
  276, 294, 294, 1725, 280, 273, 320, 10049, 285, 276, 325, 1862, 280, 273, 320, 290, 294, 389, 396, 0, 0, 0, 0, 10752,
  10752, 10752, 0, 10057, 285, 294, 1868, 343, 290, 335, 335, 10057, 347, 294, 340, 340, 1868, 280, 290, 353, 335, 285,
  294, 356, 340, 280, 290, 294, 0, 367, 368, 369, 370, 280, 290, 385, 399, 385, 385, 389, 407, 408, 392, 409, 392, 392,
  396, 417, 418, 0, 400, 407, 402, 400, 389, 389, 389, 371, 290, 0, 410, 417, 412, 410, 396, 396, 396, 371, 260, 438,
  410, 410, 410, 441, 373, 273, 400, 436, 389, 371, 276, 410, 441, 389, 462, 396, 464, 389, 371, 396, 373, 389, 371,
  396, 373, 389, 458, 396, 460, 469, 371, 471, 373, 389, 371, 396, 373, 389, 466, 396, 468, 389, 478, 396, 480, 389,
  371, 396, 373, 389, 474, 396, 476, 483, 484, 389, 396, 0, 0, 0, 0, 9898, 0, 176, 0, 0, 0, 10240, 10240, 10240, 10240,
  10240, 10240, 10240, 0, 130, 0, 93, 0, 0, 0, 108, 148, 0, 0, 152, 280, 273, 273, 290, 290, 9898, 285, 276, 294, 294,
  1725, 280, 290, 285, 294, 371, 290, 373, 294, 385, 385, 0, 385, 385, 389, 371, 290, 392, 371, 371, 290, 392, 392, 373,
  373, 294, 264, 273, 400, 400, 400, 389, 371, 400, 400, 389, 389, 389, 371, 290, 0, 410, 373, 410, 410, 396, 396, 396,
  371, 0, 276, 410, 410, 410, 396, 373, 298, 389, 371, 304, 396, 373, 273, 449, 371, 276, 451, 373, 108, 0, 0, 0, 113,
  0, 0, 108, 6144, 114, 0, 6656, 0, 0, 0, 0, 9898, 0, 2560, 0, 0, 10057, 285, 276, 294, 294, 1868, 280, 290, 10057, 285,
  294, 349, 349, 1868, 280, 290, 294, 0, 280, 290, 285, 294, 371, 290, 373, 294, 375, 385, 280, 371, 290, 393, 393, 285,
  373, 294, 264, 433, 400, 400, 400, 436, 386, 0, 386, 385, 290, 280, 290, 393, 0, 393, 392, 294, 285, 294, 0, 420, 280,
  420, 420, 290, 290, 389, 280, 389, 396, 389, 396, 0, 0, 0, 0, 5120, 0, 0, 94, 0, 427, 285, 427, 427, 294, 294, 396,
  285, 396, 0, 273, 420, 400, 420, 290, 273, 420, 290, 290, 280, 276, 427, 294, 0, 280, 290, 285, 294, 280, 290, 281,
  9898, 285, 294, 286, 1725, 10752, 0, 0, 0, 10752, 10752, 0, 0, 0, 0, 0, 0, 0, 14848, 95, 132, 9898, 9932, 134, 135, 0,
  175, 175, 0, 190, 0, 0, 0, 0, 265, 265, 90, 276, 269, 269, 269, 190, 289, 280, 9898, 276, 285, 293, 285, 1725, 371,
  400, 400, 389, 389, 389, 425, 290, 432, 294, 0, 273, 400, 400, 400, 389, 454, 396, 456, 389, 371, 396, 373, 457, 371,
  459, 373, 273, 400, 389, 444, 371, 276, 410, 396, 447, 373, 273, 389, 371, 276, 396, 373, 443, 389, 371, 446, 396,
  373, 109, 0, 0, 0, 114, 97, 97, 0, 0, 97, 97, 97, 0, 97, 0, 0, 0, 135, 0, 0, 0, 1725, 0, 0, 0, 0, 5120, 0, 0, 0, 113,
  5632, 0, 6656, 0, 0, 0, 0, 12288, 0, 0, 0, 0, 2048, 130, 132, 9898, 134, 93, 93, 0, 2048, 138, 0, 0, 0, 0, 0, 0,
  14848, 14848, 132, 9898, 9898, 134, 135, 0, 2560, 175, 0, 1536, 0, 0, 0, 0, 264, 2048, 0, 0, 0, 0, 0, 0, 212, 212, 0,
  0, 1536, 2560, 0, 1725, 0, 0, 0, 0, 0, 0, 17920, 0, 17920, 11264, 11264, 0, 0, 11264, 11264, 11264, 0, 130, 0, 93, 0,
  0, 0, 1725, 8803, 8803, 8803, 8803, 0, 8803, 8803, 0, 0, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 11264, 0,
  20992, 0, 0, 0, 0, 0, 0, 93, 0, 11776, 11776, 0, 0, 0, 0, 0, 0, 100, 0, 0, 11776, 11776, 11776, 0, 11776, 0, 11776, 0,
  0, 0, 11776, 0, 11776, 0, 130, 0, 93, 0, 0, 0, 1725, 8803, 8803, 8958, 26211, 11776, 11776, 0, 11776, 11776, 11776,
  11776, 11776, 11776, 11776, 11776, 12288, 0, 130, 132, 93, 0, 0, 0, 1725, 8803, 8957, 8803, 8803, 113, 114, 155, 6656,
  0, 0, 0, 0, 12288, 12288, 12288, 12288, 12288, 12288, 12288, 12288, 0, 184, 108, 175, 148, 150, 0, 0, 155, 1725, 0,
  1725, 8803, 113, 114, 188, 1725, 0, 0, 0, 0, 12800, 0, 0, 0, 169, 9898, 9898, 134, 135, 0, 175, 175, 0, 1725, 0, 0, 0,
  0, 0, 0, 9898, 0, 175, 0, 0, 150, 0, 0, 188, 1725, 0, 1725, 0, 0, 269, 90, 0, 0, 190, 0, 0, 260, 9898, 0, 0, 1725, 0,
  0, 168, 132, 9898, 134, 135, 93, 0, 93, 0, 0, 93, 0, 93, 0, 130, 0, 93, 0, 0, 0, 100, 0, 0, 0, 0, 0, 94, 0, 0, 0, 273,
  0, 9898, 0, 276, 1725, 0, 0, 7266, 7266, 7266, 0, 0, 7266, 7266, 0, 0, 0, 0, 279, 280, 9898, 284, 285, 1725, 279, 280,
  0, 276, 427, 410, 427, 294, 285, 273, 290, 280, 276, 294, 285, 280, 279, 279, 300, 290, 9898, 285, 284, 306, 306,
  1725, 280, 300, 284, 306, 294, 1725, 280, 318, 290, 9898, 285, 276, 294, 294, 1725, 333, 290, 285, 323, 294, 1725,
  280, 279, 300, 300, 10057, 285, 306, 1868, 280, 300, 335, 335, 10057, 285, 306, 340, 340, 1868, 280, 300, 290, 9898,
  285, 306, 294, 1725, 0, 335, 285, 306, 0, 340, 280, 300, 306, 0, 280, 300, 285, 306, 280, 300, 285, 306, 371, 300,
  373, 306, 385, 385, 0, 385, 385, 402, 375, 298, 392, 0, 410, 392, 414, 396, 306, 0, 421, 371, 421, 421, 404, 389, 404,
  371, 300, 0, 428, 373, 428, 428, 414, 396, 414, 371, 0, 284, 428, 428, 439, 396, 373, 279, 421, 404, 404, 371, 284,
  428, 414, 404, 371, 414, 373, 404, 371, 414, 373, 279, 404, 371, 284, 414, 373, 404, 414, 404, 414, 0, 0, 0, 0, 15872,
  0, 0, 0, 12900, 0, 130, 0, 93, 0, 0, 0, 1787, 8803, 8803, 8803, 8803, 0, 8803, 8803, 203, 13824, 0, 0, 13824, 0, 0, 0,
  0, 16384, 16384, 0, 0, 0, 0, 0, 0, 0, 16384, 0, 13824, 0, 0, 5120, 0, 0, 0, 3072, 148, 0, 0, 0, 147, 149, 0, 0, 0,
  190, 0, 0, 0, 0, 5120, 4213, 0, 0, 94, 0, 130, 0, 93, 0, 0, 0, 8803, 8803, 0, 0, 8803, 9898, 0, 0, 1725, 8803, 0,
  14848, 0, 0, 126, 126, 14848, 0, 130, 0, 93, 0, 15360, 0, 0, 14848, 14848, 14848, 14848, 14848, 14943, 14848, 92, 92,
  92, 92, 107, 107, 92, 107, 92, 92, 92, 92, 92, 92, 92, 107, 92, 92, 92, 107, 107, 92, 92, 92, 107, 5235, 92, 92, 92,
  92, 0, 130, 9861, 93, 0, 0, 0, 8803, 8803, 96, 96, 8803, 113, 114, 1692, 6656, 0, 0, 0, 0, 19456, 0, 0, 0, 0, 0, 0, 0,
  18944, 18944, 9728, 9898, 9898, 134, 135, 0, 175, 175, 0, 1725, 0, 0, 0, 0, 264, 0, 260, 9728, 260, 0, 1536, 0, 0,
  146, 108, 148, 0, 0, 0, 1725, 8956, 8803, 8803, 8803, 0, 9975, 0, 175, 8803, 150, 0, 0, 1536, 1725, 0, 1725, 0, 0,
  8192, 9898, 0, 0, 1725, 0, 0, 8803, 10003, 0, 0, 1814, 8803, 101, 101, 0, 5120, 8803, 8803, 0, 0, 9728, 260, 1536, 0,
  0, 264, 0, 274, 270, 9898, 0, 277, 1725, 0, 0, 9861, 108, 148, 0, 0, 0, 8803, 8803, 106, 106, 8803, 273, 282, 9898,
  276, 287, 1725, 264, 282, 291, 9898, 260, 287, 287, 295, 1725, 282, 310, 273, 282, 311, 9898, 287, 314, 287, 324, 315,
  1725, 282, 298, 301, 301, 10057, 287, 307, 1868, 282, 301, 335, 335, 10057, 287, 307, 340, 340, 1868, 282, 301, 0,
  335, 287, 307, 0, 340, 282, 301, 0, 287, 307, 0, 282, 301, 0, 287, 307, 377, 301, 382, 307, 387, 385, 0, 385, 385,
  403, 376, 299, 392, 307, 0, 282, 301, 287, 307, 282, 301, 390, 377, 301, 394, 392, 397, 382, 307, 266, 273, 375, 400,
  435, 424, 0, 411, 392, 415, 397, 307, 0, 400, 377, 423, 400, 377, 424, 405, 377, 301, 0, 410, 382, 430, 410, 382, 431,
  415, 377, 270, 276, 380, 410, 440, 431, 382, 273, 402, 405, 405, 377, 276, 412, 415, 405, 377, 415, 382, 405, 377,
  415, 382, 310, 405, 377, 314, 415, 382, 405, 415, 405, 415, 0, 0, 0, 0, 19968, 0, 0, 0, 0, 19968, 138, 7266, 8803, 0,
  0, 8803, 8803, 0, 0, 0, 0, 113, 114, 0, 6656, 4213, 8803, 8803, 0, 9898, 230, 175, 0, 8803, 8803, 0, 0, 0, 212, 1024,
  0, 0, 1725, 0, 175, 138, 0, 8803, 8803, 0, 0, 0, 5120, 8803, 8803, 0, 113, 114, 155, 1725, 8803, 8803, 8803, 0, 8926,
  8803, 8803, 8803, 206, 0, 8803, 8803, 0, 0, 0, 212, 212, 0, 0, 1725, 138, 0, 1725, 8803, 8803, 8803, 0, 8803, 8927,
  8803, 8803, 8803, 8803, 9898, 0, 1725, 8803, 8803, 0, 0, 212, 212, 0, 0, 1725, 10087, 285, 294, 1898, 280, 290, 10087,
  285, 276, 294, 1725, 280, 273, 290, 328, 294, 1898, 280, 290, 285, 294, 280, 290, 0, 392, 392, 396, 373, 294, 419,
  400, 426, 410, 373, 410, 410, 396, 396, 396, 371, 426, 276, 410, 410, 410, 396, 373, 443, 400, 389, 389, 371, 446,
  410, 396, 0, 16384, 16384, 0, 5120, 0, 0, 0, 8803, 8806, 104, 104, 8803, 0, 16384, 0, 16384, 0, 0, 16384, 0, 0, 9898,
  0, 1725, 0, 0, 0, 108, 148, 0, 151, 0, 0, 16896, 0, 0, 0, 0, 0, 0, 7266, 7266, 16896, 0, 0, 0, 0, 16896, 16896, 0,
  16896, 16896, 0, 0, 16896, 16896, 16896, 16896, 16896, 16896, 16896, 16896, 16896, 0, 130, 0, 93, 0, 0, 0, 8803, 8807,
  105, 105, 8803, 110, 0, 0, 0, 5120, 0, 0, 110, 129, 0, 17920, 0, 0, 0, 0, 0, 13824, 0, 0, 17920, 0, 130, 0, 93, 0, 0,
  0, 11264, 0, 0, 0, 0, 0, 138, 0, 0, 13312, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 29696, 0, 0, 0, 0, 18432, 0, 130, 132, 9898,
  134, 135, 93, 3584, 0, 0, 155, 1725, 0, 1725, 0, 0, 9898, 260, 1725, 0, 0, 264, 264, 9728, 276, 260, 260, 260, 1536,
  0, 19456, 0, 0, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 0, 130, 0, 93, 0, 0, 0, 16896, 0, 0,
  16896, 16896, 0, 19968, 19968, 0, 5120, 0, 0, 0, 28672, 28672, 0, 28672, 0, 28672, 0, 0, 0, 0, 0, 0, 8803, 0, 0,
  19968, 0, 19968, 0, 19968, 19968, 19968, 0, 19968, 0, 0, 0, 0, 0, 0, 0, 19456, 7266, 7266, 7266, 7266, 7266, 7266,
  7266, 7266, 0, 7266, 0, 7266, 7266, 0, 7266, 0, 0, 0, 5120, 7266, 7266, 0, 130, 0, 93, 0, 0, 0, 97, 0, 0, 0, 0, 97,
  97, 97, 97, 97, 97, 97, 97, 113, 114, 0, 6656, 0, 8803, 8803, 0, 0, 212, 212, 0, 0, 1772, 297, 290, 280, 9898, 303,
  294, 285, 1725, 10057, 285, 339, 1868, 280, 290, 335, 335, 437, 0, 276, 410, 410, 410, 396, 442, 175, 0, 1725, 8803,
  8803, 8803, 0, 8803, 0, 8803, 8803, 0, 8803, 8803, 8868, 0, 8803, 8803, 23651, 8803, 0, 9898, 0, 8803, 8803, 9996, 0,
  1807, 8803, 8803, 0, 0, 212, 212, 0, 235, 1725, 285, 276, 294, 1725, 327, 273, 290, 290, 9898, 330, 276, 294, 294,
  1725, 280, 290, 0, 335, 285, 294, 0, 340, 280, 358, 461, 371, 463, 373, 389, 371, 396, 373, 465, 371, 467, 373, 309,
  273, 273, 290, 290, 9898, 313, 276, 287, 315, 1725, 282, 319, 311, 9898, 285, 276, 294, 331, 1725, 280, 290, 10057,
  285, 294, 1868, 280, 344, 335, 335, 10057, 285, 348, 340, 340, 1868, 280, 290, 273, 400, 389, 389, 445, 276, 410, 396,
  453, 371, 455, 373, 389, 371, 396, 373, 473, 371, 475, 373, 10057, 338, 294, 1868, 280, 290, 335, 335, 366, 0, 280,
  290, 285, 294, 280, 290, 175, 0, 1797, 8803, 8803, 8803, 0, 8803, 8867, 8803, 0, 8803, 8803, 8803, 0, 8803, 8871, 276,
  294, 294, 1725, 317, 273, 290, 9898, 285, 276, 325, 294, 1725, 280, 290, 9898, 284, 285, 285, 294, 1725, 322, 276,
  294, 1725, 280, 273, 290, 290, 10057, 285, 294, 340, 340, 1868, 280, 352, 0, 335, 285, 355, 0, 340, 280, 290, 139, 0,
  0, 0, 0, 0, 0, 0, 29696, 153, 154, 0, 6656, 0, 0, 0, 0, 126, 14848, 14848, 14848, 14848, 14848, 0, 0, 0, 14848, 0,
  176, 138, 0, 0, 0, 0, 0, 130, 0, 93, 0, 0, 0, 1536, 0, 0, 0, 0, 5120, 0, 0, 16896, 0, 132, 108, 176, 148, 150, 0, 0,
  155, 1725, 0, 1725, 8921, 132, 9898, 9898, 134, 135, 0, 176, 175, 0, 1725, 0, 0, 0, 0, 266, 176, 0, 0, 0, 0, 0, 0,
  212, 176, 0, 1725, 0, 0, 0, 0, 0, 130, 0, 93, 14336, 0, 0, 90, 269, 190, 0, 0, 265, 10065, 285, 294, 1878, 280, 290,
  346, 346, 10057, 285, 294, 350, 350, 1868, 280, 290, 285, 294, 378, 290, 383, 294, 388, 388, 0, 388, 385, 406, 378,
  290, 395, 378, 371, 290, 395, 395, 383, 373, 294, 280, 290, 285, 294, 386, 386, 0, 395, 392, 416, 383, 294, 0, 422,
  378, 422, 422, 406, 406, 389, 378, 290, 0, 429, 383, 429, 429, 416, 416, 396, 383, 294, 0, 273, 422, 400, 422, 406,
  378, 416, 383, 406, 378, 416, 383, 378, 0, 276, 429, 410, 429, 416, 383, 273, 406, 378, 276, 416, 383, 273, 422, 406,
  406, 378, 276, 429, 416, 406, 416, 406, 416, 0, 0, 0, 0, 130, 0, 134, 0, 0, 0, 108, 148, 150, 0, 0, 155, 1536, 1536,
  1536, 0, 122, 122, 0, 0, 122, 122, 122, 0, 0, 9898, 270, 1725, 0, 0, 266, 122, 20602, 20602, 20602, 20602, 20602,
  20602, 20602, 0, 130, 0, 93, 0, 0, 0, 130, 0, 4608, 0, 0, 0, 130, 132, 90, 134, 135, 93, 138, 7266, 8803, 0, 0, 8803,
  8846, 0, 0, 9898, 8192, 1725, 0, 0, 7680, 144, 0, 0, 108, 148, 0, 0, 0, 130, 132, 9898, 93, 135, 93, 174, 175, 138, 0,
  8803, 8803, 0, 0, 96, 5120, 8803, 8803, 0, 113, 114, 155, 1725, 8896, 8803, 8803, 0, 0, 212, 212, 234, 0, 1725, 8803,
  8942, 8803, 8803, 0, 8803, 8803, 8803, 0, 8803, 8803, 8928, 8803, 113, 114, 155, 1725, 8803, 8803, 8899, 0, 0, 10240,
  0, 0, 0, 0, 0, 0, 9728, 0, 175, 0, 0, 138, 7266, 8803, 0, 140, 8803, 8803, 0, 112, 106, 5120, 8803, 8803, 0, 130, 0,
  93, 0, 0, 0, 130, 132, 9728, 134, 135, 93, 8865, 0, 8803, 8803, 8803, 0, 8803, 8803, 8803, 0, 8870, 8803, 280, 273,
  273, 290, 290, 10040, 285, 276, 294, 1725, 280, 273, 290, 290, 276, 294, 294, 1852, 280, 273, 290, 9898, 285, 294,
  1725, 280, 290, 345, 345, 371, 371, 391, 392, 392, 373, 373, 398, 138, 7266, 8803, 0, 0, 8845, 8803, 143, 113, 114, 0,
  6656, 0, 8803, 8803, 160, 183, 132, 108, 175, 148, 150, 0, 0, 155, 1725, 0, 1752, 0, 206, 0, 8912, 8803, 210, 0,
  28160, 212, 8936, 0, 233, 212, 212, 0, 0, 1725, 8803, 8803, 8943, 8803, 0, 27235, 8803, 8803, 228, 9898, 0, 231, 0,
  8803, 8961, 8803, 8803, 0, 9898, 0, 175, 0, 8803, 138, 0, 1725, 8803, 25187, 8803, 0, 8803, 111, 8803, 111, 8803,
  8803, 111, 8803, 112, 8803, 112, 8803, 8803, 112, 8803, 120, 8803, 120, 8803, 8803, 120, 8803, 8803, 228, 9898, 0,
  231, 27136, 8803, 111, 111, 0, 5120, 8803, 8803, 0, 0, 14848, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 10240, 0, 8803,
  8803, 9898, 0, 1725, 8803, 8976, 0, 0, 17408, 0, 0, 0, 17408, 0, 0, 17408, 0, 17408, 17408, 0, 130, 0, 93, 0, 0, 0,
  9898, 0, 0, 1725, 0, 8831, 8803, 8803, 8803, 8803, 8803, 8803, 8803, 0, 8803, 8803, 21603, 113, 114, 155, 1725, 8803,
  8897, 8803, 0, 130, 0, 93, 0, 0, 137, 150, 214, 0, 155, 1725, 0, 1725, 8803, 8803, 228, 9957, 0, 231, 0, 8803, 101,
  8803, 101, 8803, 8803, 101, 8825, 8803, 8803, 8803, 8803, 8803, 8803, 8803, 221, 8803, 8803, 8803, 8803, 246, 9898, 0,
  249, 8803, 8803, 8931, 0, 9898, 0, 175, 0, 8803, 8913, 0, 211, 0, 212, 8803, 8902, 8803, 8803, 0, 8803, 8803, 0, 8866,
  8803, 8803, 0, 8803, 8803, 8861, 0, 8803, 8803, 8803, 8803, 8924, 0, 8803, 8803, 8803, 8803, 0, 9898, 0, 175, 8803,
  8947, 8803, 8803, 0, 9898, 0, 175, 8803, 8803, 8803, 8832, 8803, 8803, 8803, 8803, 8803, 8803, 8803, 132, 9898, 9898,
  134, 135, 205, 175, 175, 0, 1725, 0, 0, 0, 0, 7680, 8941, 8803, 8803, 8803, 0, 8803, 8803, 8803, 8929, 0, 250, 0,
  1725, 8803, 8803, 8803, 8803, 0, 8803, 8946, 8803, 255, 8803, 8803, 8803, 8962, 0, 9898, 0, 0, 27648, 1725, 8803,
  8803, 8803, 8803, 246, 9898, 248, 249, 8803, 175, 0, 1725, 8966, 8803, 8803, 0, 8803, 8803, 8803, 8904, 0, 8803, 8803,
  0, 0, 17920, 0, 0, 0, 17920, 0, 0, 0, 0, 0, 165, 0, 0, 0, 175, 138, 178, 8803, 8803, 0, 0, 104, 5120, 8803, 8803, 0,
  113, 114, 155, 1725, 8803, 8898, 8803, 0, 90, 90, 90, 90, 90, 90, 90, 90, 8901, 8803, 8803, 8803, 0, 8803, 8803, 0,
  91, 0, 0, 0, 0, 0, 0, 90, 0, 175, 0, 0, 150, 0, 215, 155, 1725, 0, 1725, 8803, 8803, 8803, 8944, 0, 8803, 8803, 8803,
  8803, 130, 9898, 0, 8930, 8803, 0, 9898, 0, 175, 0, 8803, 8803, 8822, 8829, 8803, 8803, 8803, 8822, 0, 8803, 0, 8822,
  8822, 0, 8822, 8803, 8803, 8803, 8803, 8803, 8803, 8803, 8803, 8831, 8803, 8803, 8949, 0, 9898, 0, 175, 8803, 8803,
  8823, 8823, 8803, 8803, 8803, 8823, 0, 8803, 0, 8823, 8823, 0, 8823, 8803, 8803, 8803, 8803, 8803, 8803, 8803, 0,
  8905, 8803, 0, 175, 207, 8803, 8803, 0, 0, 0, 212, 0, 145, 0, 108, 148, 0, 0, 0, 130, 132, 9898, 134, 135, 93, 113,
  114, 0, 6656, 0, 8861, 8862, 0, 92, 92, 92, 92, 92, 92, 92, 92, 0, 175, 138, 0, 8803, 8884, 0, 182, 8803, 24064, 0,
  212, 212, 0, 0, 1725, 8803, 8948, 8803, 0, 9898, 0, 175, 24675, 24576, 0, 0, 1725, 8803, 8803, 8803, 8803, 241, 8803,
  8803, 8803, 0, 335, 285, 294, 0, 340, 357, 290, 0, 360, 294, 0, 280, 290, 0, 285, 361, 0, 280, 290, 0, 285, 306, 0,
  280, 300, 0, 285, 294, 0, 280, 290, 0, 285, 294, 0, 280, 364, 0, 285, 294, 0, 363, 290, 0, 365, 285, 294, 371, 379,
  373, 384, 385, 385, 0, 385, 385, 8069, 8051, 7970, 392, 389, 470, 396, 472, 389, 371, 396, 373, 481, 371, 482, 373,
  477, 371, 479, 373, 389, 371, 396, 373, 101, 0, 0, 8803, 8803, 0, 0, 8803, 9898, 0, 0, 1725, 25699, 0, 8960, 8803,
  8803, 8803, 0, 9898, 0, 175, 0, 24163, 175, 260, 1725, 8803, 8803, 8803, 26624, 8803, 8803, 8825, 8803, 8803, 8803,
  8803, 8825, 8803, 8971, 9898, 0, 1725, 8803, 8803, 0, 94, 0, 94, 94, 94, 0, 94, 94, 94, 94, 94, 94, 94, 94, 280, 280,
  10020, 276, 285, 285, 285, 1832, 10057, 285, 294, 340, 340, 1868, 351, 290, 0, 335, 354, 294, 0, 340, 280, 290, 294,
  0, 280, 290, 285, 294, 280, 372, 285, 374, 371, 290, 373, 294, 385, 385, 0, 400, 385, 404, 389, 300, 392, 113, 114,
  155, 1725, 8803, 8803, 8803, 196, 8803, 8803, 8903, 8803, 0, 8803, 8906, 0, 132, 108, 0, 148, 150, 0, 0, 155, 1725, 0,
  1725, 0, 8803, 8923, 8803, 0, 8803, 8803, 8803, 8803, 0, 9898, 23040, 175, 0, 1725, 8803, 8803, 8967, 0, 8803, 8803,
  8827, 8803, 8803, 8803, 8803, 8827, 8803, 8803, 8803, 8803, 8803, 8803, 8803, 8828, 8803, 8803, 8803, 8803, 0, 8803,
  8803, 8803, 8803, 8803, 8803, 9898, 0, 1725, 22627, 8803, 0, 132, 108, 175, 148, 150, 0, 0, 155, 190, 0, 190, 0, 113,
  114, 0, 6656, 0, 8803, 8863, 0, 132, 108, 175, 148, 150, 0, 187, 0, 175, 177, 0, 8803, 8803, 0, 0, 105, 5120, 8803,
  8803, 0, 8922, 8803, 8803, 0, 8803, 8803, 8803, 8803, 0, 9987, 0, 0, 175, 138, 0, 8883, 8803, 181, 0, 132, 108, 175,
  148, 150, 186, 0, 122, 122, 122, 122, 122, 20602, 122, 122, 122, 122, 122, 22115, 8803, 9898, 0, 1725, 8803, 8803, 0,
  132, 108, 175, 148, 185, 0, 0, 93, 0, 0, 0, 0, 0, 28672, 0, 0, 0, 28672, 28672, 0, 0, 28672, 28672, 28672, 0, 130, 0,
  93, 0, 0, 0, 130, 132, 9898, 172, 173, 93, 0, 28672, 28672, 28672, 28672, 28672, 28672, 28672, 28672, 273, 7960, 9898,
  276, 8477, 1725, 273, 7960, 7953, 273, 7970, 7970, 9898, 8477, 8468, 7960, 7960, 9898, 276, 8477, 8477, 8477, 1725,
  276, 8486, 8486, 1725, 7960, 273, 7970, 9898, 287, 304, 307, 307, 1725, 282, 301, 291, 9898, 287, 307, 295, 1725,
  9898, 8477, 276, 8486, 8486, 1725, 7960, 7970, 7960, 9898, 8477, 8486, 8477, 1725, 10057, 8477, 8486, 1868, 7960,
  7970, 335, 335, 10057, 8477, 8486, 340, 340, 1868, 7960, 7970, 0, 335, 8477, 8486, 0, 340, 7960, 7970, 0, 8477, 8486,
  0, 7960, 7970, 0, 8477, 276, 8486, 1725, 7960, 273, 7970, 7970, 8486, 0, 7960, 7970, 8477, 8486, 7960, 7970, 8477,
  8486, 8051, 7970, 8565, 8486, 8065, 385, 0, 401, 385, 405, 390, 301, 392, 8051, 8051, 7970, 8584, 392, 8565, 8565,
  8486, 7680, 273, 400, 400, 400, 8069, 0, 392, 392, 8588, 8565, 8486, 0, 400, 8051, 8080, 400, 8069, 8069, 8069, 8051,
  7970, 0, 410, 8565, 8602, 410, 8588, 8588, 8588, 8051, 8192, 276, 410, 410, 410, 8588, 8565, 7953, 8069, 8051, 8468,
  8588, 8565, 273, 400, 8069, 8069, 8051, 276, 410, 8588, 8069, 8051, 8588, 8565, 8069, 8051, 8588, 8565, 8069, 8588,
  8069, 8588, 0, 0, 0, 0, 130, 132, 9899, 134, 135, 93, 0, 29184, 0, 0, 0, 0, 0, 0, 0, 29184, 29184, 29184, 29184,
  29184, 29184, 29184, 29184, 0, 29184, 29184, 29184, 29184, 29184, 0, 29184, 29184, 0, 130, 0, 93, 0, 0, 0, 130, 169,
  9898, 134, 135, 93, 0, 30208, 0, 0, 0, 0, 30208, 0, 0, 0, 0, 0, 30208, 30208, 30208, 30208, 0, 0, 0, 30208, 30208,
  30208, 30208, 30208, 30208, 30208, 30208, 0, 130, 0, 93, 0, 0, 0, 131, 0, 136, 0, 0, 0, 100, 0, 12800, 12800, 12800,
  12800, 12800, 12800, 12800, 12900
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  16, 32, 48, 64, 80, 111, 95, 127, 143, 159, 175, 191, 204, 204, 204, 204, 220, 224, 237, 228, 232, 236, 242, 249, 253,
  256, 260, 264, 245, 271, 268, 275, 279, 286, 282, 290, 294, 297, 300, 311, 325, 393, 532, 464, 329, 333, 335, 340,
  455, 458, 452, 394, 533, 464, 347, 307, 369, 341, 238, 461, 392, 531, 465, 349, 307, 369, 342, 391, 395, 355, 306,
  368, 376, 303, 560, 306, 336, 343, 373, 334, 385, 351, 419, 364, 361, 399, 361, 405, 360, 405, 401, 362, 405, 360,
  405, 401, 402, 413, 417, 401, 401, 413, 413, 417, 401, 404, 413, 401, 404, 417, 404, 412, 399, 363, 409, 363, 358,
  411, 358, 363, 361, 399, 417, 417, 417, 402, 413, 403, 403, 403, 403, 403, 403, 403, 403, 320, 423, 424, 314, 429,
  433, 437, 476, 441, 445, 449, 469, 473, 480, 484, 488, 492, 495, 499, 503, 507, 511, 515, 519, 520, 424, 319, 547,
  380, 424, 578, 524, 528, 379, 424, 542, 320, 548, 380, 424, 537, 582, 529, 424, 541, 318, 546, 381, 425, 554, 582,
  530, 317, 321, 381, 553, 581, 568, 558, 388, 553, 566, 520, 425, 564, 572, 575, 424, 549, 424, 424, 424, 424, 424,
  424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 0, 262152, 262400, 2359296, 4456448, 134479872, 268697600,
  537133056, 262144, 262168, 335872, 270336, 71565312, 4456448, 33816576, 67371008, -2147221504, -2147221504, 262144,
  262144, 262144, 256, 262144, 262144, 4530176, 335872, -2147188736, 270868504, -2147188480, 25427968, 67371008,
  268697600, 268697600, -2147221504, -2147221504, 2367512, 335872, 262144, 262146, 268771352, 335984, -2080079872,
  -2147188736, 262146, 7684, 8724632, 1384472, 138674272, 7675928, 270868504, 352258, 466946, 335874, -2146664192,
  335874, 1081417752, 1211441176, 275062808, 352258, 385026, 141893656, 1081417752, 409280536, 409280536, 304947480,
  -1738170344, 405086232, 409280536, 304947480, -1738203112, 167059480, 167059736, 167059480, 434446360, 167059736,
  434970648, 434970904, 434970648, 434970904, 971841560, 468525336, 262144, 8, 262144, 0, 24, 65536, 65536, 65536,
  65536, 0, 256, 134217728, 536870912, 0, 1, 4, 4096, 0, 1048576, 16384, 32768, 16384, 32768, 0, 24, 8192, 65536,
  33554432, 2048, 1024, 4, 4096, 128, 65536, 65536, 0, 81920, 65536, 65536, 65536, 1073741824, 65536, 98304, 8, 262144,
  0, 2048, 1024, 4, 4, 4, 65536, 65536, 16384, 2, 32768, 0, 4, 4, 16384, 16384, 16384, 262144, 32768, 32768, 4, 65536,
  0, 65536, 81920, 65536, 65536, 24, 32768, 4, 65536, 65536, 98304, 8, 0, 0, 0, 2097152, 0, 65536, 98304, 262144, 32768,
  0, 2097152, 0, 24, 0, 65536, 65536, 0, 0, 2, 32768, 4, 16384, 16384, 16384, 16384, 32768, 32768, 32768, 4, 16384,
  16384, 262144, 262144, 32768, 32768, 32768, 32768, 32768, 32768, 16384, 16384, 98304, 262144, 32, 0, 0, 0, 0, 2048,
  8388608, 0, 0, 33554432, 0, 16777216, 4, 1, 64, 8388608, 5, 17, 32, 5, 17, 20, 1048640, 8388672, 0, 8388672, 49152,
  4247552, 4247552, 0, 24, 24, 0, 8, 8, 262144, 256, 256, 256, 0, 16, 16, 64, 32768, 0, 4, 0, 1048640, 3145792,
  12636160, 41943040, 0, 8388608, 16777217, 8388672, 0, 33554432, 460800, 3670080, 67108864, 3670080, 460800, 460864,
  3670080, 1509440, 8388864, 75497728, 1509440, 462336, 8388864, 8388864, 75497728, 1517632, 25166081, 25166081,
  92274944, 92274945, 92274945, 75497860, 92274976, 92274953, 92274977, 75497862, 92275008, 25166113, 25166113,
  25166115, 92274977, 25166115, 92275105, 92275105, 92275107, 92275113, 92275107, 92275107, 92275109, 92275111, 0, 0, 0,
  4096, 1048576, 256, 0, 512, 3072, 0, 8192, 0, 0, 0, 262146, 32, 16, 2048, 196608, 262144, 524288, 0, 4096, 0, 0,
  1048576, 16384, 32768, 4194304, 0, 0, 0, 131072, 2048, 65536, 131072, 262144, 524288, 0, 4096, 0, 32768, 0, 4, 65536,
  131072, 524288, 0, 1024, 8192, 0, 0, 1024, 0, 0, 0, 2048, 131072, 0, 2048, 458752, 524288, 1048576, 0, 512, 1024
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "DOC_COMMENT",
  "COMMENT",
  "CHAR_LITERAL",
  "STRING_LITERAL",
  "DOUBLE_QUOTE_STRING_LITERAL",
  "DOUBLE_ANGLE_STRING_LITERAL",
  "INT",
  "ARG_ACTION",
  "NESTED_ACTION_char",
  "ACTION_CHAR_LITERAL",
  "ACTION_STRING_LITERAL",
  "ACTION_ESC",
  "TOKEN_REF",
  "TOKENS",
  "OPTIONS",
  "RULE_REF",
  "EOF",
  "WHITESPACE",
  "'!'",
  "'$'",
  "'('",
  "')'",
  "'*'",
  "'+'",
  "'+='",
  "','",
  "'->'",
  "'.'",
  "'..'",
  "'...'",
  "':'",
  "';'",
  "'<'",
  "'='",
  "'=>'",
  "'>'",
  "'?'",
  "'@'",
  "'^'",
  "'^('",
  "'catch'",
  "'finally'",
  "'fragment'",
  "'grammar'",
  "'import'",
  "'lexer'",
  "'parser'",
  "'private'",
  "'protected'",
  "'public'",
  "'returns'",
  "'scope'",
  "'throws'",
  "'tree'",
  "'{'",
  "'|'",
  "'}'",
  "'~'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 512,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 512
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 32
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 32 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 512 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 8
    let $next-state := $p:TRANSITION[$i0 mod 8 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 511) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 512, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 1
    let $i0 := $t * 484 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 16
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 16 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : Parse finallyClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-finallyClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(42, $input, $state)               (: 'finally' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ACTION($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "finallyClause", $count, $begin, $end)
};

(:~
 : Parse exceptionHandler.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-exceptionHandler($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(41, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(2, $input, $state)            (: ARG_ACTION | WHITESPACE :)
  let $state := p:consume(8, $input, $state)                (: ARG_ACTION :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ACTION($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "exceptionHandler", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production exceptionGroup (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-exceptionGroup-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-exceptionHandler($input, $state)
    let $state := p:lookahead1W(59, $input, $state)         (: DOC_COMMENT | TOKEN_REF | RULE_REF | EOF | WHITESPACE |
                                                               'catch' | 'finally' | 'fragment' | 'private' |
                                                               'protected' | 'public' :)
    return
      if ($state[$p:l1] != 41) then                         (: 'catch' :)
        $state
      else
        p:parse-exceptionGroup-1($input, $state)
};

(:~
 : Parse exceptionGroup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-exceptionGroup($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 41) then                       (: 'catch' :)
      let $state := p:parse-exceptionGroup-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 42) then                   (: 'finally' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-finallyClause($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-finallyClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "exceptionGroup", $count, $begin, $end)
};

(:~
 : Parse treeRoot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-treeRoot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 13) then                           (: TOKEN_REF :)
      let $state := p:lookahead2W(74, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | '+=' | '.' | '<' |
                                                               '=' | '^' | '^(' | '{' | '~' :)
      return $state
    else if ($state[$p:l1] eq 16) then                      (: RULE_REF :)
      let $state := p:lookahead2W(70, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | '+=' | '.' | '=' |
                                                               '^' | '^(' | '{' | '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1613                           (: TOKEN_REF '+=' :)
          or $state[$p:lk] = 1616                           (: RULE_REF '+=' :)
          or $state[$p:lk] = 2189                           (: TOKEN_REF '=' :)
          or $state[$p:lk] = 2192) then                     (: RULE_REF '=' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-id($input, $state)
      let $state := p:lookahead1W(18, $input, $state)       (: WHITESPACE | '+=' | '=' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '=' :)
          let $state := p:consume(34, $input, $state)       (: '=' :)
          return $state
        else
          let $state := p:consume(25, $input, $state)       (: '+=' :)
          return $state
      let $state := p:lookahead1W(50, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | '.' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: '(' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-block($input, $state)
          return $state
        else
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-atom($input, $state)
          return $state
      return $state
    else if ($state[$p:lk] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-block($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-atom($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "treeRoot", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production tree_ (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-tree_-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(57, $input, $state)         (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | '.' | '^(' | '{' | '~' :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-element($input, $state)
    let $state := p:lookahead1W(62, $input, $state)         (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '.' | '^(' | '{' | '~' :)
    return
      if ($state[$p:l1] = 22) then                          (: ')' :)
        $state
      else
        p:parse-tree_-1($input, $state)
};

(:~
 : Parse tree_.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-tree_($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(40, $input, $state)               (: '^(' :)
  let $state := p:lookahead1W(50, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | '.' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-treeRoot($input, $state)
  let $state := p:parse-tree_-1($input, $state)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "tree_", $count, $begin, $end)
};

(:~
 : Parse ebnf.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ebnf($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-block($input, $state)
  let $state := p:lookahead1W(84, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '=>' | '?' | '^' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19                             (: '!' :)
          or $state[$p:l1] = 23                             (: '*' :)
          or $state[$p:l1] = 24                             (: '+' :)
          or $state[$p:l1] = 35                             (: '=>' :)
          or $state[$p:l1] = 37                             (: '?' :)
          or $state[$p:l1] = 39) then                       (: '^' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: '?' :)
          let $state := p:consume(37, $input, $state)       (: '?' :)
          return $state
        else if ($state[$p:l1] = 23) then                   (: '*' :)
          let $state := p:consume(23, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 24) then                   (: '+' :)
          let $state := p:consume(24, $input, $state)       (: '+' :)
          return $state
        else if ($state[$p:l1] = 35) then                   (: '=>' :)
          let $state := p:consume(35, $input, $state)       (: '=>' :)
          return $state
        else if ($state[$p:l1] = 39) then                   (: '^' :)
          let $state := p:consume(39, $input, $state)       (: '^' :)
          return $state
        else
          let $state := p:consume(19, $input, $state)       (: '!' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ebnf", $count, $begin, $end)
};

(:~
 : Parse ruleref.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleref($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(16, $input, $state)               (: RULE_REF :)
  let $state := p:lookahead1W(82, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 8) then                        (: ARG_ACTION :)
      let $state := p:consume(8, $input, $state)            (: ARG_ACTION :)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19                             (: '!' :)
          or $state[$p:l1] = 39) then                       (: '^' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '^' :)
          let $state := p:consume(39, $input, $state)       (: '^' :)
          return $state
        else
          let $state := p:consume(19, $input, $state)       (: '!' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ruleref", $count, $begin, $end)
};

(:~
 : Try parsing ruleref.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ruleref($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(16, $input, $state)              (: RULE_REF :)
  let $state := p:lookahead1W(82, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 8) then                        (: ARG_ACTION :)
      let $state := p:consumeT(8, $input, $state)           (: ARG_ACTION :)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19                             (: '!' :)
          or $state[$p:l1] = 39) then                       (: '^' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '^' :)
          let $state := p:consumeT(39, $input, $state)      (: '^' :)
          return $state
        else
          let $state := p:consumeT(19, $input, $state)      (: '!' :)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse terminal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-terminal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consume(13, $input, $state)           (: TOKEN_REF :)
      let $state := p:lookahead1W(85, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '<' | '?' | '^' | '^(' | '{' | '|' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-elementOptions($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(82, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 8) then                    (: ARG_ACTION :)
          let $state := p:consume(8, $input, $state)        (: ARG_ACTION :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 28) then                       (: '.' :)
      let $state := p:consume(28, $input, $state)           (: '.' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 3) then                    (: CHAR_LITERAL :)
          let $state := p:consume(3, $input, $state)        (: CHAR_LITERAL :)
          return $state
        else
          let $state := p:consume(4, $input, $state)        (: STRING_LITERAL :)
          return $state
      let $state := p:lookahead1W(83, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '<' | '?' | '^' | '^(' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-elementOptions($input, $state)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19                             (: '!' :)
          or $state[$p:l1] = 39) then                       (: '^' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '^' :)
          let $state := p:consume(39, $input, $state)       (: '^' :)
          return $state
        else
          let $state := p:consume(19, $input, $state)       (: '!' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "terminal", $count, $begin, $end)
};

(:~
 : Try parsing terminal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-terminal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consumeT(13, $input, $state)          (: TOKEN_REF :)
      let $state := p:lookahead1W(85, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '<' | '?' | '^' | '^(' | '{' | '|' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-elementOptions($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(82, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 8) then                    (: ARG_ACTION :)
          let $state := p:consumeT(8, $input, $state)       (: ARG_ACTION :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 28) then                       (: '.' :)
      let $state := p:consumeT(28, $input, $state)          (: '.' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 3) then                    (: CHAR_LITERAL :)
          let $state := p:consumeT(3, $input, $state)       (: CHAR_LITERAL :)
          return $state
        else
          let $state := p:consumeT(4, $input, $state)       (: STRING_LITERAL :)
          return $state
      let $state := p:lookahead1W(83, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '<' | '?' | '^' | '^(' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-elementOptions($input, $state)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19                             (: '!' :)
          or $state[$p:l1] = 39) then                       (: '^' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '^' :)
          let $state := p:consumeT(39, $input, $state)      (: '^' :)
          return $state
        else
          let $state := p:consumeT(19, $input, $state)      (: '!' :)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse rewrite_indirect_template_head.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_indirect_template_head($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ACTION($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: WHITESPACE | ')' :)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(3, $input, $state)            (: WHITESPACE | '(' :)
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE | ')' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite_template_args($input, $state)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_indirect_template_head", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_indirect_template_head.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_indirect_template_head($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ACTION($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: WHITESPACE | ')' :)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(3, $input, $state)            (: WHITESPACE | '(' :)
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-rewrite_template_args($input, $state)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse rewrite_template_arg.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_template_arg($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: WHITESPACE | '=' :)
  let $state := p:consume(34, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ACTION($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_template_arg", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_template_arg.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_template_arg($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-id($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: WHITESPACE | '=' :)
  let $state := p:consumeT(34, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ACTION($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production rewrite_template_args (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_template_args-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(16, $input, $state)         (: WHITESPACE | ')' | ',' :)
    return
      if ($state[$p:l1] != 26) then                         (: ',' :)
        $state
      else
        let $state := p:consume(26, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-rewrite_template_arg($input, $state)
        return p:parse-rewrite_template_args-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production rewrite_template_args (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_template_args-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(16, $input, $state)         (: WHITESPACE | ')' | ',' :)
    return
      if ($state[$p:l1] != 26) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(26, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-rewrite_template_arg($input, $state)
        return p:try-rewrite_template_args-1($input, $state)
};

(:~
 : Parse rewrite_template_args.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_template_args($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-rewrite_template_arg($input, $state)
      let $state := p:parse-rewrite_template_args-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_template_args", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_template_args.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_template_args($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-rewrite_template_arg($input, $state)
      let $state := p:try-rewrite_template_args-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse rewrite_template_head.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_template_head($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(3, $input, $state)            (: WHITESPACE | '(' :)
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE | ')' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite_template_args($input, $state)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_template_head", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_template_head.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_template_head($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-id($input, $state)
  let $state := p:lookahead1W(3, $input, $state)            (: WHITESPACE | '(' :)
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-rewrite_template_args($input, $state)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse rewrite_template.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_template($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-rewrite_indirect_template_head($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ACTION($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-rewrite_template_head($input, $state)
      let $state := p:lookahead1W(47, $input, $state)       (: DOUBLE_QUOTE_STRING_LITERAL |
                                                               DOUBLE_ANGLE_STRING_LITERAL | WHITESPACE | ')' | '->' |
                                                               ';' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 5                          (: DOUBLE_QUOTE_STRING_LITERAL :)
              or $state[$p:l1] = 6) then                    (: DOUBLE_ANGLE_STRING_LITERAL :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 5) then                (: DOUBLE_QUOTE_STRING_LITERAL :)
              let $state := p:consume(5, $input, $state)    (: DOUBLE_QUOTE_STRING_LITERAL :)
              return $state
            else
              let $state := p:consume(6, $input, $state)    (: DOUBLE_ANGLE_STRING_LITERAL :)
              return $state
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_template", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_template.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_template($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-rewrite_indirect_template_head($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ACTION($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-rewrite_template_head($input, $state)
      let $state := p:lookahead1W(47, $input, $state)       (: DOUBLE_QUOTE_STRING_LITERAL |
                                                               DOUBLE_ANGLE_STRING_LITERAL | WHITESPACE | ')' | '->' |
                                                               ';' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 5                          (: DOUBLE_QUOTE_STRING_LITERAL :)
              or $state[$p:l1] = 6) then                    (: DOUBLE_ANGLE_STRING_LITERAL :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 5) then                (: DOUBLE_QUOTE_STRING_LITERAL :)
              let $state := p:consumeT(5, $input, $state)   (: DOUBLE_QUOTE_STRING_LITERAL :)
              return $state
            else
              let $state := p:consumeT(6, $input, $state)   (: DOUBLE_ANGLE_STRING_LITERAL :)
              return $state
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse rewrite_block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_block($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(60, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite_alternative($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: WHITESPACE | ')' :)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_block", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_block($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(21, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(60, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-rewrite_alternative($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: WHITESPACE | ')' :)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse rewrite_ebnf.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_ebnf($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite_block($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: WHITESPACE | '*' | '+' | '?' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '?' :)
      let $state := p:consume(37, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*' :)
      let $state := p:consume(23, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(24, $input, $state)           (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_ebnf", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_ebnf.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_ebnf($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-rewrite_block($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: WHITESPACE | '*' | '+' | '?' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '?' :)
      let $state := p:consumeT(37, $input, $state)          (: '?' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*' :)
      let $state := p:consumeT(23, $input, $state)          (: '*' :)
      return $state
    else
      let $state := p:consumeT(24, $input, $state)          (: '+' :)
      return $state
  return $state
};

(:~
 : Parse ebnfSuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ebnfSuffix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '?' :)
      let $state := p:consume(37, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*' :)
      let $state := p:consume(23, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(24, $input, $state)           (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ebnfSuffix", $count, $begin, $end)
};

(:~
 : Try parsing ebnfSuffix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ebnfSuffix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '?' :)
      let $state := p:consumeT(37, $input, $state)          (: '?' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*' :)
      let $state := p:consumeT(23, $input, $state)          (: '*' :)
      return $state
    else
      let $state := p:consumeT(24, $input, $state)          (: '+' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production rewrite_tree (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_tree-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '^(' | '{' :)
    return
      if ($state[$p:l1] = 22) then                          (: ')' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-rewrite_element($input, $state)
        return p:parse-rewrite_tree-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production rewrite_tree (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_tree-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '^(' | '{' :)
    return
      if ($state[$p:l1] = 22) then                          (: ')' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-rewrite_element($input, $state)
        return p:try-rewrite_tree-1($input, $state)
};

(:~
 : Parse rewrite_tree.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_tree($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(40, $input, $state)               (: '^(' :)
  let $state := p:lookahead1W(46, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite_atom($input, $state)
  let $state := p:parse-rewrite_tree-1($input, $state)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_tree", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_tree.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_tree($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(40, $input, $state)              (: '^(' :)
  let $state := p:lookahead1W(46, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-rewrite_atom($input, $state)
  let $state := p:try-rewrite_tree-1($input, $state)
  let $state := p:consumeT(22, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse label.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-label($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consume(13, $input, $state)           (: TOKEN_REF :)
      return $state
    else
      let $state := p:consume(16, $input, $state)           (: RULE_REF :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "label", $count, $begin, $end)
};

(:~
 : Try parsing label.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-label($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consumeT(13, $input, $state)          (: TOKEN_REF :)
      return $state
    else
      let $state := p:consumeT(16, $input, $state)          (: RULE_REF :)
      return $state
  return $state
};

(:~
 : Parse elementOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: WHITESPACE | '=' :)
  let $state := p:consume(34, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(40, $input, $state)           (: STRING_LITERAL | DOUBLE_QUOTE_STRING_LITERAL |
                                                               DOUBLE_ANGLE_STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13                             (: TOKEN_REF :)
          or $state[$p:l1] = 16) then                       (: RULE_REF :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-elementOptionId($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: STRING_LITERAL :)
          let $state := p:consume(4, $input, $state)        (: STRING_LITERAL :)
          return $state
        else if ($state[$p:l1] = 5) then                    (: DOUBLE_QUOTE_STRING_LITERAL :)
          let $state := p:consume(5, $input, $state)        (: DOUBLE_QUOTE_STRING_LITERAL :)
          return $state
        else
          let $state := p:consume(6, $input, $state)        (: DOUBLE_ANGLE_STRING_LITERAL :)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "elementOption", $count, $begin, $end)
};

(:~
 : Try parsing elementOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-id($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: WHITESPACE | '=' :)
  let $state := p:consumeT(34, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(40, $input, $state)           (: STRING_LITERAL | DOUBLE_QUOTE_STRING_LITERAL |
                                                               DOUBLE_ANGLE_STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13                             (: TOKEN_REF :)
          or $state[$p:l1] = 16) then                       (: RULE_REF :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-elementOptionId($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: STRING_LITERAL :)
          let $state := p:consumeT(4, $input, $state)       (: STRING_LITERAL :)
          return $state
        else if ($state[$p:l1] = 5) then                    (: DOUBLE_QUOTE_STRING_LITERAL :)
          let $state := p:consumeT(5, $input, $state)       (: DOUBLE_QUOTE_STRING_LITERAL :)
          return $state
        else
          let $state := p:consumeT(6, $input, $state)       (: DOUBLE_ANGLE_STRING_LITERAL :)
          return $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production elementOptionId (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementOptionId-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: WHITESPACE | '.' | ';' | '>' :)
    return
      if ($state[$p:l1] != 28) then                         (: '.' :)
        $state
      else
        let $state := p:consume(28, $input, $state)         (: '.' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-id($input, $state)
        return p:parse-elementOptionId-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production elementOptionId (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementOptionId-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: WHITESPACE | '.' | ';' | '>' :)
    return
      if ($state[$p:l1] != 28) then                         (: '.' :)
        $state
      else
        let $state := p:consumeT(28, $input, $state)        (: '.' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-id($input, $state)
        return p:try-elementOptionId-1($input, $state)
};

(:~
 : Parse elementOptionId.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementOptionId($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:parse-elementOptionId-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "elementOptionId", $count, $begin, $end)
};

(:~
 : Try parsing elementOptionId.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementOptionId($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-id($input, $state)
  let $state := p:try-elementOptionId-1($input, $state)
  return $state
};

(:~
 : Parse defaultNodeOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-defaultNodeOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-elementOptionId($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "defaultNodeOption", $count, $begin, $end)
};

(:~
 : Try parsing defaultNodeOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-defaultNodeOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-elementOptionId($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production elementOptions (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(23, $input, $state)         (: WHITESPACE | ';' | '>' :)
    return
      if ($state[$p:l1] != 32) then                         (: ';' :)
        $state
      else
        let $state := p:consume(32, $input, $state)         (: ';' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-elementOption($input, $state)
        return p:parse-elementOptions-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production elementOptions (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(23, $input, $state)         (: WHITESPACE | ';' | '>' :)
    return
      if ($state[$p:l1] != 32) then                         (: ';' :)
        $state
      else
        let $state := p:consumeT(32, $input, $state)        (: ';' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-elementOption($input, $state)
        return p:try-elementOptions-1($input, $state)
};

(:~
 : Parse elementOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(33, $input, $state)               (: '<' :)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state :=
    if ($state[$p:l1] = (13,                                (: TOKEN_REF :)
                         16)) then                          (: RULE_REF :)
      let $state := p:lookahead2W(31, $input, $state)       (: WHITESPACE | '.' | '=' | '>' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2189                           (: TOKEN_REF '=' :)
          or $state[$p:lk] = 2192) then                     (: RULE_REF '=' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-elementOption($input, $state)
      let $state := p:parse-elementOptions-1($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-defaultNodeOption($input, $state)
      return $state
  let $state := p:consume(36, $input, $state)               (: '>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "elementOptions", $count, $begin, $end)
};

(:~
 : Try parsing elementOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-elementOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(33, $input, $state)              (: '<' :)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state :=
    if ($state[$p:l1] = (13,                                (: TOKEN_REF :)
                         16)) then                          (: RULE_REF :)
      let $state := p:lookahead2W(31, $input, $state)       (: WHITESPACE | '.' | '=' | '>' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2189                           (: TOKEN_REF '=' :)
          or $state[$p:lk] = 2192) then                     (: RULE_REF '=' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-elementOption($input, $state)
      let $state := p:try-elementOptions-1($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-defaultNodeOption($input, $state)
      return $state
  let $state := p:consumeT(36, $input, $state)              (: '>' :)
  return $state
};

(:~
 : Parse rewrite_atom.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_atom($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consume(13, $input, $state)           (: TOKEN_REF :)
      let $state := p:lookahead1W(80, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '$' | '(' | ')' | '*' | '+' |
                                                               '->' | ';' | '<' | '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-elementOptions($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(77, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '$' | '(' | ')' | '*' | '+' |
                                                               '->' | ';' | '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 8) then                    (: ARG_ACTION :)
          let $state := p:consume(8, $input, $state)        (: ARG_ACTION :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 16) then                       (: RULE_REF :)
      let $state := p:consume(16, $input, $state)           (: RULE_REF :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: '$' :)
      let $state := p:consume(20, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(14, $input, $state)       (: TOKEN_REF | RULE_REF | WHITESPACE :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-label($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ACTION($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 3) then                    (: CHAR_LITERAL :)
          let $state := p:consume(3, $input, $state)        (: CHAR_LITERAL :)
          return $state
        else
          let $state := p:consume(4, $input, $state)        (: STRING_LITERAL :)
          return $state
      let $state := p:lookahead1W(78, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                               '<' | '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-elementOptions($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_atom", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_atom.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_atom($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consumeT(13, $input, $state)          (: TOKEN_REF :)
      let $state := p:lookahead1W(80, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '$' | '(' | ')' | '*' | '+' |
                                                               '->' | ';' | '<' | '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-elementOptions($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(77, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '$' | '(' | ')' | '*' | '+' |
                                                               '->' | ';' | '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 8) then                    (: ARG_ACTION :)
          let $state := p:consumeT(8, $input, $state)       (: ARG_ACTION :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 16) then                       (: RULE_REF :)
      let $state := p:consumeT(16, $input, $state)          (: RULE_REF :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: '$' :)
      let $state := p:consumeT(20, $input, $state)          (: '$' :)
      let $state := p:lookahead1W(14, $input, $state)       (: TOKEN_REF | RULE_REF | WHITESPACE :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-label($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ACTION($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 3) then                    (: CHAR_LITERAL :)
          let $state := p:consumeT(3, $input, $state)       (: CHAR_LITERAL :)
          return $state
        else
          let $state := p:consumeT(4, $input, $state)       (: STRING_LITERAL :)
          return $state
      let $state := p:lookahead1W(78, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                               '<' | '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 33) then                   (: '<' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-elementOptions($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse rewrite_element.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_element($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-rewrite_ebnf($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: '^(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-rewrite_tree($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-rewrite_atom($input, $state)
          return $state
      let $state := p:lookahead1W(76, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                               '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23                         (: '*' :)
              or $state[$p:l1] = 24                         (: '+' :)
              or $state[$p:l1] = 37) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ebnfSuffix($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_element", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_element.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_element($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-rewrite_ebnf($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: '^(' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-rewrite_tree($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-rewrite_atom($input, $state)
          return $state
      let $state := p:lookahead1W(76, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                               '?' | '^(' | '{' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23                         (: '*' :)
              or $state[$p:l1] = 24                         (: '+' :)
              or $state[$p:l1] = 37) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ebnfSuffix($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production rewrite_alternative (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_alternative-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-rewrite_element($input, $state)
    let $state := p:lookahead1W(65, $input, $state)         (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '->' | ';' | '^(' | '{' |
                                                               '|' :)
    return
      if ($state[$p:l1] = 22                                (: ')' :)
       or $state[$p:l1] = 27                                (: '->' :)
       or $state[$p:l1] = 32                                (: ';' :)
       or $state[$p:l1] = 56) then                          (: '|' :)
        $state
      else
        p:parse-rewrite_alternative-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production rewrite_alternative (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_alternative-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-rewrite_element($input, $state)
    let $state := p:lookahead1W(65, $input, $state)         (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '->' | ';' | '^(' | '{' |
                                                               '|' :)
    return
      if ($state[$p:l1] = 22                                (: ')' :)
       or $state[$p:l1] = 27                                (: '->' :)
       or $state[$p:l1] = 32                                (: ';' :)
       or $state[$p:l1] = 56) then                          (: '|' :)
        $state
      else
        p:try-rewrite_alternative-1($input, $state)
};

(:~
 : Parse rewrite_alternative.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_alternative($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22                            (: ')' :)
         and $state[$p:l1] != 27                            (: '->' :)
         and $state[$p:l1] != 32                            (: ';' :)
         and $state[$p:l1] != 56) then                      (: '|' :)
      let $state :=
        if ($state[$p:l1] eq 13) then                       (: TOKEN_REF :)
          let $state := p:lookahead2W(80, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '$' | '(' | ')' | '*' | '+' |
                                                               '->' | ';' | '<' | '?' | '^(' | '{' | '|' :)
          let $state :=
            if ($state[$p:lk] eq 1357) then                 (: TOKEN_REF '(' :)
              let $state := p:lookahead3W(60, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 16) then                  (: RULE_REF :)
          let $state := p:lookahead2W(76, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                               '?' | '^(' | '{' | '|' :)
          let $state :=
            if ($state[$p:lk] eq 1360) then                 (: RULE_REF '(' :)
              let $state := p:lookahead3W(60, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 21) then                  (: '(' :)
          let $state := p:lookahead2W(60, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
          let $state :=
            if ($state[$p:lk] eq 3541) then                 (: '(' '{' :)
              let $state := p:lookahead3(44, $input, $state) (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                                ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 55) then                  (: '{' :)
          let $state := p:lookahead2(44, $input, $state)    (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
          let $state :=
            if ($state[$p:lk] eq 3703) then                 (: '{' '}' :)
              let $state := p:lookahead3W(76, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                                 '?' | '^(' | '{' | '|' :)
              return $state
            else if ($state[$p:lk] = (183,                  (: '{' COMMENT :)
                                      631,                  (: '{' NESTED_ACTION_char :)
                                      695,                  (: '{' ACTION_CHAR_LITERAL :)
                                      759,                  (: '{' ACTION_STRING_LITERAL :)
                                      823,                  (: '{' ACTION_ESC :)
                                      3575)) then           (: '{' '{' :)
              let $state := p:lookahead3(44, $input, $state) (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                                ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 8375                       (: '{' COMMENT COMMENT :)
              or $state[$p:lk] = 8823                       (: '{' NESTED_ACTION_char COMMENT :)
              or $state[$p:lk] = 8887                       (: '{' ACTION_CHAR_LITERAL COMMENT :)
              or $state[$p:lk] = 8951                       (: '{' ACTION_STRING_LITERAL COMMENT :)
              or $state[$p:lk] = 9015                       (: '{' ACTION_ESC COMMENT :)
              or $state[$p:lk] = 11733                      (: '(' '{' COMMENT :)
              or $state[$p:lk] = 11767                      (: '{' '{' COMMENT :)
              or $state[$p:lk] = 37047                      (: '{' COMMENT NESTED_ACTION_char :)
              or $state[$p:lk] = 37495                      (: '{' NESTED_ACTION_char NESTED_ACTION_char :)
              or $state[$p:lk] = 37559                      (: '{' ACTION_CHAR_LITERAL NESTED_ACTION_char :)
              or $state[$p:lk] = 37623                      (: '{' ACTION_STRING_LITERAL NESTED_ACTION_char :)
              or $state[$p:lk] = 37687                      (: '{' ACTION_ESC NESTED_ACTION_char :)
              or $state[$p:lk] = 40405                      (: '(' '{' NESTED_ACTION_char :)
              or $state[$p:lk] = 40439                      (: '{' '{' NESTED_ACTION_char :)
              or $state[$p:lk] = 41143                      (: '{' COMMENT ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41591                      (: '{' NESTED_ACTION_char ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41655                      (: '{' ACTION_CHAR_LITERAL ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41719                      (: '{' ACTION_STRING_LITERAL ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41783                      (: '{' ACTION_ESC ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 44501                      (: '(' '{' ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 44535                      (: '{' '{' ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 45239                      (: '{' COMMENT ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45687                      (: '{' NESTED_ACTION_char ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45751                      (: '{' ACTION_CHAR_LITERAL ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45815                      (: '{' ACTION_STRING_LITERAL ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45879                      (: '{' ACTION_ESC ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 48597                      (: '(' '{' ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 48631                      (: '{' '{' ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 49335                      (: '{' COMMENT ACTION_ESC :)
              or $state[$p:lk] = 49783                      (: '{' NESTED_ACTION_char ACTION_ESC :)
              or $state[$p:lk] = 49847                      (: '{' ACTION_CHAR_LITERAL ACTION_ESC :)
              or $state[$p:lk] = 49911                      (: '{' ACTION_STRING_LITERAL ACTION_ESC :)
              or $state[$p:lk] = 49975                      (: '{' ACTION_ESC ACTION_ESC :)
              or $state[$p:lk] = 52693                      (: '(' '{' ACTION_ESC :)
              or $state[$p:lk] = 52727                      (: '{' '{' ACTION_ESC :)
              or $state[$p:lk] = 54605                      (: TOKEN_REF '(' TOKEN_REF :)
              or $state[$p:lk] = 54608                      (: RULE_REF '(' TOKEN_REF :)
              or $state[$p:lk] = 66893                      (: TOKEN_REF '(' RULE_REF :)
              or $state[$p:lk] = 66896                      (: RULE_REF '(' RULE_REF :)
              or $state[$p:lk] = 91469                      (: TOKEN_REF '(' ')' :)
              or $state[$p:lk] = 91472                      (: RULE_REF '(' ')' :)
              or $state[$p:lk] = 93815                      (: '{' '}' ')' :)
              or $state[$p:lk] = 114295                     (: '{' '}' '->' :)
              or $state[$p:lk] = 134775                     (: '{' '}' ';' :)
              or $state[$p:lk] = 225463                     (: '{' COMMENT '{' :)
              or $state[$p:lk] = 225911                     (: '{' NESTED_ACTION_char '{' :)
              or $state[$p:lk] = 225975                     (: '{' ACTION_CHAR_LITERAL '{' :)
              or $state[$p:lk] = 226039                     (: '{' ACTION_STRING_LITERAL '{' :)
              or $state[$p:lk] = 226103                     (: '{' ACTION_ESC '{' :)
              or $state[$p:lk] = 228821                     (: '(' '{' '{' :)
              or $state[$p:lk] = 228855                     (: '{' '{' '{' :)
              or $state[$p:lk] = 233079                     (: '{' '}' '|' :)
              or $state[$p:lk] = 233655                     (: '{' COMMENT '}' :)
              or $state[$p:lk] = 234103                     (: '{' NESTED_ACTION_char '}' :)
              or $state[$p:lk] = 234167                     (: '{' ACTION_CHAR_LITERAL '}' :)
              or $state[$p:lk] = 234231                     (: '{' ACTION_STRING_LITERAL '}' :)
              or $state[$p:lk] = 234295                     (: '{' ACTION_ESC '}' :)
              or $state[$p:lk] = 237013                     (: '(' '{' '}' :)
              or $state[$p:lk] = 237047) then               (: '{' '{' '}' :)
          let $state := p:memoized($state, 4)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:try-rewrite_alternative-1($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -2) then
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-rewrite_template($input, $state)
          return $state
        else if ($state[$p:lk] = 30) then                   (: '...' :)
          let $state := p:consume(30, $input, $state)       (: '...' :)
          return $state
        else
          let $state := p:parse-rewrite_alternative-1($input, $state)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_alternative", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_alternative.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_alternative($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 22                            (: ')' :)
         and $state[$p:l1] != 27                            (: '->' :)
         and $state[$p:l1] != 32                            (: ';' :)
         and $state[$p:l1] != 56) then                      (: '|' :)
      let $state :=
        if ($state[$p:l1] eq 13) then                       (: TOKEN_REF :)
          let $state := p:lookahead2W(80, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '$' | '(' | ')' | '*' | '+' |
                                                               '->' | ';' | '<' | '?' | '^(' | '{' | '|' :)
          let $state :=
            if ($state[$p:lk] eq 1357) then                 (: TOKEN_REF '(' :)
              let $state := p:lookahead3W(60, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 16) then                  (: RULE_REF :)
          let $state := p:lookahead2W(76, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                               '?' | '^(' | '{' | '|' :)
          let $state :=
            if ($state[$p:lk] eq 1360) then                 (: RULE_REF '(' :)
              let $state := p:lookahead3W(60, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 21) then                  (: '(' :)
          let $state := p:lookahead2W(60, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '...' | '^(' | '{' :)
          let $state :=
            if ($state[$p:lk] eq 3541) then                 (: '(' '{' :)
              let $state := p:lookahead3(44, $input, $state) (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                                ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 55) then                  (: '{' :)
          let $state := p:lookahead2(44, $input, $state)    (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
          let $state :=
            if ($state[$p:lk] eq 3703) then                 (: '{' '}' :)
              let $state := p:lookahead3W(76, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '$' | '(' | ')' | '*' | '+' | '->' | ';' |
                                                                 '?' | '^(' | '{' | '|' :)
              return $state
            else if ($state[$p:lk] = (183,                  (: '{' COMMENT :)
                                      631,                  (: '{' NESTED_ACTION_char :)
                                      695,                  (: '{' ACTION_CHAR_LITERAL :)
                                      759,                  (: '{' ACTION_STRING_LITERAL :)
                                      823,                  (: '{' ACTION_ESC :)
                                      3575)) then           (: '{' '{' :)
              let $state := p:lookahead3(44, $input, $state) (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                                ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 8375                       (: '{' COMMENT COMMENT :)
              or $state[$p:lk] = 8823                       (: '{' NESTED_ACTION_char COMMENT :)
              or $state[$p:lk] = 8887                       (: '{' ACTION_CHAR_LITERAL COMMENT :)
              or $state[$p:lk] = 8951                       (: '{' ACTION_STRING_LITERAL COMMENT :)
              or $state[$p:lk] = 9015                       (: '{' ACTION_ESC COMMENT :)
              or $state[$p:lk] = 11733                      (: '(' '{' COMMENT :)
              or $state[$p:lk] = 11767                      (: '{' '{' COMMENT :)
              or $state[$p:lk] = 37047                      (: '{' COMMENT NESTED_ACTION_char :)
              or $state[$p:lk] = 37495                      (: '{' NESTED_ACTION_char NESTED_ACTION_char :)
              or $state[$p:lk] = 37559                      (: '{' ACTION_CHAR_LITERAL NESTED_ACTION_char :)
              or $state[$p:lk] = 37623                      (: '{' ACTION_STRING_LITERAL NESTED_ACTION_char :)
              or $state[$p:lk] = 37687                      (: '{' ACTION_ESC NESTED_ACTION_char :)
              or $state[$p:lk] = 40405                      (: '(' '{' NESTED_ACTION_char :)
              or $state[$p:lk] = 40439                      (: '{' '{' NESTED_ACTION_char :)
              or $state[$p:lk] = 41143                      (: '{' COMMENT ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41591                      (: '{' NESTED_ACTION_char ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41655                      (: '{' ACTION_CHAR_LITERAL ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41719                      (: '{' ACTION_STRING_LITERAL ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 41783                      (: '{' ACTION_ESC ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 44501                      (: '(' '{' ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 44535                      (: '{' '{' ACTION_CHAR_LITERAL :)
              or $state[$p:lk] = 45239                      (: '{' COMMENT ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45687                      (: '{' NESTED_ACTION_char ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45751                      (: '{' ACTION_CHAR_LITERAL ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45815                      (: '{' ACTION_STRING_LITERAL ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 45879                      (: '{' ACTION_ESC ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 48597                      (: '(' '{' ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 48631                      (: '{' '{' ACTION_STRING_LITERAL :)
              or $state[$p:lk] = 49335                      (: '{' COMMENT ACTION_ESC :)
              or $state[$p:lk] = 49783                      (: '{' NESTED_ACTION_char ACTION_ESC :)
              or $state[$p:lk] = 49847                      (: '{' ACTION_CHAR_LITERAL ACTION_ESC :)
              or $state[$p:lk] = 49911                      (: '{' ACTION_STRING_LITERAL ACTION_ESC :)
              or $state[$p:lk] = 49975                      (: '{' ACTION_ESC ACTION_ESC :)
              or $state[$p:lk] = 52693                      (: '(' '{' ACTION_ESC :)
              or $state[$p:lk] = 52727                      (: '{' '{' ACTION_ESC :)
              or $state[$p:lk] = 54605                      (: TOKEN_REF '(' TOKEN_REF :)
              or $state[$p:lk] = 54608                      (: RULE_REF '(' TOKEN_REF :)
              or $state[$p:lk] = 66893                      (: TOKEN_REF '(' RULE_REF :)
              or $state[$p:lk] = 66896                      (: RULE_REF '(' RULE_REF :)
              or $state[$p:lk] = 91469                      (: TOKEN_REF '(' ')' :)
              or $state[$p:lk] = 91472                      (: RULE_REF '(' ')' :)
              or $state[$p:lk] = 93815                      (: '{' '}' ')' :)
              or $state[$p:lk] = 114295                     (: '{' '}' '->' :)
              or $state[$p:lk] = 134775                     (: '{' '}' ';' :)
              or $state[$p:lk] = 225463                     (: '{' COMMENT '{' :)
              or $state[$p:lk] = 225911                     (: '{' NESTED_ACTION_char '{' :)
              or $state[$p:lk] = 225975                     (: '{' ACTION_CHAR_LITERAL '{' :)
              or $state[$p:lk] = 226039                     (: '{' ACTION_STRING_LITERAL '{' :)
              or $state[$p:lk] = 226103                     (: '{' ACTION_ESC '{' :)
              or $state[$p:lk] = 228821                     (: '(' '{' '{' :)
              or $state[$p:lk] = 228855                     (: '{' '{' '{' :)
              or $state[$p:lk] = 233079                     (: '{' '}' '|' :)
              or $state[$p:lk] = 233655                     (: '{' COMMENT '}' :)
              or $state[$p:lk] = 234103                     (: '{' NESTED_ACTION_char '}' :)
              or $state[$p:lk] = 234167                     (: '{' ACTION_CHAR_LITERAL '}' :)
              or $state[$p:lk] = 234231                     (: '{' ACTION_STRING_LITERAL '}' :)
              or $state[$p:lk] = 234295                     (: '{' ACTION_ESC '}' :)
              or $state[$p:lk] = 237013                     (: '(' '{' '}' :)
              or $state[$p:lk] = 237047) then               (: '{' '{' '}' :)
          let $state := p:memoized($state, 4)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:try-rewrite_alternative-1($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -2) then
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-rewrite_template($input, $state)
          return $state
        else if ($state[$p:lk] = 30) then                   (: '...' :)
          let $state := p:consumeT(30, $input, $state)      (: '...' :)
          return $state
        else
          let $state := p:try-rewrite_alternative-1($input, $state)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SEMPRED.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SEMPRED($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NESTED_ACTION($input, $state)
  let $state := p:lookahead1(0, $input, $state)             (: '?' :)
  let $state := p:consume(37, $input, $state)               (: '?' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SEMPRED", $count, $begin, $end)
};

(:~
 : Try parsing SEMPRED.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SEMPRED($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NESTED_ACTION($input, $state)
  let $state := p:lookahead1(0, $input, $state)             (: '?' :)
  let $state := p:consumeT(37, $input, $state)              (: '?' :)
  return $state
};

(:~
 : Parse rewrite_with_sempred.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite_with_sempred($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(27, $input, $state)               (: '->' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SEMPRED($input, $state)
  let $state := p:lookahead1W(61, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | '->' | '...' | '^(' | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite_alternative($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite_with_sempred", $count, $begin, $end)
};

(:~
 : Try parsing rewrite_with_sempred.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-rewrite_with_sempred($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(27, $input, $state)              (: '->' :)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SEMPRED($input, $state)
  let $state := p:lookahead1W(61, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | '->' | '...' | '^(' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-rewrite_alternative($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production rewrite (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(5, $input, $state)          (: WHITESPACE | '->' :)
    let $state :=
      if ($state[$p:l1] eq 27) then                         (: '->' :)
        let $state := p:lookahead2W(66, $input, $state)     (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '...' | ';' | '^(' | '{' |
                                                               '|' :)
        let $state :=
          if ($state[$p:lk] eq 3547) then                   (: '->' '{' :)
            let $state := p:lookahead3(44, $input, $state)  (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
            return $state
          else
            $state
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 11739                        (: '->' '{' COMMENT :)
            or $state[$p:lk] = 40411                        (: '->' '{' NESTED_ACTION_char :)
            or $state[$p:lk] = 44507                        (: '->' '{' ACTION_CHAR_LITERAL :)
            or $state[$p:lk] = 48603                        (: '->' '{' ACTION_STRING_LITERAL :)
            or $state[$p:lk] = 52699                        (: '->' '{' ACTION_ESC :)
            or $state[$p:lk] = 228827                       (: '->' '{' '{' :)
            or $state[$p:lk] = 237019) then                 (: '->' '{' '}' :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-rewrite_with_sempred($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-rewrite_with_sempred($input, $state)
        return p:parse-rewrite-1($input, $state)
};

(:~
 : Parse rewrite.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rewrite($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27) then                       (: '->' :)
      let $state := p:parse-rewrite-1($input, $state)
      let $state := p:consume(27, $input, $state)           (: '->' :)
      let $state := p:lookahead1W(66, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '$' | '(' | ')' | '...' | ';' | '^(' | '{' |
                                                               '|' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-rewrite_alternative($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rewrite", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production block (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-block-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(17, $input, $state)         (: WHITESPACE | ')' | '|' :)
    return
      if ($state[$p:l1] != 56) then                         (: '|' :)
        $state
      else
        let $state := p:consume(56, $input, $state)         (: '|' :)
        let $state := p:lookahead1W(67, $input, $state)     (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '->' | '.' | '^(' | '{' | '|' |
                                                               '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-alternative($input, $state)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-rewrite($input, $state)
        return p:parse-block-1($input, $state)
};

(:~
 : Parse block.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-block($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(21, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(75, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | OPTIONS |
                                                               RULE_REF | WHITESPACE | '(' | ')' | '->' | '.' | ':' |
                                                               '@' | '^(' | '{' | '|' | '~' :)
  let $state :=
    if ($state[$p:l1] eq 55) then                           (: '{' :)
      let $state := p:lookahead2(44, $input, $state)        (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 3703) then                     (: '{' '}' :)
          let $state := p:lookahead3W(71, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '->' | '.' | ':' | '?' | '^(' |
                                                               '{' | '|' | '~' :)
          return $state
        else if ($state[$p:lk] = (183,                      (: '{' COMMENT :)
                                  631,                      (: '{' NESTED_ACTION_char :)
                                  695,                      (: '{' ACTION_CHAR_LITERAL :)
                                  759,                      (: '{' ACTION_STRING_LITERAL :)
                                  823,                      (: '{' ACTION_ESC :)
                                  3575)) then               (: '{' '{' :)
          let $state := p:lookahead3(44, $input, $state)    (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 3                             (: CHAR_LITERAL :)
         and $state[$p:lk] != 4                             (: STRING_LITERAL :)
         and $state[$p:lk] != 13                            (: TOKEN_REF :)
         and $state[$p:lk] != 15                            (: OPTIONS :)
         and $state[$p:lk] != 16                            (: RULE_REF :)
         and $state[$p:lk] != 21                            (: '(' :)
         and $state[$p:lk] != 22                            (: ')' :)
         and $state[$p:lk] != 27                            (: '->' :)
         and $state[$p:lk] != 28                            (: '.' :)
         and $state[$p:lk] != 31                            (: ':' :)
         and $state[$p:lk] != 38                            (: '@' :)
         and $state[$p:lk] != 40                            (: '^(' :)
         and $state[$p:lk] != 56                            (: '|' :)
         and $state[$p:lk] != 58                            (: '~' :)
         and $state[$p:lk] != 15991                         (: '{' '}' CHAR_LITERAL :)
         and $state[$p:lk] != 20087                         (: '{' '}' STRING_LITERAL :)
         and $state[$p:lk] != 56951                         (: '{' '}' TOKEN_REF :)
         and $state[$p:lk] != 69239                         (: '{' '}' RULE_REF :)
         and $state[$p:lk] != 89719                         (: '{' '}' '(' :)
         and $state[$p:lk] != 93815                         (: '{' '}' ')' :)
         and $state[$p:lk] != 114295                        (: '{' '}' '->' :)
         and $state[$p:lk] != 118391                        (: '{' '}' '.' :)
         and $state[$p:lk] != 130679                        (: '{' '}' ':' :)
         and $state[$p:lk] != 155255                        (: '{' '}' '?' :)
         and $state[$p:lk] != 167543                        (: '{' '}' '^(' :)
         and $state[$p:lk] != 228983                        (: '{' '}' '{' :)
         and $state[$p:lk] != 233079                        (: '{' '}' '|' :)
         and $state[$p:lk] != 241271) then                  (: '{' '}' '~' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 55) then               (: '{' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ACTION($input, $state)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 15) then           (: OPTIONS :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-optionsSpec($input, $state)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(20, $input, $state) (: WHITESPACE | ':' | '@' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 38) then           (: '@' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-ruleActions($input, $state)
                  return $state
                else
                  $state
              return $state
          let $state := p:lookahead1W(8, $input, $state)    (: WHITESPACE | ':' :)
          let $state := p:consumeT(31, $input, $state)      (: ':' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
          or $state[$p:lk] = 15                             (: OPTIONS :)
          or $state[$p:lk] = 31                             (: ':' :)
          or $state[$p:lk] = 38                             (: '@' :)
          or $state[$p:lk] = 130679) then                   (: '{' '}' ':' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 55) then                   (: '{' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ACTION($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 15) then               (: OPTIONS :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-optionsSpec($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(20, $input, $state)   (: WHITESPACE | ':' | '@' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 38) then               (: '@' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-ruleActions($input, $state)
              return $state
            else
              $state
          return $state
      let $state := p:lookahead1W(8, $input, $state)        (: WHITESPACE | ':' :)
      let $state := p:consume(31, $input, $state)           (: ':' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(67, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '->' | '.' | '^(' | '{' | '|' |
                                                               '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-alternative($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite($input, $state)
  let $state := p:parse-block-1($input, $state)
  let $state := p:consume(22, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "block", $count, $begin, $end)
};

(:~
 : Parse notTerminal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-notTerminal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 3) then                        (: CHAR_LITERAL :)
      let $state := p:consume(3, $input, $state)            (: CHAR_LITERAL :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consume(13, $input, $state)           (: TOKEN_REF :)
      return $state
    else
      let $state := p:consume(4, $input, $state)            (: STRING_LITERAL :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "notTerminal", $count, $begin, $end)
};

(:~
 : Parse notSet.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-notSet($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(58, $input, $state)               (: '~' :)
  let $state := p:lookahead1W(34, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | WHITESPACE |
                                                               '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: '(' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-block($input, $state)
      return $state
    else
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-notTerminal($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "notSet", $count, $begin, $end)
};

(:~
 : Parse range.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-range($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(3, $input, $state)                (: CHAR_LITERAL :)
  let $state := p:lookahead1W(7, $input, $state)            (: WHITESPACE | '..' :)
  let $state := p:consume(29, $input, $state)               (: '..' :)
  let $state := p:lookahead1W(1, $input, $state)            (: CHAR_LITERAL | WHITESPACE :)
  let $state := p:consume(3, $input, $state)                (: CHAR_LITERAL :)
  let $end := $state[$p:e0]
  return p:reduce($state, "range", $count, $begin, $end)
};

(:~
 : Parse atom.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-atom($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 3) then                            (: CHAR_LITERAL :)
      let $state := p:lookahead2W(86, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               '..' | ';' | '<' | '?' | '^' | '^(' | '{' | '|' | '~' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 58                             (: '~' :)
          or $state[$p:lk] = 1859) then                     (: CHAR_LITERAL '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 3) then                    (: CHAR_LITERAL :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-range($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-notSet($input, $state)
          return $state
      let $state := p:lookahead1W(81, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                               ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 19                         (: '!' :)
              or $state[$p:l1] = 39) then                   (: '^' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 39) then               (: '^' :)
              let $state := p:consume(39, $input, $state)   (: '^' :)
              return $state
            else
              let $state := p:consume(19, $input, $state)   (: '!' :)
              return $state
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:l1] eq 13) then                       (: TOKEN_REF :)
          let $state := p:lookahead2W(85, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '<' | '?' | '^' | '^(' | '{' | '|' |
                                                               '~' :)
          let $state :=
            if ($state[$p:lk] eq 1805) then                 (: TOKEN_REF '.' :)
              let $state := p:lookahead3W(81, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                                 ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
              return $state
            else
              $state
          return $state
        else if ($state[$p:l1] eq 16) then                  (: RULE_REF :)
          let $state := p:lookahead2W(82, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '->' | '.' | ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
          let $state :=
            if ($state[$p:lk] eq 1808) then                 (: RULE_REF '.' :)
              let $state := p:lookahead3W(81, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '!' | '(' | ')' | '*' | '+' | '->' | '.' |
                                                                 ';' | '?' | '^' | '^(' | '{' | '|' | '~' :)
              return $state
            else
              $state
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 14093                      (: TOKEN_REF '.' CHAR_LITERAL :)
              or $state[$p:lk] = 14096                      (: RULE_REF '.' CHAR_LITERAL :)
              or $state[$p:lk] = 18189                      (: TOKEN_REF '.' STRING_LITERAL :)
              or $state[$p:lk] = 18192                      (: RULE_REF '.' STRING_LITERAL :)
              or $state[$p:lk] = 55053                      (: TOKEN_REF '.' TOKEN_REF :)
              or $state[$p:lk] = 55056                      (: RULE_REF '.' TOKEN_REF :)
              or $state[$p:lk] = 67341                      (: TOKEN_REF '.' RULE_REF :)
              or $state[$p:lk] = 67344                      (: RULE_REF '.' RULE_REF :)
              or $state[$p:lk] = 116493                     (: TOKEN_REF '.' '.' :)
              or $state[$p:lk] = 116496) then               (: RULE_REF '.' '.' :)
          let $state := p:memoized($state, 2)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-id($input, $state)
              let $state := p:lookahead1W(6, $input, $state) (: WHITESPACE | '.' :)
              let $state := p:consumeT(28, $input, $state)  (: '.' :)
              let $state := p:lookahead1W(39, $input, $state) (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                                 WHITESPACE | '.' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 16) then           (: RULE_REF :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-ruleref($input, $state)
                  return $state
                else
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-terminal($input, $state)
                  return $state
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-terminal($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
                    else
                      p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -3, -3)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1) then
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-id($input, $state)
          let $state := p:lookahead1W(6, $input, $state)    (: WHITESPACE | '.' :)
          let $state := p:consume(28, $input, $state)       (: '.' :)
          let $state := p:lookahead1W(39, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '.' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 16) then               (: RULE_REF :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-ruleref($input, $state)
              return $state
            else
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-terminal($input, $state)
              return $state
          return $state
        else if ($state[$p:lk] = -3
         or $state[$p:lk] = 208                             (: RULE_REF CHAR_LITERAL :)
         or $state[$p:lk] = 272                             (: RULE_REF STRING_LITERAL :)
         or $state[$p:lk] = 528                             (: RULE_REF ARG_ACTION :)
         or $state[$p:lk] = 848                             (: RULE_REF TOKEN_REF :)
         or $state[$p:lk] = 1040                            (: RULE_REF RULE_REF :)
         or $state[$p:lk] = 1232                            (: RULE_REF '!' :)
         or $state[$p:lk] = 1360                            (: RULE_REF '(' :)
         or $state[$p:lk] = 1424                            (: RULE_REF ')' :)
         or $state[$p:lk] = 1488                            (: RULE_REF '*' :)
         or $state[$p:lk] = 1552                            (: RULE_REF '+' :)
         or $state[$p:lk] = 1744                            (: RULE_REF '->' :)
         or $state[$p:lk] = 2064                            (: RULE_REF ';' :)
         or $state[$p:lk] = 2384                            (: RULE_REF '?' :)
         or $state[$p:lk] = 2512                            (: RULE_REF '^' :)
         or $state[$p:lk] = 2576                            (: RULE_REF '^(' :)
         or $state[$p:lk] = 3536                            (: RULE_REF '{' :)
         or $state[$p:lk] = 3600                            (: RULE_REF '|' :)
         or $state[$p:lk] = 3728                            (: RULE_REF '~' :)
         or $state[$p:lk] = 79632                           (: RULE_REF '.' '!' :)
         or $state[$p:lk] = 87824                           (: RULE_REF '.' '(' :)
         or $state[$p:lk] = 91920                           (: RULE_REF '.' ')' :)
         or $state[$p:lk] = 96016                           (: RULE_REF '.' '*' :)
         or $state[$p:lk] = 100112                          (: RULE_REF '.' '+' :)
         or $state[$p:lk] = 112400                          (: RULE_REF '.' '->' :)
         or $state[$p:lk] = 132880                          (: RULE_REF '.' ';' :)
         or $state[$p:lk] = 153360                          (: RULE_REF '.' '?' :)
         or $state[$p:lk] = 161552                          (: RULE_REF '.' '^' :)
         or $state[$p:lk] = 165648                          (: RULE_REF '.' '^(' :)
         or $state[$p:lk] = 227088                          (: RULE_REF '.' '{' :)
         or $state[$p:lk] = 231184                          (: RULE_REF '.' '|' :)
         or $state[$p:lk] = 239376) then                    (: RULE_REF '.' '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ruleref($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-terminal($input, $state)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "atom", $count, $begin, $end)
};

(:~
 : Parse elementNoOptionSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-elementNoOptionSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 55) then                           (: '{' :)
      let $state := p:lookahead2(44, $input, $state)        (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 3703) then                     (: '{' '}' :)
          let $state := p:lookahead3W(73, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '->' | '.' | ';' | '?' | '^(' |
                                                               '{' | '|' | '~' :)
          return $state
        else if ($state[$p:lk] = (183,                      (: '{' COMMENT :)
                                  631,                      (: '{' NESTED_ACTION_char :)
                                  695,                      (: '{' ACTION_CHAR_LITERAL :)
                                  759,                      (: '{' ACTION_STRING_LITERAL :)
                                  823,                      (: '{' ACTION_ESC :)
                                  3575)) then               (: '{' '{' :)
          let $state := p:lookahead3(44, $input, $state)    (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 3                             (: CHAR_LITERAL :)
         and $state[$p:lk] != 4                             (: STRING_LITERAL :)
         and $state[$p:lk] != 13                            (: TOKEN_REF :)
         and $state[$p:lk] != 16                            (: RULE_REF :)
         and $state[$p:lk] != 21                            (: '(' :)
         and $state[$p:lk] != 28                            (: '.' :)
         and $state[$p:lk] != 40                            (: '^(' :)
         and $state[$p:lk] != 58                            (: '~' :)
         and $state[$p:lk] != 15991                         (: '{' '}' CHAR_LITERAL :)
         and $state[$p:lk] != 20087                         (: '{' '}' STRING_LITERAL :)
         and $state[$p:lk] != 56951                         (: '{' '}' TOKEN_REF :)
         and $state[$p:lk] != 69239                         (: '{' '}' RULE_REF :)
         and $state[$p:lk] != 89719                         (: '{' '}' '(' :)
         and $state[$p:lk] != 93815                         (: '{' '}' ')' :)
         and $state[$p:lk] != 114295                        (: '{' '}' '->' :)
         and $state[$p:lk] != 118391                        (: '{' '}' '.' :)
         and $state[$p:lk] != 134775                        (: '{' '}' ';' :)
         and $state[$p:lk] != 155255                        (: '{' '}' '?' :)
         and $state[$p:lk] != 167543                        (: '{' '}' '^(' :)
         and $state[$p:lk] != 228983                        (: '{' '}' '{' :)
         and $state[$p:lk] != 233079                        (: '{' '}' '|' :)
         and $state[$p:lk] != 241271) then                  (: '{' '}' '~' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SEMPRED($input, $state)
          let $state := p:lookahead1W(72, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '->' | '.' | ';' | '=>' | '^(' |
                                                               '{' | '|' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 35) then               (: '=>' :)
              let $state := p:consumeT(35, $input, $state)  (: '=>' :)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -3, -3)
            else
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -4, -4)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 3                              (: CHAR_LITERAL :)
          or $state[$p:lk] = 4                              (: STRING_LITERAL :)
          or $state[$p:lk] = 13                             (: TOKEN_REF :)
          or $state[$p:lk] = 16                             (: RULE_REF :)
          or $state[$p:lk] = 28                             (: '.' :)
          or $state[$p:lk] = 58) then                       (: '~' :)
      let $state :=
        if ($state[$p:l1] eq 13) then                       (: TOKEN_REF :)
          let $state := p:lookahead2W(88, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '+=' | '->' | '.' | ';' | '<' | '=' | '?' | '^' | '^(' |
                                                               '{' | '|' | '~' :)
          return $state
        else if ($state[$p:l1] eq 16) then                  (: RULE_REF :)
          let $state := p:lookahead2W(87, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | ARG_ACTION | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '!' | '(' | ')' | '*' | '+' |
                                                               '+=' | '->' | '.' | ';' | '=' | '?' | '^' | '^(' | '{' |
                                                               '|' | '~' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 1613                       (: TOKEN_REF '+=' :)
              or $state[$p:lk] = 1616                       (: RULE_REF '+=' :)
              or $state[$p:lk] = 2189                       (: TOKEN_REF '=' :)
              or $state[$p:lk] = 2192) then                 (: RULE_REF '=' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-id($input, $state)
          let $state := p:lookahead1W(18, $input, $state)   (: WHITESPACE | '+=' | '=' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 34) then               (: '=' :)
              let $state := p:consume(34, $input, $state)   (: '=' :)
              return $state
            else
              let $state := p:consume(25, $input, $state)   (: '+=' :)
              return $state
          let $state := p:lookahead1W(50, $input, $state)   (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | '.' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 21) then               (: '(' :)
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-block($input, $state)
              return $state
            else
              let $state := p:whitespace($input, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-atom($input, $state)
              return $state
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-atom($input, $state)
          return $state
      let $state := p:lookahead1W(79, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '*' | '+' | '->' | '.' | ';' |
                                                               '?' | '^(' | '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23                         (: '*' :)
              or $state[$p:l1] = 24                         (: '+' :)
              or $state[$p:l1] = 37) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ebnfSuffix($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = 21) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ebnf($input, $state)
      return $state
    else if ($state[$p:lk] = -3
     or $state[$p:lk] = 155255) then                        (: '{' '}' '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SEMPRED($input, $state)
      let $state := p:lookahead1W(72, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '->' | '.' | ';' | '=>' | '^(' |
                                                               '{' | '|' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: '=>' :)
          let $state := p:consume(35, $input, $state)       (: '=>' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:lk] = 40) then                       (: '^(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-tree_($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ACTION($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "elementNoOptionSpec", $count, $begin, $end)
};

(:~
 : Parse element.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-element($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-elementNoOptionSpec($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "element", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production alternative (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-alternative-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | ')' | '->' | '.' | ';' | '^(' | '{' |
                                                               '|' | '~' :)
    return
      if ($state[$p:l1] = 22                                (: ')' :)
       or $state[$p:l1] = 27                                (: '->' :)
       or $state[$p:l1] = 32                                (: ';' :)
       or $state[$p:l1] = 56) then                          (: '|' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-element($input, $state)
        return p:parse-alternative-1($input, $state)
};

(:~
 : Parse alternative.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-alternative($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-alternative-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "alternative", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ruleAltList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleAltList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(24, $input, $state)         (: WHITESPACE | ';' | '|' :)
    return
      if ($state[$p:l1] != 56) then                         (: '|' :)
        $state
      else
        let $state := p:consume(56, $input, $state)         (: '|' :)
        let $state := p:lookahead1W(68, $input, $state)     (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | '->' | '.' | ';' | '^(' | '{' | '|' |
                                                               '~' :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-alternative($input, $state)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-rewrite($input, $state)
        return p:parse-ruleAltList-1($input, $state)
};

(:~
 : Parse ruleAltList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleAltList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-alternative($input, $state)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rewrite($input, $state)
  let $state := p:parse-ruleAltList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ruleAltList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production idList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-idList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(19, $input, $state)         (: WHITESPACE | ',' | ';' :)
    return
      if ($state[$p:l1] != 26) then                         (: ',' :)
        $state
      else
        let $state := p:consume(26, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-id($input, $state)
        return p:parse-idList-1($input, $state)
};

(:~
 : Parse idList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-idList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:parse-idList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "idList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ruleScopeSpec (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleScopeSpec-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(32, $input, $state)         (: WHITESPACE | ':' | '@' | 'scope' :)
    return
      if ($state[$p:l1] != 52) then                         (: 'scope' :)
        $state
      else
        let $state := p:consume(52, $input, $state)         (: 'scope' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-idList($input, $state)
        let $state := p:consume(32, $input, $state)         (: ';' :)
        return p:parse-ruleScopeSpec-1($input, $state)
};

(:~
 : Parse ruleScopeSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleScopeSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 52) then                           (: 'scope' :)
      let $state := p:lookahead2W(35, $input, $state)       (: TOKEN_REF | RULE_REF | WHITESPACE | '@' | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2484                           (: 'scope' '@' :)
          or $state[$p:lk] = 3572) then                     (: 'scope' '{' :)
      let $state := p:consume(52, $input, $state)           (: 'scope' :)
      let $state := p:lookahead1W(25, $input, $state)       (: WHITESPACE | '@' | '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '@' :)
          let $state := p:whitespace($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ruleActions($input, $state)
          return $state
        else
          $state
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ACTION($input, $state)
      return $state
    else
      $state
  let $state := p:parse-ruleScopeSpec-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ruleScopeSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production throwsSpec (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-throwsSpec-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(41, $input, $state)         (: OPTIONS | WHITESPACE | ',' | ':' | '@' | 'scope' :)
    return
      if ($state[$p:l1] != 26) then                         (: ',' :)
        $state
      else
        let $state := p:consume(26, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-id($input, $state)
        return p:parse-throwsSpec-1($input, $state)
};

(:~
 : Parse throwsSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-throwsSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(53, $input, $state)               (: 'throws' :)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:parse-throwsSpec-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "throwsSpec", $count, $begin, $end)
};

(:~
 : Parse rule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: DOC_COMMENT :)
      let $state := p:consume(1, $input, $state)            (: DOC_COMMENT :)
      return $state
    else
      $state
  let $state := p:lookahead1W(48, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE | 'fragment' |
                                                               'private' | 'protected' | 'public' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 13                            (: TOKEN_REF :)
         and $state[$p:l1] != 16) then                      (: RULE_REF :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 49) then                   (: 'protected' :)
          let $state := p:consume(49, $input, $state)       (: 'protected' :)
          return $state
        else if ($state[$p:l1] = 50) then                   (: 'public' :)
          let $state := p:consume(50, $input, $state)       (: 'public' :)
          return $state
        else if ($state[$p:l1] = 48) then                   (: 'private' :)
          let $state := p:consume(48, $input, $state)       (: 'private' :)
          return $state
        else
          let $state := p:consume(43, $input, $state)       (: 'fragment' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(54, $input, $state)           (: ARG_ACTION | OPTIONS | WHITESPACE | '!' | ':' | '@' |
                                                               'returns' | 'scope' | 'throws' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '!' :)
      let $state := p:consume(19, $input, $state)           (: '!' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(51, $input, $state)           (: ARG_ACTION | OPTIONS | WHITESPACE | ':' | '@' |
                                                               'returns' | 'scope' | 'throws' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 8) then                        (: ARG_ACTION :)
      let $state := p:consume(8, $input, $state)            (: ARG_ACTION :)
      return $state
    else
      $state
  let $state := p:lookahead1W(49, $input, $state)           (: OPTIONS | WHITESPACE | ':' | '@' | 'returns' | 'scope' |
                                                               'throws' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: 'returns' :)
      let $state := p:consume(51, $input, $state)           (: 'returns' :)
      let $state := p:lookahead1W(2, $input, $state)        (: ARG_ACTION | WHITESPACE :)
      let $state := p:consume(8, $input, $state)            (: ARG_ACTION :)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: OPTIONS | WHITESPACE | ':' | '@' | 'scope' | 'throws' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: 'throws' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-throwsSpec($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: OPTIONS :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-optionsSpec($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(32, $input, $state)           (: WHITESPACE | ':' | '@' | 'scope' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ruleScopeSpec($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '@' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ruleActions($input, $state)
      return $state
    else
      $state
  let $state := p:consume(31, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(68, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | TOKEN_REF | RULE_REF |
                                                               WHITESPACE | '(' | '->' | '.' | ';' | '^(' | '{' | '|' |
                                                               '~' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ruleAltList($input, $state)
  let $state := p:consume(32, $input, $state)               (: ';' :)
  let $state := p:lookahead1W(59, $input, $state)           (: DOC_COMMENT | TOKEN_REF | RULE_REF | EOF | WHITESPACE |
                                                               'catch' | 'finally' | 'fragment' | 'private' |
                                                               'protected' | 'public' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 41                             (: 'catch' :)
          or $state[$p:l1] = 42) then                       (: 'finally' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-exceptionGroup($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rule", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production rules (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rules-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-rule($input, $state)
    let $state := p:lookahead1W(52, $input, $state)         (: DOC_COMMENT | TOKEN_REF | RULE_REF | EOF | WHITESPACE |
                                                               'fragment' | 'private' | 'protected' | 'public' :)
    return
      if ($state[$p:l1] = 17) then                          (: EOF :)
        $state
      else
        p:parse-rules-1($input, $state)
};

(:~
 : Parse rules.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-rules($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-rules-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "rules", $count, $begin, $end)
};

(:~
 : Parse actionScopeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-actionScopeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: 'lexer' :)
      let $state := p:consume(46, $input, $state)           (: 'lexer' :)
      return $state
    else if ($state[$p:l1] = 47) then                       (: 'parser' :)
      let $state := p:consume(47, $input, $state)           (: 'parser' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-id($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "actionScopeName", $count, $begin, $end)
};

(:~
 : Parse action.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-action($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(38, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(36, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE | 'lexer' | 'parser' :)
  let $state :=
    if ($state[$p:l1] = (13,                                (: TOKEN_REF :)
                         16)) then                          (: RULE_REF :)
      let $state := p:lookahead2W(21, $input, $state)       (: WHITESPACE | ':' | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 3533                          (: TOKEN_REF '{' :)
         and $state[$p:lk] != 3536) then                    (: RULE_REF '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-actionScopeName($input, $state)
      let $state := p:lookahead1W(8, $input, $state)        (: WHITESPACE | ':' :)
      let $state := p:consume(31, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(8, $input, $state)        (: WHITESPACE | ':' :)
      let $state := p:consume(31, $input, $state)           (: ':' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ACTION($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "action", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production actions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-actions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-action($input, $state)
    let $state := p:lookahead1W(53, $input, $state)         (: DOC_COMMENT | TOKEN_REF | RULE_REF | WHITESPACE | '@' |
                                                               'fragment' | 'private' | 'protected' | 'public' :)
    return
      if ($state[$p:l1] != 38) then                         (: '@' :)
        $state
      else
        p:parse-actions-1($input, $state)
};

(:~
 : Parse actions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-actions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-actions-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "actions", $count, $begin, $end)
};

(:~
 : Parse ruleAction.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleAction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(38, $input, $state)               (: '@' :)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ACTION($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ruleAction", $count, $begin, $end)
};

(:~
 : Try parsing ruleAction.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ruleAction($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(38, $input, $state)              (: '@' :)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-id($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: WHITESPACE | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ACTION($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ruleActions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleActions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-ruleAction($input, $state)
    let $state := p:lookahead1W(33, $input, $state)         (: WHITESPACE | ':' | '@' | '{' :)
    return
      if ($state[$p:l1] != 38) then                         (: '@' :)
        $state
      else
        p:parse-ruleActions-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ruleActions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ruleActions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-ruleAction($input, $state)
    let $state := p:lookahead1W(33, $input, $state)         (: WHITESPACE | ':' | '@' | '{' :)
    return
      if ($state[$p:l1] != 38) then                         (: '@' :)
        $state
      else
        p:try-ruleActions-1($input, $state)
};

(:~
 : Parse ruleActions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ruleActions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ruleActions-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ruleActions", $count, $begin, $end)
};

(:~
 : Try parsing ruleActions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ruleActions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ruleActions-1($input, $state)
  return $state
};

(:~
 : Parse attrScope.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-attrScope($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(52, $input, $state)               (: 'scope' :)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: WHITESPACE | '@' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '@' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ruleActions($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ACTION($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "attrScope", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production attrScopes (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-attrScopes-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(55, $input, $state)         (: DOC_COMMENT | TOKEN_REF | RULE_REF | WHITESPACE | '@' |
                                                               'fragment' | 'private' | 'protected' | 'public' | 'scope' :)
    return
      if ($state[$p:l1] != 52) then                         (: 'scope' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-attrScope($input, $state)
        return p:parse-attrScopes-1($input, $state)
};

(:~
 : Parse attrScopes.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-attrScopes($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-attrScopes-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "attrScopes", $count, $begin, $end)
};

(:~
 : Parse tokenSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-tokenSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(13, $input, $state)               (: TOKEN_REF :)
  let $state := p:lookahead1W(22, $input, $state)           (: WHITESPACE | ';' | '=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '=' :)
      let $state := p:consume(34, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(13, $input, $state)       (: CHAR_LITERAL | STRING_LITERAL | WHITESPACE :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: STRING_LITERAL :)
          let $state := p:consume(4, $input, $state)        (: STRING_LITERAL :)
          return $state
        else
          let $state := p:consume(3, $input, $state)        (: CHAR_LITERAL :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(9, $input, $state)            (: WHITESPACE | ';' :)
  let $state := p:consume(32, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "tokenSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production tokensSpec (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-tokensSpec-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(15, $input, $state)         (: TOKEN_REF | WHITESPACE | '}' :)
    return
      if ($state[$p:l1] != 13) then                         (: TOKEN_REF :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-tokenSpec($input, $state)
        return p:parse-tokensSpec-1($input, $state)
};

(:~
 : Parse tokensSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-tokensSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(14, $input, $state)               (: TOKENS :)
  let $state := p:parse-tokensSpec-1($input, $state)
  let $state := p:consume(57, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "tokensSpec", $count, $begin, $end)
};

(:~
 : Parse delegateGrammar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-delegateGrammar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: WHITESPACE | ',' | ';' | '=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '=' :)
      let $state := p:consume(34, $input, $state)           (: '=' :)
      let $state := p:lookahead1W(14, $input, $state)       (: TOKEN_REF | RULE_REF | WHITESPACE :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-id($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "delegateGrammar", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production delegateGrammars (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-delegateGrammars-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(19, $input, $state)         (: WHITESPACE | ',' | ';' :)
    return
      if ($state[$p:l1] != 26) then                         (: ',' :)
        $state
      else
        let $state := p:consume(26, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(14, $input, $state)     (: TOKEN_REF | RULE_REF | WHITESPACE :)
        let $state := p:whitespace($input, $state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-delegateGrammar($input, $state)
        return p:parse-delegateGrammars-1($input, $state)
};

(:~
 : Parse delegateGrammars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-delegateGrammars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(45, $input, $state)               (: 'import' :)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-delegateGrammar($input, $state)
  let $state := p:parse-delegateGrammars-1($input, $state)
  let $state := p:consume(32, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "delegateGrammars", $count, $begin, $end)
};

(:~
 : Parse optionValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-optionValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: STRING_LITERAL :)
      let $state := p:consume(4, $input, $state)            (: STRING_LITERAL :)
      return $state
    else if ($state[$p:l1] = 3) then                        (: CHAR_LITERAL :)
      let $state := p:consume(3, $input, $state)            (: CHAR_LITERAL :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: INT :)
      let $state := p:consume(7, $input, $state)            (: INT :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*' :)
      let $state := p:consume(23, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-id($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "optionValue", $count, $begin, $end)
};

(:~
 : Try parsing optionValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-optionValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: STRING_LITERAL :)
      let $state := p:consumeT(4, $input, $state)           (: STRING_LITERAL :)
      return $state
    else if ($state[$p:l1] = 3) then                        (: CHAR_LITERAL :)
      let $state := p:consumeT(3, $input, $state)           (: CHAR_LITERAL :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: INT :)
      let $state := p:consumeT(7, $input, $state)           (: INT :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*' :)
      let $state := p:consumeT(23, $input, $state)          (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-id($input, $state)
      return $state
  return $state
};

(:~
 : Parse option.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-option($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: WHITESPACE | '=' :)
  let $state := p:consume(34, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(45, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '*' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-optionValue($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "option", $count, $begin, $end)
};

(:~
 : Try parsing option.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-option($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-id($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: WHITESPACE | '=' :)
  let $state := p:consumeT(34, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(45, $input, $state)           (: CHAR_LITERAL | STRING_LITERAL | INT | TOKEN_REF |
                                                               RULE_REF | WHITESPACE | '*' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-optionValue($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production optionsSpec (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-optionsSpec-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(14, $input, $state)         (: TOKEN_REF | RULE_REF | WHITESPACE :)
    let $state := p:whitespace($input, $state)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-option($input, $state)
    let $state := p:lookahead1W(9, $input, $state)          (: WHITESPACE | ';' :)
    let $state := p:consume(32, $input, $state)             (: ';' :)
    let $state := p:lookahead1W(27, $input, $state)         (: TOKEN_REF | RULE_REF | WHITESPACE | '}' :)
    return
      if ($state[$p:l1] = 57) then                          (: '}' :)
        $state
      else
        p:parse-optionsSpec-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production optionsSpec (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-optionsSpec-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(14, $input, $state)         (: TOKEN_REF | RULE_REF | WHITESPACE :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-option($input, $state)
    let $state := p:lookahead1W(9, $input, $state)          (: WHITESPACE | ';' :)
    let $state := p:consumeT(32, $input, $state)            (: ';' :)
    let $state := p:lookahead1W(27, $input, $state)         (: TOKEN_REF | RULE_REF | WHITESPACE | '}' :)
    return
      if ($state[$p:l1] = 57) then                          (: '}' :)
        $state
      else
        p:try-optionsSpec-1($input, $state)
};

(:~
 : Parse optionsSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-optionsSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(15, $input, $state)               (: OPTIONS :)
  let $state := p:parse-optionsSpec-1($input, $state)
  let $state := p:consume(57, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "optionsSpec", $count, $begin, $end)
};

(:~
 : Try parsing optionsSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-optionsSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(15, $input, $state)              (: OPTIONS :)
  let $state := p:try-optionsSpec-1($input, $state)
  let $state := p:consumeT(57, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse id.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-id($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consume(13, $input, $state)           (: TOKEN_REF :)
      return $state
    else
      let $state := p:consume(16, $input, $state)           (: RULE_REF :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "id", $count, $begin, $end)
};

(:~
 : Try parsing id.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-id($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: TOKEN_REF :)
      let $state := p:consumeT(13, $input, $state)          (: TOKEN_REF :)
      return $state
    else
      let $state := p:consumeT(16, $input, $state)          (: RULE_REF :)
      return $state
  return $state
};

(:~
 : Parse grammarType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-grammarType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 44) then                      (: 'grammar' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 46) then                   (: 'lexer' :)
          let $state := p:consume(46, $input, $state)       (: 'lexer' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: 'parser' :)
          let $state := p:consume(47, $input, $state)       (: 'parser' :)
          return $state
        else
          let $state := p:consume(54, $input, $state)       (: 'tree' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(11, $input, $state)           (: WHITESPACE | 'grammar' :)
  let $state := p:consume(44, $input, $state)               (: 'grammar' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "grammarType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production NESTED_ACTION (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NESTED_ACTION-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(44, $input, $state)          (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
    return
      if ($state[$p:l1] = 57) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 55) then                 (: '{' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NESTED_ACTION($input, $state)
            return $state
          else if ($state[$p:l1] = 10) then                 (: ACTION_CHAR_LITERAL :)
            let $state := p:consume(10, $input, $state)     (: ACTION_CHAR_LITERAL :)
            return $state
          else if ($state[$p:l1] = 2) then                  (: COMMENT :)
            let $state := p:consume(2, $input, $state)      (: COMMENT :)
            return $state
          else if ($state[$p:l1] = 11) then                 (: ACTION_STRING_LITERAL :)
            let $state := p:consume(11, $input, $state)     (: ACTION_STRING_LITERAL :)
            return $state
          else if ($state[$p:l1] = 12) then                 (: ACTION_ESC :)
            let $state := p:consume(12, $input, $state)     (: ACTION_ESC :)
            return $state
          else
            let $state := p:consume(9, $input, $state)      (: NESTED_ACTION_char :)
            return $state
        return p:parse-NESTED_ACTION-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production NESTED_ACTION (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NESTED_ACTION-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(44, $input, $state)          (: COMMENT | NESTED_ACTION_char | ACTION_CHAR_LITERAL |
                                                               ACTION_STRING_LITERAL | ACTION_ESC | '{' | '}' :)
    return
      if ($state[$p:l1] = 57) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 55) then                 (: '{' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-NESTED_ACTION($input, $state)
            return $state
          else if ($state[$p:l1] = 10) then                 (: ACTION_CHAR_LITERAL :)
            let $state := p:consumeT(10, $input, $state)    (: ACTION_CHAR_LITERAL :)
            return $state
          else if ($state[$p:l1] = 2) then                  (: COMMENT :)
            let $state := p:consumeT(2, $input, $state)     (: COMMENT :)
            return $state
          else if ($state[$p:l1] = 11) then                 (: ACTION_STRING_LITERAL :)
            let $state := p:consumeT(11, $input, $state)    (: ACTION_STRING_LITERAL :)
            return $state
          else if ($state[$p:l1] = 12) then                 (: ACTION_ESC :)
            let $state := p:consumeT(12, $input, $state)    (: ACTION_ESC :)
            return $state
          else
            let $state := p:consumeT(9, $input, $state)     (: NESTED_ACTION_char :)
            return $state
        return p:try-NESTED_ACTION-1($input, $state)
};

(:~
 : Parse NESTED_ACTION.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NESTED_ACTION($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(55, $input, $state)               (: '{' :)
  let $state := p:parse-NESTED_ACTION-1($input, $state)
  let $state := p:consume(57, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NESTED_ACTION", $count, $begin, $end)
};

(:~
 : Try parsing NESTED_ACTION.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NESTED_ACTION($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(55, $input, $state)              (: '{' :)
  let $state := p:try-NESTED_ACTION-1($input, $state)
  let $state := p:consumeT(57, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ACTION.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ACTION($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NESTED_ACTION($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ACTION", $count, $begin, $end)
};

(:~
 : Try parsing ACTION.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ACTION($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NESTED_ACTION($input, $state)
  return $state
};

(:~
 : Parse grammar_.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-grammar_($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(43, $input, $state)           (: DOC_COMMENT | WHITESPACE | 'grammar' | 'lexer' |
                                                               'parser' | 'tree' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 55) then                       (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ACTION($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: DOC_COMMENT | WHITESPACE | 'grammar' | 'lexer' |
                                                               'parser' | 'tree' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: DOC_COMMENT :)
      let $state := p:consume(1, $input, $state)            (: DOC_COMMENT :)
      return $state
    else
      $state
  let $state := p:lookahead1W(37, $input, $state)           (: WHITESPACE | 'grammar' | 'lexer' | 'parser' | 'tree' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-grammarType($input, $state)
  let $state := p:lookahead1W(14, $input, $state)           (: TOKEN_REF | RULE_REF | WHITESPACE :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-id($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: WHITESPACE | ';' :)
  let $state := p:consume(32, $input, $state)               (: ';' :)
  let $state := p:lookahead1W(64, $input, $state)           (: DOC_COMMENT | TOKEN_REF | TOKENS | OPTIONS | RULE_REF |
                                                               WHITESPACE | '@' | 'fragment' | 'import' | 'private' |
                                                               'protected' | 'public' | 'scope' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: OPTIONS :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-optionsSpec($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(63, $input, $state)           (: DOC_COMMENT | TOKEN_REF | TOKENS | RULE_REF |
                                                               WHITESPACE | '@' | 'fragment' | 'import' | 'private' |
                                                               'protected' | 'public' | 'scope' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: 'import' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-delegateGrammars($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: DOC_COMMENT | TOKEN_REF | TOKENS | RULE_REF |
                                                               WHITESPACE | '@' | 'fragment' | 'private' | 'protected' |
                                                               'public' | 'scope' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: TOKENS :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-tokensSpec($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(55, $input, $state)           (: DOC_COMMENT | TOKEN_REF | RULE_REF | WHITESPACE | '@' |
                                                               'fragment' | 'private' | 'protected' | 'public' | 'scope' :)
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-attrScopes($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '@' :)
      let $state := p:whitespace($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-actions($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-rules($input, $state)
  let $state := p:consume(17, $input, $state)               (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "grammar_", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 18) then                                (: WHITESPACE :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 64 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 4096 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:match($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 64 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:match($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 4096 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from lexer state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore lexer state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the lexer state before backtracking started.
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value
  }
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $dpi for input position $e0. Reconstruct state from the parameters.
 :
 : @param $state the lexer state to be restored.
 : @param $update the lexer state containing updates.
 : @param $dpi the decision point id.
 : @param $e0 the input position.
 : @param $v the id of the successful alternative.
 : @param $lk the new lookahead code.
 : @return the reconstructed state.
 :)
declare function p:memoize($state as item()+,
                           $update as item()+,
                           $dpi as xs:integer,
                           $e0 as xs:integer,
                           $v as xs:integer,
                           $lk as xs:integer) as item()+
{
  $lk,
  subsequence($state, $p:b0, $p:memo - $p:b0),
  let $memo := $update[$p:memo]
  let $errors := ($memo, $update[$p:error])[.]
  return
    element memo
    {
      $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
      $memo/value,
      element value {attribute key {$e0 * 8 + $dpi}, $v}
    },
  subsequence($state, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $dpi
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $dpi the decision point id.
 : @return the updated state.
 :)
declare function p:memoized($state as item()+, $dpi as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 8 + $dpi])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol grammar_ from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-grammar_($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>)
  let $state := p:parse-grammar_($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
